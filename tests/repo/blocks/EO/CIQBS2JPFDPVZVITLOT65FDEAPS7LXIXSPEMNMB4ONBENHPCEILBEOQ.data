
Š€€€ ['add']\\n    });\\n  } // Process\\n\\n\\n  if (client !== undefined && client.add !== undefined) {\\n    const options = {\\n      chunker: 'rabin-262144-524288-1048576',\\n      cidVersion: 0,\\n      hashAlg: 'sha2-256',\\n      pin: true,\\n      rawLeaves: false\\n    }; // Process\\n\\n    this.getLogger().info('Processing IPFS add...'); // 1 - https://github.com/ipfs/go-ipfs/issues/5683\\n    // default chunker: \\\"size-262144\\\"\\n    // chunker: \\\"rabin-262144-524288-1048576\\\"\\n    // 2 - TODO: small content generates an incnsistent cid when cidVersion: 1 is set.\\n    // Not a 'dag-pb' but a 'raw' multicodec instead\\n    // We generate a V0 and convert it to a V1\\n    // https://github.com/xmaysonnave/tiddlywiki-ipfs/issues/14\\n\\n    const result = await client.add(content, options); // Check\\n\\n    if (result === undefined || result == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    var cid = null;\\n\\n    if (result.cid !== undefined && result.cid !== null) {\\n      cid = result.cid;\\n    }\\n\\n    var mode = null;\\n\\n    if (result.mode !== undefined && result.mode !== null) {\\n      mode = result.mode;\\n    }\\n\\n    const mtime = result.mtime;\\n    var path = null;\\n\\n    if (result.path !== undefined && result.path !== null) {\\n      path = result.path;\\n    }\\n\\n    var size = null;\\n\\n    if (result.size !== undefined && result.size !== null) {\\n      size = result.size;\\n    }\\n\\n    if (cid == null || mode == null || path == null || size == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    const cidV1 = this.ipfsBundle.cidToCidV1(cid, 'ipfs', true);\\n    return {\\n      cid: cidV1,\\n      mode: mode,\\n      mtime: mtime,\\n      path: path,\\n      size: size\\n    };\\n  }\\n\\n  throw new Error('Undefined IPFS add...');\\n};\\n\\nIpfsLibrary.prototype.addAll = async function (client, content, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (content === undefined || content == null) {\\n    throw new Error('Undefined content...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['addAll']\\n    });\\n  } // Process\\n\\n\\n  if (client !== undefined && client.addAll !== undefined) {\\n    const added = new Map(); // Process\\n\\n    this.getLogger().info('Processing IPFS addAll...');\\n\\n    for await (const result of client.addAll(content, options)) {\\n      // Check\\n      if (result === undefined || result == null) {\\n        throw new Error('IPFS client returned an unknown result...');\\n      }\\n\\n      var cid = null;\\n\\n      if (result.cid !== undefined && result.cid !== null) {\\n        cid = result.cid;\\n      }\\n\\n      var path = null;\\n\\n      if (result.path !== undefined && result.path !== null) {\\n        path = result.path;\\n      }\\n\\n      var mode = null;\\n\\n      if (result.mode !== undefined && result.mode !== null) {\\n        mode = result.mode;\\n      }\\n\\n      const mtime = result.mtime;\\n      var size = null;\\n\\n      if (result.size !== undefined && result.size !== null) {\\n        size = result.size;\\n      }\\n\\n      if (cid == null || path == null || mode == null || size == null) {\\n        throw new Error('IPFS client returned an unknown result...');\\n      }\\n\\n      const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n      added.set(cidV1, {\\n        path: path,\\n        mode: mode,\\n        mtime: mtime,\\n        size: size\\n      });\\n    }\\n\\n    return added;\\n  }\\n\\n  throw new Error('Undefined IPFS addAll...');\\n};\\n\\nIpfsLibrary.prototype.analyzePinType = function (type) {\\n  if (type === undefined || type == null || type.trim() === '') {\\n    return {\\n      parentCid: null,\\n      type: null\\n    };\\n  }\\n\\n  var res = type.split(' ');\\n\\n  if (res.length === 1) {\\n    return {\\n      parentCid: null,\\n      type: res[0]\\n    };\\n  }\\n\\n  if (res.length !== 3 && res.length !== 4) {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  const index = res.length % 3;\\n\\n  if (res[index] !== 'indirect') {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  if (res[index + 1] !== 'through') {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  const parentCid = this.ipfsBundle.getCid(res[index + 2]);\\n\\n  if (parentCid == null) {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  return {\\n    parentCid: parentCid,\\n    type: res[0]\\n  };\\n}; // https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/KEY.md#keygen\\n// https://github.com/libp2p/js-libp2p-crypto/issues/145\\n\\n\\nIpfsLibrary.prototype.genKey = async function (client, ipnsName) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipnsName = ipnsName == null || ipnsName === undefined || ipnsName.trim() === '' ? null : ipnsName.trim();\\n\\n  if (ipnsName == null) {\\n    throw new Error('Undefined IPNS name...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client !== undefined && client.key !== undefined && client.key.gen !== undefined) {\\n    this.getLogger().info('Processing IPFS key gen...');\\n    const key = await client.key.gen(ipnsName, {\\n      type: 'ed25519'\\n    });\\n\\n    if (key === undefined || key == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    var keyId = null;\\n\\n    if (key.id !== undefined && key.id !== null) {\\n      keyId = key.id;\\n    }\\n\\n    if (keyId == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return keyId;\\n  }\\n\\n  throw new Error('Undefined IPFS key gen...');\\n}; // Default\\n\\n\\nIpfsLibrary.prototype.getDefaultIpfs = async function (apiUrl) {\\n  // IPFS Companion first\\n  try {\\n    const {\\n      ipfs,\\n      provider\\n    } = await this.getWindowIpfs();\\n\\n    if (ipfs !== null) {\\n      return {\\n        ipfs: ipfs,\\n        provider: provider\\n      };\\n    }\\n  } catch (error) {// IPFS Companion failed\\n  }\\n\\n  apiUrl = apiUrl === undefined || apiUrl == null || apiUrl.toString().trim() === '' ? null : apiUrl;\\n\\n  if (apiUrl == null) {\\n    throw new Error('Undefined IPFS API URL...');\\n  } // Load IpfsHttpClient\\n\\n\\n  try {\\n    const {\\n      ipfs,\\n      provider\\n    } = await this.getHttpIpfs(apiUrl);\\n\\n    if (ipfs !== null) {\\n      return {\\n        ipfs: ipfs,\\n        provider: provider\\n      };\\n    }\\n  } catch (error) {// IPFS HTTP client failed\\n  }\\n\\n  throw new Error('Unable to retrieve IPFS Companion and IPFS API URL...');\\n}; // ipfs-http-client\\n\\n\\nIpfsLibrary.prototype.getHttpIpfs = async function (apiUrl) {\\n  apiUrl = apiUrl === undefined || apiUrl == null || apiUrl.toString().trim() === '' ? null : apiUrl;\\n\\n  if (apiUrl == null) {\\n    throw new Error('Undefined IPFS API URL...');\\n  }\\n\\n  try {\\n    await this.ipfsBundle.loadIpfsHttpLibrary();\\n    this.getLogger().info(`Processing connection to IPFS API URL:\\n${apiUrl}`);\\n    const protocol = apiUrl.protocol.slice(0, -1);\\n    var port = apiUrl.port;\\n\\n    if (port === undefined || port == null || port.trim() === '') {\\n      port = 443;\\n\\n      if (protocol === 'http') {\\n        port = 80;\\n      }\\n    }\\n\\n    const {\\n      ipfs,\\n      provider\\n    } = await getIpfs({\\n      providers: [httpClient({\\n        apiAddress: {\\n          protocol: protocol,\\n          host: apiUrl.hostname,\\n          port: port,\\n          timeout: '4m'\\n        }\\n      })]\\n    });\\n    return {\\n      ipfs: ipfs,\\n      provider: `${provider}, ${apiUrl}`\\n    };\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  throw new Error('Unreachable IPFS API URL...');\\n}; // IPFS companion\\n\\n\\nIpfsLibrary.prototype.getWindowIpfs = async function () {\\n  try {\\n    this.getLogger().info('Processing connection to IPFS Companion...');\\n    const {\\n      ipfs,\\n      provider\\n    } = await getIpfs({\\n      providers: [windowIpfs()]\\n    });\\n    return {\\n      ipfs: ipfs,\\n      provider: provider\\n    };\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  throw new Error('Unreachable IPFS Companion...');\\n};\\n\\nIpfsLibrary.prototype.hasPin = async function (client, key, type, ipfsPath) {\\n  try {\\n    if (ipfsPath) {\\n      ipfsPath = `${key}${ipfsPath}`;\\n    } else {\\n      ipfsPath = key;\\n    }\\n\\n    for await (var {\\n      cid,\\n      type: fetchedType\\n    } of client.pin.ls({\\n      paths: [ipfsPath]\\n    })) {\\n      if (cid !== undefined && cid !== null) {\\n        var {\\n          type: fetchedType,\\n          parentCid\\n        } = this.analyzePinType(fetchedType);\\n        const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n        const parentCidV1 = parentCid !== null ? this.ipfsBundle.cidToCidV1(parentCid) : null;\\n\\n        if (type) {\\n          if (type === fetchedType) {\\n            return {\\n              cid: cidV1,\\n              parentCid: parentCidV1,\\n              type: type\\n            };\\n          }\\n        }\\n\\n        return {\\n          cid: cidV1,\\n          parentCid: parentCidV1,\\n          type: fetchedType\\n        };\\n      }\\n    }\\n  } catch (error) {// Ignore\\n  }\\n\\n  return {\\n    cid: '',\\n    parentCid: null,\\n    type: ''\\n  };\\n};\\n\\nIpfsLibrary.prototype.keyList = async function (client) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client !== undefined && client.key !== undefined && client.key.list !== undefined) {\\n    this.getLogger().info('Processing IPFS key list...');\\n    const result = await client.key.list();\\n\\n    if (result === undefined || result == null || Array.isArray(result) === false) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return result;\\n  }\\n\\n  throw new Error('Undefined IPFS key list...');\\n};\\n\\nIpfsLibrary.prototype.filesStat = async function (client, ipfsPath) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (ipfsPath === undefined || ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['files']\\n    });\\n  } // Process\\n\\n\\n  if (client !== undefined && client.files !== undefined && client.files.stat !== undefined) {\\n    // Process\\n    this.getLogger().info('Processing IPFS files stat...');\\n    const result = await client.files.stat(ipfsPath); // Check\\n\\n    if (result === undefined || result == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    var cid = null;\\n\\n    if (result.cid !== undefined && result.cid !== null) {\\n      cid = result.cid;\\n    }\\n\\n    var blocks = null;\\n\\n    if (result.blocks !== undefined && result.blocks !== null) {\\n      blocks = result.blocks;\\n    }\\n\\n    var cumulativeSize = null;\\n\\n    if (result.cumulativeSize !== undefined && result.cumulativeSize !== null) {\\n      cumulativeSize = result.cumulativeSize;\\n    }\\n\\n    var local = null;\\n\\n    if (result.local !== undefined && result.local !== null) {\\n      local = result.local;\\n    }\\n\\n    var size = null;\\n\\n    if (result.size !== undefined && result.size !== null) {\\n      size = result.size;\\n    }\\n\\n    var sizeLocal = null;\\n\\n    if (result.sizeLocal !== undefined && result.sizeLocal !== null) {\\n      sizeLocal = result.sizeLocal;\\n    }\\n\\n    var type = null;\\n\\n    if (result.type !== undefined && result.type !== null) {\\n      type = result.type;\\n    }\\n\\n    var withLocality = null;\\n\\n    if (result.withLocality !== undefined && result.withLocality !== null) {\\n      withLocality = result.withLocality;\\n    }\\n\\n    if (cid == null || blocks == null || cumulativeSize == null || size == null || type == null || withLocality == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    if (withLocality) {\\n      if (local == null || sizeLocal == null) {\\n        throw new Error('IPFS client returned an unknown result...');\\n      }\\n    }\\n\\n    const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n    return {\\n      cid: cidV1,\\n      blocks: blocks,\\n      cumulativeSize: cumulativeSize,\\n      local: local,\\n      size: size,\\n      sizeLocal: sizeLocal,\\n      type: type,\\n      withLocality: withLocality\\n    };\\n  }\\n\\n  throw new Error('Undefined IPFS files stat...');\\n};\\n\\nIpfsLibrary.prototype.keyRename = async function (client, oldIpnsName, newIpnsName) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  oldIpnsName = oldIpnsName == null || oldIpnsName === undefined || oldIpnsName.trim() === '' ? null : oldIpnsName.trim();\\n\\n  if (oldIpnsName == null) {\\n    throw new Error('Undefined Old IPNS name...');\\n  }\\n\\n  newIpnsName = newIpnsName == null || newIpnsName === undefined || newIpnsName.trim() === '' ? null : newIpnsName.trim();\\n\\n  if (newIpnsName == null) {\\n    throw new Error('Undefined New IPNS name...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client !== undefined && client.key !== undefined && client.key.rename !== undefined) {\\n    this.getLogger().info('Processing IPFS key rename...');\\n    const key = await client.key.rename(oldIpnsName, newIpnsName);\\n\\n    if (key === undefined || key == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    var keyId = null;\\n\\n    if (key.id !== undefined && key.id !== null) {\\n      keyId = key.id;\\n    }\\n\\n    var was = null;\\n\\n    if (key.was !== undefined && key.was !== null) {\\n      was = key.was;\\n    }\\n\\n    var now = null;\\n\\n    if (key.now !== undefined && key.now !== null) {\\n      now = key.now;\\n    }\\n\\n    var overwrite = null;\\n\\n    if (key.overwrite !== undefined && key.overwrite !== null) {\\n      overwrite = key.overwrite;\\n    }\\n\\n    if (keyId == null || was == null || now == null || overwrite == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return {\\n      keyId: keyId,\\n      was: was,\\n      now: now,\\n      overwrite: overwrite\\n    };\\n  }\\n\\n  throw new Error('Undefined IPFS key rename...');\\n};\\n\\nIpfsLibrary.prototype.ls = async function (client, ipfsPath) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (ipfsPath === undefined || ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['ls']\\n    });\\n  } // Process\\n\\n\\n  if (client !== undefined && client.ls !== undefined) {\\n    const content = new Map(); // Process\\n\\n    this.getLogger().info('Processing IPFS ls...');\\n\\n    for await (const result of client.ls(ipfsPath)) {\\n      // Check\\n      if (result === undefined || result == null) {\\n        throw new Error('IPFS client returned an unknown result...');\\n      }\\n\\n      var cid = null;\\n\\n      if (result.cid !== undefined && result.cid !== null) {\\n        cid = result.cid;\\n      }\\n\\n      var depth = null;\\n\\n      if (result.depth !== undefined && result.depth !== null) {\\n        depth = result.depth;\\n      }\\n\\n      var mode = null;\\n\\n      if (result.mode !== undefined && result.mode !== null) {\\n        mode = result.mode;\\n      }\\n\\n      const mtime = result.mtime;\\n      var name = null;\\n\\n      if (result.name !== undefined && result.name !== null) {\\n        name = result.name;\\n      }\\n\\n      var path = null;\\n\\n      if (result.path !== undefined && result.path !== null) {\\n        path = result.path;\\n      }\\n\\n      var size = null;\\n\\n      if (result.size !== undefined && result.size !== null) {\\n        size = result.size;\\n      }\\n\\n      var type = null;\\n\\n      if (result.type !== undefined && result.type !== null) {\\n        type = result.type;\\n      }\\n\\n      if (cid == null || depth == null || mode == null || name == null || path == null || size == null || type == null) {\\n        throw new Error('IPFS client returned an unknown result...');\\n      }\\n\\n      const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n      content.set(cidV1, {\\n        depth: depth,\\n        mode: mode,\\n        mtime: mtime,\\n        name: name,\\n        path: path,\\n        size: size,\\n        type: type\\n      });\\n    }\\n\\n    return content;\\n  }\\n\\n  throw new Error('Undefined IPFS ls...');\\n};\\n\\nIpfsLibrary.prototype.namePublish = async function (client, ipnsName, cid) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipnsName = ipnsName == null || ipnsName === undefined || ipnsName.trim() === '' ? null : ipnsName.trim();\\n\\n  if (ipnsName == null) {\\n    throw new Error('Undefined IPNS name...');\\n  }\\n\\n  cid = cid == null || cid === undefined || cid.toString().trim() === '' ? null : cid.toString().trim();\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['name']\\n    });\\n  }\\n\\n  if (client !== undefined && client.name !== undefined && client.name.publish !== undefined) {\\n    this.getLogger().info('Processing IPFS name publish...');\\n    const result = await client.name.publish(cid, {\\n      resolve: true,\\n      key: ipnsName,\\n      allowOffline: false\\n    });\\n\\n    if (result === undefined || result == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    var name = null;\\n\\n    if (result.name !== undefined && result.name !== null) {\\n      name = result.name;\\n    }\\n\\n    var value = null;\\n\\n    if (result.value !== undefined && result.value !== null) {\\n      value = result.value;\\n    }\\n\\n    if (name == null || value == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return {\\n      name: name,\\n      value: value\\n    };\\n  }\\n\\n  throw new Error('Undefined IPFS name publish...');\\n};\\n\\nIpfsLibrary.prototype.nameResolve = async function (client, value) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  value = value == null || value === undefined || value.trim() === '' ? null : value.trim();\\n\\n  if (value == null) {\\n    throw new Error('Undefined IPNS address...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['name']\\n    });\\n  }\\n\\n  if (client !== undefined && client.name !== undefined && client.name.resolve !== undefined) {\\n    this.getLogger().info('Processing IPFS name resolve...');\\n    const resolvedPaths = await client.name.resolve(value, {\\n      nocache: false,\\n      recursive: true\\n    });\\n\\n    if (resolvedPaths === undefined || resolvedPaths == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    } // https://gist.github.com/alanshaw/04b2ddc35a6fff25c040c011ac6acf26\\n\\n\\n    var lastPath = null;\\n\\n    for await (const path of resolvedPaths) {\\n      lastPath = path !== undefined || path !== null ? path : null;\\n    }\\n\\n    if (lastPath == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return lastPath;\\n  }\\n\\n  throw new Error('Undefined IPFS name resolve...');\\n};\\n\\nIpfsLibrary.prototype.pinAdd = async function (client, cid, recursive) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  cid = cid == null || cid === undefined || cid.toString().trim() === '' ? null : cid.toString().trim();\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  }\\n\\n  recursive = recursive == null || recursive === undefined ? true : recursive === true; // Window IPFS policy\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['pin']\\n    });\\n  } // Process\\n\\n\\n  if (client !== undefined && client.pin !== undefined && client.pin.add !== undefined) {\\n    this.getLogger().info('Processing IPFS pin add...');\\n    const result = await client.pin.add(cid, {\\n      recursive: recursive\\n    });\\n\\n    if (result === undefined || result == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return this.ipfsBundle.cidToCidV1(result, 'ipfs', true);\\n  }\\n\\n  throw new Error('Undefined IPFS pin add...');\\n};\\n\\nIpfsLibrary.prototype.pinRm = async function (client, cid, recursive) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  cid = cid == null || cid === undefined || cid.toString().trim() === '' ? null : cid.toString().trim();\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  }\\n\\n  recursive = recursive == null || recursive === undefined ? true : recursive === true; // Window IPFS policy\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['pin']\\n    });\\n  } // Process\\n\\n\\n  if (client !== undefined && client.pin !== undefined && client.pin.rm !== undefined) {\\n    this.getLogger().info('Processing IPFS pin rm...');\\n    const result = await client.pin.rm(cid, {\\n      recursive: recursive\\n    });\\n\\n    if (result === undefined || result == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return this.ipfsBundle.cidToCidV1(result, 'ipfs', true);\\n  }\\n\\n  throw new Error('Undefined IPFS pin rm...');\\n};\\n\\nIpfsLibrary.prototype.rmKey = async function (client, ipnsName) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipnsName = ipnsName == null || ipnsName === undefined || ipnsName.trim() === '' ? null : ipnsName.trim();\\n\\n  if (ipnsName == null) {\\n    throw new Error('Undefined IPNS name...');\\n  } // Window IPFS policy\\n\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client !== undefined && client.key !== undefined && client.key.rm !== undefined) {\\n    this.getLogger().info('Processing IPFS key rm...');\\n    const key = await client.key.rm(ipnsName);\\n\\n    if (key === undefined || key == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    var keyId = null;\\n\\n    if (key.id !== undefined && key.id !== null) {\\n      keyId = key.id;\\n    }\\n\\n    if (keyId == null) {\\n      throw new Error('IPFS client returned an unknown result...');\\n    }\\n\\n    return keyId;\\n  }\\n\\n  throw new Error('Undefined IPFS key rm...');\\n};\\n\\nexports.IpfsLibrary = IpfsLibrary;\\n\\n},{\\\"core-js/modules/esnext.map.delete-all.js\\\":127,\\\"core-js/modules/esnext.map.every.js\\\":128,\\\"core-js/modules/esnext.map.filter.js\\\":129,\\\"core-js/modules/esnext.map.find-key.js\\\":130,\\\"core-js/modules/esnext.map.find.js\\\":131,\\\"core-js/modules/esnext.map.includes.js\\\":132,\\\"core-js/modules/esnext.map.key-of.js\\\":133,\\\"core-js/modules/esnext.map.map-keys.js\\\":134,\\\"core-js/modules/esnext.map.map-values.js\\\":135,\\\"core-js/modules/esnext.map.merge.js\\\":136,\\\"core-js/modules/esnext.map.reduce.js\\\":137,\\\"core-js/modules/esnext.map.some.js\\\":138,\\\"core-js/modules/esnext.map.update.js\\\":139,\\\"core-js/modules/web.dom-collections.iterator.js\\\":140,\\\"ipfs-provider\\\":155}],5:[function(require,module,exports){\\n'use strict';\\n\\nrequire(\\\"core-js/modules/es.typed-array.uint8-array.js\\\");\\n\\nrequire(\\\"core-js/modules/web.dom-collections.iterator.js\\\");\\n\\nrequire(\\\"core-js/modules/web.url.js\\\");\\n\\nvar IpfsLoader = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle;\\n  this.name = 'ipfs-loader';\\n};\\n\\nIpfsLoader.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger();\\n}; // https://www.srihash.org/\\n\\n\\nIpfsLoader.prototype.loadTiddlerLibrary = async function (title, obj, module) {\\n  if (globalThis[obj] === undefined) {\\n    const tiddler = $tw.wiki.getTiddler(title);\\n\\n    if (tiddler) {\\n      const sourceUri = tiddler.fields._source_uri;\\n      const sourceSri = tiddler.fields._source_sri;\\n      const loaded = await this.loadLibrary(title, sourceUri, sourceSri, module);\\n\\n      if (loaded !== undefined && globalThis[obj] !== undefined) {\\n        this.getLogger().info(`Loaded ${title}:\\n${sourceUri}`);\\n        return true;\\n      }\\n\\n      throw new Error(`Unable to load Library: ${title}`);\\n    }\\n\\n    throw new Error(`Undefined Library: ${title}`);\\n  }\\n\\n  return false;\\n}; // https://github.com/liriliri/eruda\\n\\n\\nIpfsLoader.prototype.loadErudaLibrary = async function () {\\n  if (typeof globalThis.eruda === 'undefined') {\\n    return await this.loadTiddlerLibrary('$:/ipfs/library/eruda', 'eruda', true);\\n  }\\n\\n  return false;\\n}; // https://github.com/ethers-io/ethers.js/\\n\\n\\nIpfsLoader.prototype.loadEtherJsLibrary = async function () {\\n  if (typeof globalThis.ethers === 'undefined') {\\n    return await this.loadTiddlerLibrary('$:/ipfs/library/ethers', 'ethers', true);\\n  }\\n\\n  return false;\\n}; // https://github.com/xmaysonnave/eth-sig-util\\n\\n\\nIpfsLoader.prototype.loadEthSigUtilLibrary = async function () {\\n  if (typeof globalThis.sigUtil === 'undefined') {\\n    return await this.loadTiddlerLibrary('$:/ipfs/library/eth-sig-util', 'sigUtil', true);\\n  }\\n\\n  return false;\\n}; // https://github.com/ipfs/js-ipfs-http-client\\n\\n\\nIpfsLoader.prototype.loadIpfsHttpLibrary = async function () {\\n  if (typeof globalThis.IpfsHttpClient === 'undefined') {\\n    await this.loadTiddlerLibrary('$:/ipfs/library/ipfs-http-client', 'IpfsHttpClient', true);\\n  }\\n\\n  return false;\\n};\\n/*eslint no-new:\\\"off\\\",no-new-func:\\\"off\\\"*/\\n\\n\\nIpfsLoader.prototype.supportDynamicImport = function () {\\n  try {\\n    new Function('import(\\\"\\\")');\\n    return true;\\n  } catch (error) {\\n    return false;\\n  }\\n}; // https://observablehq.com/@bryangingechen/dynamic-import-polyfill\\n\\n\\nIpfsLoader.prototype.loadLibrary = function (id, url, sri, asModule) {\\n  // Dynamic import\\n  // if (this.supportDynamicImport()) {\\n  //   try {\\n  //     return new Function(`return import(\\\"${url}\\\")`)();\\n  //   } catch (error) {\\n  //     // Ignore\\n  //   }\\n  // }\\n  const self = this;\\n  return new Promise((resolve, reject) => {\\n    // Process\\n    const script = globalThis.document.createElement('script'); // Functions\\n\\n    const cleanup = () => {\\n      try {\\n        delete globalThis[id];\\n        script.onerror = null;\\n        script.onload = null;\\n        script.remove();\\n        URL.revokeObjectURL(script.src);\\n        script.src = '';\\n      } catch (error) {\\n        self.getLogger().error(error);\\n      }\\n    };\\n\\n    script.onload = () => {\\n      resolve(globalThis[id]);\\n      cleanup();\\n    };\\n\\n    script.onerror = () => {\\n      reject(new Error(`Failed to load: ${url}`));\\n      cleanup();\\n    }; // Attributes\\n\\n\\n    if (asModule) {\\n      script.type = 'module';\\n    } else {\\n      script.type = 'text/javascript';\\n    }\\n\\n    script.id = id;\\n    script.async = false;\\n    script.defer = 'defer';\\n\\n    if (sri) {\\n      script.integrity = sri;\\n    }\\n\\n    script.crossOrigin = 'anonymous'; // URL\\n\\n    script.src = url; // Load\\n\\n    globalThis.document.head.appendChild(script);\\n  });\\n};\\n\\nIpfsLoader.prototype.isJson = function (content) {\\n  if (content !== undefined && content !== null && typeof content === 'string') {\\n    try {\\n      JSON.parse(content);\\n      return true;\\n    } catch (error) {// Ignore\\n    }\\n  }\\n\\n  return false;\\n};\\n\\nIpfsLoader.prototype.fetchUint8Array = async function (url) {\\n  var options = null;\\n\\n  try {\\n    options = await fetch(url, {\\n      method: 'options'\\n    });\\n  } catch (error) {// Ignore\\n  }\\n\\n  try {\\n    const response = await fetch(options && options.ok && options.url ? options.url : url);\\n\\n    if (response.ok) {\\n      const ab = await response.arrayBuffer();\\n      const ua = new Uint8Array(ab);\\n      this.getLogger().info(`[${response.status}] Loaded:\\n  ${response.url}`);\\n      return ua;\\n    }\\n\\n    throw new Error(`[${response.status}] ${$tw.language.getString('NetworkError/Fetch')}`);\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  throw new Error(`${$tw.language.getString('NetworkError/Fetch')}`);\\n};\\n\\nIpfsLoader.prototype.xhrToJson = async function (url) {\\n  return await this.httpRequest(url, 'post', 'json');\\n};\\n\\nIpfsLoader.prototype.xhrToUint8Array = async function (url) {\\n  return await this.httpRequest(url, 'get', 'arraybuffer');\\n};\\n\\nIpfsLoader.prototype.httpRequest = function (url, method, responseType) {\\n  const self = this;\\n  const xhr = new XMLHttpRequest();\\n  return new Promise(function (resolve, reject) {\\n    xhr.responseType = responseType;\\n\\n    xhr.onreadystatechange = function () {\\n      if (xhr.readyState === 4 && xhr.status !== 0) {\\n        if (xhr.status >= 300) {\\n          reject(new Error($tw.language.getString('NetworkError/Fetch')));\\n          return;\\n        }\\n\\n        try {\\n          var result = null;\\n\\n          if (responseType === 'arraybuffer') {\\n            result = new Uint8Array(this.response);\\n          } else {\\n            result = this.response;\\n          }\\n\\n          self.getLogger().info(`[${xhr.status}] Loaded:\\n${xhr.responseURL}`);\\n          resolve(result);\\n        } catch (error) {\\n          reject(error);\\n        }\\n      }\\n    };\\n\\n    xhr.onerror = function () {\\n      reject(new Error($tw.language.getString('NetworkError/Fetch')));\\n    };\\n\\n    try {\\n      xhr.open(method, url, true);\\n      xhr.send();\\n    } catch (error) {\\n      reject(error);\\n    }\\n  });\\n};\\n\\nIpfsLoader.prototype.checkMessage = async function (message, keccak256, signature) {\\n  message = message === undefined || message == null || message.trim() === '' ? null : message.trim();\\n\\n  if (message == null) {\\n    throw new Error('Undefined encrypted content...');\\n  }\\n\\n  if (keccak256) {\\n    const hash = $tw.crypto.keccak256(message);\\n\\n    if (keccak256 !== hash) {\\n      throw new Error('Tampered encrypted content, signature do not match...');\\n    }\\n  }\\n\\n  if (signature) {\\n    try {\\n      const recovered = await this.ipfsBundle.personalRecover(keccak256, signature);\\n      $tw.ipfs.getLogger().info(`Signed from: https://app.ens.domains/address/${recovered}`);\\n      $tw.utils.alert(this.name, `Signed from: <a class=\\\"tc-tiddlylink-external\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\" href=\\\"https://app.ens.domains/address/${recovered}\\\">${recovered}</a>`);\\n    } catch (error) {\\n      if (error.name === 'UnrecoverableSignature') {\\n        throw new Error(`Tampered encrypted content. ${error.message}`);\\n      }\\n\\n      throw error;\\n    }\\n  }\\n};\\n/**\\n * Load to Base64\\n */\\n\\n\\nIpfsLoader.prototype.loadToBase64 = async function (url, password) {\\n  url = url === undefined || url == null || url.toString().trim() === '' ? null : url.toString().trim();\\n\\n  if (url == null) {\\n    throw new Error('Undefined URL...');\\n  }\\n\\n  password = password === undefined || password == null || password.trim() === '' ? null : password.trim();\\n  const ua = await this.fetchUint8Array(url);\\n\\n  if (ua.length === 0) {\\n    return '';\\n  }\\n\\n  var content = this.ipfsBundle.Utf8ArrayToStr(ua);\\n\\n  if (content.match(/{\\\"compressed\\\":/)) {\\n    const json = JSON.parse(content);\\n\\n    if (json.compressed.match(/{\\\"iv\\\":/)) {\\n      if (password == null && $tw.crypto.hasPassword() === false) {\\n        content = await this.decryptFromPasswordPrompt(json.compressed);\\n      } else {\\n        content = $tw.crypto.decrypt(json.compressed, password);\\n      }\\n\\n      content = this.ipfsBundle.inflate(content);\\n    } else if (json.compressed.match(/{\\\"version\\\":/)) {\\n      if (json.signature) {\\n        const signature = await this.ipfsBundle.decrypt(json.signature);\\n        await this.checkMessage(json.compressed, json.keccak256, signature);\\n      }\\n\\n      content = await this.ipfsBundle.decrypt(json.compressed);\\n      content = this.ipfsBundle.inflate(content);\\n    } else {\\n      content = this.ipfsBundle.inflate(json.compressed);\\n    }\\n  } else if (content.match(/{\\\"encrypted\\\":/)) {\\n    const json = JSON.parse(content);\\n\\n    if (json.signature) {\\n      const signature = await this.ipfsBundle.decrypt(json.signature);\\n      await this.checkMessage(json.encrypted, json.keccak256, signature);\\n    }\\n\\n    content = await this.ipfsBundle.decrypt(json.encrypted);\\n    content = btoa(content);\\n  } else if (content.match(/{\\\"iv\\\":/)) {\\n    if (password == null && $tw.crypto.hasPassword() === false) {\\n      content = await this.decryptFromPasswordPrompt(content);\\n    } else {\\n      content = $tw.crypto.decrypt(content, password);\\n    }\\n\\n    content = btoa(content);\\n  } else {\\n    content = this.ipfsBundle.Uint8ArrayToBase64(ua);\\n  }\\n\\n  return content;\\n};\\n/**\\n * Load to UTF-8\\n */\\n\\n\\nIpfsLoader.prototype.loadToUtf8 = async function (url, password) {\\n  url = url === undefined || url == null || url.toString().trim() === '' ? null : url.toString().trim();\\n\\n  if (url == null) {\\n    throw new Error('Undefined URL...');\\n  }\\n\\n  password = password === undefined || password == null || password.trim() === '' ? null : password.trim();\\n  const ua = await this.fetchUint8Array(url);\\n\\n  if (ua.length === 0) {\\n    return '';\\n  }\\n\\n  var content = this.ipfsBundle.Utf8ArrayToStr(ua);\\n\\n  if (content.match(/{\\\"compressed\\\":/)) {\\n    const compressedStoreArea = $tw.utils.extractCompressedStoreArea(content);\\n\\n    if (compressedStoreArea) {\\n      content = compressedStoreArea;\\n    }\\n\\n    const json = JSON.parse(content);\\n\\n    if (json.compressed.match(/{\\\"iv\\\":/)) {\\n      if (password == null && $tw.crypto.hasPassword() === false) {\\n        content = await this.decryptFromPasswordPrompt(json.compressed);\\n      } else {\\n        content = $tw.crypto.decrypt(json.compressed, password);\\n      }\\n\\n      content = this.ipfsBundle.inflate(content);\\n    } else if (json.compressed.match(/{\\\"version\\\":/)) {\\n      if (json.signature) {\\n        const signature = await this.ipfsBundle.decrypt(json.signature);\\n        await this.checkMessage(json.compressed, json.keccak256, signature);\\n      }\\n\\n      content = await this.ipfsBundle.decrypt(json.compressed);\\n      content = this.ipfsBundle.inflate(content);\\n    } else {\\n      content = this.ipfsBundle.inflate(json.compressed);\\n    }\\n  } else if (content.match(/{\\\"encrypted\\\":/)) {\\n    const encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(content);\\n\\n    if (encryptedStoreArea) {\\n      content = encryptedStoreArea;\\n    }\\n\\n    const json = JSON.parse(content);\\n\\n    if (json.signature) {\\n      const signature = await this.ipfsBundle.decrypt(json.signature);\\n      await this.checkMessage(json.encrypted, json.keccak256, signature);\\n    }\\n\\n    content = await this.ipfsBundle.decrypt(json.encrypted);\\n  } else if (content.match(/{\\\"iv\\\":/)) {\\n    const encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(content);\\n\\n    if (encryptedStoreArea) {\\n      content = encryptedStoreArea;\\n    }\\n\\n    if (password == null && $tw.crypto.hasPassword() === false) {\\n      content = await this.decryptFromPasswordPrompt(content);\\n    } else {\\n      content = $tw.crypto.decrypt(content, password);\\n    }\\n  }\\n\\n  return content;\\n};\\n\\nIpfsLoader.prototype.decryptFromPasswordPrompt = function (encrypted) {\\n  return new Promise((resolve, reject) => {\\n    $tw.passwordPrompt.createPrompt({\\n      serviceName: 'Enter a password to decrypt the imported content!!',\\n      noUserName: true,\\n      canCancel: true,\\n      submitText: 'Decrypt',\\n      callback: function (data) {\\n        if (!data) {\\n          return false;\\n        } // Decrypt\\n\\n\\n        try {\\n          const content = $tw.crypto.decrypt(encrypted, data.password);\\n          resolve(content);\\n          return true;\\n        } catch (error) {\\n          reject(error);\\n        }\\n\\n        return false;\\n      }\\n    });\\n  });\\n};\\n\\nexports.IpfsLoader = IpfsLoader;\\n\\n},{\\\"core-js/modules/es.typed-array.uint8-array.js\\\":126,\\\"core-js/modules/web.dom-collections.iterator.js\\\":140,\\\"core-js/modules/web.url.js\\\":142}],6:[function(require,module,exports){\\n'use strict';\\n\\nrequire(\\\"core-js/modules/es.string.replace.js\\\");\\n\\nrequire(\\\"core-js/modules/web.dom-collections.iterator.js\\\");\\n\\nrequire(\\\"core-js/modules/web.url.js\\\");\\n\\nconst filenamify = require('filenamify');\\n\\nvar IpfsUrl = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle;\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n\\n  this.name = 'ipfs-url';\\n};\\n\\nIpfsUrl.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger();\\n};\\n\\nIpfsUrl.prototype.filenamify = function (name, options) {\\n  if (name === undefined || name == null || name.trim() === '') {\\n    throw new Error('Undefined name...');\\n  }\\n\\n  return filenamify.replace(name, options);\\n};\\n\\nIpfsUrl.prototype.getIpfsDefaultApiUrl = function () {\\n  return new URL(this.getIpfsDefaultApi());\\n};\\n\\nIpfsUrl.prototype.getIpfsDefaultGatewayUrl = function () {\\n  return new URL(this.getIpfsDefaultGateway());\\n};\\n\\nIpfsUrl.prototype.getIpfsApiUrl = function () {\\n  try {\\n    return this.getUrl($tw.utils.getIpfsSaverApiUrl());\\n  } catch (error) {\\n    return this.getIpfsDefaultApiUrl();\\n  }\\n};\\n\\nIpfsUrl.prototype.getIpfsGatewayUrl = function () {\\n  try {\\n    return this.getUrl($tw.utils.getIpfsSaverGatewayUrl());\\n  } catch (error) {\\n    return this.getIpfsDefaultGatewayUrl();\\n  }\\n};\\n\\nIpfsUrl.prototype.getIpfsDefaultApi = function () {\\n  return 'https://ipfs.infura.io:5001';\\n};\\n\\nIpfsUrl.prototype.getIpfsDefaultGateway = function () {\\n  return 'https://dweb.link';\\n};\\n/**\\n * url.href;\\n * url.origin\\n * url.protocol;\\n * url.username;\\n * url.password;\\n * url.host;\\n * url.hostname;\\n * url.port;\\n * url.pathname;\\n * url.search;\\n * url.hash;\\n * https://jsdom.github.io/whatwg-url/\\n * https://github.com/stevenvachon/universal-url\\n * https://github.com/stevenvachon/universal-url-lite\\n * https://url.spec.whatwg.org/\\n */\\n\\n\\nIpfsUrl.prototype.getDocumentUrl = function () {\\n  try {\\n    return new URL(globalThis.location.href);\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  throw new Error('Invalid current HTML Document URL...');\\n};\\n\\nIpfsUrl.prototype.getUrl = function (url, base) {\\n  try {\\n    if (url instanceof URL) {\\n      return new URL(url.href, base);\\n    }\\n\\n    return new URL(url, base);\\n  } catch (error) {// Ignore\\n  }\\n\\n  if (url) {\\n    throw new Error('Invalid URL...');\\n  }\\n\\n  throw new Error('Undefined URL...');\\n};\\n\\nIpfsUrl.prototype.getIpfsBaseUrl = function () {\\n  var base = this.getIpfsGatewayUrl();\\n\\n  try {\\n    if ($tw.utils.getIpfsUrlPolicy() === 'origin') {\\n      base = this.getDocumentUrl();\\n    }\\n  } catch (error) {\\n    base = this.getIpfsGatewayUrl();\\n  }\\n\\n  return this.getUrl(base);\\n};\\n\\nIpfsUrl.prototype.getBase = function (base) {\\n  base = base === undefined || base == null || base.toString().trim() === '' ? null : base.toString().trim();\\n  var url;\\n\\n  if (base == null) {\\n    return this.getIpfsBaseUrl();\\n  }\\n\\n  try {\\n    url = this.getUrl(base);\\n  } catch (error) {\\n    return this.getIpfsBaseUrl();\\n  } // Parse\\n\\n\\n  var {\\n    cid,\\n    hostname,\\n    ipnsIdentifier,\\n    protocol\\n  } = this.ipfsBundle.decodeCid(base);\\n\\n  if (hostname === undefined || hostname == null || hostname.trim() === '') {\\n    return url;\\n  }\\n\\n  if (!protocol || !cid && !ipnsIdentifier) {\\n    return url;\\n  }\\n\\n  if (protocol !== 'ipfs' && protocol !== 'ipfs:' && protocol !== 'ipns' && protocol !== 'ipns:') {\\n    return url;\\n  }\\n\\n  const host = url.port ? `${hostname}:${url.port}` : hostname;\\n  return this.getUrl(`${url.protocol}//${host}`);\\n};\\n\\nIpfsUrl.prototype.normalizeUrl = function (value, base) {\\n  value = value === undefined || value == null || value.toString().trim() === '' ? null : value.toString().trim();\\n\\n  if (value == null) {\\n    return null;\\n  }\\n\\n  base = this.getBase(base); // Parse\\n\\n  var url = null; // Text or URL\\n\\n  try {\\n    url = this.getUrl(value);\\n  } catch (error) {\\n    if (value.startsWith('/') === false && value.startsWith('./') === false && value.startsWith('../') === false) {\\n      var text = true;\\n\\n      try {\\n        url = this.getUrl(`https://${value}`);\\n\\n        if (url.hostname.endsWith('.eth') === false && url.hostname.endsWith('.eth.link') === false) {\\n          url = null;\\n        } else {\\n          text = false;\\n        }\\n      } catch (error) {// ignore\\n      }\\n\\n      if (text) {\\n        return null;\\n      }\\n    }\\n  } // Invalid URL, try to parse with a Base URL\\n\\n\\n  var credential = '';\\n  var search = '';\\n  var hash = '';\\n\\n  if (url == null) {\\n    // URL\\n    url = this.getUrl(value, base); // Credential\\n\\n    if (url.username && url.password) {\\n      credential = `${url.username}:${url.password}@`;\\n    } // Hash\\n\\n\\n    hash = url.hash; // Search\\n\\n    search = url.search;\\n  } else if (url.protocol === 'ipfs:' || url.protocol === 'ipns:') {\\n    // Protocol\\n    const protocol = url.protocol.slice(0, -1); // Pathname\\n\\n    var pathname = null;\\n\\n    if (url.hostname !== undefined && url.hostname !== null && url.hostname.trim() !== '') {\\n      if (url.pathname.startsWith('//')) {\\n        pathname = `/${protocol}/${url.hostname}/${url.pathname.slice(2)}`;\\n      } else {\\n        pathname = `/${protocol}/${url.hostname}${url.pathname}`;\\n      }\\n    } else if (url.pathname !== undefined && url.pathname !== null && url.pathname.trim() !== '') {\\n      if (url.pathname.startsWith('//')) {\\n        pathname = `/${protocol}/${url.pathname.slice(2)}`;\\n      } else {\\n        pathname = `/${protocol}${url.pathname}`;\\n      }\\n    } // Credential\\n\\n\\n    if (url.username && url.password) {\\n      credential = `${url.username}:${url.password}@`;\\n    } // Hash\\n\\n\\n    hash = url.hash; // Search\\n\\n    search = url.search; // URL\\n\\n    url = this.getUrl(`${base.protocol}//${credential}${base.host}${pathname}${search}${hash}`);\\n  } // Remove .link from .eth.link\\n\\n\\n  if (url.hostname.endsWith('.eth.link')) {\\n    const hostname = url.hostname.substring(0, url.hostname.indexOf('.link'));\\n    var host = null;\\n\\n    if (url.port && url.port.trim() !== '') {\\n      host = `${hostname}:${url.port}`;\\n    } else {\\n      host = hostname;\\n    } // URL\\n\\n\\n    url = this.getUrl(`${base.protocol}//${credential}${host}${url.pathname}${search}${hash}`);\\n  }\\n\\n  return url;\\n};\\n\\nexports.IpfsUrl = IpfsUrl;\\n\\n},{\\\"core-js/modules/es.string.replace.js\\\":124,\\\"core-js/modules/web.dom-collections.iterator.js\\\":140,\\\"core-js/modules/web.url.js\\\":142,\\\"filenamify\\\":148}],7:[function(require,module,exports){\\n'use strict'\\n// base-x encoding / decoding\\n// Copyright (c) 2018 base-x contributors\\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\\n// Distributed under the MIT software license, see the accompanying\\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\\nfunction base (ALPHABET) {\\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\\n  var BASE_MAP = new Uint8Array(256)\\n  for (var j = 0; j < BASE_MAP.length; j++) {\\n    BASE_MAP[j] = 255\\n  }\\n  for (var i = 0; i < ALPHABET.length; i++) {\\n    var x = ALPHABET.charAt(i)\\n    var xc = x.charCodeAt(0)\\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\\n    BASE_MAP[xc] = i\\n  }\\n  var BASE = ALPHABET.length\\n  var LEADER = ALPHABET.charAt(0)\\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\\n  function encode (source) {\\n    if (source instanceof Uint8Array) {\\n    } else if (ArrayBuffer.isView(source)) {\\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\\n    } else if (Array.isArray(source)) {\\n      source = Uint8Array.from(source)\\n    }\\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\\n    if (source.length === 0) { return '' }\\n        // Skip & count leading zeroes.\\n    var zeroes = 0\\n    var length = 0\\n    var pbegin = 0\\n    var pend = source.length\\n    while (pbegin !== pend && source[pbegin] === 0) {\\n      pbegin++\\n      zeroes++\\n    }\\n        // Allocate enough space in big-endian base58 representation.\\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\\n    var b58 = new Uint8Array(size)\\n        // Process the bytes.\\n    while (pbegin !== pend) {\\n      var carry = source[pbegin]\\n            // Apply \\\"b58 = b58 * 256 + ch\\\".\\n      var i = 0\\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\\n        carry += (256 * b58[it1]) >>> 0\\n        b58[it1] = (carry % BASE) >>> 0\\n        carry = (carry / BASE) >>> 0\\n      }\\n      if (carry !== 0) { throw new Error('Non-zero carry') }\\n      length = i\\n      pbegin++\\n    }\\n        // Skip leading zeroes in base58 result.\\n    var it2 = size - length\\n    while (it2 !== size && b58[it2] === 0) {\\n      it2++\\n    }\\n        // Translate the result into a string.\\n    var str = LEADER.repeat(zeroes)\\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\\n    return str\\n  }\\n  function decodeUnsafe (source) {\\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\\n    if (source.length === 0) { return new Uint8Array() }\\n    var psz = 0\\n        // Skip leading spaces.\\n    if (source[psz] === ' ') { return }\\n        // Skip and count leading '1's.\\n    var zeroes = 0\\n    var length = 0\\n    while (source[psz] === LEADER) {\\n      zeroes++\\n      psz++\\n    }\\n        // Allocate enough space in big-endian base256 representation.\\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\\n    var b256 = new Uint8Array(size)\\n        // Process the characters.\\n    while (source[psz]) {\\n            // Decode character\\n      var carry = BASE_MAP[source.charCodeAt(psz)]\\n            // Invalid character\\n      if (carry === 255) { return }\\n      var i = 0\\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\\n        carry += (BASE * b256[it3]) >>> 0\\n        b256[it3] = (carry % 256) >>> 0\\n        carry = (carry / 256) >>> 0\\n      }\\n      if (carry !== 0) { throw new Error('Non-zero carry') }\\n      length = i\\n      psz++\\n    }\\n        // Skip trailing spaces.\\n    if (source[psz] === ' ') { return }\\n        // Skip leading zeroes in b256.\\n    var it4 = size - length\\n    while (it4 !== size && b256[it4] === 0) {\\n      it4++\\n    }\\n    var vch = new Uint8Array(zeroes + (size - it4))\\n    var j = zeroes\\n    while (it4 !== size) {\\n      vch[j++] = b256[it4++]\\n    }\\n    return vch\\n  }\\n  function decode (string) {\\n    var buffer = decodeUnsafe(string)\\n    if (buffer) { return buffer }\\n    throw new Error('Non-base' + BASE + ' character')\\n  }\\n  return {\\n    encode: encode,\\n    decodeUnsafe: decodeUnsafe,\\n    decode: decode\\n  }\\n}\\nmodule.exports = base\\n\\n},{}],8:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\\n *\\n * @param {Array<ArrayLike<number>>} arrays\\n * @param {number} [length]\\n * @returns {Uint8Array}\\n */\\nfunction concat (arrays, length) {\\n  if (!length) {\\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\\n  }\\n\\n  const output = new Uint8Array(length)\\n  let offset = 0\\n\\n  for (const arr of arrays) {\\n    output.set(arr, offset)\\n    offset += arr.length\\n  }\\n\\n  return output\\n}\\n\\nmodule.exports = concat\\n\\n},{}],9:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns true if the two passed Uint8Arrays have the same content\\n *\\n * @param {Uint8Array} a\\n * @param {Uint8Array} b\\n * @returns {boolean}\\n */\\nfunction equals (a, b) {\\n  if (a === b) {\\n    return true\\n  }\\n\\n  if (a.byteLength !== b.byteLength) {\\n    return false\\n  }\\n\\n  for (let i = 0; i < a.byteLength; i++) {\\n    if (a[i] !== b[i]) {\\n      return false\\n    }\\n  }\\n\\n  return true\\n}\\n\\nmodule.exports = equals\\n\\n},{}],10:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst { TextDecoder } = require('web-encoding')\\nconst utf8Decoder = new TextDecoder('utf8')\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName} BaseName\\n */\\n\\n/**\\n * Turns a Uint8Array of bytes into a string with each\\n * character being the char code of the corresponding byte\\n *\\n * @param {Uint8Array} array - The array to turn into a string\\n * @returns {string}\\n */\\nfunction uint8ArrayToAsciiString (array) {\\n  let string = ''\\n\\n  for (let i = 0; i < array.length; i++) {\\n    string += String.fromCharCode(array[i])\\n  }\\n  return string\\n}\\n\\n/**\\n * Turns a `Uint8Array` into a string.\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {Uint8Array} array - The array to turn into a string\\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - The encoding to use\\n * @returns {string}\\n */\\nfunction toString (array, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Decoder.decode(array)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return uint8ArrayToAsciiString(array)\\n  }\\n\\n  return getCodec(encoding).encode(array)\\n}\\n\\nmodule.exports = toString\\n\\n},{\\\"multibase\\\":164,\\\"web-encoding\\\":201}],11:[function(require,module,exports){\\n'use strict'\\n\\nconst mh = require('multihashes')\\n\\nconst CIDUtil = {\\n  /**\\n   * Test if the given input is a valid CID object.\\n   * Returns an error message if it is not.\\n   * Returns undefined if it is a valid CID.\\n   *\\n   * @param {any} other\\n   * @returns {string|undefined}\\n   */\\n  checkCIDComponents: function (other) {\\n    if (other == null) {\\n      return 'null values are not valid CIDs'\\n    }\\n\\n    if (!(other.version === 0 || other.version === 1)) {\\n      return 'Invalid version, must be a number equal to 1 or 0'\\n    }\\n\\n    if (typeof other.codec !== 'string') {\\n      return 'codec must be string'\\n    }\\n\\n    if (other.version === 0) {\\n      if (other.codec !== 'dag-pb') {\\n        return \\\"codec must be 'dag-pb' for CIDv0\\\"\\n      }\\n      if (other.multibaseName !== 'base58btc') {\\n        return \\\"multibaseName must be 'base58btc' for CIDv0\\\"\\n      }\\n    }\\n\\n    if (!(other.multihash instanceof Uint8Array)) {\\n      return 'multihash must be a Uint8Array'\\n    }\\n\\n    try {\\n      mh.validate(other.multihash)\\n    } catch (err) {\\n      let errorMsg = err.message\\n      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message\\n        errorMsg = 'Multihash validation failed'\\n      }\\n      return errorMsg\\n    }\\n  }\\n}\\n\\nmodule.exports = CIDUtil\\n\\n},{\\\"multihashes\\\":189}],12:[function(require,module,exports){\\n'use strict'\\n\\nconst mh = require('multihashes')\\nconst multibase = require('multibase')\\nconst multicodec = require('multicodec')\\nconst { baseTable: codecs } = require('multicodec/src/base-table.js')\\nconst CIDUtil = require('./cid-util')\\nconst uint8ArrayConcat = require('uint8arrays/concat')\\nconst uint8ArrayToString = require('uint8arrays/to-string')\\nconst uint8ArrayEquals = require('uint8arrays/equals')\\n\\nconst codecInts = /** @type {CodecName[]} */(Object.keys(codecs)).reduce((p, name) => {\\n  p[codecs[name]] = name\\n  return p\\n}, /** @type {Record<CodecNumber, CodecName>} */({}))\\n\\nconst symbol = Symbol.for('@ipld/js-cid/CID')\\n\\n/**\\n * @typedef {Object} SerializedCID\\n * @property {string} codec\\n * @property {number} version\\n * @property {Uint8Array} hash\\n */\\n/**\\n * @typedef {0|1} CIDVersion\\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\\n * @typedef {import('multicodec').CodecName} CodecName\\n * @typedef {import('multicodec').CodecNumber} CodecNumber\\n */\\n\\n/**\\n * Class representing a CID `<mbase><version><mcodec><mhash>`\\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\\n *\\n * @class CID\\n */\\nclass CID {\\n  /**\\n   * Create a new CID.\\n   *\\n   * The algorithm for argument input is roughly:\\n   * ```\\n   * if (cid)\\n   *   -> create a copy\\n   * else if (str)\\n   *   if (1st char is on multibase table) -> CID String\\n   *   else -> bs58 encoded multihash\\n   * else if (Uint8Array)\\n   *   if (1st byte is 0 or 1) -> CID\\n   *   else -> multihash\\n   * else if (Number)\\n   *   -> construct CID by parts\\n   * ```\\n   *\\n   * @param {CIDVersion | string | Uint8Array | CID} version\\n   * @param {string|number} [codec]\\n   * @param {Uint8Array} [multihash]\\n   * @param {string} [multibaseName]\\n   *\\n   * @example\\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\\n   * new CID(<cidStr>)\\n   * new CID(<cid.bytes>)\\n   * new CID(<multihash>)\\n   * new CID(<bs58 encoded multihash>)\\n   * new CID(<cid>)\\n   */\\n  constructor (version, codec, multihash, multibaseName) {\\n    // We have below three blank field accessors only because\\n    // otherwise TS will not pick them up if done after assignemnts\\n\\n    /**\\n     * The version of the CID.\\n     *\\n     * @type {CIDVersion}\\n     */\\n    // eslint-disable-next-line no-unused-expressions\\n    this.version\\n\\n    /**\\n     * The codec of the CID.\\n     *\\n     * @deprecated\\n     * @type {CodecName}\\n     */\\n    // eslint-disable-next-line no-unused-expressions\\n    this.codec\\n\\n    /**\\n     * The multihash of the CID.\\n     *\\n     * @type {Uint8Array}\\n     */\\n    // eslint-disable-next-line no-unused-expressions\\n    this.multihash\\n\\n    Object.defineProperty(this, symbol, { value: true })\\n    if (CID.isCID(version)) {\\n      // version is an exising CID instance\\n      const cid = /** @type {CID} */(version)\\n      this.version = cid.version\\n      this.codec = cid.codec\\n      this.multihash = cid.multihash\\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\\n      // @ts-ignore\\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\\n      return\\n    }\\n\\n    if (typeof version === 'string') {\\n      // e.g. 'base32' or false\\n      const baseName = multibase.isEncoded(version)\\n      if (baseName) {\\n        // version is a CID String encoded with multibase, so v1\\n        const cid = multibase.decode(version)\\n        this.version = /** @type {CIDVersion} */(parseInt(cid[0].toString(), 16))\\n        this.codec = multicodec.getCodec(cid.slice(1))\\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\\n        this.multibaseName = baseName\\n      } else {\\n        // version is a base58btc string multihash, so v0\\n        this.version = 0\\n        this.codec = 'dag-pb'\\n        this.multihash = mh.fromB58String(version)\\n        this.multibaseName = 'base58btc'\\n      }\\n      CID.validateCID(this)\\n      Object.defineProperty(this, 'string', { value: version })\\n      return\\n    }\\n\\n    if (version instanceof Uint8Array) {\\n      const v = parseInt(version[0].toString(), 16)\\n      if (v === 1) {\\n        // version is a CID Uint8Array\\n        const cid = version\\n        this.version = v\\n        this.codec = multicodec.getCodec(cid.slice(1))\\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\\n        this.multibaseName = 'base32'\\n      } else {\\n        // version is a raw multihash Uint8Array, so v0\\n        this.version = 0\\n        this.codec = 'dag-pb'\\n        this.multihash = version\\n        this.multibaseName = 'base58btc'\\n      }\\n      CID.validateCID(this)\\n      return\\n    }\\n\\n    // otherwise, assemble the CID from the parameters\\n\\n    this.version = version\\n\\n    if (typeof codec === 'number') {\\n      // @ts-ignore\\n      codec = codecInts[codec]\\n    }\\n\\n    this.codec = /** @type {CodecName} */ (codec)\\n\\n    this.multihash = /** @type {Uint8Array} */ (multihash)\\n\\n    /**\\n     * Multibase name as string.\\n     *\\n     * @deprecated\\n     * @type {string}\\n     */\\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\\n\\n    CID.validateCID(this)\\n  }\\n\\n  /**\\n   * The CID as a `Uint8Array`\\n   *\\n   * @returns {Uint8Array}\\n   *\\n   */\\n  get bytes () {\\n    // @ts-ignore\\n    let bytes = this._bytes\\n\\n    if (!bytes) {\\n      if (this.version === 0) {\\n        bytes = this.multihash\\n      } else if (this.version === 1) {\\n        const codec = multicodec.getCodeVarint(this.codec)\\n        bytes = uint8ArrayConcat([\\n          [1], codec, this.multihash\\n        ], 1 + codec.byteLength + this.multihash.byteLength)\\n      } else {\\n        throw new Error('unsupported version')\\n      }\\n\\n      // Cache this Uint8Array so it doesn't have to be recreated\\n      Object.defineProperty(this, '_bytes', { value: bytes })\\n    }\\n\\n    return bytes\\n  }\\n\\n  /**\\n   * The prefix of the CID.\\n   *\\n   * @returns {Uint8Array}\\n   */\\n  get prefix () {\\n    const codec = multicodec.getCodeVarint(this.codec)\\n    const multihash = mh.prefix(this.multihash)\\n    const prefix = uint8ArrayConcat([\\n      [this.version], codec, multihash\\n    ], 1 + codec.byteLength + multihash.byteLength)\\n\\n    return prefix\\n  }\\n\\n  /**\\n   * The codec of the CID in its number form.\\n   *\\n   * @returns {CodecNumber}\\n   */\\n  get code () {\\n    return codecs[this.codec]\\n  }\\n\\n  /**\\n   * Convert to a CID of version `0`.\\n   *\\n   * @returns {CID}\\n   */\\n  toV0 () {\\n    if (this.codec !== 'dag-pb') {\\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\\n    }\\n\\n    const { name, length } = mh.decode(this.multihash)\\n\\n    if (name !== 'sha2-256') {\\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\\n    }\\n\\n    if (length !== 32) {\\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\\n    }\\n\\n    return new CID(0, this.codec, this.multihash)\\n  }\\n\\n  /**\\n   * Convert to a CID of version `1`.\\n   *\\n   * @returns {CID}\\n   */\\n  toV1 () {\\n    return new CID(1, this.codec, this.multihash)\\n  }\\n\\n  /**\\n   * Encode the CID into a string.\\n   *\\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\\n   * @returns {string}\\n   */\\n  toBaseEncodedString (base = this.multibaseName) {\\n    // @ts-ignore non enumerable cache property\\n    if (this.string && this.string.length !== 0 && base === this.multibaseName) {\\n      // @ts-ignore non enumerable cache property\\n      return this.string\\n    }\\n    let str\\n    if (this.version === 0) {\\n      if (base !== 'base58btc') {\\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\\n      }\\n      str = mh.toB58String(this.multihash)\\n    } else if (this.version === 1) {\\n      str = uint8ArrayToString(multibase.encode(base, this.bytes))\\n    } else {\\n      throw new Error('unsupported version')\\n    }\\n    if (base === this.multibaseName) {\\n      // cache the string value\\n      Object.defineProperty(this, 'string', { value: str })\\n    }\\n    return str\\n  }\\n\\n  /**\\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\\n   *\\n   * @returns {string}\\n   */\\n  [Symbol.for('nodejs.util.inspect.custom')] () {\\n    return 'CID(' + this.toString() + ')'\\n  }\\n\\n  /**\\n   * Encode the CID into a string.\\n   *\\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\\n   * @returns {string}\\n   */\\n  toString (base) {\\n    return this.toBaseEncodedString(base)\\n  }\\n\\n  /**\\n   * Serialize to a plain object.\\n   *\\n   * @returns {SerializedCID}\\n   */\\n  toJSON () {\\n    return {\\n      codec: this.codec,\\n      version: this.version,\\n      hash: this.multihash\\n    }\\n  }\\n\\n  /**\\n   * Compare equality with another CID.\\n   *\\n   * @param {CID} other\\n   * @returns {boolean}\\n   */\\n  equals (other) {\\n    return this.codec === other.codec &&\\n      this.version === other.version &&\\n      uint8ArrayEquals(this.multihash, other.multihash)\\n  }\\n\\n  /**\\n   * Test if the given input is a valid CID object.\\n   * Throws if it is not.\\n   *\\n   * @param {any} other - The other CID.\\n   * @returns {void}\\n   */\\n  static validateCID (other) {\\n    const errorMsg = CIDUtil.checkCIDComponents(other)\\n    if (errorMsg) {\\n      throw new Error(errorMsg)\\n    }\\n  }\\n\\n  /**\\n   * Check if object is a CID instance\\n   *\\n   * @param {any} value\\n   * @returns {value is CID}\\n   */\\n  static isCID (value) {\\n    return value instanceof CID || Boolean(value && value[symbol])\\n  }\\n}\\n\\nCID.codecs = codecs\\n\\nmodule.exports = CID\\n\\n},{\\\"./cid-util\\\":11,\\\"multibase\\\":164,\\\"multicodec\\\":176,\\\"multicodec/src/base-table.js\\\":174,\\\"multihashes\\\":189,\\\"uint8arrays/concat\\\":8,\\\"uint8arrays/equals\\\":9,\\\"uint8arrays/to-string\\\":10}],13:[function(require,module,exports){\\nmodule.exports = function (it) {\\n  if (typeof it != 'function') {\\n    throw TypeError(String(it) + ' is not a function');\\n  } return it;\\n};\\n\\n},{}],14:[function(require,module,exports){\\nvar isObject = require('../internals/is-object');\\n\\nmodule.exports = function (it) {\\n  if (!isObject(it) && it !== null) {\\n    throw TypeError(\\\"Can't set \\\" + String(it) + ' as a prototype');\\n  } return it;\\n};\\n\\n},{\\\"../internals/is-object\\\":65}],15:[function(require,module,exports){\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar create = require('../internals/object-create');\\nvar definePropertyModule = require('../internals/object-define-property');\\n\\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\\nvar ArrayPrototype = Array.prototype;\\n\\n// Array.prototype[@@unscopables]\\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\\n    configurable: true,\\n    value: create(null)\\n  });\\n}\\n\\n// add a key to Array.prototype[@@unscopables]\\nmodule.exports = function (key) {\\n  ArrayPrototype[UNSCOPABLES][key] = true;\\n};\\n\\n},{\\\"../internals/object-create\\\":75,\\\"../internals/object-define-property\\\":77,\\\"../internals/well-known-symbol\\\":120}],16:[function(require,module,exports){\\n'use strict';\\nvar charAt = require('../internals/string-multibyte').charAt;\\n\\n// `AdvanceStringIndex` abstract operation\\n// https://tc39.es/ecma262/#sec-advancestringindex\\nmodule.exports = function (S, index, unicode) {\\n  return index + (unicode ? charAt(S, index).length : 1);\\n};\\n\\n},{\\\"../internals/string-multibyte\\\":103}],17:[function(require,module,exports){\\nmodule.exports = function (it, Constructor, name) {\\n  if (!(it instanceof Constructor)) {\\n    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\\n  } return it;\\n};\\n\\n},{}],18:[function(require,module,exports){\\nvar isObject = require('../internals/is-object');\\n\\nmodule.exports = function (it) {\\n  if (!isObject(it)) {\\n    throw TypeError(String(it) + ' is not an object');\\n  } return it;\\n};\\n\\n},{\\\"../internals/is-object\\\":65}],19:[function(require,module,exports){\\nmodule.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';\\n\\n},{}],20:[function(require,module,exports){\\n'use strict';\\nvar NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar global = require('../internals/global');\\nvar isObject = require('../internals/is-object');\\nvar has = require('../internals/has');\\nvar classof = require('../internals/classof');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar redefine = require('../internals/redefine');\\nvar defineProperty = require('../internals/object-define-property').f;\\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar uid = require('../internals/uid');\\n\\nvar Int8Array = global.Int8Array;\\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\\nvar Uint8ClampedArray = global.Uint8ClampedArray;\\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\\nvar TypedArray = Int8Array && getPrototypeOf(Int8Array);\\nvar TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\\nvar ObjectPrototype = Object.prototype;\\nvar isPrototypeOf = ObjectPrototype.isPrototypeOf;\\n\\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\\nvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\\nvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';\\nvar TYPED_ARRAY_TAG_REQIRED = false;\\nvar NAME;\\n\\nvar TypedArrayConstructorsList = {\\n  Int8Array: 1,\\n  Uint8Array: 1,\\n  Uint8ClampedArray: 1,\\n  Int16Array: 2,\\n  Uint16Array: 2,\\n  Int32Array: 4,\\n  Uint32Array: 4,\\n  Float32Array: 4,\\n  Float64Array: 8\\n};\\n\\nvar BigIntArrayConstructorsList = {\\n  BigInt64Array: 8,\\n  BigUint64Array: 8\\n};\\n\\nvar isView = function isView(it) {\\n  if (!isObject(it)) return false;\\n  var klass = classof(it);\\n  return klass === 'DataView'\\n    || has(TypedArrayConstructorsList, klass)\\n    || has(BigIntArrayConstructorsList, klass);\\n};\\n\\nvar isTypedArray = function (it) {\\n  if (!isObject(it)) return false;\\n  var klass = classof(it);\\n  return has(TypedArrayConstructorsList, klass)\\n    || has(BigIntArrayConstructorsList, klass);\\n};\\n\\nvar aTypedArray = function (it) {\\n  if (isTypedArray(it)) return it;\\n  throw TypeError('Target is not a typed array');\\n};\\n\\nvar aTypedArrayConstructor = function (C) {\\n  if (setPrototypeOf) {\\n    if (isPrototypeOf.call(TypedArray, C)) return C;\\n  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {\\n    var TypedArrayConstructor = global[ARRAY];\\n    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {\\n      return C;\\n    }\\n  } throw TypeError('Target is not a typed array constructor');\\n};\\n\\nvar exportTypedArrayMethod = function (KEY, property, forced) {\\n  if (!DESCRIPTORS) return;\\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\\n    var TypedArrayConstructor = global[ARRAY];\\n    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {\\n      delete TypedArrayConstructor.prototype[KEY];\\n    }\\n  }\\n  if (!TypedArrayPrototype[KEY] || forced) {\\n    redefine(TypedArrayPrototype, KEY, forced ? property\\n      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);\\n  }\\n};\\n\\nvar exportTypedArrayStaticMethod = function (KEY, property, forced) {\\n  var ARRAY, TypedArrayConstructor;\\n  if (!DESCRIPTORS) return;\\n  if (setPrototypeOf) {\\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\\n      TypedArrayConstructor = global[ARRAY];\\n      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {\\n        delete TypedArrayConstructor[KEY];\\n      }\\n    }\\n    if (!TypedArray[KEY] || forced) {\\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\\n      try {\\n        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);\\n      } catch (error) { /* empty */ }\\n    } else return;\\n  }\\n  for (ARRAY in TypedArrayConstructorsList) {\\n    TypedArrayConstructor = global[ARRAY];\\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\\n      redefine(TypedArrayConstructor, KEY, property);\\n    }\\n  }\\n};\\n\\nfor (NAME in TypedArrayConstructorsList) {\\n  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;\\n}\\n\\n// WebKit bug - typed arrays constructors prototype is Object.prototype\\nif (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {\\n  // eslint-disable-next-line no-shadow\\n  TypedArray = function TypedArray() {\\n    throw TypeError('Incorrect invocation');\\n  };\\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\\n    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);\\n  }\\n}\\n\\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\\n  TypedArrayPrototype = TypedArray.prototype;\\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\\n    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);\\n  }\\n}\\n\\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\\nif (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\\n  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\\n}\\n\\nif (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {\\n  TYPED_ARRAY_TAG_REQIRED = true;\\n  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {\\n    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\\n  } });\\n  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {\\n    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);\\n  }\\n}\\n\\nmodule.exports = {\\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,\\n  aTypedArray: aTypedArray,\\n  aTypedArrayConstructor: aTypedArrayConstructor,\\n  exportTypedArrayMethod: exportTypedArrayMethod,\\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\\n  isView: isView,\\n  isTypedArray: isTypedArray,\\n  TypedArray: TypedArray,\\n  TypedArrayPrototype: TypedArrayPrototype\\n};\\n\\n},{\\\"../internals/array-buffer-native\\\":19,\\\"../internals/classof\\\":30,\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/descriptors\\\":39,\\\"../internals/global\\\":52,\\\"../internals/has\\\":53,\\\"../internals/is-object\\\":65,\\\"../internals/object-define-property\\\":77,\\\"../internals/object-get-prototype-of\\\":81,\\\"../internals/object-set-prototype-of\\\":85,\\\"../internals/redefine\\\":89,\\\"../internals/uid\\\":118,\\\"../internals/well-known-symbol\\\":120}],21:[function(require,module,exports){\\n'use strict';\\nvar global = require('../internals/global');\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar redefineAll = require('../internals/redefine-all');\\nvar fails = require('../internals/fails');\\nvar anInstance = require('../internals/an-instance');\\nvar toInteger = require('../internals/to-integer');\\nvar toLength = require('../internals/to-length');\\nvar toIndex = require('../internals/to-index');\\nvar IEEE754 = require('../internals/ieee754');\\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\\nvar defineProperty = require('../internals/object-define-property').f;\\nvar arrayFill = require('../internals/array-fill');\\nvar setToStringTag = require('../internals/set-to-string-tag');\\nvar InternalStateModule = require('../internals/internal-state');\\n\\nvar getInternalState = InternalStateModule.get;\\nvar setInternalState = InternalStateModule.set;\\nvar ARRAY_BUFFER = 'ArrayBuffer';\\nvar DATA_VIEW = 'DataView';\\nvar PROTOTYPE = 'prototype';\\nvar WRONG_LENGTH = 'Wrong length';\\nvar WRONG_INDEX = 'Wrong index';\\nvar NativeArrayBuffer = global[ARRAY_BUFFER];\\nvar $ArrayBuffer = NativeArrayBuffer;\\nvar $DataView = global[DATA_VIEW];\\nvar $DataViewPrototype = $DataView && $DataView[PROTOTYPE];\\nvar ObjectPrototype = Object.prototype;\\nvar RangeError = global.RangeError;\\n\\nvar packIEEE754 = IEEE754.pack;\\nvar unpackIEEE754 = IEEE754.unpack;\\n\\nvar packInt8 = function (number) {\\n  return [number & 0xFF];\\n};\\n\\nvar packInt16 = function (number) {\\n  return [number & 0xFF, number >> 8 & 0xFF];\\n};\\n\\nvar packInt32 = function (number) {\\n  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\\n};\\n\\nvar unpackInt32 = function (buffer) {\\n  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\\n};\\n\\nvar packFloat32 = function (number) {\\n  return packIEEE754(number, 23, 4);\\n};\\n\\nvar packFloat64 = function (number) {\\n  return packIEEE754(number, 52, 8);\\n};\\n\\nvar addGetter = function (Constructor, key) {\\n  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });\\n};\\n\\nvar get = function (view, count, index, isLittleEndian) {\\n  var intIndex = toIndex(index);\\n  var store = getInternalState(view);\\n  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);\\n  var bytes = getInternalState(store.buffer).bytes;\\n  var start = intIndex + store.byteOffset;\\n  var pack = bytes.slice(start, start + count);\\n  return isLittleEndian ? pack : pack.reverse();\\n};\\n\\nvar set = function (view, count, index, conversion, value, isLittleEndian) {\\n  var intIndex = toIndex(index);\\n  var store = getInternalState(view);\\n  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);\\n  var bytes = getInternalState(store.buffer).bytes;\\n  var start = intIndex + store.byteOffset;\\n  var pack = conversion(+value);\\n  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\\n};\\n\\nif (!NATIVE_ARRAY_BUFFER) {\\n  $ArrayBuffer = function ArrayBuffer(length) {\\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\\n    var byteLength = toIndex(length);\\n    setInternalState(this, {\\n      bytes: arrayFill.call(new Array(byteLength), 0),\\n      byteLength: byteLength\\n    });\\n    if (!DESCRIPTORS) this.byteLength = byteLength;\\n  };\\n\\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\\n    anInstance(this, $DataView, DATA_VIEW);\\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\\n    var bufferLength = getInternalState(buffer).byteLength;\\n    var offset = toInteger(byteOffset);\\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');\\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\\n    setInternalState(this, {\\n      buffer: buffer,\\n      byteLength: byteLength,\\n      byteOffset: offset\\n    });\\n    if (!DESCRIPTORS) {\\n      this.buffer = buffer;\\n      this.byteLength = byteLength;\\n      this.byteOffset = offset;\\n    }\\n  };\\n\\n  if (DESCRIPTORS) {\\n    addGetter($ArrayBuffer, 'byteLength');\\n    addGetter($DataView, 'buffer');\\n    addGetter($DataView, 'byteLength');\\n    addGetter($DataView, 'byteOffset');\\n  }\\n\\n  redefineAll($DataView[PROTOTYPE], {\\n    getInt8: function getInt8(byteOffset) {\\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\\n    },\\n    getUint8: function getUint8(byteOffset) {\\n      return get(this, 1, byteOffset)[0];\\n    },\\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\\n    },\\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\\n      return bytes[1] << 8 | bytes[0];\\n    },\\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\\n    },\\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\\n    },\\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\\n      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\\n    },\\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\\n      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\\n    },\\n    setInt8: function setInt8(byteOffset, value) {\\n      set(this, 1, byteOffset, packInt8, value);\\n    },\\n    setUint8: function setUint8(byteOffset, value) {\\n      set(this, 1, byteOffset, packInt8, value);\\n    },\\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\\n    },\\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\\n    },\\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\\n    },\\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\\n    },\\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\\n      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\\n    },\\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\\n      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\\n    }\\n  });\\n} else {\\n  if (!fails(function () {\\n    NativeArrayBuffer(1);\\n  }) || !fails(function () {\\n    new NativeArrayBuffer(-1); // eslint-disable-line no-new\\n  }) || fails(function () {\\n    new NativeArrayBuffer(); // eslint-disable-line no-new\\n    new NativeArrayBuffer(1.5); // eslint-disable-line no-new\\n    new NativeArrayBuffer(NaN); // eslint-disable-line no-new\\n    return NativeArrayBuffer.name != ARRAY_BUFFER;\\n  })) {\\n    $ArrayBuffer = function ArrayBuffer(length) {\\n      anInstance(this, $ArrayBuffer);\\n      return new NativeArrayBuffer(toIndex(length));\\n    };\\n    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];\\n    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {\\n      if (!((key = keys[j++]) in $ArrayBuffer)) {\\n        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);\\n      }\\n    }\\n    ArrayBufferPrototype.constructor = $ArrayBuffer;\\n  }\\n\\n  // WebKit bug - the same parent prototype for typed arrays and data view\\n  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {\\n    setPrototypeOf($DataViewPrototype, ObjectPrototype);\\n  }\\n\\n  // iOS Safari 7.x bug\\n  var testView = new $DataView(new $ArrayBuffer(2));\\n  var nativeSetInt8 = $DataViewPrototype.setInt8;\\n  testView.setInt8(0, 2147483648);\\n  testView.setInt8(1, 2147483649);\\n  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {\\n    setInt8: function setInt8(byteOffset, value) {\\n      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);\\n    },\\n    setUint8: function setUint8(byteOffset, value) {\\n      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);\\n    }\\n  }, { unsafe: true });\\n}\\n\\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\\nsetToStringTag($DataView, DATA_VIEW);\\n\\nmodule.exports = {\\n  ArrayBuffer: $ArrayBuffer,\\n  DataView: $DataView\\n};\\n\\n},{\\\"../internals/an-instance\\\":17,\\\"../internals/array-buffer-native\\\":19,\\\"../internals/array-fill\\\":22,\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/descriptors\\\":39,\\\"../internals/fails\\\":44,\\\"../internals/global\\\":52,\\\"../internals/ieee754\\\":57,\\\"../internals/internal-state\\\":61,\\\"../internals/object-define-property\\\":77,\\\"../internals/object-get-own-property-names\\\":79,\\\"../internals/object-get-prototype-of\\\":81,\\\"../internals/object-set-prototype-of\\\":85,\\\"../internals/redefine-all\\\":88,\\\"../internals/set-to-string-tag\\\":98,\\\"../internals/to-index\\\":106,\\\"../internals/to-integer\\\":108,\\\"../internals/to-length\\\":109}],22:[function(require,module,exports){\\n'use strict';\\nvar toObject = require('../internals/to-object');\\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\\nvar toLength = require('../internals/to-length');\\n\\n// `Array.prototype.fill` method implementation\\n// https://tc39.es/ecma262/#sec-array.prototype.fill\\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\\n  var O = toObject(this);\\n  var length = toLength(O.length);\\n  var argumentsLength = arguments.length;\\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\\n  while (endPos > index) O[index++] = value;\\n  return O;\\n};\\n\\n},{\\\"../internals/to-absolute-index\\\":105,\\\"../internals/to-length\\\":109,\\\"../internals/to-object\\\":110}],23:[function(require,module,exports){\\n'use strict';\\nvar bind = require('../internals/function-bind-context');\\nvar toObject = require('../internals/to-object');\\nvar callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');\\nvar isArrayIteratorMethod = require('../internals/is-array-iterator-method');\\nvar toLength = require('../internals/to-length');\\nvar createProperty = require('../internals/create-property');\\nvar getIteratorMethod = require('../internals/get-iterator-method');\\n\\n// `Array.from` method implementation\\n// https://tc39.es/ecma262/#sec-array.from\\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\\n  var O = toObject(arrayLike);\\n  var C = typeof this == 'function' ? this : Array;\\n  var argumentsLength = arguments.length;\\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\\n  var mapping = mapfn !== undefined;\\n  var iteratorMethod = getIteratorMethod(O);\\n  var index = 0;\\n  var length, result, step, iterator, next, value;\\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\\n    iterator = iteratorMethod.call(O);\\n    next = iterator.next;\\n    result = new C();\\n    for (;!(step = next.call(iterator)).done; index++) {\\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\\n      createProperty(result, index, value);\\n    }\\n  } else {\\n    length = toLength(O.length);\\n    result = new C(length);\\n    for (;length > index; index++) {\\n      value = mapping ? mapfn(O[index], index) : O[index];\\n      createProperty(result, index, value);\\n    }\\n  }\\n  result.length = index;\\n  return result;\\n};\\n\\n},{\\\"../internals/call-with-safe-iteration-closing\\\":27,\\\"../internals/create-property\\\":37,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-iterator-method\\\":48,\\\"../internals/is-array-iterator-method\\\":62,\\\"../internals/to-length\\\":109,\\\"../internals/to-object\\\":110}],24:[function(require,module,exports){\\nvar toIndexedObject = require('../internals/to-indexed-object');\\nvar toLength = require('../internals/to-length');\\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\\n\\n// `Array.prototype.{ indexOf, includes }` methods implementation\\nvar createMethod = function (IS_INCLUDES) {\\n  return function ($this, el, fromIndex) {\\n    var O = toIndexedObject($this);\\n    var length = toLength(O.length);\\n    var index = toAbsoluteIndex(fromIndex, length);\\n    var value;\\n    // Array#includes uses SameValueZero equality algorithm\\n    // eslint-disable-next-line no-self-compare\\n    if (IS_INCLUDES && el != el) while (length > index) {\\n      value = O[index++];\\n      // eslint-disable-next-line no-self-compare\\n      if (value != value) return true;\\n    // Array#indexOf ignores holes, Array#includes - not\\n    } else for (;length > index; index++) {\\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\\n    } return !IS_INCLUDES && -1;\\n  };\\n};\\n\\nmodule.exports = {\\n  // `Array.prototype.includes` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\\n  includes: createMethod(true),\\n  // `Array.prototype.indexOf` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\\n  indexOf: createMethod(false)\\n};\\n\\n},{\\\"../internals/to-absolute-index\\\":105,\\\"../internals/to-indexed-object\\\":107,\\\"../internals/to-length\\\":109}],25:[function(require,module,exports){\\nvar bind = require('../internals/function-bind-context');\\nvar IndexedObject = require('../internals/indexed-object');\\nvar toObject = require('../internals/to-object');\\nvar toLength = require('../internals/to-length');\\nvar arraySpeciesCreate = require('../internals/array-species-create');\\n\\nvar push = [].push;\\n\\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\\nvar createMethod = function (TYPE) {\\n  var IS_MAP = TYPE == 1;\\n  var IS_FILTER = TYPE == 2;\\n  var IS_SOME = TYPE == 3;\\n  var IS_EVERY = TYPE == 4;\\n  var IS_FIND_INDEX = TYPE == 6;\\n  var IS_FILTER_OUT = TYPE == 7;\\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\\n  return function ($this, callbackfn, that, specificCreate) {\\n    var O = toObject($this);\\n    var self = IndexedObject(O);\\n    var boundFunction = bind(callbackfn, that, 3);\\n    var length = toLength(self.length);\\n    var index = 0;\\n    var create = specificCreate || arraySpeciesCreate;\\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\\n    var value, result;\\n    for (;length > index; index++) if (NO_HOLES || index in self) {\\n      value = self[index];\\n      result = boundFunction(value, index, O);\\n      if (TYPE) {\\n        if (IS_MAP) target[index] = result; // map\\n        else if (result) switch (TYPE) {\\n          case 3: return true;              // some\\n          case 5: return value;             // find\\n          case 6: return index;             // findIndex\\n          case 2: push.call(target, value); // filter\\n        } else switch (TYPE) {\\n          case 4: return false;             // every\\n          case 7: push.call(target, value); // filterOut\\n        }\\n      }\\n    }\\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\\n  };\\n};\\n\\nmodule.exports = {\\n  // `Array.prototype.forEach` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\\n  forEach: createMethod(0),\\n  // `Array.prototype.map` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.map\\n  map: createMethod(1),\\n  // `Array.prototype.filter` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\\n  filter: createMethod(2),\\n  // `Array.prototype.some` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.some\\n  some: createMethod(3),\\n  // `Array.prototype.every` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.every\\n  every: createMethod(4),\\n  // `Array.prototype.find` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.find\\n  find: createMethod(5),\\n  // `Array.prototype.findIndex` method\\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\\n  findIndex: createMethod(6),\\n  // `Array.prototype.filterOut` method\\n  // https://github.com/tc39/proposal-array-filtering\\n  filterOut: createMethod(7)\\n};\\n\\n},{\\\"../internals/array-species-create\\\":26,\\\"../internals/function-bind-context\\\":46,\\\"../internals/indexed-object\\\":58,\\\"../internals/to-length\\\":109,\\\"../internals/to-object\\\":110}],26:[function(require,module,exports){\\nvar isObject = require('../internals/is-object');\\nvar isArray = require('../internals/is-array');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar SPECIES = wellKnownSymbol('species');\\n\\n// `ArraySpeciesCreate` abstract operation\\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\\nmodule.exports = function (originalArray, length) {\\n  var C;\\n  if (isArray(originalArray)) {\\n    C = originalArray.constructor;\\n    // cross-realm fallback\\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\\n    else if (isObject(C)) {\\n      C = C[SPECIES];\\n      if (C === null) C = undefined;\\n    }\\n  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\\n};\\n\\n},{\\\"../internals/is-array\\\":63,\\\"../internals/is-object\\\":65,\\\"../internals/well-known-symbol\\\":120}],27:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\nvar iteratorClose = require('../internals/iterator-close');\\n\\n// call something on iterator step with safe closing on error\\nmodule.exports = function (iterator, fn, value, ENTRIES) {\\n  try {\\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\\n  // 7.4.6 IteratorClose(iterator, completion)\\n  } catch (error) {\\n    iteratorClose(iterator);\\n    throw error;\\n  }\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/iterator-close\\\":68}],28:[function(require,module,exports){\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar ITERATOR = wellKnownSymbol('iterator');\\nvar SAFE_CLOSING = false;\\n\\ntry {\\n  var called = 0;\\n  var iteratorWithReturn = {\\n    next: function () {\\n      return { done: !!called++ };\\n    },\\n    'return': function () {\\n      SAFE_CLOSING = true;\\n    }\\n  };\\n  iteratorWithReturn[ITERATOR] = function () {\\n    return this;\\n  };\\n  // eslint-disable-next-line no-throw-literal\\n  Array.from(iteratorWithReturn, function () { throw 2; });\\n} catch (error) { /* empty */ }\\n\\nmodule.exports = function (exec, SKIP_CLOSING) {\\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\\n  var ITERATION_SUPPORT = false;\\n  try {\\n    var object = {};\\n    object[ITERATOR] = function () {\\n      return {\\n        next: function () {\\n          return { done: ITERATION_SUPPORT = true };\\n        }\\n      };\\n    };\\n    exec(object);\\n  } catch (error) { /* empty */ }\\n  return ITERATION_SUPPORT;\\n};\\n\\n},{\\\"../internals/well-known-symbol\\\":120}],29:[function(require,module,exports){\\nvar toString = {}.toString;\\n\\nmodule.exports = function (it) {\\n  return toString.call(it).slice(8, -1);\\n};\\n\\n},{}],30:[function(require,module,exports){\\nvar TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\\nvar classofRaw = require('../internals/classof-raw');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\\n// ES3 wrong here\\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\\n\\n// fallback for IE11 Script Access Denied error\\nvar tryGet = function (it, key) {\\n  try {\\n    return it[key];\\n  } catch (error) { /* empty */ }\\n};\\n\\n// getting tag from ES6+ `Object.prototype.toString`\\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\\n  var O, tag, result;\\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\\n    // @@toStringTag case\\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\\n    // builtinTag case\\n    : CORRECT_ARGUMENTS ? classofRaw(O)\\n    // ES3 arguments fallback\\n    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\\n};\\n\\n},{\\\"../internals/classof-raw\\\":29,\\\"../internals/to-string-tag-support\\\":114,\\\"../internals/well-known-symbol\\\":120}],31:[function(require,module,exports){\\n'use strict';\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\n\\n// https://github.com/tc39/collection-methods\\nmodule.exports = function (/* ...elements */) {\\n  var collection = anObject(this);\\n  var remover = aFunction(collection['delete']);\\n  var allDeleted = true;\\n  var wasDeleted;\\n  for (var k = 0, len = arguments.length; k < len; k++) {\\n    wasDeleted = remover.call(collection, arguments[k]);\\n    allDeleted = allDeleted && wasDeleted;\\n  }\\n  return !!allDeleted;\\n};\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18}],32:[function(require,module,exports){\\nvar has = require('../internals/has');\\nvar ownKeys = require('../internals/own-keys');\\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\\nvar definePropertyModule = require('../internals/object-define-property');\\n\\nmodule.exports = function (target, source) {\\n  var keys = ownKeys(source);\\n  var defineProperty = definePropertyModule.f;\\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\\n  }\\n};\\n\\n},{\\\"../internals/has\\\":53,\\\"../internals/object-define-property\\\":77,\\\"../internals/object-get-own-property-descriptor\\\":78,\\\"../internals/own-keys\\\":86}],33:[function(require,module,exports){\\nvar fails = require('../internals/fails');\\n\\nmodule.exports = !fails(function () {\\n  function F() { /* empty */ }\\n  F.prototype.constructor = null;\\n  return Object.getPrototypeOf(new F()) !== F.prototype;\\n});\\n\\n},{\\\"../internals/fails\\\":44}],34:[function(require,module,exports){\\n'use strict';\\nvar IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;\\nvar create = require('../internals/object-create');\\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\\nvar setToStringTag = require('../internals/set-to-string-tag');\\nvar Iterators = require('../internals/iterators');\\n\\nvar returnThis = function () { return this; };\\n\\nmodule.exports = function (IteratorConstructor, NAME, next) {\\n  var TO_STRING_TAG = NAME + ' Iterator';\\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\\n  Iterators[TO_STRING_TAG] = returnThis;\\n  return IteratorConstructor;\\n};\\n\\n},{\\\"../internals/create-property-descriptor\\\":36,\\\"../internals/iterators\\\":70,\\\"../internals/iterators-core\\\":69,\\\"../internals/object-create\\\":75,\\\"../internals/set-to-string-tag\\\":98}],35:[function(require,module,exports){\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar definePropertyModule = require('../internals/object-define-property');\\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\\n\\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\\n} : function (object, key, value) {\\n  object[key] = value;\\n  return object;\\n};\\n\\n},{\\\"../internals/create-property-descriptor\\\":36,\\\"../internals/descriptors\\\":39,\\\"../internals/object-define-property\\\":77}],36:[function(require,module,exports){\\nmodule.exports = function (bitmap, value) {\\n  return {\\n    enumerable: !(bitmap & 1),\\n    configurable: !(bitmap & 2),\\n    writable: !(bitmap & 4),\\n    value: value\\n  };\\n};\\n\\n},{}],37:[function(require,module,exports){\\n'use strict';\\nvar toPrimitive = require('../internals/to-primitive');\\nvar definePropertyModule = require('../internals/object-define-property');\\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\\n\\nmodule.exports = function (object, key, value) {\\n  var propertyKey = toPrimitive(key);\\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\\n  else object[propertyKey] = value;\\n};\\n\\n},{\\\"../internals/create-property-descriptor\\\":36,\\\"../internals/object-define-property\\\":77,\\\"../internals/to-primitive\\\":113}],38:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar createIteratorConstructor = require('../internals/create-iterator-constructor');\\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\\nvar setToStringTag = require('../internals/set-to-string-tag');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar redefine = require('../internals/redefine');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar IS_PURE = require('../internals/is-pure');\\nvar Iterators = require('../internals/iterators');\\nvar IteratorsCore = require('../internals/iterators-core');\\n\\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\\nvar ITERATOR = wellKnownSymbol('iterator');\\nvar KEYS = 'keys';\\nvar VALUES = 'values';\\nvar ENTRIES = 'entries';\\n\\nvar returnThis = function () { return this; };\\n\\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\\n  createIteratorConstructor(IteratorConstructor, NAME, next);\\n\\n  var getIterationMethod = function (KIND) {\\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\\n    switch (KIND) {\\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\\n    } return function () { return new IteratorConstructor(this); };\\n  };\\n\\n  var TO_STRING_TAG = NAME + ' Iterator';\\n  var INCORRECT_VALUES_NAME = false;\\n  var IterablePrototype = Iterable.prototype;\\n  var nativeIterator = IterablePrototype[ITERATOR]\\n    || IterablePrototype['@@iterator']\\n    || DEFAULT && IterablePrototype[DEFAULT];\\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\\n  var CurrentIteratorPrototype, methods, KEY;\\n\\n  // fix native\\n  if (anyNativeIterator) {\\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\\n        if (setPrototypeOf) {\\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\\n          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\\n        }\\n      }\\n      // Set @@toStringTag to native iterators\\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\\n    }\\n  }\\n\\n  // fix Array#{values, @@iterator}.name in V8 / FF\\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\\n    INCORRECT_VALUES_NAME = true;\\n    defaultIterator = function values() { return nativeIterator.call(this); };\\n  }\\n\\n  // define iterator\\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\\n    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\\n  }\\n  Iterators[NAME] = defaultIterator;\\n\\n  // export additional methods\\n  if (DEFAULT) {\\n    methods = {\\n      values: getIterationMethod(VALUES),\\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\\n      entries: getIterationMethod(ENTRIES)\\n    };\\n    if (FORCED) for (KEY in methods) {\\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\\n        redefine(IterablePrototype, KEY, methods[KEY]);\\n      }\\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\\n  }\\n\\n  return methods;\\n};\\n\\n},{\\\"../internals/create-iterator-constructor\\\":34,\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/export\\\":43,\\\"../internals/is-pure\\\":66,\\\"../internals/iterators\\\":70,\\\"../internals/iterators-core\\\":69,\\\"../internals/object-get-prototype-of\\\":81,\\\"../internals/object-set-prototype-of\\\":85,\\\"../internals/redefine\\\":89,\\\"../internals/set-to-string-tag\\\":98,\\\"../internals/well-known-symbol\\\":120}],39:[function(require,module,exports){\\nvar fails = require('../internals/fails');\\n\\n// Detect IE8's incomplete defineProperty implementation\\nmodule.exports = !fails(function () {\\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\\n});\\n\\n},{\\\"../internals/fails\\\":44}],40:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar isObject = require('../internals/is-object');\\n\\nvar document = global.document;\\n// typeof document.createElement is 'object' in old IE\\nvar EXISTS = isObject(document) && isObject(document.createElement);\\n\\nmodule.exports = function (it) {\\n  return EXISTS ? document.createElement(it) : {};\\n};\\n\\n},{\\\"../internals/global\\\":52,\\\"../internals/is-object\\\":65}],41:[function(require,module,exports){\\n// iterable DOM collections\\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\\nmodule.exports = {\\n  CSSRuleList: 0,\\n  CSSStyleDeclaration: 0,\\n  CSSValueList: 0,\\n  ClientRectList: 0,\\n  DOMRectList: 0,\\n  DOMStringList: 0,\\n  DOMTokenList: 1,\\n  DataTransferItemList: 0,\\n  FileList: 0,\\n  HTMLAllCollection: 0,\\n  HTMLCollection: 0,\\n  HTMLFormElement: 0,\\n  HTMLSelectElement: 0,\\n  MediaList: 0,\\n  MimeTypeArray: 0,\\n  NamedNodeMap: 0,\\n  NodeList: 1,\\n  PaintRequestList: 0,\\n  Plugin: 0,\\n  PluginArray: 0,\\n  SVGLengthList: 0,\\n  SVGNumberList: 0,\\n  SVGPathSegList: 0,\\n  SVGPointList: 0,\\n  SVGStringList: 0,\\n  SVGTransformList: 0,\\n  SourceBufferList: 0,\\n  StyleSheetList: 0,\\n  TextTrackCueList: 0,\\n  TextTrackList: 0,\\n  TouchList: 0\\n};\\n\\n},{}],42:[function(require,module,exports){\\n// IE8- don't enum bug keys\\nmodule.exports = [\\n  'constructor',\\n  'hasOwnProperty',\\n  'isPrototypeOf',\\n  'propertyIsEnumerable',\\n  'toLocaleString',\\n  'toString',\\n  'valueOf'\\n];\\n\\n},{}],43:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar redefine = require('../internals/redefine');\\nvar setGlobal = require('../internals/set-global');\\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\\nvar isForced = require('../internals/is-forced');\\n\\n/*\\n  options.target      - name of the target object\\n  options.global      - target is the global object\\n  options.stat        - export as static methods of target\\n  options.proto       - export as prototype methods of target\\n  options.real        - real prototype method for the `pure` version\\n  options.forced      - export even if the native feature is available\\n  options.bind        - bind methods to the target, required for the `pure` version\\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\\n  options.sham        - add a flag to not completely full polyfills\\n  options.enumerable  - export as enumerable property\\n  options.noTargetGet - prevent calling a getter on target\\n*/\\nmodule.exports = function (options, source) {\\n  var TARGET = options.target;\\n  var GLOBAL = options.global;\\n  var STATIC = options.stat;\\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\\n  if (GLOBAL) {\\n    target = global;\\n  } else if (STATIC) {\\n    target = global[TARGET] || setGlobal(TARGET, {});\\n  } else {\\n    target = (global[TARGET] || {}).prototype;\\n  }\\n  if (target) for (key in source) {\\n    sourceProperty = source[key];\\n    if (options.noTargetGet) {\\n      descriptor = getOwnPropertyDescriptor(target, key);\\n      targetProperty = descriptor && descriptor.value;\\n    } else targetProperty = target[key];\\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\\n    // contained in target\\n    if (!FORCED && targetProperty !== undefined) {\\n      if (typeof sourceProperty === typeof targetProperty) continue;\\n      copyConstructorProperties(sourceProperty, targetProperty);\\n    }\\n    // add a flag to not completely full polyfills\\n    if (options.sham || (targetProperty && targetProperty.sham)) {\\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\\n    }\\n    // extend global\\n    redefine(target, key, sourceProperty, options);\\n  }\\n};\\n\\n},{\\\"../internals/copy-constructor-properties\\\":32,\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/global\\\":52,\\\"../internals/is-forced\\\":64,\\\"../internals/object-get-own-property-descriptor\\\":78,\\\"../internals/redefine\\\":89,\\\"../internals/set-global\\\":96}],44:[function(require,module,exports){\\nmodule.exports = function (exec) {\\n  try {\\n    return !!exec();\\n  } catch (error) {\\n    return true;\\n  }\\n};\\n\\n},{}],45:[function(require,module,exports){\\n'use strict';\\n// TODO: Remove from `core-js@4` since it's moved to entry points\\nrequire('../modules/es.regexp.exec');\\nvar redefine = require('../internals/redefine');\\nvar fails = require('../internals/fails');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar regexpExec = require('../internals/regexp-exec');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\n\\nvar SPECIES = wellKnownSymbol('species');\\n\\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\\n  // #replace needs built-in support for named groups.\\n  // #match works fine because it just return the exec results, even if it has\\n  // a \\\"grops\\\" property.\\n  var re = /./;\\n  re.exec = function () {\\n    var result = [];\\n    result.groups = { a: '7' };\\n    return result;\\n  };\\n  return ''.replace(re, '$<a>') !== '7';\\n});\\n\\n// IE <= 11 replaces $0 with the whole match, as if it was $&\\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\\nvar REPLACE_KEEPS_$0 = (function () {\\n  return 'a'.replace(/./, '$0') === '$0';\\n})();\\n\\nvar REPLACE = wellKnownSymbol('replace');\\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\\n  if (/./[REPLACE]) {\\n    return /./[REPLACE]('a', '$0') === '';\\n  }\\n  return false;\\n})();\\n\\n// Chrome 51 has a buggy \\\"split\\\" implementation when RegExp#exec !== nativeExec\\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\\n  var re = /(?:)/;\\n  var originalExec = re.exec;\\n  re.exec = function () { return originalExec.apply(this, arguments); };\\n  var result = 'ab'.split(re);\\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\\n});\\n\\nmodule.exports = function (KEY, length, exec, sham) {\\n  var SYMBOL = wellKnownSymbol(KEY);\\n\\n  var DELEGATES_TO_SYMBOL = !fails(function () {\\n    // String methods call symbol-named RegEp methods\\n    var O = {};\\n    O[SYMBOL] = function () { return 7; };\\n    return ''[KEY](O) != 7;\\n  });\\n\\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\\n    // Symbol-named RegExp methods call .exec\\n    var execCalled = false;\\n    var re = /a/;\\n\\n    if (KEY === 'split') {\\n      // We can't use real regex here since it causes deoptimization\\n      // and serious performance degradation in V8\\n      // https://github.com/zloirock/core-js/issues/306\\n      re = {};\\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\\n      // a new one. We need to return the patched regex when creating the new one.\\n      re.constructor = {};\\n      re.constructor[SPECIES] = function () { return re; };\\n      re.flags = '';\\n      re[SYMBOL] = /./[SYMBOL];\\n    }\\n\\n    re.exec = function () { execCalled = true; return null; };\\n\\n    re[SYMBOL]('');\\n    return !execCalled;\\n  });\\n\\n  if (\\n    !DELEGATES_TO_SYMBOL ||\\n    !DELEGATES_TO_EXEC ||\\n    (KEY === 'replace' && !(\\n      REPLACE_SUPPORTS_NAMED_GROUPS &&\\n      REPLACE_KEEPS_$0 &&\\n      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE\\n    )) ||\\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\\n  ) {\\n    var nativeRegExpMethod = /./[SYMBOL];\\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\\n      if (regexp.exec === regexpExec) {\\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\\n          // The native String method already delegates to @@method (this\\n          // polyfilled function), leasing to infinite recursion.\\n          // We avoid it by directly calling the native @@method method.\\n          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\\n        }\\n        return { done: true, value: nativeMethod.call(str, regexp, arg2) };\\n      }\\n      return { done: false };\\n    }, {\\n      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,\\n      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE\\n    });\\n    var stringMethod = methods[0];\\n    var regexMethod = methods[1];\\n\\n    redefine(String.prototype, KEY, stringMethod);\\n    redefine(RegExp.prototype, SYMBOL, length == 2\\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\\n      ? function (string, arg) { return regexMethod.call(string, this, arg); }\\n      // 21.2.5.6 RegExp.prototype[@@match](string)\\n      // 21.2.5.9 RegExp.prototype[@@search](string)\\n      : function (string) { return regexMethod.call(string, this); }\\n    );\\n  }\\n\\n  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);\\n};\\n\\n},{\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/fails\\\":44,\\\"../internals/redefine\\\":89,\\\"../internals/regexp-exec\\\":91,\\\"../internals/well-known-symbol\\\":120,\\\"../modules/es.regexp.exec\\\":122}],46:[function(require,module,exports){\\nvar aFunction = require('../internals/a-function');\\n\\n// optional / simple context binding\\nmodule.exports = function (fn, that, length) {\\n  aFunction(fn);\\n  if (that === undefined) return fn;\\n  switch (length) {\\n    case 0: return function () {\\n      return fn.call(that);\\n    };\\n    case 1: return function (a) {\\n      return fn.call(that, a);\\n    };\\n    case 2: return function (a, b) {\\n      return fn.call(that, a, b);\\n    };\\n    case 3: return function (a, b, c) {\\n      return fn.call(that, a, b, c);\\n    };\\n  }\\n  return function (/* ...args */) {\\n    return fn.apply(that, arguments);\\n  };\\n};\\n\\n},{\\\"../internals/a-function\\\":13}],47:[function(require,module,exports){\\nvar path = require('../internals/path');\\nvar global = require('../internals/global');\\n\\nvar aFunction = function (variable) {\\n  return typeof variable == 'function' ? variable : undefined;\\n};\\n\\nmodule.exports = function (namespace, method) {\\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\\n};\\n\\n},{\\\"../internals/global\\\":52,\\\"../internals/path\\\":87}],48:[function(require,module,exports){\\nvar classof = require('../internals/classof');\\nvar Iterators = require('../internals/iterators');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar ITERATOR = wellKnownSymbol('iterator');\\n\\nmodule.exports = function (it) {\\n  if (it != undefined) return it[ITERATOR]\\n    || it['@@iterator']\\n    || Iterators[classof(it)];\\n};\\n\\n},{\\\"../internals/classof\\\":30,\\\"../internals/iterators\\\":70,\\\"../internals/well-known-symbol\\\":120}],49:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\nvar getIteratorMethod = require('../internals/get-iterator-method');\\n\\nmodule.exports = function (it) {\\n  var iteratorMethod = getIteratorMethod(it);\\n  if (typeof iteratorMethod != 'function') {\\n    throw TypeError(String(it) + ' is not iterable');\\n  } return anObject(iteratorMethod.call(it));\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/get-iterator-method\\\":48}],50:[function(require,module,exports){\\nvar IS_PURE = require('../internals/is-pure');\\nvar getIterator = require('../internals/get-iterator');\\n\\nmodule.exports = IS_PURE ? getIterator : function (it) {\\n  // eslint-disable-next-line no-undef\\n  return Map.prototype.entries.call(it);\\n};\\n\\n},{\\\"../internals/get-iterator\\\":49,\\\"../internals/is-pure\\\":66}],51:[function(require,module,exports){\\nvar toObject = require('../internals/to-object');\\n\\nvar floor = Math.floor;\\nvar replace = ''.replace;\\nvar SUBSTITUTION_SYMBOLS = /\\\\$([$&'`]|\\\\d\\\\d?|<[^>]*>)/g;\\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\\\$([$&'`]|\\\\d\\\\d?)/g;\\n\\n// https://tc39.es/ecma262/#sec-getsubstitution\\nmodule.exports = function (matched, str, position, captures, namedCaptures, replacement) {\\n  var tailPos = position + matched.length;\\n  var m = captures.length;\\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\\n  if (namedCaptures !== undefined) {\\n    namedCaptures = toObject(namedCaptures);\\n    symbols = SUBSTITUTION_SYMBOLS;\\n  }\\n  return replace.call(replacement, symbols, function (match, ch) {\\n    var capture;\\n    switch (ch.charAt(0)) {\\n      case '$': return '$';\\n      case '&': return matched;\\n      case '`': return str.slice(0, position);\\n      case \\\"'\\\": return str.slice(tailPos);\\n      case '<':\\n        capture = namedCaptures[ch.slice(1, -1)];\\n        break;\\n      default: // \\\\d\\\\d?\\n        var n = +ch;\\n        if (n === 0) return match;\\n        if (n > m) {\\n          var f = floor(n / 10);\\n          if (f === 0) return match;\\n          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\\n          return match;\\n        }\\n        capture = captures[n - 1];\\n    }\\n    return capture === undefined ? '' : capture;\\n  });\\n};\\n\\n},{\\\"../internals/to-object\\\":110}],52:[function(require,module,exports){\\n(function (global){(function (){\\nvar check = function (it) {\\n  return it && it.Math == Math && it;\\n};\\n\\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\\nmodule.exports =\\n  // eslint-disable-next-line no-undef\\n  check(typeof globalThis == 'object' && globalThis) ||\\n  check(typeof window == 'object' && window) ||\\n  check(typeof self == 'object' && self) ||\\n  check(typeof global == 'object' && global) ||\\n  // eslint-disable-next-line no-new-func\\n  (function () { return this; })() || Function('return this')();\\n\\n}).call(this)}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],53:[function(require,module,exports){\\nvar hasOwnProperty = {}.hasOwnProperty;\\n\\nmodule.exports = function (it, key) {\\n  return hasOwnProperty.call(it, key);\\n};\\n\\n},{}],54:[function(require,module,exports){\\nmodule.exports = {};\\n\\n},{}],55:[function(require,module,exports){\\nvar getBuiltIn = require('../internals/get-built-in');\\n\\nmodule.exports = getBuiltIn('document', 'documentElement');\\n\\n},{\\\"../internals/get-built-in\\\":47}],56:[function(require,module,exports){\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar fails = require('../internals/fails');\\nvar createElement = require('../internals/document-create-element');\\n\\n// Thank's IE8 for his funny defineProperty\\nmodule.exports = !DESCRIPTORS && !fails(function () {\\n  return Object.defineProperty(createElement('div'), 'a', {\\n    get: function () { return 7; }\\n  }).a != 7;\\n});\\n\\n},{\\\"../internals/descriptors\\\":39,\\\"../internals/document-create-element\\\":40,\\\"../internals/fails\\\":44}],57:[function(require,module,exports){\\n// IEEE754 conversions based on https://github.com/feross/ieee754\\n// eslint-disable-next-line no-shadow-restricted-names\\nvar Infinity = 1 / 0;\\nvar abs = Math.abs;\\nvar pow = Math.pow;\\nvar floor = Math.floor;\\nvar log = Math.log;\\nvar LN2 = Math.LN2;\\n\\nvar pack = function (number, mantissaLength, bytes) {\\n  var buffer = new Array(bytes);\\n  var exponentLength = bytes * 8 - mantissaLength - 1;\\n  var eMax = (1 << exponentLength) - 1;\\n  var eBias = eMax >> 1;\\n  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\\n  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\\n  var index = 0;\\n  var exponent, mantissa, c;\\n  number = abs(number);\\n  // eslint-disable-next-line no-self-compare\\n  if (number != number || number === Infinity) {\\n    // eslint-disable-next-line no-self-compare\\n    mantissa = number != number ? 1 : 0;\\n    exponent = eMax;\\n  } else {\\n    exponent = floor(log(number) / LN2);\\n    if (number * (c = pow(2, -exponent)) < 1) {\\n      exponent--;\\n      c *= 2;\\n    }\\n    if (exponent + eBias >= 1) {\\n      number += rt / c;\\n    } else {\\n      number += rt * pow(2, 1 - eBias);\\n    }\\n    if (number * c >= 2) {\\n      exponent++;\\n      c /= 2;\\n    }\\n    if (exponent + eBias >= eMax) {\\n      mantissa = 0;\\n      exponent = eMax;\\n    } else if (exponent + eBias >= 1) {\\n      mantissa = (number * c - 1) * pow(2, mantissaLength);\\n      exponent = exponent + eBias;\\n    } else {\\n      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\\n      exponent = 0;\\n    }\\n  }\\n  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);\\n  exponent = exponent << mantissaLength | mantissa;\\n  exponentLength += mantissaLength;\\n  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);\\n  buffer[--index] |= sign * 128;\\n  return buffer;\\n};\\n\\nvar unpack = function (buffer, mantissaLength) {\\n  var bytes = buffer.length;\\n  var exponentLength = bytes * 8 - mantissaLength - 1;\\n  var eMax = (1 << exponentLength) - 1;\\n  var eBias = eMax >> 1;\\n  var nBits = exponentLength - 7;\\n  var index = bytes - 1;\\n  var sign = buffer[index--];\\n  var exponent = sign & 127;\\n  var mantissa;\\n  sign >>= 7;\\n  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);\\n  mantissa = exponent & (1 << -nBits) - 1;\\n  exponent >>= -nBits;\\n  nBits += mantissaLength;\\n  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);\\n  if (exponent === 0) {\\n    exponent = 1 - eBias;\\n  } else if (exponent === eMax) {\\n    return mantissa ? NaN : sign ? -Infinity : Infinity;\\n  } else {\\n    mantissa = mantissa + pow(2, mantissaLength);\\n    exponent = exponent - eBias;\\n  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\\n};\\n\\nmodule.exports = {\\n  pack: pack,\\n  unpack: unpack\\n};\\n\\n},{}],58:[function(require,module,exports){\\nvar fails = require('../internals/fails');\\nvar classof = require('../internals/classof-raw');\\n\\nvar split = ''.split;\\n\\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\\nmodule.exports = fails(function () {\\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\\n  // eslint-disable-next-line no-prototype-builtins\\n  return !Object('z').propertyIsEnumerable(0);\\n}) ? function (it) {\\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\\n} : Object;\\n\\n},{\\\"../internals/classof-raw\\\":29,\\\"../internals/fails\\\":44}],59:[function(require,module,exports){\\nvar isObject = require('../internals/is-object');\\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\\n\\n// makes subclassing work correct for wrapped built-ins\\nmodule.exports = function ($this, dummy, Wrapper) {\\n  var NewTarget, NewTargetPrototype;\\n  if (\\n    // it can work only with native `setPrototypeOf`\\n    setPrototypeOf &&\\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\\n    typeof (NewTarget = dummy.constructor) == 'function' &&\\n    NewTarget !== Wrapper &&\\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\\n    NewTargetPrototype !== Wrapper.prototype\\n  ) setPrototypeOf($this, NewTargetPrototype);\\n  return $this;\\n};\\n\\n},{\\\"../internals/is-object\\\":65,\\\"../internals/object-set-prototype-of\\\":85}],60:[function(require,module,exports){\\nvar store = require('../internals/shared-store');\\n\\nvar functionToString = Function.toString;\\n\\n// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\\nif (typeof store.inspectSource != 'function') {\\n  store.inspectSource = function (it) {\\n    return functionToString.call(it);\\n  };\\n}\\n\\nmodule.exports = store.inspectSource;\\n\\n},{\\\"../internals/shared-store\\\":100}],61:[function(require,module,exports){\\nvar NATIVE_WEAK_MAP = require('../internals/native-weak-map');\\nvar global = require('../internals/global');\\nvar isObject = require('../internals/is-object');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar objectHas = require('../internals/has');\\nvar shared = require('../internals/shared-store');\\nvar sharedKey = require('../internals/shared-key');\\nvar hiddenKeys = require('../internals/hidden-keys');\\n\\nvar WeakMap = global.WeakMap;\\nvar set, get, has;\\n\\nvar enforce = function (it) {\\n  return has(it) ? get(it) : set(it, {});\\n};\\n\\nvar getterFor = function (TYPE) {\\n  return function (it) {\\n    var state;\\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\\n    } return state;\\n  };\\n};\\n\\nif (NATIVE_WEAK_MAP) {\\n  var store = shared.state || (shared.state = new WeakMap());\\n  var wmget = store.get;\\n  var wmhas = store.has;\\n  var wmset = store.set;\\n  set = function (it, metadata) {\\n    metadata.facade = it;\\n    wmset.call(store, it, metadata);\\n    return metadata;\\n  };\\n  get = function (it) {\\n    return wmget.call(store, it) || {};\\n  };\\n  has = function (it) {\\n    return wmhas.call(store, it);\\n  };\\n} else {\\n  var STATE = sharedKey('state');\\n  hiddenKeys[STATE] = true;\\n  set = function (it, metadata) {\\n    metadata.facade = it;\\n    createNonEnumerableProperty(it, STATE, metadata);\\n    return metadata;\\n  };\\n  get = function (it) {\\n    return objectHas(it, STATE) ? it[STATE] : {};\\n  };\\n  has = function (it) {\\n    return objectHas(it, STATE);\\n  };\\n}\\n\\nmodule.exports = {\\n  set: set,\\n  get: get,\\n  has: has,\\n  enforce: enforce,\\n  getterFor: getterFor\\n};\\n\\n},{\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/global\\\":52,\\\"../internals/has\\\":53,\\\"../internals/hidden-keys\\\":54,\\\"../internals/is-object\\\":65,\\\"../internals/native-weak-map\\\":73,\\\"../internals/shared-key\\\":99,\\\"../internals/shared-store\\\":100}],62:[function(require,module,exports){\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar Iterators = require('../internals/iterators');\\n\\nvar ITERATOR = wellKnownSymbol('iterator');\\nvar ArrayPrototype = Array.prototype;\\n\\n// check on default Array iterator\\nmodule.exports = function (it) {\\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\\n};\\n\\n},{\\\"../internals/iterators\\\":70,\\\"../internals/well-known-symbol\\\":120}],63:[function(require,module,exports){\\nvar classof = require('../internals/classof-raw');\\n\\n// `IsArray` abstract operation\\n// https://tc39.es/ecma262/#sec-isarray\\nmodule.exports = Array.isArray || function isArray(arg) {\\n  return classof(arg) == 'Array';\\n};\\n\\n},{\\\"../internals/classof-raw\\\":29}],64:[function(require,module,exports){\\nvar fails = require('../internals/fails');\\n\\nvar replacement = /#|\\\\.prototype\\\\./;\\n\\nvar isForced = function (feature, detection) {\\n  var value = data[normalize(feature)];\\n  return value == POLYFILL ? true\\n    : value == NATIVE ? false\\n    : typeof detection == 'function' ? fails(detection)\\n    : !!detection;\\n};\\n\\nvar normalize = isForced.normalize = function (string) {\\n  return String(string).replace(replacement, '.').toLowerCase();\\n};\\n\\nvar data = isForced.data = {};\\nvar NATIVE = isForced.NATIVE = 'N';\\nvar POLYFILL = isForced.POLYFILL = 'P';\\n\\nmodule.exports = isForced;\\n\\n},{\\\"../internals/fails\\\":44}],65:[function(require,module,exports){\\nmodule.exports = function (it) {\\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\\n};\\n\\n},{}],66:[function(require,module,exports){\\nmodule.exports = false;\\n\\n},{}],67:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\nvar isArrayIteratorMethod = require('../internals/is-array-iterator-method');\\nvar toLength = require('../internals/to-length');\\nvar bind = require('../internals/function-bind-context');\\nvar getIteratorMethod = require('../internals/get-iterator-method');\\nvar iteratorClose = require('../internals/iterator-close');\\n\\nvar Result = function (stopped, result) {\\n  this.stopped = stopped;\\n  this.result = result;\\n};\\n\\nmodule.exports = function (iterable, unboundFunction, options) {\\n  var that = options && options.that;\\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\\n  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);\\n  var iterator, iterFn, index, length, result, next, step;\\n\\n  var stop = function (condition) {\\n    if (iterator) iteratorClose(iterator);\\n    return new Result(true, condition);\\n  };\\n\\n  var callFn = function (value) {\\n    if (AS_ENTRIES) {\\n      anObject(value);\\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\\n  };\\n\\n  if (IS_ITERATOR) {\\n    iterator = iterable;\\n  } else {\\n    iterFn = getIteratorMethod(iterable);\\n    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');\\n    // optimisation for array iterators\\n    if (isArrayIteratorMethod(iterFn)) {\\n      for (index = 0, length = toLength(iterable.length); length > index; index++) {\\n        result = callFn(iterable[index]);\\n        if (result && result instanceof Result) return result;\\n      } return new Result(false);\\n    }\\n    iterator = iterFn.call(iterable);\\n  }\\n\\n  next = iterator.next;\\n  while (!(step = next.call(iterator)).done) {\\n    try {\\n      result = callFn(step.value);\\n    } catch (error) {\\n      iteratorClose(iterator);\\n      throw error;\\n    }\\n    if (typeof result == 'object' && result && result instanceof Result) return result;\\n  } return new Result(false);\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-iterator-method\\\":48,\\\"../internals/is-array-iterator-method\\\":62,\\\"../internals/iterator-close\\\":68,\\\"../internals/to-length\\\":109}],68:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\n\\nmodule.exports = function (iterator) {\\n  var returnMethod = iterator['return'];\\n  if (returnMethod !== undefined) {\\n    return anObject(returnMethod.call(iterator)).value;\\n  }\\n};\\n\\n},{\\\"../internals/an-object\\\":18}],69:[function(require,module,exports){\\n'use strict';\\nvar fails = require('../internals/fails');\\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar has = require('../internals/has');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar IS_PURE = require('../internals/is-pure');\\n\\nvar ITERATOR = wellKnownSymbol('iterator');\\nvar BUGGY_SAFARI_ITERATORS = false;\\n\\nvar returnThis = function () { return this; };\\n\\n// `%IteratorPrototype%` object\\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\\n\\nif ([].keys) {\\n  arrayIterator = [].keys();\\n  // Safari 8 has buggy iterators w/o `next`\\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\\n  else {\\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\\n  }\\n}\\n\\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\\n  var test = {};\\n  // FF44- legacy iterators case\\n  return IteratorPrototype[ITERATOR].call(test) !== test;\\n});\\n\\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\\n\\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\\nif ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\\n  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\\n}\\n\\nmodule.exports = {\\n  IteratorPrototype: IteratorPrototype,\\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\\n};\\n\\n},{\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/fails\\\":44,\\\"../internals/has\\\":53,\\\"../internals/is-pure\\\":66,\\\"../internals/object-get-prototype-of\\\":81,\\\"../internals/well-known-symbol\\\":120}],70:[function(require,module,exports){\\narguments[4][54][0].apply(exports,arguments)\\n},{\\\"dup\\\":54}],71:[function(require,module,exports){\\nvar fails = require('../internals/fails');\\n\\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\\n  // Chrome 38 Symbol has incorrect toString conversion\\n  // eslint-disable-next-line no-undef\\n  return !String(Symbol());\\n});\\n\\n},{\\\"../internals/fails\\\":44}],72:[function(require,module,exports){\\nvar fails = require('../internals/fails');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar IS_PURE = require('../internals/is-pure');\\n\\nvar ITERATOR = wellKnownSymbol('iterator');\\n\\nmodule.exports = !fails(function () {\\n  var url = new URL('b?a=1&b=2&c=3', 'http://a');\\n  var searchParams = url.searchParams;\\n  var result = '';\\n  url.pathname = 'c%20d';\\n  searchParams.forEach(function (value, key) {\\n    searchParams['delete']('b');\\n    result += key + value;\\n  });\\n  return (IS_PURE && !url.toJSON)\\n    || !searchParams.sort\\n    || url.href !== 'http://a/c%20d?a=1&c=3'\\n    || searchParams.get('c') !== '3'\\n    || String(new URLSearchParams('?a=1')) !== 'a=1'\\n    || !searchParams[ITERATOR]\\n    // throws in Edge\\n    || new URL('https://a@b').username !== 'a'\\n    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'\\n    // not punycoded in Edge\\n    || new URL('http://Ñ‚ÐµÑÑ‚').host !== 'xn--e1aybc'\\n    // not escaped in Chrome 62-\\n    || new URL('http://a#Ð±').hash !== '#%D0%B1'\\n    // fails in Chrome 66-\\n    || result !== 'a1c3'\\n    // throws in Safari\\n    || new URL('http://x', undefined).host !== 'x';\\n});\\n\\n},{\\\"../internals/fails\\\":44,\\\"../internals/is-pure\\\":66,\\\"../internals/well-known-symbol\\\":120}],73:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar inspectSource = require('../internals/inspect-source');\\n\\nvar WeakMap = global.WeakMap;\\n\\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\\n\\n},{\\\"../internals/global\\\":52,\\\"../internals/inspect-source\\\":60}],74:[function(require,module,exports){\\n'use strict';\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar fails = require('../internals/fails');\\nvar objectKeys = require('../internals/object-keys');\\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\\nvar toObject = require('../internals/to-object');\\nvar IndexedObject = require('../internals/indexed-object');\\n\\nvar nativeAssign = Object.assign;\\nvar defineProperty = Object.defineProperty;\\n\\n// `Object.assign` method\\n// https://tc39.es/ecma262/#sec-object.assign\\nmodule.exports = !nativeAssign || fails(function () {\\n  // should have correct order of operations (Edge bug)\\n  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {\\n    enumerable: true,\\n    get: function () {\\n      defineProperty(this, 'b', {\\n        value: 3,\\n        enumerable: false\\n      });\\n    }\\n  }), { b: 2 })).b !== 1) return true;\\n  // should work with symbols and should have deterministic property order (V8 bug)\\n  var A = {};\\n  var B = {};\\n  // eslint-disable-next-line no-undef\\n  var symbol = Symbol();\\n  var alphabet = 'abcdefghijklmnopqrst';\\n  A[symbol] = 7;\\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\\n  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\\n  var T = toObject(target);\\n  var argumentsLength = arguments.length;\\n  var index = 1;\\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\\n  while (argumentsLength > index) {\\n    var S = IndexedObject(arguments[index++]);\\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\\n    var length = keys.length;\\n    var j = 0;\\n    var key;\\n    while (length > j) {\\n      key = keys[j++];\\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\\n    }\\n  } return T;\\n} : nativeAssign;\\n\\n},{\\\"../internals/descriptors\\\":39,\\\"../internals/fails\\\":44,\\\"../internals/indexed-object\\\":58,\\\"../internals/object-get-own-property-symbols\\\":80,\\\"../internals/object-keys\\\":83,\\\"../internals/object-property-is-enumerable\\\":84,\\\"../internals/to-object\\\":110}],75:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\nvar defineProperties = require('../internals/object-define-properties');\\nvar enumBugKeys = require('../internals/enum-bug-keys');\\nvar hiddenKeys = require('../internals/hidden-keys');\\nvar html = require('../internals/html');\\nvar documentCreateElement = require('../internals/document-create-element');\\nvar sharedKey = require('../internals/shared-key');\\n\\nvar GT = '>';\\nvar LT = '<';\\nvar PROTOTYPE = 'prototype';\\nvar SCRIPT = 'script';\\nvar IE_PROTO = sharedKey('IE_PROTO');\\n\\nvar EmptyConstructor = function () { /* empty */ };\\n\\nvar scriptTag = function (content) {\\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\\n};\\n\\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\\n  activeXDocument.write(scriptTag(''));\\n  activeXDocument.close();\\n  var temp = activeXDocument.parentWindow.Object;\\n  activeXDocument = null; // avoid memory leak\\n  return temp;\\n};\\n\\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\\nvar NullProtoObjectViaIFrame = function () {\\n  // Thrash, waste and sodomy: IE GC bug\\n  var iframe = documentCreateElement('iframe');\\n  var JS = 'java' + SCRIPT + ':';\\n  var iframeDocument;\\n  iframe.style.display = 'none';\\n  html.appendChild(iframe);\\n  // https://github.com/zloirock/core-js/issues/475\\n  iframe.src = String(JS);\\n  iframeDocument = iframe.contentWindow.document;\\n  iframeDocument.open();\\n  iframeDocument.write(scriptTag('document.F=Object'));\\n  iframeDocument.close();\\n  return iframeDocument.F;\\n};\\n\\n// Check for document.domain and active x support\\n// No need to use active x approach when document.domain is not set\\n// see https://github.com/es-shims/es5-shim/issues/150\\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\\n// avoid IE GC bug\\nvar activeXDocument;\\nvar NullProtoObject = function () {\\n  try {\\n    /* global ActiveXObject */\\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\\n  } catch (error) { /* ignore */ }\\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\\n  var length = enumBugKeys.length;\\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\\n  return NullProtoObject();\\n};\\n\\nhiddenKeys[IE_PROTO] = true;\\n\\n// `Object.create` method\\n// https://tc39.es/ecma262/#sec-object.create\\nmodule.exports = Object.create || function create(O, Properties) {\\n  var result;\\n  if (O !== null) {\\n    EmptyConstructor[PROTOTYPE] = anObject(O);\\n    result = new EmptyConstructor();\\n    EmptyConstructor[PROTOTYPE] = null;\\n    // add \\\"__proto__\\\" for Object.getPrototypeOf polyfill\\n    result[IE_PROTO] = O;\\n  } else result = NullProtoObject();\\n  return Properties === undefined ? result : defineProperties(result, Properties);\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/document-create-element\\\":40,\\\"../internals/enum-bug-keys\\\":42,\\\"../internals/hidden-keys\\\":54,\\\"../internals/html\\\":55,\\\"../internals/object-define-properties\\\":76,\\\"../internals/shared-key\\\":99}],76:[function(require,module,exports){\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar definePropertyModule = require('../internals/object-define-property');\\nvar anObject = require('../internals/an-object');\\nvar objectKeys = require('../internals/object-keys');\\n\\n// `Object.defineProperties` method\\n// https://tc39.es/ecma262/#sec-object.defineproperties\\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\\n  anObject(O);\\n  var keys = objectKeys(Properties);\\n  var length = keys.length;\\n  var index = 0;\\n  var key;\\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\\n  return O;\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/descriptors\\\":39,\\\"../internals/object-define-property\\\":77,\\\"../internals/object-keys\\\":83}],77:[function(require,module,exports){\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\\nvar anObject = require('../internals/an-object');\\nvar toPrimitive = require('../internals/to-primitive');\\n\\nvar nativeDefineProperty = Object.defineProperty;\\n\\n// `Object.defineProperty` method\\n// https://tc39.es/ecma262/#sec-object.defineproperty\\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\\n  anObject(O);\\n  P = toPrimitive(P, true);\\n  anObject(Attributes);\\n  if (IE8_DOM_DEFINE) try {\\n    return nativeDefineProperty(O, P, Attributes);\\n  } catch (error) { /* empty */ }\\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\\n  if ('value' in Attributes) O[P] = Attributes.value;\\n  return O;\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/descriptors\\\":39,\\\"../internals/ie8-dom-define\\\":56,\\\"../internals/to-primitive\\\":113}],78:[function(require,module,exports){\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\\nvar toIndexedObject = require('../internals/to-indexed-object');\\nvar toPrimitive = require('../internals/to-primitive');\\nvar has = require('../internals/has');\\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\\n\\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\\n\\n// `Object.getOwnPropertyDescriptor` method\\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\\n  O = toIndexedObject(O);\\n  P = toPrimitive(P, true);\\n  if (IE8_DOM_DEFINE) try {\\n    return nativeGetOwnPropertyDescriptor(O, P);\\n  } catch (error) { /* empty */ }\\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\\n};\\n\\n},{\\\"../internals/create-property-descriptor\\\":36,\\\"../internals/descriptors\\\":39,\\\"../internals/has\\\":53,\\\"../internals/ie8-dom-define\\\":56,\\\"../internals/object-property-is-enumerable\\\":84,\\\"../internals/to-indexed-object\\\":107,\\\"../internals/to-primitive\\\":113}],79:[function(require,module,exports){\\nvar internalObjectKeys = require('../internals/object-keys-internal');\\nvar enumBugKeys = require('../internals/enum-bug-keys');\\n\\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\\n\\n// `Object.getOwnPropertyNames` method\\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\\n  return internalObjectKeys(O, hiddenKeys);\\n};\\n\\n},{\\\"../internals/enum-bug-keys\\\":42,\\\"../internals/object-keys-internal\\\":82}],80:[function(require,module,exports){\\nexports.f = Object.getOwnPropertySymbols;\\n\\n},{}],81:[function(require,module,exports){\\nvar has = require('../internals/has');\\nvar toObject = require('../internals/to-object');\\nvar sharedKey = require('../internals/shared-key');\\nvar CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');\\n\\nvar IE_PROTO = sharedKey('IE_PROTO');\\nvar ObjectPrototype = Object.prototype;\\n\\n// `Object.getPrototypeOf` method\\n// https://tc39.es/ecma262/#sec-object.getprototypeof\\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\\n  O = toObject(O);\\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\\n    return O.constructor.prototype;\\n  } return O instanceof Object ? ObjectPrototype : null;\\n};\\n\\n},{\\\"../internals/correct-prototype-getter\\\":33,\\\"../internals/has\\\":53,\\\"../internals/shared-key\\\":99,\\\"../internals/to-object\\\":110}],82:[function(require,module,exports){\\nvar has = require('../internals/has');\\nvar toIndexedObject = require('../internals/to-indexed-object');\\nvar indexOf = require('../internals/array-includes').indexOf;\\nvar hiddenKeys = require('../internals/hidden-keys');\\n\\nmodule.exports = function (object, names) {\\n  var O = toIndexedObject(object);\\n  var i = 0;\\n  var result = [];\\n  var key;\\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\\n  // Don't enum bug & hidden keys\\n  while (names.length > i) if (has(O, key = names[i++])) {\\n    ~indexOf(result, key) || result.push(key);\\n  }\\n  return result;\\n};\\n\\n},{\\\"../internals/array-includes\\\":24,\\\"../internals/has\\\":53,\\\"../internals/hidden-keys\\\":54,\\\"../internals/to-indexed-object\\\":107}],83:[function(require,module,exports){\\nvar internalObjectKeys = require('../internals/object-keys-internal');\\nvar enumBugKeys = require('../internals/enum-bug-keys');\\n\\n// `Object.keys` method\\n// https://tc39.es/ecma262/#sec-object.keys\\nmodule.exports = Object.keys || function keys(O) {\\n  return internalObjectKeys(O, enumBugKeys);\\n};\\n\\n},{\\\"../internals/enum-bug-keys\\\":42,\\\"../internals/object-keys-internal\\\":82}],84:[function(require,module,exports){\\n'use strict';\\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\\n\\n// Nashorn ~ JDK8 bug\\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\\n\\n// `Object.prototype.propertyIsEnumerable` method implementation\\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\\n  var descriptor = getOwnPropertyDescriptor(this, V);\\n  return !!descriptor && descriptor.enumerable;\\n} : nativePropertyIsEnumerable;\\n\\n},{}],85:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\nvar aPossiblePrototype = require('../internals/a-possible-prototype');\\n\\n// `Object.setPrototypeOf` method\\n// https://tc39.es/ecma262/#sec-object.setprototypeof\\n// Works with __proto__ only. Old v8 can't work with null proto objects.\\n/* eslint-disable no-proto */\\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\\n  var CORRECT_SETTER = false;\\n  var test = {};\\n  var setter;\\n  try {\\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\\n    setter.call(test, []);\\n    CORRECT_SETTER = test instanceof Array;\\n  } catch (error) { /* empty */ }\\n  return function setPrototypeOf(O, proto) {\\n    anObject(O);\\n    aPossiblePrototype(proto);\\n    if (CORRECT_SETTER) setter.call(O, proto);\\n    else O.__proto__ = proto;\\n    return O;\\n  };\\n}() : undefined);\\n\\n},{\\\"../internals/a-possible-prototype\\\":14,\\\"../internals/an-object\\\":18}],86:[function(require,module,exports){\\nvar getBuiltIn = require('../internals/get-built-in');\\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\\nvar anObject = require('../internals/an-object');\\n\\n// all object keys, includes non-enumerable and symbols\\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\\n};\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/get-built-in\\\":47,\\\"../internals/object-get-own-property-names\\\":79,\\\"../internals/object-get-own-property-symbols\\\":80}],87:[function(require,module,exports){\\nvar global = require('../internals/global');\\n\\nmodule.exports = global;\\n\\n},{\\\"../internals/global\\\":52}],88:[function(require,module,exports){\\nvar redefine = require('../internals/redefine');\\n\\nmodule.exports = function (target, src, options) {\\n  for (var key in src) redefine(target, key, src[key], options);\\n  return target;\\n};\\n\\n},{\\\"../internals/redefine\\\":89}],89:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar has = require('../internals/has');\\nvar setGlobal = require('../internals/set-global');\\nvar inspectSource = require('../internals/inspect-source');\\nvar InternalStateModule = require('../internals/internal-state');\\n\\nvar getInternalState = InternalStateModule.get;\\nvar enforceInternalState = InternalStateModule.enforce;\\nvar TEMPLATE = String(String).split('String');\\n\\n(module.exports = function (O, key, value, options) {\\n  var unsafe = options ? !!options.unsafe : false;\\n  var simple = options ? !!options.enumerable : false;\\n  var noTargetGet = options ? !!options.noTargetGet : false;\\n  var state;\\n  if (typeof value == 'function') {\\n    if (typeof key == 'string' && !has(value, 'name')) {\\n      createNonEnumerableProperty(value, 'name', key);\\n    }\\n    state = enforceInternalState(value);\\n    if (!state.source) {\\n      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\\n    }\\n  }\\n  if (O === global) {\\n    if (simple) O[key] = value;\\n    else setGlobal(key, value);\\n    return;\\n  } else if (!unsafe) {\\n    delete O[key];\\n  } else if (!noTargetGet && O[key]) {\\n    simple = true;\\n  }\\n  if (simple) O[key] = value;\\n  else createNonEnumerableProperty(O, key, value);\\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\\n})(Function.prototype, 'toString', function toString() {\\n  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\\n});\\n\\n},{\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/global\\\":52,\\\"../internals/has\\\":53,\\\"../internals/inspect-source\\\":60,\\\"../internals/internal-state\\\":61,\\\"../internals/set-global\\\":96}],90:[function(require,module,exports){\\nvar classof = require('./classof-raw');\\nvar regexpExec = require('./regexp-exec');\\n\\n// `RegExpExec` abstract operation\\n// https://tc39.es/ecma262/#sec-regexpexec\\nmodule.exports = function (R, S) {\\n  var exec = R.exec;\\n  if (typeof exec === 'function') {\\n    var result = exec.call(R, S);\\n    if (typeof result !== 'object') {\\n      throw TypeError('RegExp exec method returned something other than an Object or null');\\n    }\\n    return result;\\n  }\\n\\n  if (classof(R) !== 'RegExp') {\\n    throw TypeError('RegExp#exec called on incompatible receiver');\\n  }\\n\\n  return regexpExec.call(R, S);\\n};\\n\\n\\n},{\\\"./classof-raw\\\":29,\\\"./regexp-exec\\\":91}],91:[function(require,module,exports){\\n'use strict';\\nvar regexpFlags = require('./regexp-flags');\\nvar stickyHelpers = require('./regexp-sticky-helpers');\\n\\nvar nativeExec = RegExp.prototype.exec;\\n// This always refers to the native implementation, because the\\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\\n// which loads this file before patching the method.\\nvar nativeReplace = String.prototype.replace;\\n\\nvar patchedExec = nativeExec;\\n\\nvar UPDATES_LAST_INDEX_WRONG = (function () {\\n  var re1 = /a/;\\n  var re2 = /b*/g;\\n  nativeExec.call(re1, 'a');\\n  nativeExec.call(re2, 'a');\\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\\n})();\\n\\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;\\n\\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\\n\\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;\\n\\nif (PATCH) {\\n  patchedExec = function exec(str) {\\n    var re = this;\\n    var lastIndex, reCopy, match, i;\\n    var sticky = UNSUPPORTED_Y && re.sticky;\\n    var flags = regexpFlags.call(re);\\n    var source = re.source;\\n    var charsAdded = 0;\\n    var strCopy = str;\\n\\n    if (sticky) {\\n      flags = flags.replace('y', '');\\n      if (flags.indexOf('g') === -1) {\\n        flags += 'g';\\n      }\\n\\n      strCopy = String(str).slice(re.lastIndex);\\n      // Support anchored sticky behavior.\\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\\\\n')) {\\n        source = '(?: ' + source + ')';\\n        strCopy = ' ' + strCopy;\\n        charsAdded++;\\n      }\\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\\n      // simulate the 'y' flag.\\n      reCopy = new RegExp('^(?:' + source + ')', flags);\\n    }\\n\\n    if (NPCG_INCLUDED) {\\n      reCopy = new RegExp('^' + source + '$(?!\\\\\\\\s)', flags);\\n    }\\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\\n\\n    match = nativeExec.call(sticky ? reCopy : re, strCopy);\\n\\n    if (sticky) {\\n      if (match) {\\n        match.input = match.input.slice(charsAdded);\\n        match[0] = match[0].slice(charsAdded);\\n        match.index = re.lastIndex;\\n        re.lastIndex += match[0].length;\\n      } else re.lastIndex = 0;\\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\\n    }\\n    if (NPCG_INCLUDED && match && match.length > 1) {\\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\\n      nativeReplace.call(match[0], reCopy, function () {\\n        for (i = 1; i < arguments.length - 2; i++) {\\n          if (arguments[i] === undefined) match[i] = undefined;\\n        }\\n      });\\n    }\\n\\n    return match;\\n  };\\n}\\n\\nmodule.exports = patchedExec;\\n\\n},{\\\"./regexp-flags\\\":92,\\\"./regexp-sticky-helpers\\\":93}],92:[function(require,module,exports){\\n'use strict';\\nvar anObject = require('../internals/an-object');\\n\\n// `RegExp.prototype.flags` getter implementation\\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\\nmodule.exports = function () {\\n  var that = anObject(this);\\n  var result = '';\\n  if (that.global) result += 'g';\\n  if (that.ignoreCase) result += 'i';\\n  if (that.multiline) result += 'm';\\n  if (that.dotAll) result += 's';\\n  if (that.unicode) result += 'u';\\n  if (that.sticky) result += 'y';\\n  return result;\\n};\\n\\n},{\\\"../internals/an-object\\\":18}],93:[function(require,module,exports){\\n'use strict';\\n\\nvar fails = require('./fails');\\n\\n// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,\\n// so we use an intermediate function.\\nfunction RE(s, f) {\\n  return RegExp(s, f);\\n}\\n\\nexports.UNSUPPORTED_Y = fails(function () {\\n  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\\n  var re = RE('a', 'y');\\n  re.lastIndex = 2;\\n  return re.exec('abcd') != null;\\n});\\n\\nexports.BROKEN_CARET = fails(function () {\\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\\n  var re = RE('^r', 'gy');\\n  re.lastIndex = 2;\\n  return re.exec('str') != null;\\n});\\n\\n},{\\\"./fails\\\":44}],94:[function(require,module,exports){\\n// `RequireObjectCoercible` abstract operation\\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\\nmodule.exports = function (it) {\\n  if (it == undefined) throw TypeError(\\\"Can't call method on \\\" + it);\\n  return it;\\n};\\n\\n},{}],95:[function(require,module,exports){\\n// `SameValueZero` abstract operation\\n// https://tc39.es/ecma262/#sec-samevaluezero\\nmodule.exports = function (x, y) {\\n  // eslint-disable-next-line no-self-compare\\n  return x === y || x != x && y != y;\\n};\\n\\n},{}],96:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\n\\nmodule.exports = function (key, value) {\\n  try {\\n    createNonEnumerableProperty(global, key, value);\\n  } catch (error) {\\n    global[key] = value;\\n  } return value;\\n};\\n\\n},{\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/global\\\":52}],97:[function(require,module,exports){\\n'use strict';\\nvar getBuiltIn = require('../internals/get-built-in');\\nvar definePropertyModule = require('../internals/object-define-property');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\nvar DESCRIPTORS = require('../internals/descriptors');\\n\\nvar SPECIES = wellKnownSymbol('species');\\n\\nmodule.exports = function (CONSTRUCTOR_NAME) {\\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\\n  var defineProperty = definePropertyModule.f;\\n\\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\\n    defineProperty(Constructor, SPECIES, {\\n      configurable: true,\\n      get: function () { return this; }\\n    });\\n  }\\n};\\n\\n},{\\\"../internals/descriptors\\\":39,\\\"../internals/get-built-in\\\":47,\\\"../internals/object-define-property\\\":77,\\\"../internals/well-known-symbol\\\":120}],98:[function(require,module,exports){\\nvar defineProperty = require('../internals/object-define-property').f;\\nvar has = require('../internals/has');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\\n\\nmodule.exports = function (it, TAG, STATIC) {\\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\\n  }\\n};\\n\\n},{\\\"../internals/has\\\":53,\\\"../internals/object-define-property\\\":77,\\\"../internals/well-known-symbol\\\":120}],99:[function(require,module,exports){\\nvar shared = require('../internals/shared');\\nvar uid = require('../internals/uid');\\n\\nvar keys = shared('keys');\\n\\nmodule.exports = function (key) {\\n  return keys[key] || (keys[key] = uid(key));\\n};\\n\\n},{\\\"../internals/shared\\\":101,\\\"../internals/uid\\\":118}],100:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar setGlobal = require('../internals/set-global');\\n\\nvar SHARED = '__core-js_shared__';\\nvar store = global[SHARED] || setGlobal(SHARED, {});\\n\\nmodule.exports = store;\\n\\n},{\\\"../internals/global\\\":52,\\\"../internals/set-global\\\":96}],101:[function(require,module,exports){\\nvar IS_PURE = require('../internals/is-pure');\\nvar store = require('../internals/shared-store');\\n\\n(module.exports = function (key, value) {\\n  return store[key] || (store[key] = value !== undefined ? value : {});\\n})('versions', []).push({\\n  version: '3.8.3',\\n  mode: IS_PURE ? 'pure' : 'global',\\n  copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'\\n});\\n\\n},{\\\"../internals/is-pure\\\":66,\\\"../internals/shared-store\\\":100}],102:[function(require,module,exports){\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar SPECIES = wellKnownSymbol('species');\\n\\n// `SpeciesConstructor` abstract operation\\n// https://tc39.es/ecma262/#sec-speciesconstructor\\nmodule.exports = function (O, defaultConstructor) {\\n  var C = anObject(O).constructor;\\n  var S;\\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);\\n};\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/well-known-symbol\\\":120}],103:[function(require,module,exports){\\nvar toInteger = require('../internals/to-integer');\\nvar requireObjectCoercible = require('../internals/require-object-coercible');\\n\\n// `String.prototype.{ codePointAt, at }` methods implementation\\nvar createMethod = function (CONVERT_TO_STRING) {\\n  return function ($this, pos) {\\n    var S = String(requireObjectCoercible($this));\\n    var position = toInteger(pos);\\n    var size = S.length;\\n    var first, second;\\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\\n    first = S.charCodeAt(position);\\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\\n      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\\n        ? CONVERT_TO_STRING ? S.charAt(position) : first\\n        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\\n  };\\n};\\n\\nmodule.exports = {\\n  // `String.prototype.codePointAt` method\\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\\n  codeAt: createMethod(false),\\n  // `String.prototype.at` method\\n  // https://github.com/mathiasbynens/String.prototype.at\\n  charAt: createMethod(true)\\n};\\n\\n},{\\\"../internals/require-object-coercible\\\":94,\\\"../internals/to-integer\\\":108}],104:[function(require,module,exports){\\n'use strict';\\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\\nvar base = 36;\\nvar tMin = 1;\\nvar tMax = 26;\\nvar skew = 38;\\nvar damp = 700;\\nvar initialBias = 72;\\nvar initialN = 128; // 0x80\\nvar delimiter = '-'; // '\\\\x2D'\\nvar regexNonASCII = /[^\\\\0-\\\\u007E]/; // non-ASCII chars\\nvar regexSeparators = /[.\\\\u3002\\\\uFF0E\\\\uFF61]/g; // RFC 3490 separators\\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\\nvar baseMinusTMin = base - tMin;\\nvar floor = Math.floor;\\nvar stringFromCharCode = String.fromCharCode;\\n\\n/**\\n * Creates an array containing the numeric code points of each Unicode\\n * character in the string. While JavaScript uses UCS-2 internally,\\n * this function will convert a pair of surrogate halves (each of which\\n * UCS-2 exposes as separate characters) into a single code point,\\n * matching UTF-16.\\n */\\nvar ucs2decode = function (string) {\\n  var output = [];\\n  var counter = 0;\\n  var length = string.length;\\n  while (counter < length) {\\n    var value = string.charCodeAt(counter++);\\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n      // It's a high surrogate, and there is a next character.\\n      var extra = string.charCodeAt(counter++);\\n      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n      } else {\\n        // It's an unmatched surrogate; only append this code unit, in case the\\n        // next code unit is the high surrogate of a surrogate pair.\\n        output.push(value);\\n        counter--;\\n      }\\n    } else {\\n      output.push(value);\\n    }\\n  }\\n  return output;\\n};\\n\\n/**\\n * Converts a digit/integer into a basic code point.\\n */\\nvar digitToBasic = function (digit) {\\n  //  0..25 map to ASCII a..z or A..Z\\n  // 26..35 map to ASCII 0..9\\n  return digit + 22 + 75 * (digit < 26);\\n};\\n\\n/**\\n * Bias adaptation function as per section 3.4 of RFC 3492.\\n * https://tools.ietf.org/html/rfc3492#section-3.4\\n */\\nvar adapt = function (delta, numPoints, firstTime) {\\n  var k = 0;\\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\\n  delta += floor(delta / numPoints);\\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\\n    delta = floor(delta / baseMinusTMin);\\n  }\\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\n};\\n\\n/**\\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\\n * Punycode string of ASCII-only symbols.\\n */\\n// eslint-disable-next-line  max-statements\\nvar encode = function (input) {\\n  var output = [];\\n\\n  // Convert the input in UCS-2 to an array of Unicode code points.\\n  input = ucs2decode(input);\\n\\n  // Cache the length.\\n  var inputLength = input.length;\\n\\n  // Initialize the state.\\n  var n = initialN;\\n  var delta = 0;\\n  var bias = initialBias;\\n  var i, currentValue;\\n\\n  // Handle the basic code points.\\n  for (i = 0; i < input.length; i++) {\\n    currentValue = input[i];\\n    if (currentValue < 0x80) {\\n      output.push(stringFromCharCode(currentValue));\\n    }\\n  }\\n\\n  var basicLength = output.length; // number of basic code points.\\n  var handledCPCount = basicLength; // number of code points that have been handled;\\n\\n  // Finish the basic string with a delimiter unless it's empty.\\n  if (basicLength) {\\n    output.push(delimiter);\\n  }\\n\\n  // Main encoding loop:\\n  while (handledCPCount < inputLength) {\\n    // All non-basic code points < n have been handled already. Find the next larger one:\\n    var m = maxInt;\\n    for (i = 0; i < input.length; i++) {\\n      currentValue = input[i];\\n      if (currentValue >= n && currentValue < m) {\\n        m = currentValue;\\n      }\\n    }\\n\\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\\n    var handledCPCountPlusOne = handledCPCount + 1;\\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\n      throw RangeError(OVERFLOW_ERROR);\\n    }\\n\\n    delta += (m - n) * handledCPCountPlusOne;\\n    n = m;\\n\\n    for (i = 0; i < input.length; i++) {\\n      currentValue = input[i];\\n      if (currentValue < n && ++delta > maxInt) {\\n        throw RangeError(OVERFLOW_ERROR);\\n      }\\n      if (currentValue == n) {\\n        // Represent delta as a generalized variable-length integer.\\n        var q = delta;\\n        for (var k = base; /* no condition */; k += base) {\\n          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n          if (q < t) break;\\n          var qMinusT = q - t;\\n          var baseMinusT = base - t;\\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\\n          q = floor(qMinusT / baseMinusT);\\n        }\\n\\n        output.push(stringFromCharCode(digitToBasic(q)));\\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\n        delta = 0;\\n        ++handledCPCount;\\n      }\\n    }\\n\\n    ++delta;\\n    ++n;\\n  }\\n  return output.join('');\\n};\\n\\nmodule.exports = function (input) {\\n  var encoded = [];\\n  var labels = input.toLowerCase().replace(regexSeparators, '\\\\u002E').split('.');\\n  var i, label;\\n  for (i = 0; i < labels.length; i++) {\\n    label = labels[i];\\n    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);\\n  }\\n  return encoded.join('.');\\n};\\n\\n},{}],105:[function(require,module,exports){\\nvar toInteger = require('../internals/to-integer');\\n\\nvar max = Math.max;\\nvar min = Math.min;\\n\\n// Helper for a popular repeating case of the spec:\\n// Let integer be ? ToInteger(index).\\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\\nmodule.exports = function (index, length) {\\n  var integer = toInteger(index);\\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\\n};\\n\\n},{\\\"../internals/to-integer\\\":108}],106:[function(require,module,exports){\\nvar toInteger = require('../internals/to-integer');\\nvar toLength = require('../internals/to-length');\\n\\n// `ToIndex` abstract operation\\n// https://tc39.es/ecma262/#sec-toindex\\nmodule.exports = function (it) {\\n  if (it === undefined) return 0;\\n  var number = toInteger(it);\\n  var length = toLength(number);\\n  if (number !== length) throw RangeError('Wrong length or index');\\n  return length;\\n};\\n\\n},{\\\"../internals/to-integer\\\":108,\\\"../internals/to-length\\\":109}],107:[function(require,module,exports){\\n// toObject with fallback for non-array-like ES3 strings\\nvar IndexedObject = require('../internals/indexed-object');\\nvar requireObjectCoercible = require('../internals/require-object-coercible');\\n\\nmodule.exports = function (it) {\\n  return IndexedObject(requireObjectCoercible(it));\\n};\\n\\n},{\\\"../internals/indexed-object\\\":58,\\\"../internals/require-object-coercible\\\":94}],108:[function(require,module,exports){\\nvar ceil = Math.ceil;\\nvar floor = Math.floor;\\n\\n// `ToInteger` abstract operation\\n// https://tc39.es/ecma262/#sec-tointeger\\nmodule.exports = function (argument) {\\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\\n};\\n\\n},{}],109:[function(require,module,exports){\\nvar toInteger = require('../internals/to-integer');\\n\\nvar min = Math.min;\\n\\n// `ToLength` abstract operation\\n// https://tc39.es/ecma262/#sec-tolength\\nmodule.exports = function (argument) {\\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\\n};\\n\\n},{\\\"../internals/to-integer\\\":108}],110:[function(require,module,exports){\\nvar requireObjectCoercible = require('../internals/require-object-coercible');\\n\\n// `ToObject` abstract operation\\n// https://tc39.es/ecma262/#sec-toobject\\nmodule.exports = function (argument) {\\n  return Object(requireObjectCoercible(argument));\\n};\\n\\n},{\\\"../internals/require-object-coercible\\\":94}],111:[function(require,module,exports){\\nvar toPositiveInteger = require('../internals/to-positive-integer');\\n\\nmodule.exports = function (it, BYTES) {\\n  var offset = toPositiveInteger(it);\\n  if (offset % BYTES) throw RangeError('Wrong offset');\\n  return offset;\\n};\\n\\n},{\\\"../internals/to-positive-integer\\\":112}],112:[function(require,module,exports){\\nvar toInteger = require('../internals/to-integer');\\n\\nmodule.exports = function (it) {\\n  var result = toInteger(it);\\n  if (result < 0) throw RangeError(\\\"The argument can't be less than 0\\\");\\n  return result;\\n};\\n\\n},{\\\"../internals/to-integer\\\":108}],113:[function(require,module,exports){\\nvar isObject = require('../internals/is-object');\\n\\n// `ToPrimitive` abstract operation\\n// https://tc39.es/ecma262/#sec-toprimitive\\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\\n// and the second argument - flag - preferred type is a string\\nmodule.exports = function (input, PREFERRED_STRING) {\\n  if (!isObject(input)) return input;\\n  var fn, val;\\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\\n  throw TypeError(\\\"Can't convert object to primitive value\\\");\\n};\\n\\n},{\\\"../internals/is-object\\\":65}],114:[function(require,module,exports){\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\\nvar test = {};\\n\\ntest[TO_STRING_TAG] = 'z';\\n\\nmodule.exports = String(test) === '[object z]';\\n\\n},{\\\"../internals/well-known-symbol\\\":120}],115:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar global = require('../internals/global');\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');\\nvar ArrayBufferViewCore = require('../internals/array-buffer-view-core');\\nvar ArrayBufferModule = require('../internals/array-buffer');\\nvar anInstance = require('../internals/an-instance');\\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar toLength = require('../internals/to-length');\\nvar toIndex = require('../internals/to-index');\\nvar toOffset = require('../internals/to-offset');\\nvar toPrimitive = require('../internals/to-primitive');\\nvar has = require('../internals/has');\\nvar classof = require('../internals/classof');\\nvar isObject = require('../internals/is-object');\\nvar create = require('../internals/object-create');\\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\\nvar typedArrayFrom = require('../internals/typed-array-from');\\nvar forEach = require('../internals/array-iteration').forEach;\\nvar setSpecies = require('../internals/set-species');\\nvar definePropertyModule = require('../internals/object-define-property');\\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\\nvar InternalStateModule = require('../internals/internal-state');\\nvar inheritIfRequired = require('../internals/inherit-if-required');\\n\\nvar getInternalState = InternalStateModule.get;\\nvar setInternalState = InternalStateModule.set;\\nvar nativeDefineProperty = definePropertyModule.f;\\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\\nvar round = Math.round;\\nvar RangeError = global.RangeError;\\nvar ArrayBuffer = ArrayBufferModule.ArrayBuffer;\\nvar DataView = ArrayBufferModule.DataView;\\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;\\nvar TypedArray = ArrayBufferViewCore.TypedArray;\\nvar TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;\\nvar aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;\\nvar isTypedArray = ArrayBufferViewCore.isTypedArray;\\nvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\\nvar WRONG_LENGTH = 'Wrong length';\\n\\nvar fromList = function (C, list) {\\n  var index = 0;\\n  var length = list.length;\\n  var result = new (aTypedArrayConstructor(C))(length);\\n  while (length > index) result[index] = list[index++];\\n  return result;\\n};\\n\\nvar addGetter = function (it, key) {\\n  nativeDefineProperty(it, key, { get: function () {\\n    return getInternalState(this)[key];\\n  } });\\n};\\n\\nvar isArrayBuffer = function (it) {\\n  var klass;\\n  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\\n};\\n\\nvar isTypedArrayIndex = function (target, key) {\\n  return isTypedArray(target)\\n    && typeof key != 'symbol'\\n    && key in target\\n    && String(+key) == String(key);\\n};\\n\\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\\n  return isTypedArrayIndex(target, key = toPrimitive(key, true))\\n    ? createPropertyDescriptor(2, target[key])\\n    : nativeGetOwnPropertyDescriptor(target, key);\\n};\\n\\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\\n  if (isTypedArrayIndex(target, key = toPrimitive(key, true))\\n    && isObject(descriptor)\\n    && has(descriptor, 'value')\\n    && !has(descriptor, 'get')\\n    && !has(descriptor, 'set')\\n    // TODO: add validation descriptor w/o calling accessors\\n    && !descriptor.configurable\\n    && (!has(descriptor, 'writable') || descriptor.writable)\\n    && (!has(descriptor, 'enumerable') || descriptor.enumerable)\\n  ) {\\n    target[key] = descriptor.value;\\n    return target;\\n  } return nativeDefineProperty(target, key, descriptor);\\n};\\n\\nif (DESCRIPTORS) {\\n  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\\n    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\\n    definePropertyModule.f = wrappedDefineProperty;\\n    addGetter(TypedArrayPrototype, 'buffer');\\n    addGetter(TypedArrayPrototype, 'byteOffset');\\n    addGetter(TypedArrayPrototype, 'byteLength');\\n    addGetter(TypedArrayPrototype, 'length');\\n  }\\n\\n  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\\n    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\\n    defineProperty: wrappedDefineProperty\\n  });\\n\\n  module.exports = function (TYPE, wrapper, CLAMPED) {\\n    var BYTES = TYPE.match(/\\\\d+$/)[0] / 8;\\n    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\\n    var GETTER = 'get' + TYPE;\\n    var SETTER = 'set' + TYPE;\\n    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];\\n    var TypedArrayConstructor = NativeTypedArrayConstructor;\\n    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\\n    var exported = {};\\n\\n    var getter = function (that, index) {\\n      var data = getInternalState(that);\\n      return data.view[GETTER](index * BYTES + data.byteOffset, true);\\n    };\\n\\n    var setter = function (that, index, value) {\\n      var data = getInternalState(that);\\n      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\\n      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\\n    };\\n\\n    var addElement = function (that, index) {\\n      nativeDefineProperty(that, index, {\\n        get: function () {\\n          return getter(this, index);\\n        },\\n        set: function (value) {\\n          return setter(this, index, value);\\n        },\\n        enumerable: true\\n      });\\n    };\\n\\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\\n      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\\n        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);\\n        var index = 0;\\n        var byteOffset = 0;\\n        var buffer, byteLength, length;\\n        if (!isObject(data)) {\\n          length = toIndex(data);\\n          byteLength = length * BYTES;\\n          buffer = new ArrayBuffer(byteLength);\\n        } else if (isArrayBuffer(data)) {\\n          buffer = data;\\n          byteOffset = toOffset(offset, BYTES);\\n          var $len = data.byteLength;\\n          if ($length === undefined) {\\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\\n            byteLength = $len - byteOffset;\\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\\n          } else {\\n            byteLength = toLength($length) * BYTES;\\n            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);\\n          }\\n          length = byteLength / BYTES;\\n        } else if (isTypedArray(data)) {\\n          return fromList(TypedArrayConstructor, data);\\n        } else {\\n          return typedArrayFrom.call(TypedArrayConstructor, data);\\n        }\\n        setInternalState(that, {\\n          buffer: buffer,\\n          byteOffset: byteOffset,\\n          byteLength: byteLength,\\n          length: length,\\n          view: new DataView(buffer)\\n        });\\n        while (index < length) addElement(that, index++);\\n      });\\n\\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\\n      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\\n    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\\n      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\\n        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);\\n        return inheritIfRequired(function () {\\n          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\\n          if (isArrayBuffer(data)) return $length !== undefined\\n            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)\\n            : typedArrayOffset !== undefined\\n              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))\\n              : new NativeTypedArrayConstructor(data);\\n          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\\n          return typedArrayFrom.call(TypedArrayConstructor, data);\\n        }(), dummy, TypedArrayConstructor);\\n      });\\n\\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\\n      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\\n        if (!(key in TypedArrayConstructor)) {\\n          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\\n        }\\n      });\\n      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\\n    }\\n\\n    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\\n      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\\n    }\\n\\n    if (TYPED_ARRAY_TAG) {\\n      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\\n    }\\n\\n    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\\n\\n    $({\\n      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS\\n    }, exported);\\n\\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\\n      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\\n    }\\n\\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\\n      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\\n    }\\n\\n    setSpecies(CONSTRUCTOR_NAME);\\n  };\\n} else module.exports = function () { /* empty */ };\\n\\n},{\\\"../internals/an-instance\\\":17,\\\"../internals/array-buffer\\\":21,\\\"../internals/array-buffer-view-core\\\":20,\\\"../internals/array-iteration\\\":25,\\\"../internals/classof\\\":30,\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/create-property-descriptor\\\":36,\\\"../internals/descriptors\\\":39,\\\"../internals/export\\\":43,\\\"../internals/global\\\":52,\\\"../internals/has\\\":53,\\\"../internals/inherit-if-required\\\":59,\\\"../internals/internal-state\\\":61,\\\"../internals/is-object\\\":65,\\\"../internals/object-create\\\":75,\\\"../internals/object-define-property\\\":77,\\\"../internals/object-get-own-property-descriptor\\\":78,\\\"../internals/object-get-own-property-names\\\":79,\\\"../internals/object-set-prototype-of\\\":85,\\\"../internals/set-species\\\":97,\\\"../internals/to-index\\\":106,\\\"../internals/to-length\\\":109,\\\"../internals/to-offset\\\":111,\\\"../internals/to-primitive\\\":113,\\\"../internals/typed-array-constructors-require-wrappers\\\":116,\\\"../internals/typed-array-from\\\":117}],116:[function(require,module,exports){\\n/* eslint-disable no-new */\\nvar global = require('../internals/global');\\nvar fails = require('../internals/fails');\\nvar checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');\\nvar NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;\\n\\nvar ArrayBuffer = global.ArrayBuffer;\\nvar Int8Array = global.Int8Array;\\n\\nmodule.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {\\n  Int8Array(1);\\n}) || !fails(function () {\\n  new Int8Array(-1);\\n}) || !checkCorrectnessOfIteration(function (iterable) {\\n  new Int8Array();\\n  new Int8Array(null);\\n  new Int8Array(1.5);\\n  new Int8Array(iterable);\\n}, true) || fails(function () {\\n  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\\n  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;\\n});\\n\\n},{\\\"../internals/array-buffer-view-core\\\":20,\\\"../internals/check-correctness-of-iteration\\\":28,\\\"../internals/fails\\\":44,\\\"../internals/global\\\":52}],117:[function(require,module,exports){\\nvar toObject = require('../internals/to-object');\\nvar toLength = require('../internals/to-length');\\nvar getIteratorMethod = require('../internals/get-iterator-method');\\nvar isArrayIteratorMethod = require('../internals/is-array-iterator-method');\\nvar bind = require('../internals/function-bind-context');\\nvar aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;\\n\\nmodule.exports = function from(source /* , mapfn, thisArg */) {\\n  var O = toObject(source);\\n  var argumentsLength = arguments.length;\\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\\n  var mapping = mapfn !== undefined;\\n  var iteratorMethod = getIteratorMethod(O);\\n  var i, length, result, step, iterator, next;\\n  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {\\n    iterator = iteratorMethod.call(O);\\n    next = iterator.next;\\n    O = [];\\n    while (!(step = next.call(iterator)).done) {\\n      O.push(step.value);\\n    }\\n  }\\n  if (mapping && argumentsLength > 2) {\\n    mapfn = bind(mapfn, arguments[2], 2);\\n  }\\n  length = toLength(O.length);\\n  result = new (aTypedArrayConstructor(this))(length);\\n  for (i = 0; length > i; i++) {\\n    result[i] = mapping ? mapfn(O[i], i) : O[i];\\n  }\\n  return result;\\n};\\n\\n},{\\\"../internals/array-buffer-view-core\\\":20,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-iterator-method\\\":48,\\\"../internals/is-array-iterator-method\\\":62,\\\"../internals/to-length\\\":109,\\\"../internals/to-object\\\":110}],118:[function(require,module,exports){\\nvar id = 0;\\nvar postfix = Math.random();\\n\\nmodule.exports = function (key) {\\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\\n};\\n\\n},{}],119:[function(require,module,exports){\\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\\n\\nmodule.exports = NATIVE_SYMBOL\\n  // eslint-disable-next-line no-undef\\n  && !Symbol.sham\\n  // eslint-disable-next-line no-undef\\n  && typeof Symbol.iterator == 'symbol';\\n\\n},{\\\"../internals/native-symbol\\\":71}],120:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar shared = require('../internals/shared');\\nvar has = require('../internals/has');\\nvar uid = require('../internals/uid');\\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\\n\\nvar WellKnownSymbolsStore = shared('wks');\\nvar Symbol = global.Symbol;\\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\\n\\nmodule.exports = function (name) {\\n  if (!has(WellKnownSymbolsStore, name)) {\\n    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];\\n    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\\n  } return WellKnownSymbolsStore[name];\\n};\\n\\n},{\\\"../internals/global\\\":52,\\\"../internals/has\\\":53,\\\"../internals/native-symbol\\\":71,\\\"../internals/shared\\\":101,\\\"../internals/uid\\\":118,\\\"../internals/use-symbol-as-uid\\\":119}],121:[function(require,module,exports){\\n'use strict';\\nvar toIndexedObject = require('../internals/to-indexed-object');\\nvar addToUnscopables = require('../internals/add-to-unscopables');\\nvar Iterators = require('../internals/iterators');\\nvar InternalStateModule = require('../internals/internal-state');\\nvar defineIterator = require('../internals/define-iterator');\\n\\nvar ARRAY_ITERATOR = 'Array Iterator';\\nvar setInternalState = InternalStateModule.set;\\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\\n\\n// `Array.prototype.entries` method\\n// https://tc39.es/ecma262/#sec-array.prototype.entries\\n// `Array.prototype.keys` method\\n// https://tc39.es/ecma262/#sec-array.prototype.keys\\n// `Array.prototype.values` method\\n// https://tc39.es/ecma262/#sec-array.prototype.values\\n// `Array.prototype[@@iterator]` method\\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\\n// `CreateArrayIterator` internal method\\n// https://tc39.es/ecma262/#sec-createarrayiterator\\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\\n  setInternalState(this, {\\n    type: ARRAY_ITERATOR,\\n    target: toIndexedObject(iterated), // target\\n    index: 0,                          // next index\\n    kind: kind                         // kind\\n  });\\n// `%ArrayIteratorPrototype%.next` method\\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\\n}, function () {\\n  var state = getInternalState(this);\\n  var target = state.target;\\n  var kind = state.kind;\\n  var index = state.index++;\\n  if (!target || index >= target.length) {\\n    state.target = undefined;\\n    return { value: undefined, done: true };\\n  }\\n  if (kind == 'keys') return { value: index, done: false };\\n  if (kind == 'values') return { value: target[index], done: false };\\n  return { value: [index, target[index]], done: false };\\n}, 'values');\\n\\n// argumentsList[@@iterator] is %ArrayProto_values%\\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\\nIterators.Arguments = Iterators.Array;\\n\\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\\naddToUnscopables('keys');\\naddToUnscopables('values');\\naddToUnscopables('entries');\\n\\n},{\\\"../internals/add-to-unscopables\\\":15,\\\"../internals/define-iterator\\\":38,\\\"../internals/internal-state\\\":61,\\\"../internals/iterators\\\":70,\\\"../internals/to-indexed-object\\\":107}],122:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar exec = require('../internals/regexp-exec');\\n\\n// `RegExp.prototype.exec` method\\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\\n$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {\\n  exec: exec\\n});\\n\\n},{\\\"../internals/export\\\":43,\\\"../internals/regexp-exec\\\":91}],123:[function(require,module,exports){\\n'use strict';\\nvar charAt = require('../internals/string-multibyte').charAt;\\nvar InternalStateModule = require('../internals/internal-state');\\nvar defineIterator = require('../internals/define-iterator');\\n\\nvar STRING_ITERATOR = 'String Iterator';\\nvar setInternalState = InternalStateModule.set;\\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\\n\\n// `String.prototype[@@iterator]` method\\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\\ndefineIterator(String, 'String', function (iterated) {\\n  setInternalState(this, {\\n    type: STRING_ITERATOR,\\n    string: String(iterated),\\n    index: 0\\n  });\\n// `%StringIteratorPrototype%.next` method\\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\\n}, function next() {\\n  var state = getInternalState(this);\\n  var string = state.string;\\n  var index = state.index;\\n  var point;\\n  if (index >= string.length) return { value: undefined, done: true };\\n  point = charAt(string, index);\\n  state.index += point.length;\\n  return { value: point, done: false };\\n});\\n\\n},{\\\"../internals/define-iterator\\\":38,\\\"../internals/internal-state\\\":61,\\\"../internals/string-multibyte\\\":103}],124:[function(require,module,exports){\\n'use strict';\\nvar fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');\\nvar anObject = require('../internals/an-object');\\nvar toLength = require('../internals/to-length');\\nvar toInteger = require('../internals/to-integer');\\nvar requireObjectCoercible = require('../internals/require-object-coercible');\\nvar advanceStringIndex = require('../internals/advance-string-index');\\nvar getSubstitution = require('../internals/get-substitution');\\nvar regExpExec = require('../internals/regexp-exec-abstract');\\n\\nvar max = Math.max;\\nvar min = Math.min;\\n\\nvar maybeToString = function (it) {\\n  return it === undefined ? it : String(it);\\n};\\n\\n// @@replace logic\\nfixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {\\n  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;\\n  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;\\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\\n\\n  return [\\n    // `String.prototype.replace` method\\n    // https://tc39.es/ecma262/#sec-string.prototype.replace\\n    function replace(searchValue, replaceValue) {\\n      var O = requireObjectCoercible(this);\\n      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];\\n      return replacer !== undefined\\n        ? replacer.call(searchValue, O, replaceValue)\\n        : nativeReplace.call(String(O), searchValue, replaceValue);\\n    },\\n    // `RegExp.prototype[@@replace]` method\\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\\n    function (regexp, replaceValue) {\\n      if (\\n        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||\\n        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)\\n      ) {\\n        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);\\n        if (res.done) return res.value;\\n      }\\n\\n      var rx = anObject(regexp);\\n      var S = String(this);\\n\\n      var functionalReplace = typeof replaceValue === 'function';\\n      if (!functionalReplace) replaceValue = String(replaceValue);\\n\\n      var global = rx.global;\\n      if (global) {\\n        var fullUnicode = rx.unicode;\\n        rx.lastIndex = 0;\\n      }\\n      var results = [];\\n      while (true) {\\n        var result = regExpExec(rx, S);\\n        if (result === null) break;\\n\\n        results.push(result);\\n        if (!global) break;\\n\\n        var matchStr = String(result[0]);\\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\\n      }\\n\\n      var accumulatedResult = '';\\n      var nextSourcePosition = 0;\\n      for (var i = 0; i < results.length; i++) {\\n        result = results[i];\\n\\n        var matched = String(result[0]);\\n        var position = max(min(toInteger(result.index), S.length), 0);\\n        var captures = [];\\n        // NOTE: This is equivalent to\\n        //   captures = result.slice(1).map(maybeToString)\\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\\n        // the slice polyfill when slicing native arrays) \\\"doesn't work\\\" in safari 9 and\\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\\n        var namedCaptures = result.groups;\\n        if (functionalReplace) {\\n          var replacerArgs = [matched].concat(captures, position, S);\\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\\n        } else {\\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\\n        }\\n        if (position >= nextSourcePosition) {\\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\\n          nextSourcePosition = position + matched.length;\\n        }\\n      }\\n      return accumulatedResult + S.slice(nextSourcePosition);\\n    }\\n  ];\\n});\\n\\n},{\\\"../internals/advance-string-index\\\":16,\\\"../internals/an-object\\\":18,\\\"../internals/fix-regexp-well-known-symbol-logic\\\":45,\\\"../internals/get-substitution\\\":51,\\\"../internals/regexp-exec-abstract\\\":90,\\\"../internals/require-object-coercible\\\":94,\\\"../internals/to-integer\\\":108,\\\"../internals/to-length\\\":109}],125:[function(require,module,exports){\\n'use strict';\\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');\\nvar exportTypedArrayStaticMethod = require('../internals/array-buffer-view-core').exportTypedArrayStaticMethod;\\nvar typedArrayFrom = require('../internals/typed-array-from');\\n\\n// `%TypedArray%.from` method\\n// https://tc39.es/ecma262/#sec-%typedarray%.from\\nexportTypedArrayStaticMethod('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);\\n\\n},{\\\"../internals/array-buffer-view-core\\\":20,\\\"../internals/typed-array-constructors-require-wrappers\\\":116,\\\"../internals/typed-array-from\\\":117}],126:[function(require,module,exports){\\nvar createTypedArrayConstructor = require('../internals/typed-array-constructor');\\n\\n// `Uint8Array` constructor\\n// https://tc39.es/ecma262/#sec-typedarray-objects\\ncreateTypedArrayConstructor('Uint8', function (init) {\\n  return function Uint8Array(data, byteOffset, length) {\\n    return init(this, data, byteOffset, length);\\n  };\\n});\\n\\n},{\\\"../internals/typed-array-constructor\\\":115}],127:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar collectionDeleteAll = require('../internals/collection-delete-all');\\n\\n// `Map.prototype.deleteAll` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  deleteAll: function deleteAll(/* ...elements */) {\\n    return collectionDeleteAll.apply(this, arguments);\\n  }\\n});\\n\\n},{\\\"../internals/collection-delete-all\\\":31,\\\"../internals/export\\\":43,\\\"../internals/is-pure\\\":66}],128:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar bind = require('../internals/function-bind-context');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.every` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  every: function every(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    return !iterate(iterator, function (key, value, stop) {\\n      if (!boundFunction(value, key, map)) return stop();\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;\\n  }\\n});\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],129:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar getBuiltIn = require('../internals/get-built-in');\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\nvar bind = require('../internals/function-bind-context');\\nvar speciesConstructor = require('../internals/species-constructor');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.filter` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  filter: function filter(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();\\n    var setter = aFunction(newMap.set);\\n    iterate(iterator, function (key, value) {\\n      if (boundFunction(value, key, map)) setter.call(newMap, key, value);\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true });\\n    return newMap;\\n  }\\n});\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-built-in\\\":47,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67,\\\"../internals/species-constructor\\\":102}],130:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar bind = require('../internals/function-bind-context');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.findKey` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  findKey: function findKey(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    return iterate(iterator, function (key, value, stop) {\\n      if (boundFunction(value, key, map)) return stop(key);\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;\\n  }\\n});\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],131:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar bind = require('../internals/function-bind-context');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.find` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  find: function find(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    return iterate(iterator, function (key, value, stop) {\\n      if (boundFunction(value, key, map)) return stop(value);\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;\\n  }\\n});\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],132:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar sameValueZero = require('../internals/same-value-zero');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.includes` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  includes: function includes(searchElement) {\\n    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {\\n      if (sameValueZero(value, searchElement)) return stop();\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;\\n  }\\n});\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67,\\\"../internals/same-value-zero\\\":95}],133:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.includes` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  keyOf: function keyOf(searchElement) {\\n    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {\\n      if (value === searchElement) return stop(key);\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;\\n  }\\n});\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],134:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar getBuiltIn = require('../internals/get-built-in');\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\nvar bind = require('../internals/function-bind-context');\\nvar speciesConstructor = require('../internals/species-constructor');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.mapKeys` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  mapKeys: function mapKeys(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();\\n    var setter = aFunction(newMap.set);\\n    iterate(iterator, function (key, value) {\\n      setter.call(newMap, boundFunction(value, key, map), value);\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true });\\n    return newMap;\\n  }\\n});\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-built-in\\\":47,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67,\\\"../internals/species-constructor\\\":102}],135:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar getBuiltIn = require('../internals/get-built-in');\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\nvar bind = require('../internals/function-bind-context');\\nvar speciesConstructor = require('../internals/species-constructor');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.mapValues` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  mapValues: function mapValues(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();\\n    var setter = aFunction(newMap.set);\\n    iterate(iterator, function (key, value) {\\n      setter.call(newMap, key, boundFunction(value, key, map));\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true });\\n    return newMap;\\n  }\\n});\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-built-in\\\":47,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67,\\\"../internals/species-constructor\\\":102}],136:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.merge` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  // eslint-disable-next-line no-unused-vars\\n  merge: function merge(iterable /* ...iterbles */) {\\n    var map = anObject(this);\\n    var setter = aFunction(map.set);\\n    var i = 0;\\n    while (i < arguments.length) {\\n      iterate(arguments[i++], setter, { that: map, AS_ENTRIES: true });\\n    }\\n    return map;\\n  }\\n});\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],137:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Map.prototype.reduce` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  reduce: function reduce(callbackfn /* , initialValue */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var noInitial = arguments.length < 2;\\n    var accumulator = noInitial ? undefined : arguments[1];\\n    aFunction(callbackfn);\\n    iterate(iterator, function (key, value) {\\n      if (noInitial) {\\n        noInitial = false;\\n        accumulator = value;\\n      } else {\\n        accumulator = callbackfn(accumulator, value, key, map);\\n      }\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true });\\n    if (noInitial) throw TypeError('Reduce of empty map with no initial value');\\n    return accumulator;\\n  }\\n});\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],138:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar bind = require('../internals/function-bind-context');\\nvar getMapIterator = require('../internals/get-map-iterator');\\nvar iterate = require('../internals/iterate');\\n\\n// `Set.prototype.some` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  some: function some(callbackfn /* , thisArg */) {\\n    var map = anObject(this);\\n    var iterator = getMapIterator(map);\\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    return iterate(iterator, function (key, value, stop) {\\n      if (boundFunction(value, key, map)) return stop();\\n    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;\\n  }\\n});\\n\\n},{\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-map-iterator\\\":50,\\\"../internals/is-pure\\\":66,\\\"../internals/iterate\\\":67}],139:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\nvar IS_PURE = require('../internals/is-pure');\\nvar anObject = require('../internals/an-object');\\nvar aFunction = require('../internals/a-function');\\n\\n// `Set.prototype.update` method\\n// https://github.com/tc39/proposal-collection-methods\\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\\n  update: function update(key, callback /* , thunk */) {\\n    var map = anObject(this);\\n    var length = arguments.length;\\n    aFunction(callback);\\n    var isPresentInMap = map.has(key);\\n    if (!isPresentInMap && length < 3) {\\n      throw TypeError('Updating absent value');\\n    }\\n    var value = isPresentInMap ? map.get(key) : aFunction(length > 2 ? arguments[2] : undefined)(key, map);\\n    map.set(key, callback(value, key, map));\\n    return map;\\n  }\\n});\\n\\n},{\\\"../internals/a-function\\\":13,\\\"../internals/an-object\\\":18,\\\"../internals/export\\\":43,\\\"../internals/is-pure\\\":66}],140:[function(require,module,exports){\\nvar global = require('../internals/global');\\nvar DOMIterables = require('../internals/dom-iterables');\\nvar ArrayIteratorMethods = require('../modules/es.array.iterator');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar ITERATOR = wellKnownSymbol('iterator');\\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\\nvar ArrayValues = ArrayIteratorMethods.values;\\n\\nfor (var COLLECTION_NAME in DOMIterables) {\\n  var Collection = global[COLLECTION_NAME];\\n  var CollectionPrototype = Collection && Collection.prototype;\\n  if (CollectionPrototype) {\\n    // some Chrome versions have non-configurable methods on DOMTokenList\\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\\n    } catch (error) {\\n      CollectionPrototype[ITERATOR] = ArrayValues;\\n    }\\n    if (!CollectionPrototype[TO_STRING_TAG]) {\\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\\n    }\\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\\n      // some Chrome versions have non-configurable methods on DOMTokenList\\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\\n      } catch (error) {\\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\\n      }\\n    }\\n  }\\n}\\n\\n},{\\\"../internals/create-non-enumerable-property\\\":35,\\\"../internals/dom-iterables\\\":41,\\\"../internals/global\\\":52,\\\"../internals/well-known-symbol\\\":120,\\\"../modules/es.array.iterator\\\":121}],141:[function(require,module,exports){\\n'use strict';\\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\\nrequire('../modules/es.array.iterator');\\nvar $ = require('../internals/export');\\nvar getBuiltIn = require('../internals/get-built-in');\\nvar USE_NATIVE_URL = require('../internals/native-url');\\nvar redefine = require('../internals/redefine');\\nvar redefineAll = require('../internals/redefine-all');\\nvar setToStringTag = require('../internals/set-to-string-tag');\\nvar createIteratorConstructor = require('../internals/create-iterator-constructor');\\nvar InternalStateModule = require('../internals/internal-state');\\nvar anInstance = require('../internals/an-instance');\\nvar hasOwn = require('../internals/has');\\nvar bind = require('../internals/function-bind-context');\\nvar classof = require('../internals/classof');\\nvar anObject = require('../internals/an-object');\\nvar isObject = require('../internals/is-object');\\nvar create = require('../internals/object-create');\\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\\nvar getIterator = require('../internals/get-iterator');\\nvar getIteratorMethod = require('../internals/get-iterator-method');\\nvar wellKnownSymbol = require('../internals/well-known-symbol');\\n\\nvar $fetch = getBuiltIn('fetch');\\nvar Headers = getBuiltIn('Headers');\\nvar ITERATOR = wellKnownSymbol('iterator');\\nvar URL_SEARCH_PARAMS = 'URLSearchParams';\\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';\\nvar setInternalState = InternalStateModule.set;\\nvar getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);\\nvar getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);\\n\\nvar plus = /\\\\+/g;\\nvar sequences = Array(4);\\n\\nvar percentSequence = function (bytes) {\\n  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\\\\\\\da-f]{2}){' + bytes + '})', 'gi'));\\n};\\n\\nvar percentDecode = function (sequence) {\\n  try {\\n    return decodeURIComponent(sequence);\\n  } catch (error) {\\n    return sequence;\\n  }\\n};\\n\\nvar deserialize = function (it) {\\n  var result = it.replace(plus, ' ');\\n  var bytes = 4;\\n  try {\\n    return decodeURIComponent(result);\\n  } catch (error) {\\n    while (bytes) {\\n      result = result.replace(percentSequence(bytes--), percentDecode);\\n    }\\n    return result;\\n  }\\n};\\n\\nvar find = /[!'()~]|%20/g;\\n\\nvar replace = {\\n  '!': '%21',\\n  \\\"'\\\": '%27',\\n  '(': '%28',\\n  ')': '%29',\\n  '~': '%7E',\\n  '%20': '+'\\n};\\n\\nvar replacer = function (match) {\\n  return replace[match];\\n};\\n\\nvar serialize = function (it) {\\n  return encodeURIComponent(it).replace(find, replacer);\\n};\\n\\nvar parseSearchParams = function (result, query) {\\n  if (query) {\\n    var attributes = query.split('&');\\n    var index = 0;\\n    var attribute, entry;\\n    while (index < attributes.length) {\\n      attribute = attributes[index++];\\n      if (attribute.length) {\\n        entry = attribute.split('=');\\n        result.push({\\n          key: deserialize(entry.shift()),\\n          value: deserialize(entry.join('='))\\n        });\\n      }\\n    }\\n  }\\n};\\n\\nvar updateSearchParams = function (query) {\\n  this.entries.length = 0;\\n  parseSearchParams(this.entries, query);\\n};\\n\\nvar validateArgumentsLength = function (passed, required) {\\n  if (passed < required) throw TypeError('Not enough arguments');\\n};\\n\\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\\n  setInternalState(this, {\\n    type: URL_SEARCH_PARAMS_ITERATOR,\\n    iterator: getIterator(getInternalParamsState(params).entries),\\n    kind: kind\\n  });\\n}, 'Iterator', function next() {\\n  var state = getInternalIteratorState(this);\\n  var kind = state.kind;\\n  var step = state.iterator.next();\\n  var entry = step.value;\\n  if (!step.done) {\\n    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];\\n  } return step;\\n});\\n\\n// `URLSearchParams` constructor\\n// https://url.spec.whatwg.org/#interface-urlsearchparams\\nvar URLSearchParamsConstructor = function URLSearchParams(/* init */) {\\n  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);\\n  var init = arguments.length > 0 ? arguments[0] : undefined;\\n  var that = this;\\n  var entries = [];\\n  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;\\n\\n  setInternalState(that, {\\n    type: URL_SEARCH_PARAMS,\\n    entries: entries,\\n    updateURL: function () { /* empty */ },\\n    updateSearchParams: updateSearchParams\\n  });\\n\\n  if (init !== undefined) {\\n    if (isObject(init)) {\\n      iteratorMethod = getIteratorMethod(init);\\n      if (typeof iteratorMethod === 'function') {\\n        iterator = iteratorMethod.call(init);\\n        next = iterator.next;\\n        while (!(step = next.call(iterator)).done) {\\n          entryIterator = getIterator(anObject(step.value));\\n          entryNext = entryIterator.next;\\n          if (\\n            (first = entryNext.call(entryIterator)).done ||\\n            (second = entryNext.call(entryIterator)).done ||\\n            !entryNext.call(entryIterator).done\\n          ) throw TypeError('Expected sequence with length 2');\\n          entries.push({ key: first.value + '', value: second.value + '' });\\n        }\\n      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' });\\n    } else {\\n      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');\\n    }\\n  }\\n};\\n\\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\\n\\nredefineAll(URLSearchParamsPrototype, {\\n  // `URLSearchParams.prototype.append` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-append\\n  append: function append(name, value) {\\n    validateArgumentsLength(arguments.length, 2);\\n    var state = getInternalParamsState(this);\\n    state.entries.push({ key: name + '', value: value + '' });\\n    state.updateURL();\\n  },\\n  // `URLSearchParams.prototype.delete` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete\\n  'delete': function (name) {\\n    validateArgumentsLength(arguments.length, 1);\\n    var state = getInternalParamsState(this);\\n    var entries = state.entries;\\n    var key = name + '';\\n    var index = 0;\\n    while (index < entries.length) {\\n      if (entries[index].key === key) entries.splice(index, 1);\\n      else index++;\\n    }\\n    state.updateURL();\\n  },\\n  // `URLSearchParams.prototype.get` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-get\\n  get: function get(name) {\\n    validateArgumentsLength(arguments.length, 1);\\n    var entries = getInternalParamsState(this).entries;\\n    var key = name + '';\\n    var index = 0;\\n    for (; index < entries.length; index++) {\\n      if (entries[index].key === key) return entries[index].value;\\n    }\\n    return null;\\n  },\\n  // `URLSearchParams.prototype.getAll` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall\\n  getAll: function getAll(name) {\\n    validateArgumentsLength(arguments.length, 1);\\n    var entries = getInternalParamsState(this).entries;\\n    var key = name + '';\\n    var result = [];\\n    var index = 0;\\n    for (; index < entries.length; index++) {\\n      if (entries[index].key === key) result.push(entries[index].value);\\n    }\\n    return result;\\n  },\\n  // `URLSearchParams.prototype.has` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-has\\n  has: function has(name) {\\n    validateArgumentsLength(arguments.length, 1);\\n    var entries = getInternalParamsState(this).entries;\\n    var key = name + '';\\n    var index = 0;\\n    while (index < entries.length) {\\n      if (entries[index++].key === key) return true;\\n    }\\n    return false;\\n  },\\n  // `URLSearchParams.prototype.set` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-set\\n  set: function set(name, value) {\\n    validateArgumentsLength(arguments.length, 1);\\n    var state = getInternalParamsState(this);\\n    var entries = state.entries;\\n    var found = false;\\n    var key = name + '';\\n    var val = value + '';\\n    var index = 0;\\n    var entry;\\n    for (; index < entries.length; index++) {\\n      entry = entries[index];\\n      if (entry.key === key) {\\n        if (found) entries.splice(index--, 1);\\n        else {\\n          found = true;\\n          entry.value = val;\\n        }\\n      }\\n    }\\n    if (!found) entries.push({ key: key, value: val });\\n    state.updateURL();\\n  },\\n  // `URLSearchParams.prototype.sort` method\\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort\\n  sort: function sort() {\\n    var state = getInternalParamsState(this);\\n    var entries = state.entries;\\n    // Array#sort is not stable in some engines\\n    var slice = entries.slice();\\n    var entry, entriesIndex, sliceIndex;\\n    entries.length = 0;\\n    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {\\n      entry = slice[sliceIndex];\\n      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {\\n        if (entries[entriesIndex].key > entry.key) {\\n          entries.splice(entriesIndex, 0, entry);\\n          break;\\n        }\\n      }\\n      if (entriesIndex === sliceIndex) entries.push(entry);\\n    }\\n    state.updateURL();\\n  },\\n  // `URLSearchParams.prototype.forEach` method\\n  forEach: function forEach(callback /* , thisArg */) {\\n    var entries = getInternalParamsState(this).entries;\\n    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);\\n    var index = 0;\\n    var entry;\\n    while (index < entries.length) {\\n      entry = entries[index++];\\n      boundFunction(entry.value, entry.key, this);\\n    }\\n  },\\n  // `URLSearchParams.prototype.keys` method\\n  keys: function keys() {\\n    return new URLSearchParamsIterator(this, 'keys');\\n  },\\n  // `URLSearchParams.prototype.values` method\\n  values: function values() {\\n    return new URLSearchParamsIterator(this, 'values');\\n  },\\n  // `URLSearchParams.prototype.entries` method\\n  entries: function entries() {\\n    return new URLSearchParamsIterator(this, 'entries');\\n  }\\n}, { enumerable: true });\\n\\n// `URLSearchParams.prototype[@@iterator]` method\\nredefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);\\n\\n// `URLSearchParams.prototype.toString` method\\n// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\\nredefine(URLSearchParamsPrototype, 'toString', function toString() {\\n  var entries = getInternalParamsState(this).entries;\\n  var result = [];\\n  var index = 0;\\n  var entry;\\n  while (index < entries.length) {\\n    entry = entries[index++];\\n    result.push(serialize(entry.key) + '=' + serialize(entry.value));\\n  } return result.join('&');\\n}, { enumerable: true });\\n\\nsetToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\\n\\n$({ global: true, forced: !USE_NATIVE_URL }, {\\n  URLSearchParams: URLSearchParamsConstructor\\n});\\n\\n// Wrap `fetch` for correct work with polyfilled `URLSearchParams`\\n// https://github.com/zloirock/core-js/issues/674\\nif (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {\\n  $({ global: true, enumerable: true, forced: true }, {\\n    fetch: function fetch(input /* , init */) {\\n      var args = [input];\\n      var init, body, headers;\\n      if (arguments.length > 1) {\\n        init = arguments[1];\\n        if (isObject(init)) {\\n          body = init.body;\\n          if (classof(body) === URL_SEARCH_PARAMS) {\\n            headers = init.headers ? new Headers(init.headers) : new Headers();\\n            if (!headers.has('content-type')) {\\n              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\\n            }\\n            init = create(init, {\\n              body: createPropertyDescriptor(0, String(body)),\\n              headers: createPropertyDescriptor(0, headers)\\n            });\\n          }\\n        }\\n        args.push(init);\\n      } return $fetch.apply(this, args);\\n    }\\n  });\\n}\\n\\nmodule.exports = {\\n  URLSearchParams: URLSearchParamsConstructor,\\n  getState: getInternalParamsState\\n};\\n\\n},{\\\"../internals/an-instance\\\":17,\\\"../internals/an-object\\\":18,\\\"../internals/classof\\\":30,\\\"../internals/create-iterator-constructor\\\":34,\\\"../internals/create-property-descriptor\\\":36,\\\"../internals/export\\\":43,\\\"../internals/function-bind-context\\\":46,\\\"../internals/get-built-in\\\":47,\\\"../internals/get-iterator\\\":49,\\\"../internals/get-iterator-method\\\":48,\\\"../internals/has\\\":53,\\\"../internals/internal-state\\\":61,\\\"../internals/is-object\\\":65,\\\"../internals/native-url\\\":72,\\\"../internals/object-create\\\":75,\\\"../internals/redefine\\\":89,\\\"../internals/redefine-all\\\":88,\\\"../internals/set-to-string-tag\\\":98,\\\"../internals/well-known-symbol\\\":120,\\\"../modules/es.array.iterator\\\":121}],142:[function(require,module,exports){\\n'use strict';\\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\\nrequire('../modules/es.string.iterator');\\nvar $ = require('../internals/export');\\nvar DESCRIPTORS = require('../internals/descriptors');\\nvar USE_NATIVE_URL = require('../internals/native-url');\\nvar global = require('../internals/global');\\nvar defineProperties = require('../internals/object-define-properties');\\nvar redefine = require('../internals/redefine');\\nvar anInstance = require('../internals/an-instance');\\nvar has = require('../internals/has');\\nvar assign = require('../internals/object-assign');\\nvar arrayFrom = require('../internals/array-from');\\nvar codeAt = require('../internals/string-multibyte').codeAt;\\nvar toASCII = require('../internals/string-punycode-to-ascii');\\nvar setToStringTag = require('../internals/set-to-string-tag');\\nvar URLSearchParamsModule = require('../modules/web.url-search-params');\\nvar InternalStateModule = require('../internals/internal-state');\\n\\nvar NativeURL = global.URL;\\nvar URLSearchParams = URLSearchParamsModule.URLSearchParams;\\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\\nvar setInternalState = InternalStateModule.set;\\nvar getInternalURLState = InternalStateModule.getterFor('URL');\\nvar floor = Math.floor;\\nvar pow = Math.pow;\\n\\nvar INVALID_AUTHORITY = 'Invalid authority';\\nvar INVALID_SCHEME = 'Invalid scheme';\\nvar INVALID_HOST = 'Invalid host';\\nvar INVALID_PORT = 'Invalid port';\\n\\nvar ALPHA = /[A-Za-z]/;\\nvar ALPHANUMERIC = /[\\\\d+-.A-Za-z]/;\\nvar DIGIT = /\\\\d/;\\nvar HEX_START = /^(0x|0X)/;\\nvar OCT = /^[0-7]+$/;\\nvar DEC = /^\\\\d+$/;\\nvar HEX = /^[\\\\dA-Fa-f]+$/;\\n// eslint-disable-next-line no-control-regex\\nvar FORBIDDEN_HOST_CODE_POINT = /[\\\\u0000\\\\u0009\\\\u000A\\\\u000D #%/:?@[\\\\\\\\]]/;\\n// eslint-disable-next-line no-control-regex\\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\\\u0000\\\\u0009\\\\u000A\\\\u000D #/:?@[\\\\\\\\]]/;\\n// eslint-disable-next-line no-control-regex\\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\\\u0000-\\\\u001F ]+|[\\\\u0000-\\\\u001F ]+$/g;\\n// eslint-disable-next-line no-control-regex\\nvar TAB_AND_NEW_LINE = /[\\\\u0009\\\\u000A\\\\u000D]/g;\\nvar EOF;\\n\\nvar parseHost = function (url, input) {\\n  var result, codePoints, index;\\n  if (input.charAt(0) == '[') {\\n    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;\\n    result = parseIPv6(input.slice(1, -1));\\n    if (!result) return INVALID_HOST;\\n    url.host = result;\\n  // opaque host\\n  } else if (!isSpecial(url)) {\\n    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;\\n    result = '';\\n    codePoints = arrayFrom(input);\\n    for (index = 0; index < codePoints.length; index++) {\\n      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\\n    }\\n    url.host = result;\\n  } else {\\n    input = toASCII(input);\\n    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;\\n    result = parseIPv4(input);\\n    if (result === null) return INVALID_HOST;\\n    url.host = result;\\n  }\\n};\\n\\nvar parseIPv4 = function (input) {\\n  var parts = input.split('.');\\n  var partsLength, numbers, index, part, radix, number, ipv4;\\n  if (parts.length && parts[parts.length - 1] == '') {\\n    parts.pop();\\n  }\\n  partsLength = parts.length;\\n  if (partsLength > 4) return input;\\n  numbers = [];\\n  for (index = 0; index < partsLength; index++) {\\n    part = parts[index];\\n    if (part == '') return input;\\n    radix = 10;\\n    if (part.length > 1 && part.charAt(0) == '0') {\\n      radix = HEX_START.test(part) ? 16 : 8;\\n      part = part.slice(radix == 8 ? 1 : 2);\\n    }\\n    if (part === '') {\\n      number = 0;\\n    } else {\\n      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;\\n      number = parseInt(part, radix);\\n    }\\n    numbers.push(number);\\n  }\\n  for (index = 0; index < partsLength; index++) {\\n    number = numbers[index];\\n    if (index == partsLength - 1) {\\n      if (number >= pow(256, 5 - partsLength)) return null;\\n    } else if (number > 255) return null;\\n  }\\n  ipv4 = numbers.pop();\\n  for (index = 0; index < numbers.length; index++) {\\n    ipv4 += numbers[index] * pow(256, 3 - index);\\n  }\\n  return ipv4;\\n};\\n\\n// eslint-disable-next-line max-statements\\nvar parseIPv6 = function (input) {\\n  var address = [0, 0, 0, 0, 0, 0, 0, 0];\\n  var pieceIndex = 0;\\n  var compress = null;\\n  var pointer = 0;\\n  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\\n\\n  var char = function () {\\n    return input.charAt(pointer);\\n  };\\n\\n  if (char() == ':') {\\n    if (input.charAt(1) != ':') return;\\n    pointer += 2;\\n    pieceIndex++;\\n    compress = pieceIndex;\\n  }\\n  while (char()) {\\n    if (pieceIndex == 8) return;\\n    if (char() == ':') {\\n      if (compress !== null) return;\\n      pointer++;\\n      pieceIndex++;\\n      compress = pieceIndex;\\n      continue;\\n    }\\n    value = length = 0;\\n    while (length < 4 && HEX.test(char())) {\\n      value = value * 16 + parseInt(char(), 16);\\n      pointer++;\\n      length++;\\n    }\\n    if (char() == '.') {\\n      if (length == 0) return;\\n      pointer -= length;\\n      if (pieceIndex > 6) return;\\n      numbersSeen = 0;\\n      while (char()) {\\n        ipv4Piece = null;\\n        if (numbersSeen > 0) {\\n          if (char() == '.' && numbersSeen < 4) pointer++;\\n          else return;\\n        }\\n        if (!DIGIT.test(char())) return;\\n        while (DIGIT.test(char())) {\\n          number = parseInt(char(), 10);\\n          if (ipv4Piece === null) ipv4Piece = number;\\n          else if (ipv4Piece == 0) return;\\n          else ipv4Piece = ipv4Piece * 10 + number;\\n          if (ipv4Piece > 255) return;\\n          pointer++;\\n        }\\n        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\\n        numbersSeen++;\\n        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;\\n      }\\n      if (numbersSeen != 4) return;\\n      break;\\n    } else if (char() == ':') {\\n      pointer++;\\n      if (!char()) return;\\n    } else if (char()) return;\\n    address[pieceIndex++] = value;\\n  }\\n  if (compress !== null) {\\n    swaps = pieceIndex - compress;\\n    pieceIndex = 7;\\n    while (pieceIndex != 0 && swaps > 0) {\\n      swap = address[pieceIndex];\\n      address[pieceIndex--] = address[compress + swaps - 1];\\n      address[compress + --swaps] = swap;\\n    }\\n  } else if (pieceIndex != 8) return;\\n  return address;\\n};\\n\\nvar findLongestZeroSequence = function (ipv6) {\\n  var maxIndex = null;\\n  var maxLength = 1;\\n  var currStart = null;\\n  var currLength = 0;\\n  var index = 0;\\n  for (; index < 8; index++) {\\n    if (ipv6[index] !== 0) {\\n      if (currLength > maxLength) {\\n        maxIndex = currStart;\\n        maxLength = currLength;\\n      }\\n      currStart = null;\\n      currLength = 0;\\n    } else {\\n      if (currStart === null) currStart = index;\\n      ++currLength;\\n    }\\n  }\\n  if (currLength > maxLength) {\\n    maxIndex = currStart;\\n    maxLength = currLength;\\n  }\\n  return maxIndex;\\n};\\n\\nvar serializeHost = function (host) {\\n  var result, index, compress, ignore0;\\n  // ipv4\\n  if (typeof host == 'number') {\\n    result = [];\\n    for (index = 0; index < 4; index++) {\\n      result.unshift(host % 256);\\n      host = floor(host / 256);\\n    } return result.join('.');\\n  // ipv6\\n  } else if (typeof host == 'object') {\\n    result = '';\\n    compress = findLongestZeroSequence(host);\\n    for (index = 0; index < 8; index++) {\\n      if (ignore0 && host[index] === 0) continue;\\n      if (ignore0) ignore0 = false;\\n      if (compress === index) {\\n        result += index ? ':' : '::';\\n        ignore0 = true;\\n      } else {\\n        result += host[index].toString(16);\\n        if (index < 7) result += ':';\\n      }\\n    }\\n    return '[' + result + ']';\\n  } return host;\\n};\\n\\nvar C0ControlPercentEncodeSet = {};\\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\\n  ' ': 1, '\\\"': 1, '<': 1, '>': 1, '`': 1\\n});\\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\\n  '#': 1, '?': 1, '{': 1, '}': 1\\n});\\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\\n  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\\\\\\\': 1, ']': 1, '^': 1, '|': 1\\n});\\n\\nvar percentEncode = function (char, set) {\\n  var code = codeAt(char, 0);\\n  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);\\n};\\n\\nvar specialSchemes = {\\n  ftp: 21,\\n  file: null,\\n  http: 80,\\n  https: 443,\\n  ws: 80,\\n  wss: 443\\n};\\n\\nvar isSpecial = function (url) {\\n  return has(specialSchemes, url.scheme);\\n};\\n\\nvar includesCredentials = function (url) {\\n  return url.username != '' || url.password != '';\\n};\\n\\nvar cannotHaveUsernamePasswordPort = function (url) {\\n  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';\\n};\\n\\nvar isWindowsDriveLetter = function (string, normalized) {\\n  var second;\\n  return string.length == 2 && ALPHA.test(string.charAt(0))\\n    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));\\n};\\n\\nvar startsWithWindowsDriveLetter = function (string) {\\n  var third;\\n  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (\\n    string.length == 2 ||\\n    ((third = string.charAt(2)) === '/' || third === '\\\\\\\\' || third === '?' || third === '#')\\n  );\\n};\\n\\nvar shortenURLsPath = function (url) {\\n  var path = url.path;\\n  var pathSize = path.length;\\n  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\\n    path.pop();\\n  }\\n};\\n\\nvar isSingleDot = function (segment) {\\n  return segment === '.' || segment.toLowerCase() === '%2e';\\n};\\n\\nvar isDoubleDot = function (segment) {\\n  segment = segment.toLowerCase();\\n  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';\\n};\\n\\n// States:\\nvar SCHEME_START = {};\\nvar SCHEME = {};\\nvar NO_SCHEME = {};\\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\\nvar PATH_OR_AUTHORITY = {};\\nvar RELATIVE = {};\\nvar RELATIVE_SLASH = {};\\nvar SPECIAL_AUTHORITY_SLASHES = {};\\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\\nvar AUTHORITY = {};\\nvar HOST = {};\\nvar HOSTNAME = {};\\nvar PORT = {};\\nvar FILE = {};\\nvar FILE_SLASH = {};\\nvar FILE_HOST = {};\\nvar PATH_START = {};\\nvar PATH = {};\\nvar CANNOT_BE_A_BASE_URL_PATH = {};\\nvar QUERY = {};\\nvar FRAGMENT = {};\\n\\n// eslint-disable-next-line max-statements\\nvar parseURL = function (url, input, stateOverride, base) {\\n  var state = stateOverride || SCHEME_START;\\n  var pointer = 0;\\n  var buffer = '';\\n  var seenAt = false;\\n  var seenBracket = false;\\n  var seenPasswordToken = false;\\n  var codePoints, char, bufferCodePoints, failure;\\n\\n  if (!stateOverride) {\\n    url.scheme = '';\\n    url.username = '';\\n    url.password = '';\\n    url.host = null;\\n    url.port = null;\\n    url.path = [];\\n    url.query = null;\\n    url.fragment = null;\\n    url.cannotBeABaseURL = false;\\n    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');\\n  }\\n\\n  input = input.replace(TAB_AND_NEW_LINE, '');\\n\\n  codePoints = arrayFrom(input);\\n\\n  while (pointer <= codePoints.length) {\\n    char = codePoints[pointer];\\n    switch (state) {\\n      case SCHEME_START:\\n        if (char && ALPHA.test(char)) {\\n          buffer += char.toLowerCase();\\n          state = SCHEME;\\n        } else if (!stateOverride) {\\n          state = NO_SCHEME;\\n          continue;\\n        } else return INVALID_SCHEME;\\n        break;\\n\\n      case SCHEME:\\n        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {\\n          buffer += char.toLowerCase();\\n        } else if (char == ':') {\\n          if (stateOverride && (\\n            (isSpecial(url) != has(specialSchemes, buffer)) ||\\n            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||\\n            (url.scheme == 'file' && !url.host)\\n          )) return;\\n          url.scheme = buffer;\\n          if (stateOverride) {\\n            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;\\n            return;\\n          }\\n          buffer = '';\\n          if (url.scheme == 'file') {\\n            state = FILE;\\n          } else if (isSpecial(url) && base && base.scheme == url.scheme) {\\n            state = SPECIAL_RELATIVE_OR_AUTHORITY;\\n          } else if (isSpecial(url)) {\\n            state = SPECIAL_AUTHORITY_SLASHES;\\n          } else if (codePoints[pointer + 1] == '/') {\\n            state = PATH_OR_AUTHORITY;\\n            pointer++;\\n          } else {\\n            url.cannotBeABaseURL = true;\\n            url.path.push('');\\n            state = CANNOT_BE_A_BASE_URL_PATH;\\n          }\\n        } else if (!stateOverride) {\\n          buffer = '';\\n          state = NO_SCHEME;\\n          pointer = 0;\\n          continue;\\n        } else return INVALID_SCHEME;\\n        break;\\n\\n      case NO_SCHEME:\\n        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;\\n        if (base.cannotBeABaseURL && char == '#') {\\n          url.scheme = base.scheme;\\n          url.path = base.path.slice();\\n          url.query = base.query;\\n          url.fragment = '';\\n          url.cannotBeABaseURL = true;\\n          state = FRAGMENT;\\n          break;\\n        }\\n        state = base.scheme == 'file' ? FILE : RELATIVE;\\n        continue;\\n\\n      case SPECIAL_RELATIVE_OR_AUTHORITY:\\n        if (char == '/' && codePoints[pointer + 1] == '/') {\\n          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\\n          pointer++;\\n        } else {\\n          state = RELATIVE;\\n          continue;\\n        } break;\\n\\n      case PATH_OR_AUTHORITY:\\n        if (char == '/') {\\n          state = AUTHORITY;\\n          break;\\n        } else {\\n          state = PATH;\\n          continue;\\n        }\\n\\n      case RELATIVE:\\n        url.scheme = base.scheme;\\n        if (char == EOF) {\\n          url.username = base.username;\\n          url.password = base.password;\\n          url.host = base.host;\\n          url.port = base.port;\\n          url.path = base.path.slice();\\n          url.query = base.query;\\n        } else if (char == '/' || (char == '\\\\\\\\' && isSpecial(url))) {\\n          state = RELATIVE_SLASH;\\n        } else if (char == '?') {\\n          url.username = base.username;\\n          url.password = base.password;\\n          url.host = base.host;\\n          url.port = base.port;\\n          url.path = base.path.slice();\\n          url.query = '';\\n          state = QUERY;\\n        } else if (char == '#') {\\n          url.username = base.username;\\n          url.password = base.password;\\n          url.host = base.host;\\n          url.port = base.port;\\n          url.path = base.path.slice();\\n          url.query = base.query;\\n          url.fragment = '';\\n          state = FRAGMENT;\\n        } else {\\n          url.username = base.username;\\n          url.password = base.password;\\n          url.host = base.host;\\n          url.port = base.port;\\n          url.path = base.path.slice();\\n          url.path.pop();\\n          state = PATH;\\n          continue;\\n        } break;\\n\\n      case RELATIVE_SLASH:\\n        if (isSpecial(url) && (char == '/' || char == '\\\\\\\\')) {\\n          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\\n        } else if (char == '/') {\\n          state = AUTHORITY;\\n        } else {\\n          url.username = base.username;\\n          url.password = base.password;\\n          url.host = base.host;\\n          url.port = base.port;\\n          state = PATH;\\n          continue;\\n        } break;\\n\\n      case SPECIAL_AUTHORITY_SLASHES:\\n        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\\n        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;\\n        pointer++;\\n        break;\\n\\n      case SPECIAL_AUTHORITY_IGNORE_SLASHES:\\n        if (char != '/' && char != '\\\\\\\\') {\\n          state = AUTHORITY;\\n          continue;\\n        } break;\\n\\n      case AUTHORITY:\\n        if (char == '@') {\\n          if (seenAt) buffer = '%40' + buffer;\\n          seenAt = true;\\n          bufferCodePoints = arrayFrom(buffer);\\n          for (var i = 0; i < bufferCodePoints.length; i++) {\\n            var codePoint = bufferCodePoints[i];\\n            if (codePoint == ':' && !seenPasswordToken) {\\n              seenPasswordToken = true;\\n              continue;\\n            }\\n            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\\n            if (seenPasswordToken) url.password += encodedCodePoints;\\n            else url.username += encodedCodePoints;\\n          }\\n          buffer = '';\\n        } else if (\\n          char == EOF || char == '/' || char == '?' || char == '#' ||\\n          (char == '\\\\\\\\' && isSpecial(url))\\n        ) {\\n          if (seenAt && buffer == '') return INVALID_AUTHORITY;\\n          pointer -= arrayFrom(buffer).length + 1;\\n          buffer = '';\\n          state = HOST;\\n        } else buffer += char;\\n        break;\\n\\n      case HOST:\\n      case HOSTNAME:\\n        if (stateOverride && url.scheme == 'file') {\\n          state = FILE_HOST;\\n          continue;\\n        } else if (char == ':' && !seenBracket) {\\n          if (buffer == '') return INVALID_HOST;\\n          failure = parseHost(url, buffer);\\n          if (failure) return failure;\\n          buffer = '';\\n          state = PORT;\\n          if (stateOverride == HOSTNAME) return;\\n        } else if (\\n          char == EOF || char == '/' || char == '?' || char == '#' ||\\n          (char == '\\\\\\\\' && isSpecial(url))\\n        ) {\\n          if (isSpecial(url) && buffer == '') return INVALID_HOST;\\n          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;\\n          failure = parseHost(url, buffer);\\n          if (failure) return failure;\\n          buffer = '';\\n          state = PATH_START;\\n          if (stateOverride) return;\\n          continue;\\n        } else {\\n          if (char == '[') seenBracket = true;\\n          else if (char == ']') seenBracket = false;\\n          buffer += char;\\n        } break;\\n\\n      case PORT:\\n        if (DIGIT.test(char)) {\\n          buffer += char;\\n        } else if (\\n          char == EOF || char == '/' || char == '?' || char == '#' ||\\n          (char == '\\\\\\\\' && isSpecial(url)) ||\\n          stateOverride\\n        ) {\\n          if (buffer != '') {\\n            var port = parseInt(buffer, 10);\\n            if (port > 0xFFFF) return INVALID_PORT;\\n            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;\\n            buffer = '';\\n          }\\n          if (stateOverride) return;\\n          state = PATH_START;\\n          continue;\\n        } else return INVALID_PORT;\\n        break;\\n\\n      case FILE:\\n        url.scheme = 'file';\\n        if (char == '/' || char == '\\\\\\\\') state = FILE_SLASH;\\n        else if (base && base.scheme == 'file') {\\n          if (char == EOF) {\\n            url.host = base.host;\\n            url.path = base.path.slice();\\n            url.query = base.query;\\n          } else if (char == '?') {\\n            url.host = base.host;\\n            url.path = base.path.slice();\\n            url.query = '';\\n            state = QUERY;\\n          } else if (char == '#') {\\n            url.host = base.host;\\n            url.path = base.path.slice();\\n            url.query = base.query;\\n            url.fragment = '';\\n            state = FRAGMENT;\\n          } else {\\n            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\\n              url.host = base.host;\\n              url.path = base.path.slice();\\n              shortenURLsPath(url);\\n            }\\n            state = PATH;\\n            continue;\\n          }\\n        } else {\\n          state = PATH;\\n          continue;\\n        } break;\\n\\n      case FILE_SLASH:\\n        if (char == '/' || char == '\\\\\\\\') {\\n          state = FILE_HOST;\\n          break;\\n        }\\n        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\\n          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);\\n          else url.host = base.host;\\n        }\\n        state = PATH;\\n        continue;\\n\\n      case FILE_HOST:\\n        if (char == EOF || char == '/' || char == '\\\\\\\\' || char == '?' || char == '#') {\\n          if (!stateOverride && isWindowsDriveLetter(buffer)) {\\n            state = PATH;\\n          } else if (buffer == '') {\\n            url.host = '';\\n            if (stateOverride) return;\\n            state = PATH_START;\\n          } else {\\n            failure = parseHost(url, buffer);\\n            if (failure) return failure;\\n            if (url.host == 'localhost') url.host = '';\\n            if (stateOverride) return;\\n            buffer = '';\\n            state = PATH_START;\\n          } continue;\\n        } else buffer += char;\\n        break;\\n\\n      case PATH_START:\\n        if (isSpecial(url)) {\\n          state = PATH;\\n          if (char != '/' && char != '\\\\\\\\') continue;\\n        } else if (!stateOverride && char == '?') {\\n          url.query = '';\\n          state = QUERY;\\n        } else if (!stateOverride && char == '#') {\\n          url.fragment = '';\\n          state = FRAGMENT;\\n        } else if (char != EOF) {\\n          state = PATH;\\n          if (char != '/') continue;\\n        } break;\\n\\n      case PATH:\\n        if (\\n          char == EOF || char == '/' ||\\n          (char == '\\\\\\\\' && isSpecial(url)) ||\\n          (!stateOverride && (char == '?' || char == '#'))\\n        ) {\\n          if (isDoubleDot(buffer)) {\\n            shortenURLsPath(url);\\n            if (char != '/' && !(char == '\\\\\\\\' && isSpecial(url))) {\\n              url.path.push('');\\n            }\\n          } else if (isSingleDot(buffer)) {\\n            if (char != '/' && !(char == '\\\\\\\\' && isSpecial(url))) {\\n              url.path.push('');\\n            }\\n          } else {\\n            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {\\n              if (url.host) url.host = '';\\n              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter\\n            }\\n            url.path.push(buffer);\\n          }\\n          buffer = '';\\n          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {\\n            while (url.path.length > 1 && url.path[0] === '') {\\n              url.path.shift();\\n            }\\n          }\\n          if (char == '?') {\\n            url.query = '';\\n            state = QUERY;\\n          } else if (char == '#') {\\n            url.fragment = '';\\n            state = FRAGMENT;\\n          }\\n        } else {\\n          buffer += percentEncode(char, pathPercentEncodeSet);\\n        } break;\\n\\n      case CANNOT_BE_A_BASE_URL_PATH:\\n        if (char == '?') {\\n          url.query = '';\\n          state = QUERY;\\n        } else if (char == '#') {\\n          url.fragment = '';\\n          state = FRAGMENT;\\n        } else if (char != EOF) {\\n          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);\\n        } break;\\n\\n      case QUERY:\\n        if (!stateOverride && char == '#') {\\n          url.fragment = '';\\n          state = FRAGMENT;\\n        } else if (char != EOF) {\\n          if (char == \\\"'\\\" && isSpecial(url)) url.query += '%27';\\n          else if (char == '#') url.query += '%23';\\n          else url.query += percentEncode(char, C0ControlPercentEncodeSet);\\n        } break;\\n\\n      case FRAGMENT:\\n        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);\\n        break;\\n    }\\n\\n    pointer++;\\n  }\\n};\\n\\n// `URL` constructor\\n// https://url.spec.whatwg.org/#url-class\\nvar URLConstructor = function URL(url /* , base */) {\\n  var that = anInstance(this, URLConstructor, 'URL');\\n  var base = arguments.length > 1 ? arguments[1] : undefined;\\n  var urlString = String(url);\\n  var state = setInternalState(that, { type: 'URL' });\\n  var baseState, failure;\\n  if (base !== undefined) {\\n    if (base instanceof URLConstructor) baseState = getInternalURLState(base);\\n    else {\\n      failure = parseURL(baseState = {}, String(base));\\n      if (failure) throw TypeError(failure);\\n    }\\n  }\\n  failure = parseURL(state, urlString, null, baseState);\\n  if (failure) throw TypeError(failure);\\n  var searchParams = state.searchParams = new URLSearchParams();\\n  var searchParamsState = getInternalSearchParamsState(searchParams);\\n  searchParamsState.updateSearchParams(state.query);\\n  searchParamsState.updateURL = function () {\\n    state.query = String(searchParams) || null;\\n  };\\n  if (!DESCRIPTORS) {\\n    that.href = serializeURL.call(that);\\n    that.origin = getOrigin.call(that);\\n    that.protocol = getProtocol.call(that);\\n    that.username = getUsername.call(that);\\n    that.password = getPassword.call(that);\\n    that.host = getHost.call(that);\\n    that.hostname = getHostname.call(that);\\n    that.port = getPort.call(that);\\n    that.pathname = getPathname.call(that);\\n    that.search = getSearch.call(that);\\n    that.searchParams = getSearchParams.call(that);\\n    that.hash = getHash.call(that);\\n  }\\n};\\n\\nvar URLPrototype = URLConstructor.prototype;\\n\\nvar serializeURL = function () {\\n  var url = getInternalURLState(this);\\n  var scheme = url.scheme;\\n  var username = url.username;\\n  var password = url.password;\\n  var host = url.host;\\n  var port = url.port;\\n  var path = url.path;\\n  var query = url.query;\\n  var fragment = url.fragment;\\n  var output = scheme + ':';\\n  if (host !== null) {\\n    output += '//';\\n    if (includesCredentials(url)) {\\n      output += username + (password ? ':' + password : '') + '@';\\n    }\\n    output += serializeHost(host);\\n    if (port !== null) output += ':' + port;\\n  } else if (scheme == 'file') output += '//';\\n  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\\n  if (query !== null) output += '?' + query;\\n  if (fragment !== null) output += '#' + fragment;\\n  return output;\\n};\\n\\nvar getOrigin = function () {\\n  var url = getInternalURLState(this);\\n  var scheme = url.scheme;\\n  var port = url.port;\\n  if (scheme == 'blob') try {\\n    return new URL(scheme.path[0]).origin;\\n  } catch (error) {\\n    return 'null';\\n  }\\n  if (scheme == 'file' || !isSpecial(url)) return 'null';\\n  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');\\n};\\n\\nvar getProtocol = function () {\\n  return getInternalURLState(this).scheme + ':';\\n};\\n\\nvar getUsername = function () {\\n  return getInternalURLState(this).username;\\n};\\n\\nvar getPassword = function () {\\n  return getInternalURLState(this).password;\\n};\\n\\nvar getHost = function () {\\n  var url = getInternalURLState(this);\\n  var host = url.host;\\n  var port = url.port;\\n  return host === null ? ''\\n    : port === null ? serializeHost(host)\\n    : serializeHost(host) + ':' + port;\\n};\\n\\nvar getHostname = function () {\\n  var host = getInternalURLState(this).host;\\n  return host === null ? '' : serializeHost(host);\\n};\\n\\nvar getPort = function () {\\n  var port = getInternalURLState(this).port;\\n  return port === null ? '' : String(port);\\n};\\n\\nvar getPathname = function () {\\n  var url = getInternalURLState(this);\\n  var path = url.path;\\n  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\\n};\\n\\nvar getSearch = function () {\\n  var query = getInternalURLState(this).query;\\n  return query ? '?' + query : '';\\n};\\n\\nvar getSearchParams = function () {\\n  return getInternalURLState(this).searchParams;\\n};\\n\\nvar getHash = function () {\\n  var fragment = getInternalURLState(this).fragment;\\n  return fragment ? '#' + fragment : '';\\n};\\n\\nvar accessorDescriptor = function (getter, setter) {\\n  return { get: getter, set: setter, configurable: true, enumerable: true };\\n};\\n\\nif (DESCRIPTORS) {\\n  defineProperties(URLPrototype, {\\n    // `URL.prototype.href` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-href\\n    href: accessorDescriptor(serializeURL, function (href) {\\n      var url = getInternalURLState(this);\\n      var urlString = String(href);\\n      var failure = parseURL(url, urlString);\\n      if (failure) throw TypeError(failure);\\n      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\\n    }),\\n    // `URL.prototype.origin` getter\\n    // https://url.spec.whatwg.org/#dom-url-origin\\n    origin: accessorDescriptor(getOrigin),\\n    // `URL.prototype.protocol` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-protocol\\n    protocol: accessorDescriptor(getProtocol, function (protocol) {\\n      var url = getInternalURLState(this);\\n      parseURL(url, String(protocol) + ':', SCHEME_START);\\n    }),\\n    // `URL.prototype.username` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-username\\n    username: accessorDescriptor(getUsername, function (username) {\\n      var url = getInternalURLState(this);\\n      var codePoints = arrayFrom(String(username));\\n      if (cannotHaveUsernamePasswordPort(url)) return;\\n      url.username = '';\\n      for (var i = 0; i < codePoints.length; i++) {\\n        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\\n      }\\n    }),\\n    // `URL.prototype.password` accessors pair\\n    // https://url.spec.whatwg.org/#do€€