
Ã|»|      method: 'eth_requestAccounts',
          })
        }
        if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {
          accounts = await provider.request({ method: 'eth_accounts' })
        }
      } catch (error) {
        if (error.code === 4001) {
          throw error
        }
        $tw.boot.getLogger().error(error)
      }
      // Enable attempt
      if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {
        if (typeof provider.enable === 'function') {
          accounts = await provider.enable()
        }
      }
      if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {
        throw new Error('Unable to retrieve any Ethereum accounts...')
      }
      if (provider.chainId !== undefined) {
        $tw.boot.getLogger().log(`Chain: ${provider.chainId}, Ethereum Account: ${accounts[0]}`)
      } else {
        $tw.boot.getLogger().log(`Ethereum Account: ${accounts[0]}`)
      }
      try {
        if (signature) {
          var tStart = new Date()
          signature = await provider.request({
            method: 'eth_decrypt',
            params: [signature, accounts[0]],
          })
          if (signature !== undefined || signature !== null) {
            var tStop = new Date() - tStart
            $tw.boot.getLogger().info(`Ethereum Signature Decrypt: ${tStop}ms`)
          }
          recovered = await personalRecover(provider, keccak256, signature)
          $tw.boot.getLogger().info(`Signed from: https://app.ens.domains/address/${recovered}`)
        }
        var tStart = new Date()
        decrypted = await provider.request({
          method: 'eth_decrypt',
          params: [encrypted, accounts[0]],
        })
        if (decrypted !== undefined || decrypted !== null) {
          var tStop = new Date() - tStart
          var ratio = Math.floor((decrypted.length * 100) / encrypted.length)
          $tw.boot.getLogger().info(`Ethereum Decrypt: ${tStop}ms, In: ${encrypted.length}, Out: ${decrypted.length}, Ratio: ${ratio}%`)
        }
      } catch (error) {
        if (error.code === 4001) {
          throw error
        }
        if (error.name === 'UnrecoverableSignature') {
          throw new Error(`Tampered encrypted content. ${error.message}`)
        }
        $tw.boot.getLogger().error(error)
        throw new Error('Unable to Decrypt Ethereum content...')
      }
    } catch (error) {
      if (error.code === 4001) {
        $tw.utils.error('Rejected User Request...')
      } else {
        $tw.utils.error(error.message)
      }
    }
    callback(decrypted, recovered)
  }

  /////////////////////////// Module mechanism

  /**
   * Execute the module named 'moduleName'. The name can optionally be relative to the module named 'moduleRoot'
   */
  $tw.modules.execute = function (moduleName, moduleRoot) {
    var name = moduleName
    if (moduleName.charAt(0) === '.') {
      name = $tw.utils.resolvePath(moduleName, moduleRoot)
    }
    if (!$tw.modules.titles[name]) {
      if ($tw.modules.titles[name + '.js']) {
        name = name + '.js'
      } else if ($tw.modules.titles[name + '/index.js']) {
        name = name + '/index.js'
      } else if ($tw.modules.titles[moduleName]) {
        name = moduleName
      } else if ($tw.modules.titles[moduleName + '.js']) {
        name = moduleName + '.js'
      } else if ($tw.modules.titles[moduleName + '/index.js']) {
        name = moduleName + '/index.js'
      }
    }
    var moduleInfo = $tw.modules.titles[name]
    var tiddler = $tw.wiki.getTiddler(name)
    var _exports = {}
    var sandbox = {
      module: { exports: _exports },
      //moduleInfo: moduleInfo,
      exports: _exports,
      console: console,
      setInterval: setInterval,
      clearInterval: clearInterval,
      setTimeout: setTimeout,
      clearTimeout: clearTimeout,
      Buffer: $tw.browser ? undefined : Buffer,
      $tw: $tw,
      require: function (title) {
        return $tw.modules.execute(title, name)
      },
    }

    Object.defineProperty(sandbox.module, 'id', {
      value: name,
      writable: false,
      enumerable: true,
      configurable: false,
    })

    if (!$tw.browser) {
      $tw.utils.extend(sandbox, {
        process: process,
      })
    } else {
      /**
       * CommonJS optional require.main property:
       * In a browser we offer a fake main module which points back to the boot function
       * (Theoretically, this may allow TW to eventually load itself as a module in the browser)
       */
      Object.defineProperty(sandbox.require, 'main', {
        value: typeof require !== 'undefined' ? require.main : { TiddlyWiki: _ipfs },
        writable: false,
        enumerable: true,
        configurable: false,
      })
    }
    if (!moduleInfo) {
      // We could not find the module on this path
      // Try to defer to browserify etc, or node
      if ($tw.browser) {
        if (window.require) {
          try {
            return window.require(moduleName)
          } catch (e) {}
        }
        throw new Error(`Cannot find module named '${moduleName}' required by module '${moduleRoot}', resolved to ${name}`)
      } else {
        // If we don't have a module with that name, let node.js try to find it
        return require(moduleName)
      }
    }
    // Execute the module if we haven't already done so
    if (!moduleInfo.exports) {
      try {
        // Check the type of the definition
        if (typeof moduleInfo.definition === 'function') {
          // Function
          moduleInfo.exports = _exports
          moduleInfo.definition(moduleInfo, moduleInfo.exports, sandbox.require)
        } else if (typeof moduleInfo.definition === 'string') {
          // String
          moduleInfo.exports = _exports
          $tw.utils.evalSandboxed(moduleInfo.definition, sandbox, tiddler.fields.title)
          if (sandbox.module.exports) {
            moduleInfo.exports = sandbox.module.exports //more codemirror workaround
          }
        } else {
          // Object
          moduleInfo.exports = moduleInfo.definition
        }
      } catch (e) {
        if (e instanceof SyntaxError) {
          var line = e.lineNumber || e.line // Firefox || Safari
          if (typeof line !== 'undefined' && line !== null) {
            $tw.utils.error('Syntax error in boot module ' + name + ':' + line + ':\n' + e.stack)
          } else if (!$tw.browser) {
            // this is the only way to get node.js to display the line at which the syntax error appeared,
            // and $tw.utils.error would exit anyway
            // cf. https://bugs.chromium.org/p/v8/issues/detail?id=2589
            throw e
          } else {
            // Opera: line number is included in e.message
            // Chrome/IE: there's currently no way to get the line number
            $tw.utils.error('Syntax error in boot module ' + name + ': ' + e.message + '\n' + e.stack)
          }
        } else {
          // line number should be included in e.stack for runtime errors
          $tw.utils.error('Error executing boot module ' + name + ': ' + JSON.stringify(e) + '\n\n' + e.stack)
        }
      }
    }
    // Return the exports of the module
    return moduleInfo.exports
  }

  /////////////////////////// Browser definitions

  if ($tw.browser && !$tw.node) {
    $tw.boot.passwordPrompt = function (text, callback) {
      var prompt = 'Enter a password to decrypt this TiddlyWiki'
      // Prompt for the password
      if ($tw.utils.hop($tw.boot, 'encryptionPrompts')) {
        prompt = $tw.boot.encryptionPrompts.decrypt
      }
      $tw.passwordPrompt.createPrompt({
        serviceName: prompt,
        noUserName: true,
        submitText: 'Decrypt',
        callback: function (data) {
          // Attempt to decrypt the tiddlers
          $tw.crypto.setPassword(data.password)
          var decryptedText = $tw.crypto.decrypt(text)
          if (decryptedText) {
            callback(decryptedText)
            // Exit and remove the password prompt
            return true
          } else {
            // We didn't decrypt everything, so continue to prompt for password
            return false
          }
        },
      })
    }

    $tw.boot.preloadTiddler = function (text, callback) {
      try {
        if (text !== undefined && text !== null) {
          var json = JSON.parse(text)
          for (var title in json) {
            $tw.preloadTiddler(json[title])
          }
        }
      } catch (error) {
        $tw.boot.getLogger().error(error)
      }
      callback()
    }

    $tw.boot.inflateTiddlers = function (callback) {
      var compressedStoreArea = document.getElementById('compressedStoreArea')
      if (compressedStoreArea) {
        var inflate = function (b64) {
          if (b64 !== undefined && b64 !== null) {
            $tw.boot.preloadTiddler($tw.compress.inflate(b64), callback)
          }
        }
        var content = compressedStoreArea.innerHTML
        if (content.match(/{"compressed":/)) {
          var json = JSON.parse(content)
          if (json.compressed.match(/{"iv":/)) {
            $tw.boot.passwordPrompt(json.compressed, function (decrypted) {
              inflate(decrypted)
            })
          } else if (json.compressed.match(/{"version":/)) {
            $tw.boot.metamaskPrompt(json.compressed, json.keccak256, json.signature, function (decrypted, recovered) {
              inflate(decrypted)
              if (recovered) {
                $tw.utils.alert(
                  name,
                  `Signed from: <a class="tc-tiddlylink-external" rel="noopener noreferrer" target="_blank" href="https://app.ens.domains/address/${recovered}">${recovered}</a>`
                )
              }
            })
          } else {
            inflate(json.compressed)
          }
        } else {
          $tw.boot.preloadTiddler(content, callback)
        }
      } else {
        // Preload any encrypted tiddlers
        $tw.boot.decryptEncryptedTiddlers(callback)
      }
    }

    /**
     * Decrypt any tiddlers stored within the element with the ID "encryptedArea".
     * The function is asynchronous to allow the user to be prompted for a password
     * callback: function to be called the decryption is complete
     */
    $tw.boot.decryptEncryptedTiddlers = function (callback) {
      var encryptedStoreArea = document.getElementById('encryptedStoreArea')
      if (encryptedStoreArea) {
        var content = encryptedStoreArea.innerHTML
        if (content.match(/{"iv":/)) {
          $tw.boot.passwordPrompt(content, function (decrypted) {
            $tw.boot.preloadTiddler(decrypted, callback)
          })
        } else if (content.match(/{"encrypted":/)) {
          const json = JSON.parse(content)
          $tw.boot.metamaskPrompt(json.encrypted, json.keccak256, json.signature, function (decrypted, recovered) {
            $tw.boot.preloadTiddler(decrypted, callback)
            if (recovered) {
              $tw.utils.alert(
                name,
                `Signed from: <a class="tc-tiddlylink-external" rel="noopener noreferrer" target="_blank" href="https://app.ens.domains/address/${recovered}">${recovered}</a>`
              )
            }
          })
        } else {
          $tw.boot.preloadTiddler(content, callback)
        }
      } else {
        // Just invoke the callback straight away if there weren't any encrypted tiddlers
        callback()
      }
    }
  } else {
    /////////////////////////// Server definitions

    /**
     * Get any compressed tiddlers
     */
    $tw.boot.inflateTiddlers = function (callback) {
      // Storing compressed tiddlers on the server isn't supported yet
      callback()
    }

    /**
     * Get any encrypted tiddlers
     */
    $tw.boot.decryptEncryptedTiddlers = function (callback) {
      // Storing encrypted tiddlers on the server isn't supported yet
      callback()
    }
  } // End of if($tw.browser && !$tw.node)

  /////////////////////////// Node definitions

  if ($tw.node) {
    $tw.filepaths = Object.create(null)

    /*
    Load the tiddlers from a plugin folder, and package them up into a proper JSON plugin tiddler
    */
    $tw.loadPluginFolder = function (filepath, excludeRegExp) {
      excludeRegExp = excludeRegExp || $tw.boot.excludeRegExp
      var infoPath = filepath + path.sep + 'plugin.info'
      if (fs.existsSync(filepath) && fs.statSync(filepath).isDirectory()) {
        // Read the plugin information
        if (!fs.existsSync(infoPath) || !fs.statSync(infoPath).isFile()) {
          console.log('Warning: missing plugin.info file in ' + filepath)
          return null
        }
        var pluginInfo = JSON.parse(fs.readFileSync(infoPath, 'utf8'))
        // Read the plugin files
        var pluginFiles = $tw.loadTiddlersFromPath(filepath, excludeRegExp)
        // Save the plugin tiddlers into the plugin info
        pluginInfo.tiddlers = pluginInfo.tiddlers || Object.create(null)
        for (var f = 0; f < pluginFiles.length; f++) {
          var tiddlers = pluginFiles[f].tiddlers
          for (var t = 0; t < tiddlers.length; t++) {
            var tiddler = tiddlers[t]
            if (tiddler.title) {
              if (pluginFiles[f].type === 'application/javascript') {
                $tw.filepaths[tiddler.title] = pluginFiles[f].filepath
              }
              pluginInfo.tiddlers[tiddler.title] = tiddler
            }
          }
        }
        // Give the plugin the same version number as the core if it doesn't have one
        if (!('version' in pluginInfo)) {
          pluginInfo.version = $tw.packageInfo.version
        }
        // Use "plugin" as the plugin-type if we don't have one
        if (!('plugin-type' in pluginInfo)) {
          pluginInfo['plugin-type'] = 'plugin'
        }
        pluginInfo.dependents = pluginInfo.dependents || []
        pluginInfo.type = 'application/json'
        // Set plugin text
        pluginInfo.text = JSON.stringify({ tiddlers: pluginInfo.tiddlers }, null, 4)
        delete pluginInfo.tiddlers
        // Deserialise array fields (currently required for the dependents field)
        for (var field in pluginInfo) {
          if ($tw.utils.isArray(pluginInfo[field])) {
            pluginInfo[field] = $tw.utils.stringifyList(pluginInfo[field])
          }
        }
        return pluginInfo
      }
      return null
    }
  }

  /////////////////////////// Main boot function to decrypt tiddlers and then startup

  $tw.boot.boot = function (callback) {
    // Initialise crypto object
    $tw.crypto = new $tw.utils.Crypto()
    // Initialise password prompter
    if ($tw.browser && !$tw.node) {
      $tw.passwordPrompt = new $tw.utils.PasswordPrompt()
    }
    // Initialise compress object
    $tw.compress = new $tw.utils.Compress()
    // Preload any compressed tiddlers
    $tw.boot.inflateTiddlers(function () {
      // Startup
      $tw.boot.startup({ callback: callback })
      // Make sure the crypto state tiddler is up to date
      var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')
      if (encrypted && encrypted.fields._encryption_public_key) {
        $tw.crypto.setEncryptionKey(encrypted.fields._encryption_public_key)
      } else {
        $tw.crypto.updateCryptoStateTiddler()
      }
      // Make sure the compress state tiddler is up to date
      var compressed = $tw.wiki.getTiddler('$:/isCompressed')
      if (!compressed) {
        $tw.compress.updateCompressStateTiddler()
      }
    })
  }

  if ($tw.browser && !$tw.boot.suppressBoot) {
    $tw.boot.boot()
  }

  return $tw
}

if (typeof exports !== 'undefined') {
  exports.TiddlyWiki = _ipfs
} else {
  _ipfs(window.$tw)
}

</script>
</div>
<!--~~ Raw markup for the bottom of the body section ~~-->

</body>
</html>
»|