
Š€€€{
    "title": "$:/plugins/ipfs",
    "name": "IPFS with TiddlyWiki",
    "description": "IPFS with TiddlyWiki",
    "author": "Xavier Maysonnave",
    "build": "210514348",
    "version": "0.4.0-beta-tw-v5.1.23+build-210514348",
    "license": "GPL-3.0-or-later",
    "tags": "$:/ipfs/core",
    "core-version": ">=5.1.2",
    "project-uri": "https://github.com/xmaysonnave/tiddlywiki-ipfs",
    "plugin-priority": "71000",
    "plugin-type": "plugin",
    "list": "readme changelog",
    "dependents": "",
    "type": "application/json",
    "text": "{\n    \"tiddlers\": {\n        \"$:/bluelight.ico\": {\n            \"title\": \"$:/bluelight.ico\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isIpfs\",\n            \"type\": \"image/x-icon\",\n            \"_canonical_uri\": \"ipfs://bafybeifn6upicwwbecu6hfjzqwkeyocku7c6eemvzbyhc36vaehnyejnqi/$_bluelight.ico\",\n            \"altSourceUri\": \"https://dweb.link/ipfs/bafybeifn6upicwwbecu6hfjzqwkeyocku7c6eemvzbyhc36vaehnyejnqi/$_bluelight.ico\",\n            \"_license_uri\": \"https://flyclipart.com/license\",\n            \"_source_uri\": \"https://flyclipart.com/blue-light-blue-edit-icon-with-png-and-vector-format-for-free-blue-light-png-564668\"\n        },\n        \"$:/bluelight.png\": {\n            \"title\": \"$:/bluelight.png\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isIpfs\",\n            \"type\": \"image/png\",\n            \"_canonical_uri\": \"ipfs://bafybeihnseopt2e4ddmh23vwmucqsth4l52jtj5zmtgpfazjvnrn7m6w34/$_bluelight.png\",\n            \"altSourceUri\": \"https://dweb.link/ipfs/bafybeihnseopt2e4ddmh23vwmucqsth4l52jtj5zmtgpfazjvnrn7m6w34/$_bluelight.png\",\n            \"_license_uri\": \"https://flyclipart.com/license\",\n            \"_source_uri\": \"https://flyclipart.com/blue-light-blue-edit-icon-with-png-and-vector-format-for-free-blue-light-png-564668\"\n        },\n        \"$:/favicon.ico\": {\n            \"title\": \"$:/favicon.ico\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isIpfs\",\n            \"type\": \"image/x-icon\",\n            \"_canonical_uri\": \"ipfs://bafybeifn6upicwwbecu6hfjzqwkeyocku7c6eemvzbyhc36vaehnyejnqi/$_bluelight.ico\",\n            \"altSourceUri\": \"https://dweb.link/ipfs/bafybeifn6upicwwbecu6hfjzqwkeyocku7c6eemvzbyhc36vaehnyejnqi/$_bluelight.ico\"\n        },\n        \"$:/ipfs/core/icons/dns\": {\n            \"title\": \"$:/ipfs/core/icons/dns\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAABMAAAAQCAIAAAB7ptM1AAAk5HpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZxpjiS5kqT/8xR9BO7LcbgCc4M5fn9CWuTLzKoGBpiurIqIdPcwI3URFVGqldn/9/8c81/8U0uoJqZSc8vZ8k9ssfnOD9W+f/r96my8X99fwvee+/N183231vOSPvR9sObv8z+vu18XeN86P6XfLlTn98b4840Wv+vXvy7k37egFenn9V2ofRcK/r3hvgv0ty2bWy2/b2Hs93397KS+/4y++Pl97Pvw33+PBeutxH2C9ztgJr764N8Cwv3PhM4bnq8+8A4/u/tz5GsI5bsYBvk3O9nfVmX+9sqvn/7yyir/7pSQ3ycML/xpzPzr+7++7tJfr38XNNfEv905/NjH//n6Ov4f2/n575xVzTn77a7HjEnzt6mfLd6f+ODA5OH+WuZP4b/Ez+X+afyphuiduHzZaQd/pmvO45bjoluuu+P2/T7dZInRb1/47v304b5WQ/HNT3nN4SH+uONLaGGFis8m7g286n+txd37tnu76So3Xo5PesfF5HVv9OV/48//eKFzFPLOyZi43l3/OC+Lswx5Tl/5FA5x5yeO0jXwz5+//5FfAx5M18yVDXY73iVGcl9sKY7CdXTgg4nvL9dcWd8FMBH3TiyGqI/OZheSy84W74tz2LHin86FKvngBy5wKfnFKn0MIeOc6nVvfqe4+1mf/HsZzMIRKeQAoOGgjq8iwEb8lFiJoZ5CiimlnEqqqaWeQ4455ZxLFvj1EkosqeRSSi2t9BpqrKnmWmo1tdXefAuAY2q5lVZba71z086VO7/d+UDvw48w4kgjjzLqaKNPwmfGmWaeZVYz2+zLr7DAiZVXWXW11bfbhNKOO+28y6677X4ItRNOPOnkU0497fRfXnPmufUff/7fveZ+vOavp/TB8str/GopP5dwgpMkn+ExHx0eL/IAAe3lM1tdjN7IdfKZbSBbSJ5VJjlnOXkMD8btfDrul+/+47k//GZi/P/ym//xnJHr/jc8Z+S6/8Fz//Tbv3htqdpMG8z1kNJQRrWB9DvF9ZbtGfx+i3PVsno7TjeM7UR+cbi48h4xg1aHH7ONywiF4+5rb1LkzBH2wm+1nTJTHKw6ejfCTGFX63Mde7OQFXbHDuW41AfxmIo3sc4zu00hnJH2Omc0f3YMZ2Y+m4YvrZFvYxOPfUXcdDZ+Pvbskhpv15bn8smURE4foC+WRcpuUjucWrFZjsH1iX99WSlilJU6bt0zjj7s3ql2jM5rDUMVA7KXHM+s+mRo+XiclzchMEvcxEInLgr7m9ufDhYTkBjN8UNvZe50AAICxPjRfcTTPo/Kr81mV5xnEFlnrcyuW6jcP8d0RjlcbHqiYRKaI7q8TlkE7RjdZFUb19PBPiMdvNY2YXeoY9dObvk2Svee7dW+e4kY4IhkRPYSU+jD5XCccavVuiJhSog47nd/PVZy0mUKTR3XUDnVmlxLbum29WQZK5XBB0tIuVsz6tn8PvG8uffmmrMURxblHXNYufuZ1iSwZ+gJEsWyMb+bhV+2KRJt4xADySRSKkLPymLZa4dFvJDjRNMks4YN+CZnYsi1cFZ2PfPxTSLW5irb8xgUfhbNiGTUCoNQLj3HWuZIs57EdgjMTV4ne9rk+qy34/Mct1gcEd0DOZAml/HJsaKS/GhlUGR3GrVOj7dntkHer45VjHZkXsJAObZLi9fcZTbZi1WS2d6kEnOR6esY4BFXvb902vUgHOHwKjlEekVCBAzOs/fqtPQjEOHKJNw2J8h+eXe7AIlg2dFak+it3wWbQgFX7uZZSGLnmHKyreaaUjPV5mEnpi34JgDIL+zMtdcsGJ0wDW2lOkOTz3JfiXDsI8hDGJ3fIorYWiCrXALiDB8Mm5ATy/C8lBqAQvy2iYUI0kjqgjzgaDilkAskEsnTd9GKR9YPo7liNrmgRB+ntn2SB1mpuZBg58Pe4+aqJ7XKcHaP6UC5FK4dWVpKe7hBrJRswL1Nzg8QGfTll4tP0U2liqAQoDoezIyKK7vtnrPXeaHURQFmJT26AhIgXuTNqGvifHaSy8mA2lmseU5WREHwkQ3j1msHEneRuINcI5G40CbvD17rbeHRQHzJ2kSdB2DZ/eaa0YOSFB3oItFKVnHXQplqiehWSo6x4H7slLp2b32CLn1IA6Ctkwh5UMmKkP/EWvOaZF8NWIEIWDIa9ibe+bBfq7lhDuWFK+bFNQZgJ6AB2Sfp7tLilUndIHyhobzM0mOrWxHYXSWm8ae7OWSURGLGHcygvJEl1KG2Wpcw6i0hM7AyyeZP84PtQgWpcptgSpU7wJo6wQX1I9Y8IVAoCb3t1sFFchKfdipc2ykvQqmEdQB3vBMaZnILuIZHeJu/DLBG3zZ+H3XysZ7198nficmifa7TdyOhdit+b1gEuOXIoQI0nYQg2CQy2zOZIKBIHbGfwecpM5n4TGl1sJ6Qz1DqoFBd44Yh0aVbwA+qoGUAyx0qaIg/qjZB39Kc1CEuRskgPXEryDlXKmQB7lPUbGKnq+hBDbBAcqymsGOMZJYdlPrQp7Jkcb2jUniLH7q5O6CLiCI/sSkUoCDk7Ns+US8hc+EGY7cOVo858gUroS9VHQ/UAoIlrELdQieQUjgpUk4Ec5YqOIfiD7ZwMMVuZg9FaGnANCyNElko9IB4JaqABcrGhOVRyTArVYLKSak/Py7hWiQIqR1MoACDCLzal16lmgMyiVwC6TBAgMP01Uk+3hcKEWn3MmAnduLfkHnhwEb81hsQ9cMC2hFNGMRdDxNccarui0SGwUBRCJrQj9IDE/ZbTi0cQbnm5W6KoGok2QkNI1RHAX4ARfCS9aQU+xReQLyonxAeFs0qSQOCXaUYEDUgkJKJkg8Owd3yBS34KHBE/UtdzAq5zU/FK04sPOE3IgYAZu4WDfFIqSdEx6zQV4jGpKw4uEwle9PEbHIThazf70kYpXITFwYcwWcynLUZPon7CbS2rxEhi3xTUu7pMNcJ8/oISZpgxJmyAF1v1HRILnhKtowB5TUA16AAE4GgCjHsF7CP8iMvRxSLy9SvXURpAu6F1DjMyV8m7HsS47VPLNwNMo11ZgoxzLz7QC7A1cChykfXaMQKIML9VSLGljmABVbdBYLYEfdKPxs7QHZgBz2cmksV51kR+DmVkJQ84NZnSNddhTjPYNUXM0BnPKNijP2NEAqKKWqzh6dskBUNGgOJcAcS2mS98qquJS6XuN6CHGbgZBNma3Z49TSsDnqoAACDH65huwRTSJDTFned5BLAEG7YVsh1ArSA2JcmROkOGM1A0YqSZR5MuVEmYhhgPLwWDtVSGIDt6VV1aFLXUD1bGOZh3atUwYqgJ5gEAYROUZC5y4eP9x2QrcLuR2xoCeLb+wY+OuwacE2pGTQmX/0Rq8BGuHsABAs/ssUAwYdssELSBVJNAD8ii+0SfqKGESbw0m17cCwWkKAucB/iiDdWplRALCGgXGUFkY448qLIA/VUHopALTBvxxqIvw1xsm7CuvPoNStbwCPk/nXnLNQwGZQKOATKWAIAENfD4EgdaEdGVik8n/vrEqeBHPpGQOL82Q9SDNEB0xqUkxxCFXxRcScwRX7fX0xdBHgRW0PEkoA75D0lHTKfTbipCKyiVbwSgnBA2oWBNkLdNfQFxYTPY/XJ4lSGBLjSxS+6NiFuD/wI+w0KHgsB4TOuIgXImuEkTGxdgMcIsP5uwYsd+bUoBUBtJAujAtbOVG+BXAVtREQ4VS2iKE74GeKc8E7QfYQXHL7H5OHqwBYxD0cbAbNGyESDkCw4pEC6zyAehTSUIQhy5X0XEVVrqnVp6jZUPfsSNGWqSEx9syjSa3iAwMCoYU0US9DBUd/BV5grPDCoUgb3VvxqZT7UtTbJZ0IAsQhMLwvrFYuBH13YAg0PekT3AS4omHuRbY7sjQvKTbncoDChR9FFncaM4riFspCX7GkZApz8RwRJVikxHBEpnpF+eMZ/aAZwPzGCB6I2uttNrolKhBAVxDEpFRB1PUZvo0BepoDLRkUdNeEF6x+MDukFQCn8sTKVCVY6jMOQS1SjLQxNlhWy2juSnlQFLyfVl+h3uaftLeEaoN2EIAtig0GKNiHakyFydZf5dixHID/B1HFt5624xVaFV3CgixZ5Gh6xKAgxr4SHQ6GOuIwLCFnlUF23eiJD34YSBA2qPMqe1B03LswMFW0Qty3CgjDBxSLsA91ziJ/SCcbAu1alAvF1L8VKHz6zneddCAQ0gYSX3hINuHcVsLHpvbHSFgjOSy253hBpT2VavgtA/7MS2dtd+naFdADKKOLDSGxk4HaRbmr6kHDo0iQThEvv1ekI6PYJVPPr9V6tX8Bh5e5BSpjm76UDyApsVduB3hUW4VwAFpo7kRlZZJfNkxpZPI6QIhxbMIoLimJR0lA/XLGRaFLjyxFcYkQwAJDastFvOwjpeTlmJouQ4Wp6FSO9IDduCGOrMkaL66iqeJnmx0VRdMjFtEWgTvm1zYX4GQpFA/wNsbBywW+o4yE7+cFafCeRBFCehCNlz49RnjOfPSSPh6+IY7WJIug84Ws+UiyRqCRE3aqC0BLgPikodrQKpKPG1Y02QA8rEfBw32EmZApd1SbRCgdX6dhsSsVB+tsvFY5qqTBZerBDjNByZNIfqd6sgbAJrtBI06Ww9ppbkszD948Yf0+Ebgh4P1LoHbEPZkPjkeLsSFe9Gzy3nw0rE8GmTiUUKeA11bFkjUgFEK4FURQpIyACV1JyOxS9qxk40L+FKI6mhoF+UOUZqDxfurittosGhrpXEZkgdVNg3JECzOel7cgpOAwCgfVZKoLxrVmbA6tuCOjRMC00iewG9TGvmp2X7lEp5y3dtZetTtmN53VByqW5DQRALBpKLcAEFATAgLmyGopOQhLA5f4NubdAXphWACwX2tMFmAM2ScsbCo8qWMhziyhR1au6Zn2o3ZBFRnd5TocMKzfQVXFVr04ZcsAftA5cHhjhzdbCWwBynmBiE11Np35zA9Sn5GMbChf04YbjvaLaaVDaC4hUEa8go2IS3i7OAP0/YpBg6qXAuM1OF6YCP/ZI/anfrz7hUXdQayB7c9D7C8mzUIqkDh/za+t8I2VXJ9xFh4DFqR5Rv7N3FMDpkHHAL6THSQ5zISQEkWXFgJIK/azbsiH4EjdQg6VbxH6hQIsTkT+uqj27oVSY4cDQI0kBbi5DNSj5InWJ+BU+JiidHrsjgpB+6ux5lhcIkzFZJqDY5VD2jfYs5wO2IFmcPlCbkHRQCadJVPc40UpV/R8HCJEdGJ47qbdNUPSgVucAdMDRola9GkvhCfVlw75BBvfChkRzIY0tzl64aaKDe22pfoenGWFTFvV1tmXWbq7AVTZI5iOmys1V8mZJAQih1CuMBA/cARl04mLHs06oMHwcg1FFS/XBgPgQfV+t2i+D8jhQ3Ortzf2h+SN+lbQZYVFksqW+g1xVPU32rSAexXDPpJJ5dHuYGHcHJkn4rf4GtKgcRySh5wrpIKbvcfQAkMAAdNji4qRKMUNNNxAHAn/IbhCM7ErzroIUYz1P+MH+pEwRLkk0rrCd0aAauCBuogYboaZg7QQHVJSErK1RgSqLr1aNQZzXUFdz9QUaZEJMhMBGwhVKH0HB6Mh3A7529SaPn6TvvbfndxFque6VIVYO8wAlYBZkoLSNAmoAALQXigVbCa+u/bvbg0M5VO/gJOJC2AWyTMAcTBPVA1R3mTiClBECEJFlwPxrg6AYdboYMIXsGfwEATnSPHBFqrbU3wJyFhFBlhMJAacleEOBAFx6TBaHo8Mhbl8oDYIZogJ8jsTtQSlGlUryAUZQo1DEgrcjOD/jVg8niNUusPpuj50Xoc34VLXqDDnBEmuTToNneLzrUDGKSJQJxQTehUqJy6jaQKgnuFOnji0mQmbdos5q/JREI4w6maueyyWoGdkoaROvUQrVeTUDCBDMkuSvF1MLubNzVBOCIsHCQnMsfmAjxDhxcBWJqMUVAUhsK9ZnWvusdDfXRUBu97iqB+MwbYljw1C+s4cBv5sWU1cYaYwJvQx/KSMZj1TiM0V+mHGpCZge2C9Y7xHdAOqGKPV4as6O16CDDgG1zQW/sJh5xzZ4HPp84OuxAoh53lWzeFgu3kNYAMTUZ+oq6hBCNXVwp6ONc8+JzjQQvw3aLR0cJPh0RdoWUQ8KnKOULZ0asjtMpSbCVY6Xt492G4TDU6IRieYTb/Gx7NfQoxqR+QSLDw0yOSOc77aP1vY/JwEeHsVW8oK34K1o0us9Uu7h0SQP2jATjd1l2AnYnNRhU7NRvbl2exEbf4wUpHbYRIBNUbaNxFRHaGEVHZ5BOYOOEEFENfyQvhQwFAOwaSXSG2wSAID2tI4+bf6eBGA0o9YreN+oLDVRxIityaeLGtFRjB9xXV42QmzPHOh9SjK2mOJG/uGopUAqXJMENJU4DaXO5dAe7LkEa25RGGi5utEIf+gaafk7XZPiYkXqfxBuWAQiDZI72EmXUH6iZumsTJ1p8iuhnYu0XB/zOcee1xdF90M219UtYEiPXhhEFMHtbU5ET7i46YiBBZVnhYVqAREHBovOP4pHYzrrqoG5B/E0ilMnwUNCrwYqbCblRCJErMCovi9pILEEgLdTANcVo4r3fHwZMBN+i1i1CtGJEikq9RMRNgYcjbxaLIzgYeXILu6GNyR3LxvG9Jna65JZlI/wNOzrW+ElFCyFMb9jpZIhspoB8hJV096MQ38DFGoKk9au7OMMAHxD7ncgSerInwOXFZkmkXTOCL2EZwS1/v5sHoNPFETTSJr6r2/xTkXcHDU4Mxq/6uBfJHaph4ewPngbueQxZ+9G3SGdBWM3NcSIwiOW8zgOND4kmFcr1alFm1Xp1ZlOgo7ykKMNKoc3OIgIS5rtivU0fCG+jmXIV52qgpMCAmjcxSjyZrKHjlekyUkuESUQwED2JDBuQ/vn5GE3yjEMhOI5RtT4CHUxOh1JJUnsxyHr+UFs0s4aeAEU1lN4UASvc14u5f7ph+iQMlj5G37Tc13IfXXGgA9PqtxOA4TfpNvtw9Yba0bJyYjjgAKiZc1+ta+K01BnjEAhoW7Tvg+bdMCvQTdd11gpvwDEFamZiKPqqj1U6mnW0W7Y2enobrIS1IV62sQClRReCfH5brOptNJ3YBJRTHEG70Wy9lYbWh21xy17mBAlmKAHqEmwIf53ANHmtxAxLUeBpIAHNxbpUDdb2jAzJ/lw+88iRzr8oo4cNTdKH69XodiPSx0/ZO+KZD/5eTLMx0EuCAFwj+WjeCGpFZ2YkQlrK89sgsDBA+N6OH/wt7tVouwxTYMRk+IUGOp7wHkNPr/dEhpScSKu57MHj/I19Pi367FYQKN6ozK8PCJAjbjlNYNQX/UNyk/R00u+gB+gr1JHekLt6b6QWsROQY3AxdG0+5L4nOvt1zxJhyrsLMkvFeUoJo4qtKRV0zlwIV6TzoiSu+4Ax49pVIAr/SPIcmNWgzS/2mFqj+goNmR0TsiDL2oMai7EYV68FIZamMdEtcHBOh2YaWAkqEGKElRTq6sn4sgz4QpptW8OvW1vbfvxXd6/KnvoXOnMI8W51YalZFcMniXtmyqvDjuyTg9EO/tU1wNllLUynW84NQJNriCjzjtzgsC+EKSi+p+jJr4JDtGp5/Kri9ZiWHIZRgLKlD0k7V9cUFRwkYo9oyjBeQqHWiLkrpp4iTr7eJqIwJ3TAKbVujRrNjbW/+BsCa6XdUD8T1z9oJMgUUv0t9eN3hiEcv4PR2uXo+kkn3RigR08kAxIyKVBdcpIja3DdOE/xZFE75BRjBFzyxaDoWUoaupKSNDceNLpLYkKJwYTh5/r0yNZrS3ibHM1j2RIplJrIOBTIg4Cik76TBp9umej7uIbbM0K9jXtAH9ajpAccPXXr8UhJiQSAi+X9LSptncptoaSIFwLqpDJYzgfAsRSmop6nVGcYcGXyO88d3GUI52XFh22EAMPqJAB50fRk1fO6ozSbp1c/uqROlUEQhvqGkjWYFoeK7fkwD6FAOGWFmozatoH6AYqxjtskCgpRRhCkD5sh+NMiHQcL7LVegFxwIaWNWu4FoupA/GSYynq/brmNLCLXWGgEEiEUDq1kv43RawHU03Gk++oh5yLygRsJLYJJiR5OL4DgTuHJ7xUg/vmM/YBB7v0D3losBqSbel0SYdaUHFpewfWdCIKmlWRwhTplYNvQcLzqBshIRr6gDRSplkYBRKiljT0lkAEzAaZKgTlcksHSGv/0/wUvNJFMeEGLQcHTW4JUQM1rPAA4ke3sRrKiEsXUqOHIhqgbxWdkIh8ij/KkzBMOg8kHO6ZTtcIhxFhQiuMr4kbun+tefk6ehkHNqcW1ErtdqrJlqjTyIxApoh1KhKZssxQx2SkplZ8lHrVKewckvaAPlKaWrWQP8A8/F/HVyHES0UJnENCq/mFGjOT2rQW91Cz4FAm7ywEEkgNU/HmdLtFlNys48LOmstKGjQZRaMiJFzvzkeDJNfMA6Fhdc5CbHWrcwmnM6H8DsyWjsSuFo9i/TWmWUGt1HyF/d9GcRJComPPeA3mpsYuxGmiznXMRHVRJw2DAXk4EPxFbjkd3Kq9snSI0yRZ3FVH96oKNF4CIVx3wmSUG4UQqY53iEkQKOsYHwKhVgos7s4fzfJohPlNS0ODSkW9eWiv7LSORIlgd2g0BS2V37rTHdLSqLQayGH7DWNDHIOPczdQymraj9qquu/RdeLECO3ZYQZb50c/ePOnpAcFTjGrbBFBCptaQWE4HTj6BgOoWZFHoVNjwKutPMEljVQhoUE3FfjbUj8aazAdEMEr1OGiMwxWnaBphDoIVL36FwAyjENzfR6ug3IrTZ2BrqaUOoBKo93NH9ME1E/usvrtGk0QjZtsnWoG7lJnjBCQRZawT8QhtxvhDRXUZn6fKgCKNZLD5nbv7LM3OT5fKoOmlEII31gMHF49hEakDlbcyP65CQwYAHytq5qDmEHUpOwliLtBY9XZu8chulw85XnvVmWuiofni6MyxndQD8YIiiPVPbUgkQ15gg7CFgMGHzNoiu+ImpdfB/gI12bU7HWX1V+ePevPW0uTVPtOnMJqNFe4RTFB4wUMQSKFxZDbA/6hxgjIEnQgnxIbX5ZaRXWNy6pFkrOqUchkcoBPsIuhuSbNsd75kSj5n9fFAvPbtnRq3rxEGHJKmUk90+A8FiIl4g9y8w0qhaVgBUCazmxAPKOT8NsWuq2a2aHpJJNaRTpkFJaxMCqFJnp7c9RsTH7B78RXlpqoTzcnXmckAHmvv70hpw/K2z0l8zCgSOhXajeUD/6jplK4ARGnGpr9Uucatfn2AMW/i8GKoFNUZQdTcMRwJz99QdUAHFVjQhXiD6k7V/dP6YXUytLcqA6yvBdP+8GoeysA5lFVv3SWvu+8k9dQAIwZ/EbT3mgkYMCvsKpsp0Y1G30xkjRpPHHn1FRUVSeQqhTz1GDNdfe4BMiU+xd3+aio8MfbIjnodQxOlOmUXcMJ07u70vMaaU3+GyAHuiJM44vCFhC9exRFYAuILk07oS3f3Ma4YzQSJNRZCIhat41lqs1LXaNaUfvzPYDTMfof7qSCeXygOWA/ZVBE0AOzggiAocYtvsjdrEboxUaahZioQnmXALWiGhrRJRP+gJxcQ73gAYojtZxG9g63SHFqICWgRhVypZiTJWCF4VtNA5Jsu6Lxqzug8I/5BChWosRwva6xa3cQeFuS2Kg/7POPFAc4SGKKjfsQJyx0PTZZ+gf1SBJUjS5ZQAajEq4i8qLHqrlV24cktBbJkKqGpUMSVdZJbAACvEUp0CiNRhl0hiYS4CIpUyjBRC2sltoOU0OfssSjc0QqilyrMc2qhiDaQ1LF1fOdpQl3vV6Kt5sw9AzGMZrEUq3V9Mche25De0H/WfXc0HlAxyYxh1asRhB0mkwxabNi5e52nNebJsz2ndphuqEpZg82grVeeax2GTzvwrvOxnNVh4DAffJQHVkoHNk9TdK4pE44oppdXR108gQWOVBbxF7448Qxj2TVtoeOOdyqfj0cSUPj5j5iIZED78SjOpDjXY1QTQtZROpXiN/SLAuBDYWIFf7UYUwDKD0taBiWHVzwP2VC8SaieFTnYtWBQwqAIJqKz+r0Gl5XvnY9SUWR543O2x0k66hEj4QIVo9q6GiJyjRQ/MhiVPU70T9qdXEjpxG5qW6QWmU9QloWSRDU/PRBpxByDFUA+jIiYj/hAw25YD4YuIaOxaopZ6yn6EQdZvrP16EXZuZP1LxJgo0ePZrpfAdPwWpeyvroqJ0KjY3+1KQ8dQuxQ1gS5g2R2A3QiYaqeB75rrazVQtD/aqlhwj0NMU99ZwabNHJ6Z1AWZS3ILIMA9LY5Y7wI7Wtwz0Te+L7SIShib7DpzuEQTxjbSTJ6HrCgEjYST2F2AA+Hb9TaamIUFP4VKt8BAAGSmEbRX1MpNEdoiTS7pli0dMPfDhsq5GdpS5C9rrL0mTd7alNnSsSuXtSyIGRCdkrFraRCUUEAKADqoryd8JkarZfj/EhUIlVkNxwz6ZJfxJCHSu0AxVbklWZG50em6yaVLtPe5H9Kpz+nql1iQwbY9bZi9eh+J08yVAE4mtlqjYRgvJrzelhn/cAZp0NWqURwR0DlYu8glWo2e++49Uc3pSKVrHlYJ0kYNYDf6KoB03ya0Sbe/ivjTGP2mg3aSsO0/l3P6ZcGU7+7KlfnFSxgTuuCJErNUxYNhwEpxDTerQCwK/vYP98B/t1eaPeMKo1eHexg5SFY4uNRzujpuHJzXfaxdrOOy69nbx7BqSBpQixRR0BWNVB1zWdmffU+DjbIt63d4hBiFJMQSsiVIf6niCW1pZBdThT9T6oWdSgx0N9V+T/cjOBfCBxXWrbYXZHyhe14ASpavtJMuvcXf08xGKcFT1SO7BvYIio3tC81WieRskCNKyoBQzTzuiHdeexmp4u+Wo78Kf5rB++jYiG+cPOyUKgB6J+pzk04BTGVInRCVeCYS5MvxSCej4XrgDqo40EqoT0O0+KxrZyI8G6b8wFsgz6nzuussThNBhJwBS8mOcdAhZZmzovFpF9g95oETHZ9DFZeDqFPLiq7pSOdRvp4SpZrI59EkFJakZpGGI6nciOQcbDa6uBMyFRt3Cwv05xfdMOhKeea5iqhRRxsr1qbm8RfEuP99yQ2IOt3faVQQdBYprzYqAQ2lUBVG4E4afMRk24Ug3gWorQ89S4CJVSBoahCScUPJitKbqv9/pz9qbZIj2Gw8LvhKzeSTp4EfiGFuOSsMya11P7WnvazeixOjAd9UfVipRxElZd4/S6xpolfKNyapxp148OagIaalZxSKfEEZBnfGSmsXaPfIXxIMZhMd8QvgjuO3XxV1tSr8WyDoV8oeUVpeRbMRhxaH4ig4PqPismNTatp3t2YJNQwJkRD3pgx4s+9w7g6xkMFFDWgWkXkpoqSSYbbp27K3guAf/mVH6IJ8HqUiB9NgU33Ee2RGarWmSy7YCxedUO0rxSNSjWJEcRyVGrMOlQWTM6TY22vVn64T3CZvd0PMqVSoEwoGxBa/SUw35xPUJ65NdWtWXf/PN+GLg1CjzinQVUf2irYXePBF9IGFFWcS09HtFL6kMOduS1F9EjljP6lGvkpcnm9eKvpDS2nkUQrU45e6rImoAChZ0QtRF+QRmJFaQFvQp1Q+10v8Qt1KxMrOCdryufq685FlXT2CERlC89PpR0vlk6RbX/NumPvId46tGcouGc8T3/FC6XjDqyuNOb5LMhC6N6xJrge8+lXaGvo0+2Bq2HouuxAAcaEzawPxVOPS7j9RwpLkKYcnvTNdYRwhUmCsx7x3E0FZRugHjky6Gy4TaP2NHA791cedOcUyVgljcyXAWbRJgHbKnfq3zPGogG41+kTNNRyqKEdv2/DI4OPBO1qTU9czZhQJIQDp4dpcEa4ivWkd5DIOrwrZK9nha9DTGAFQ6rgVmdx6vnJpkjvYIxihGrU1wHuTJA5YhVKHVNNVg2vM43cJmRRRY/62lhdPkdD9XEaGu5fPT4Pguis+SoByuJWls+0fdephppPAMFSQqMpmbAbWRo4kEPjzW1uLW1rWuRl3qMQlPy1NDwEOo+vabz5mT1f1jIamXyUZ3O4Qk9ihTDCnekFVbbNOrXLjtUwuPne95SVB68D+9JOFDL6X+UEcHRiYnL3fBRgfnO7wyXfk+irZ8n0USsRKOcZkEtcYTioOjpfEIbJQ4avE88DUDXaR4hWIYBLKmiGoD1sIjkc4UtVTZOHXrDTR5aFdVtoLiVELLKNeDq9PDZmlRcsGAWAz+HKQWdfa8YO9LlziTDKCnVqq4sAD5QMJMj2JKOe+4DMlnPIGsmbcGRwSMlDQxLTJSFHdKkE+qsLqhR46J+MwNB7yd8dlhufh9i9V8/p0WDfLMa5gWENWwdvvYu19NYw3vamYqvo194AOZAE/I7MH6nB5kJZl3UNaNHCeb9XwTA2ShCvrny3K/BpKgBX80GBOf1KM17ZPatRzqVFX1rNXfAVEcmabxlwGYQG+H9pfr4I1Lv0hXKRPF/A3ZCPvKRoUKqAAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV9TS0UqDhYUcchQnSz4UcRRq1CECqFWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIk6OToouU+L+m0CLGg+N+vLv3uHsHCPUy06yucUDTbTOViIuZ7KoYfEUIAwgghgmZWcacJCXhOb7u4ePrXZRneZ/7c/SqOYsBPpF4lhmmTbxBPL1pG5z3icOsKKvE58RjJl2Q+JHristvnAtNFnhm2Eyn5onDxGKhg5UOZkVTI44RR1RNp3wh47LKeYuzVq6y1j35C0M5fWWZ6zSHkcAiliBBhIIqSijDRpRWnRQLKdqPe/iHmn6JXAq5SmDkWEAFGuSmH/wPfndr5acm3aRQHAi8OM7HCBDcBRo1x/k+dpzGCeB/Bq70tr9SB2Y+Sa+1tcgR0LcNXFy3NWUPuNwBBp8M2ZSbkp+mkM8D72f0TVmg/xboWXN7a+3j9AFIU1fJG+DgEBgtUPa6x7u7O3v790yrvx/KXnLKBL63RQAAD4tpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOmlwdGNFeHQ9Imh0dHA6Ly9pcHRjLm9yZy9zdGQvSXB0YzR4bXBFeHQvMjAwOC0wMi0yOS8iCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpwbHVzPSJodHRwOi8vbnMudXNlcGx1cy5vcmcvbGRmL3htcC8xLjAvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDpkMGMzNzExYi0xMjE5LTRlOWUtOWNjOS1hZmE0OGIzOGJlNTkiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjlkY2EzYTUtYTI4YS00NTcxLTg5YWUtMWYyNjhkMDMxMjcyIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZmE4OWMxNGEtM2IyYi00YTc5LWIwNzktZWIzMDY3MDcyMjM1IgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2MDg3MDI4Nzg5Nzk5NDgiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4yMiIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIj4KICAgPGlwdGNFeHQ6TG9jYXRpb25DcmVhdGVkPgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6TG9jYXRpb25DcmVhdGVkPgogICA8aXB0Y0V4dDpMb2NhdGlvblNob3duPgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6TG9jYXRpb25TaG93bj4KICAgPGlwdGNFeHQ6QXJ0d29ya09yT2JqZWN0PgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6QXJ0d29ya09yT2JqZWN0PgogICA8aXB0Y0V4dDpSZWdpc3RyeUlkPgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6UmVnaXN0cnlJZD4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NjE2ZmQ4NTAtZWZmZS00YzVjLWFjNjUtOGUzMmIyZTU5MzZhIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKExpbnV4KSIKICAgICAgc3RFdnQ6d2hlbj0iKzA1OjMwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICAgPHBsdXM6SW1hZ2VTdXBwbGllcj4KICAgIDxyZGY6U2VxLz4KICAgPC9wbHVzOkltYWdlU3VwcGxpZXI+CiAgIDxwbHVzOkltYWdlQ3JlYXRvcj4KICAgIDxyZGY6U2VxLz4KICAgPC9wbHVzOkltYWdlQ3JlYXRvcj4KICAgPHBsdXM6Q29weXJpZ2h0T3duZXI+CiAgICA8cmRmOlNlcS8+CiAgIDwvcGx1czpDb3B5cmlnaHRPd25lcj4KICAgPHBsdXM6TGljZW5zb3I+CiAgICA8cmRmOlNlcS8+CiAgIDwvcGx1czpMaWNlbnNvcj4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pr9k1dcAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkDBcFNiYU5adwAAADSUlEQVQozz3Tz28UVQDA8fdrZnbezszudju17dLSlhQVYk2UiCEYRTwYExVjwMiBg/4DRj1JuHDngBquEkI4eNAYI42SGGuxpWiUbVI2VVvKtmy3+6t9s/Pe7s6+Hx5IvH9vn3whY8z3fSllHMeO47iuKzqi2hRCWQYYAuSgh8N81hgQRRHG2PO8JEmEEFAIgRAyxmitDYDFMr+7EYeBHWYcC8NI9Lea3bxLThwOfAdDCBFCWmtjDLIsi3OulNSIXL29syfR9Gj66fHg5xL7fK5KHWt61CsMeTeWWmu1HiZYCKG1ppSiJEnS6bQG+Ku5R0cP5rcaohnJuZXmrc24LNSX89vUsW/crR5/KvfDveZqeY9SijHmnEPGmO97t4p1y7Xv/MMm8tYzk9md3Z5S2gCAMM6lrbZI5pcbhyaDe3+3Lpx5EmgphCCpVGqXxSvV7kgOfPNvnCnjd4S+urzr28iCQChz2CcBNJeW915fb39wcuS34vaLhwZ830cIoc16ZyJ0F9fZ+WP5iycHZ0ZSoYOvvD32fGifPxaK3e6pIwPX3hj+sS4JwssbkTEGY4yEEImxsj4pZOwwY3/7V2ur2T03k4MYn30hHHDJWN4aDOzF1eh0gSCCACGEEMYYghAao40GUVcDAAwAjgX7UsW8/7DSHh+ls2vi0nebn747xRMjlQEAAgAghIhS6hLVakul9NpO982ZfMohlxebpc3o4s3tclW8NknfOx4ulVo3a9LCAGsppQyCAEkp9w/Rjbo4OpW5/Efzi4V6rS1Zu3f9TmPYJx9//aAj9fxqfPb7yvsTruio5w5kIYRSyscq/u1SPeqjh43OgG9PDdNKoyNEXxtt2bgQem2RlB7sTY8Fv99vXjhzUCvJOYdCCAih0ub6Qu1AwSuuM6iBVPqzX+vGgBN5+6O39l+ZLX9yauKXP2vnXhral3cBAAAAKKWMosi2bWTZ137asDw3l7GeyNHZhcqjVuf0K/ukNkbppZXWh6+OjoU0jmPbttPpNOScE0K01kopAOFahc8WGYBgKOsgZNpdtdPqHRmnLz8bEqgQQv/HkDEWBEG/3398GaWUc87ibqIwJkQlXT+NctksMIAxRgjxfb/X6wkh/gN7w80+G4fwvgAAAABJRU5ErkJggg==\",\n            \"type\": \"image/png\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\"\n        },\n        \"$:/ipfs/core/icons/ens\": {\n            \"title\": \"$:/ipfs/core/icons/ens\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAYAAAAmlE46AAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSotUHCwo4pChOlkQFemoVShChVArtOpgcv2EJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OTopukiJ/0sKLWI8OO7Hu3uPu3eA0Kwy1QxMAKpmGelkQszmVsXgK8IYRABxhGRm6nOSlILn+LqHj693MZ7lfe7P0ZcvmAzwicSzTDcs4g3imU1L57xPHGFlOU98Tjxu0AWJH7muuPzGueSwwDMjRiY9TxwhFktdrHQxKxsq8TRxNK9qlC9kXc5z3uKsVuusfU/+wnBBW1nmOs0RJLGIJUgQoaCOCqqwEKNVI8VEmvYTHv5hxy+RSyFXBYwcC6hBhez4wf/gd7dmcWrSTQongJ4X2/4YBYK7QKth29/Htt06AfzPwJXW8deaQPyT9EZHix4B/dvAxXVHU/aAyx1g6EmXDdmR/DSFYhF4P6NvygEDt0Dvmttbex+nD0CGukrdAAeHwFiJstc93h3q7u3fM+3+fgBr1HKk47w5KwAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+QMFwUEGU/z3jwAAAJZSURBVCjPhZNLSFVRFIbXXmfvs8+9evV6b6URQk0iCg16IESjwkQiDQkbRRPDZ1SGaRRBEWG3wkKNMIpolgMjzMpyEFGBJJFFg2jQg0pLTe/Dc84+j70bKXJ99M0WrG/BWvyLwALcaBeFnivXSKVMzrWx6gb+Lr2HzC1il1MYDvFailgzNWUX2bbv5uYF+32pHkwmzPbmpmw5T2zrsFZkBvQuqmGZEO6+mmq9BwCg87ooCATZG1+qAdMWVUfqgqMAAAgA0HI+tVwiH1QUywXIgfF48v7MwPo6/kFIGQOGu40M4237LWfbrJh09YoJk6yetJVjut6x0yeiau4KcdNqdUB9kpSsRE57r9y28jF2R5SMmSpjJAkwmvA7Gw/xj+mHaGkImbb0DjsI0tdIBDlrRtC1CzxgDY1b1s+JlHUOFuH4Qf2ZC7LbQwBfI6XoM1K4bkPmdiDJkrtns6ZgCWzPaXI0lXQ1yEehgfJ0bNm4OSsB/+HF5z9ZNpGtggJBh8IPQUnIN/TYUlL51d/haUafvv8y8tJBNYyCwmObAQgd9zf2OcWLmjmhMzTCV40qudUl3in0iHvRouqvyYBYnHYcfZQKpju1T8R6I2rUG9EAZESM1KUyox+vlRrffeLvsaj6ldLJ2njQODlXquoziRmgbTRE9GAO+xYJaT2zAejayV4zJTY5VPYmDGw68MoumBGnw9reJCfFPpMPo7pXdK9y2di8kFc9T2AiwOpdVBV5jrnLRsomKR9kEm7mTIuOrh1hueB3zFA5FC/UlZ8rAYIe0b52b8keTu/5B84rA4ufLFw3AAAAAElFTkSuQmCC\",\n            \"type\": \"image/png\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\"\n        },\n        \"$:/ipfs/core/icons/github\": {\n            \"title\": \"$:/ipfs/core/icons/github\",\n            \"text\": \"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bnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICB4bWxuczpwbHVzPSJodHRwOi8vbnMudXNlcGx1cy5vcmcvbGRmL3htcC8xLjAvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTUxNzhBMkI5OUEwMTFFMjlBMTVCQzEwNDZBODkwNEQiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTJhYTcxMTItZTYyZS00MTU1LTk2OWEtNGFmMGI4NjkyNzAwIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ODdkNTAxYTktNjM1NC00NDEzLWFhZGEtOGEwNzlmN2IzNDZiIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2MDg2OTk5MDAyMzIxMTkiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4yMiIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIj4KICAgPGlwdGNFeHQ6TG9jYXRpb25DcmVhdGVkPgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6TG9jYXRpb25DcmVhdGVkPgogICA8aXB0Y0V4dDpMb2NhdGlvblNob3duPgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6TG9jYXRpb25TaG93bj4KICAgPGlwdGNFeHQ6QXJ0d29ya09yT2JqZWN0PgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6QXJ0d29ya09yT2JqZWN0PgogICA8aXB0Y0V4dDpSZWdpc3RyeUlkPgogICAgPHJkZjpCYWcvPgogICA8L2lwdGNFeHQ6UmVnaXN0cnlJZD4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OTAzNjc1ZjUtMGE3OC00ZWIzLTgyMDgtNjcwYmEzZjliMTQyIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKExpbnV4KSIKICAgICAgc3RFdnQ6d2hlbj0iKzA1OjMwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICAgPHhtcE1NOkRlcml2ZWRGcm9tCiAgICBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTI5OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIgogICAgc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFNTE3OEEyODk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCIvPgogICA8cGx1czpJbWFnZVN1cHBsaWVyPgogICAgPHJkZjpTZXEvPgogICA8L3BsdXM6SW1hZ2VTdXBwbGllcj4KICAgPHBsdXM6SW1hZ2VDcmVhdG9yPgogICAgPHJkZjpTZXEvPgogICA8L3BsdXM6SW1hZ2VDcmVhdG9yPgogICA8cGx1czpDb3B5cmlnaHRPd25lcj4KICAgIDxyZGY6U2VxLz4KICAgPC9wbHVzOkNvcHlyaWdodE93bmVyPgogICA8cGx1czpMaWNlbnNvcj4KICAgIDxyZGY6U2VxLz4KICAgPC9wbHVzOkxpY2Vuc29yPgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+2/JmKwAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+QMFwUFADKDR70AAAGrSURBVDjLjdM7axRxFAXw30w2JCGbSma2CloIYmmhqIVIvoClYpPOzyAIphMtbBRBCBJtBMHCBwTFFGqjEoliZ+MaIuLMiI+QjcGQXZs7MoWPnGb4c8859zmJBjpZPoyDmMZR7IzQMh7jBp4XVblZa5KGOMN5nMSoP2MDN3G6qMrqt0Eny3PcwpEgpn8x6Mf3KY4XVVkORdmXcAwvcRE7MIEP+IoW3jRih5G1x8fnW/E4EdW8xmXMRhu9yDge5W9gLw6E5norBjaKAdYxKKqy1xDXvetkeVpzQjOddLK8i134gX1FVb71D3SyfA9eYQzvU0xG7BtW/B8rwYXJNMqBNka2YTASXBik6MZjDFPbMJgKLnRbWMDu2PG5TpZ/wiI2i6ocRN8JhrE/jq0VBgsp5rAWZ7qIh5iPk65xCA/wKJKJLc21sIRrOBUr/Ywc7xoGH8NwrHGRs1hKi6rcwkxkPotnuIovDYPVxrD7uIuZoiq3UiiqcjWy38cV3GlMusYA33EB06ExVEd7672fE+32E9zDcpIkL9Z6vS2YaLf78U+cSZLkdlGVG7XuF/dEiMn/tBr8AAAAAElFTkSuQmCC\",\n            \"type\": \"image/png\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\"\n        },\n        \"$:/ipfs/core/icons/ipfs\": {\n            \"title\": \"$:/ipfs/core/icons/ipfs\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAYAAAAmlE46AAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSotUHCwo4pChOlkQFemoVShChVArtOpgcv2EJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OTopukiJ/0sKLWI8OO7Hu3uPu3eA0Kwy1QxMAKpmGelkQszmVsXgK8IYRABxhGRm6nOSlILn+LqHj693MZ7lfe7P0ZcvmAzwicSzTDcs4g3imU1L57xPHGFlOU98Tjxu0AWJH7muuPzGueSwwDMjRiY9TxwhFktdrHQxKxsq8TRxNK9qlC9kXc5z3uKsVuusfU/+wnBBW1nmOs0RJLGIJUgQoaCOCqqwEKNVI8VEmvYTHv5hxy+RSyFXBYwcC6hBhez4wf/gd7dmcWrSTQongJ4X2/4YBYK7QKth29/Htt06AfzPwJXW8deaQPyT9EZHix4B/dvAxXVHU/aAyx1g6EmXDdmR/DSFYhF4P6NvygEDt0Dvmttbex+nD0CGukrdAAeHwFiJstc93h3q7u3fM+3+fgBr1HKk47w5KwAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+QMFwUDBo26RQ4AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAB/UlEQVQoz42TS2sTURiGn3PLdDK5dKat9YYoLoqu3Im6cNeFy/6AgkEsiAvpDyhS3ClFJCuRLor4E1wE+yMqQsWF9dKmTWOaqeklmcyZcSEVm47guzy8zzkv7/cdQYYmF5euAc+BBHhUq0y/H/SIAeAUMO+4+XvlYEQB7O60bO/w4CXwuFaZ3j4GTi4u5YCH2pi5YPx0uVj2EeL3nWma0gnbtBpbbRv354FqrTIdi8nFpTtCyIXh0dEJf2wcKWVWehJraTe3CVvN1SRJZmVv7+C1MWaiOBz8EwKQSlH0fYzjXEli+0YKITHG5evHVZr1Day1JyBrLc36BvW1z5T9UZQ2aCEE+UIB1/PohG3WWh8YO3cek8sB0I967DQaFMs+Zy9eRgiBEAL9pyUhKPkBNi7xY71ObCOEkuTzBc5cuITS+nj0wVhKawqlMtFBl9QmlIKRExCAzipiyPMo+QFOIY/rFbLLStOUNE3Jellrc+L8yC9tHLP/c5f/VSdsY+M+MkmSqZ3G1krY3CbJGMXfC9BqbNLaqq8AU+p77e2XsRu3X1kbb+53dq9LpTzjOETdLjqXw3FdOmGbxvq35uH+3qxUcubd/btrx5b85tMXgVRqzhlyH+icMY6Xpx9Fvah7WAWeLM9UwszfcaRbz6pXhRQLjufGwOzyTOXToOcXpMLGTLGqOcgAAAAASUVORK5CYII=\",\n            \"type\": \"image/png\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\"\n        },\n        \"$_ipfs_core_images_bluelight\": {\n            \"title\": \"$_ipfs_core_images_bluelight\",\n            \"_canonical_uri\": \"ipfs://bafybeihf7g4g6hwl455uhuzsxqdc7ljmrfiiomdaqbluzqkxtji56mkj6u/$_ipfs_core_images_bluelight.png\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeihf7g4g6hwl455uhuzsxqdc7ljmrfiiomdaqbluzqkxtji56mkj6u/$_ipfs_core_images_bluelight.png\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isIpfs\",\n            \"type\": \"image/png\"\n        },\n        \"$:/ipfs/core/images/ens\": {\n            \"title\": \"$:/ipfs/core/images/ens\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/ensdomains/ens-app/dev/LICENSE\",\n            \"_project_uri\": \"https://github.com/ensdomains/ens-app/\",\n            \"_source_uri\": \"https://github.com/ensdomains/ens-app/blob/dev/public/safari-pinned-tab.svg\",\n            \"text\": \"<svg\\n   xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n   xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n   xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:sodipodi=\\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\\"\\n   xmlns:inkscape=\\\"http://www.inkscape.org/namespaces/inkscape\\\"\\n   version=\\\"1.0\\\"\\n   width=\\\"18\\\"\\n   height=\\\"18\\\"\\n   viewBox=\\\"0 0 128 128\\\"\\n   class=\\\"tc-image-button\\\"\\n   preserveAspectRatio=\\\"xMidYMid meet\\\"\\n   id=\\\"svg14\\\"\\n   sodipodi:docname=\\\"ens-small.svg\\\"\\n   inkscape:version=\\\"0.92.4 (5da689c313, 2019-01-14)\\\"\\n>\\n  <defs\\n     id=\\\"defs18\\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\\"#ffffff\\\"\\n     bordercolor=\\\"#666666\\\"\\n     borderopacity=\\\"1\\\"\\n     objecttolerance=\\\"10\\\"\\n     gridtolerance=\\\"10\\\"\\n     guidetolerance=\\\"10\\\"\\n     inkscape:pageopacity=\\\"0\\\"\\n     inkscape:pageshadow=\\\"2\\\"\\n     inkscape:window-width=\\\"1920\\\"\\n     inkscape:window-height=\\\"1020\\\"\\n     id=\\\"namedview16\\\"\\n     showgrid=\\\"false\\\"\\n     inkscape:zoom=\\\"12.361274\\\"\\n     inkscape:cx=\\\"41.295086\\\"\\n     inkscape:cy=\\\"21.734019\\\"\\n     inkscape:window-x=\\\"0\\\"\\n     inkscape:window-y=\\\"31\\\"\\n     inkscape:window-maximized=\\\"1\\\"\\n     inkscape:current-layer=\\\"svg14\\\" />\\n  <metadata\\n     id=\\\"metadata2\\\">\\nCreated by potrace 1.11, written by Peter Selinger 2001-2013\\n<rdf:RDF>\\n  <cc:Work\\n     rdf:about=\\\"\\\">\\n    <dc:format>image/svg+xml</dc:format>\\n    <dc:type\\n       rdf:resource=\\\"http://purl.org/dc/dcmitype/StillImage\\\" />\\n    <dc:title></dc:title>\\n  </cc:Work>\\n</rdf:RDF>\\n</metadata>\\n  <g\\n     transform=\\\"matrix(0.08837363,0,0,-0.07925696,-8.0787259,127.6037)\\\"\\n     id=\\\"g12\\\"\\n     style=\\\"fill:#000000;stroke:none\\\">\\n    <path\\n       d=\\\"m 640,1519 c -69,-48 -173,-122 -231,-163 -94,-65 -110,-82 -134,-129 -30,-63 -37,-155 -15,-222 15,-49 61,-135 71,-135 6,0 437,704 447,731 7,19 -17,4 -138,-82 z\\\"\\n       id=\\\"path4\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"m 856,1598 c 4,-7 44,-67 89,-133 118,-175 286,-437 393,-615 93,-154 122,-224 125,-300 2,-55 17,-35 52,75 26,80 28,92 22,217 -7,185 -45,284 -149,387 -35,36 -520,381 -534,381 -3,0 -2,-6 2,-12 z\\\"\\n       id=\\\"path6\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"M 141,1068 C 97,969 87,913 93,776 98,649 106,607 146,523 163,485 224,403 254,378 291,346 772,9 776,12 c 2,2 -57,95 -131,206 -132,199 -320,496 -404,639 -48,81 -70,145 -73,210 -1,23 -3,43 -4,43 -2,0 -12,-19 -23,-42 z\\\"\\n       id=\\\"path8\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"M 1079,398 C 962,204 859,34 851,20 l -16,-25 30,21 c 306,211 436,304 461,331 51,53 72,165 49,254 -14,51 -63,149 -76,149 -4,0 -103,-159 -220,-352 z\\\"\\n       id=\\\"path10\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n  </g>\\n</svg>\"\n        },\n        \"$:/ipfs/core/images/ethereum\": {\n            \"title\": \"$:/ipfs/core/images/ethereum\",\n            \"tags\": \"$:/tags/Image [[Font Awesome 5]] Brands $:/ipfs/core $:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"caption\": \"ethereum (Brands)\",\n            \"_license_uri\": \"https://creativecommons.org/licenses/by/4.0\",\n            \"_project_uri\": \"https://fontawesome.com/\",\n            \"_source_uri\": \"http://fa5-free-svg.tiddlyspot.com/#%24%3A%2Fimages%2Ffa5%2Fbrands%2Fethereum\",\n            \"text\": \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"tc-image-button\\\" width=\\\"22pt\\\" height=\\\"22pt\\\" viewBox=\\\"0 0 320 512\\\">\\n  <path d=\\\"M311.9 260.8L160 353.6 8 260.8 160 0l151.9 260.8zM160 383.4L8 290.6 160 512l152-221.4-152 92.8z\\\"/>\\n</svg>\"\n        },\n        \"$:/ipfs/core/images/ice\": {\n            \"title\": \"$:/ipfs/core/images/ice\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $$:/isAttachment $:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/ipfs-inactive/logo/master/LICENSE\",\n            \"_project_uri\": \"https://github.com/ipfs-inactive/logo/\",\n            \"_source_uri\": \"https://github.com/ipfs-inactive/logo/blob/master/vector/ipfs-logo-vector-ice-text.svg\",\n            \"text\": \"<svg\\n  xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n  style=\\\"enable-background:new\\\"\\n  xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n  height=\\\"512\\\"\\n  width=\\\"512\\\"\\n  version=\\\"1.1\\\"\\n  xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n  xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n  viewBox=\\\"0 0 512 512\\\"\\n>\\n  <defs>\\n    <linearGradient id=\\\"c\\\" y2=\\\"771.51\\\" gradientUnits=\\\"userSpaceOnUse\\\" y1=\\\"771.51\\\" x2=\\\"527.72\\\" x1=\\\"84.315\\\">\\n      <stop stop-color=\\\"#4a9ea1\\\" offset=\\\"0\\\"/>\\n    </linearGradient>\\n    <linearGradient id=\\\"d\\\" y2=\\\"771.48\\\" gradientUnits=\\\"userSpaceOnUse\\\" y1=\\\"771.48\\\" x2=\\\"512.36\\\" x1=\\\"99.675\\\">\\n      <stop stop-color=\\\"#63d3d7\\\" offset=\\\"0\\\"/>\\n    </linearGradient>\\n  </defs>\\n  <g>\\n    <g style=\\\"enable-background:new\\\" transform=\\\"translate(-50.017,-515.51)\\\">\\n      <path fill=\\\"url(#c)\\\" d=\\\"m84.315 899.51 221.7 128 221.7-128v-256l-221.7-127.99-221.7 128z\\\"/>\\n      <path fill=\\\"url(#d)\\\" d=\\\"m283.13 546.35-160.74 92.806c0.32126 2.8543 0.32125 5.7352 0 8.5894l160.75 92.806c13.554-10.001 32.043-10.001 45.597 0l160.75-92.807c-0.32126-2.8543-0.32293-5.7338-0.001-8.588l-160.74-92.806c-13.554 10.001-32.044 10.001-45.599 0zm221.79 127.03-160.92 93.84c1.884 16.739-7.3611 32.751-22.799 39.489l0.18062 184.58c2.6325 1.1489 5.1267 2.5886 7.438 4.294l160.75-92.805c-1.884-16.739 7.3611-32.752 22.799-39.49v-185.61c-2.6325-1.1489-5.1281-2.5886-7.4394-4.294zm-397.81 1.0315c-2.3112 1.7054-4.8054 3.1465-7.438 4.2954v185.61c15.438 6.7378 24.683 22.75 22.799 39.489l160.74 92.806c2.3112-1.7054 4.8069-3.1465 7.4394-4.2954v-185.61c-15.438-6.7378-24.683-22.75-22.799-39.489l-160.74-92.81z\\\"/>\\n    </g>\\n    <g style=\\\"enable-background:new\\\" transform=\\\"translate(0,-196.66)\\\">\\n      <path fill-opacity=\\\".25098\\\" d=\\\"m256 708.66 221.7-128v-256l-221.7 128v256z\\\"/>\\n      <path fill-opacity=\\\".039216\\\" d=\\\"m256 708.66v-256l-221.7-128v256l221.7 128z\\\"/>\\n      <path fill-opacity=\\\".13018\\\" d=\\\"m34.298 324.66 221.7 128 221.7-128-221.7-128-221.7 128z\\\"/>\\n    </g>\\n  </g>\\n  <g style=\\\"enable-background:new\\\" fill=\\\"#fff\\\">\\n    <path d=\\\"m103.09 186h-29.2v141.2h29.2v-141.2z\\\"/>\\n    <path d=\\\"m153.97 327.2v-51.8c7.2 0.6 14.4 0.6 20.4 0.6 41.6 0 53.6-20.6 53.6-46 0-30.8-22-44-56-44h-47.2v141.2h29.2zm15.8-71.8c-5.4 0-13.4 0-15.8-0.2v-48h18.2c17.6 0 27.6 8.4 27.6 23.8v0.4c0 12-4.4 24-30 24z\\\"/>\\n    <path d=\\\"m327.95 186h-88.6v141.2h29.2v-62.2h55.4v-21.2h-55.6v-36.4h57.6l2-21.4z\\\"/>\\n    <path d=\\\"m423.51 213.6 7.6-19.6c-11.4-8.2-26.8-11.2-46.2-11.2-28.2 0-51.4 13.2-51.4 40.2 0 24.2 17.8 33.8 35.6 39.6l17.8 6c12.2 4.2 22.2 8.2 22.2 21.4 0 12-10.4 16.8-26.2 16.8-16 0-33.2-4.8-43-11l-7.6 21.2c12.8 8.2 29 12.2 50.8 12.2 31 0 55-13.6 55-42.6 0-27-20.6-35.6-41.4-42.6l-19.4-6.4c-8.4-2.8-14.8-6.6-14.8-17.4 0-11 9-15.4 22.4-15.4 16.4 0 29.2 3 38.6 8.8z\\\"/>\\n  </g>\\n</svg>\"\n        },\n        \"$:/ipfs/core/images/ipfs\": {\n            \"title\": \"$:/ipfs/core/images/ipfs\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/ipfs-inactive/logo/master/LICENSE\",\n            \"_project_uri\": \"https://github.com/ipfs-inactive/logo/\",\n            \"_source_uri\": \"https://github.com/ipfs-inactive/logo/blob/master/vector/ipfs-logo-vector-black.svg\",\n            \"text\": \"<svg\\n   xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n   xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n   xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:sodipodi=\\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\\"\\n   xmlns:inkscape=\\\"http://www.inkscape.org/namespaces/inkscape\\\"\\n   style=\\\"enable-background:new\\\"\\n   height=\\\"22\\\"\\n   width=\\\"22\\\"\\n   version=\\\"1.1\\\"\\n   viewBox=\\\"0 0 128 128\\\"\\n   class=\\\"tc-image-button\\\"\\n   id=\\\"svg24\\\"\\n   sodipodi:docname=\\\"ipfs-small.svg\\\"\\n   inkscape:version=\\\"0.92.4 (5da689c313, 2019-01-14)\\\"\\n>\\n  <metadata\\n     id=\\\"metadata28\\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\\"\\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\\"http://purl.org/dc/dcmitype/StillImage\\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <sodipodi:namedview\\n     pagecolor=\\\"#ffffff\\\"\\n     bordercolor=\\\"#666666\\\"\\n     borderopacity=\\\"1\\\"\\n     objecttolerance=\\\"10\\\"\\n     gridtolerance=\\\"10\\\"\\n     guidetolerance=\\\"10\\\"\\n     inkscape:pageopacity=\\\"0\\\"\\n     inkscape:pageshadow=\\\"2\\\"\\n     inkscape:window-width=\\\"1920\\\"\\n     inkscape:window-height=\\\"1020\\\"\\n     id=\\\"namedview26\\\"\\n     showgrid=\\\"false\\\"\\n     units=\\\"pt\\\"\\n     inkscape:zoom=\\\"5.2149125\\\"\\n     inkscape:cx=\\\"133.61143\\\"\\n     inkscape:cy=\\\"41.576599\\\"\\n     inkscape:window-x=\\\"0\\\"\\n     inkscape:window-y=\\\"31\\\"\\n     inkscape:window-maximized=\\\"1\\\"\\n     inkscape:current-layer=\\\"svg24\\\" />\\n  <defs\\n     id=\\\"defs8\\\">\\n    <linearGradient\\n       id=\\\"b\\\"\\n       y2=\\\"771.51001\\\"\\n       gradientUnits=\\\"userSpaceOnUse\\\"\\n       x2=\\\"527.71997\\\"\\n       y1=\\\"771.51001\\\"\\n       x1=\\\"84.315002\\\">\\n      <stop\\n         offset=\\\"0\\\"\\n         id=\\\"stop2\\\" />\\n    </linearGradient>\\n    <linearGradient\\n       id=\\\"a\\\"\\n       y2=\\\"771.47998\\\"\\n       gradientUnits=\\\"userSpaceOnUse\\\"\\n       x2=\\\"512.35999\\\"\\n       y1=\\\"771.47998\\\"\\n       x1=\\\"99.675003\\\">\\n      <stop\\n         stop-color=\\\"#d8d8d8\\\"\\n         offset=\\\"0\\\"\\n         id=\\\"stop5\\\" />\\n    </linearGradient>\\n  </defs>\\n  <g\\n     transform=\\\"matrix(0.28867709,0,0,0.24999998,-24.339808,-128.87748)\\\"\\n     id=\\\"g14\\\">\\n    <path\\n       d=\\\"m 84.315,899.51 221.7,128 221.7,-128 v -256 l -221.7,-127.99 -221.7,128 z\\\"\\n       id=\\\"path10\\\"\\n       style=\\\"fill:url(#b)\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"m 283.13,546.35 -160.74,92.806 c 0.32126,2.8543 0.32125,5.7352 0,8.5894 l 160.75,92.806 c 13.554,-10.001 32.043,-10.001 45.597,0 l 160.75,-92.807 c -0.32126,-2.8543 -0.32293,-5.7338 -0.001,-8.588 l -160.74,-92.806 c -13.554,10.001 -32.044,10.001 -45.599,0 z M 504.92,673.38 344,767.22 c 1.884,16.739 -7.3611,32.751 -22.799,39.489 l 0.18062,184.58 c 2.6325,1.1489 5.1267,2.5886 7.438,4.294 l 160.75,-92.805 c -1.884,-16.739 7.3611,-32.752 22.799,-39.49 v -185.61 c -2.6325,-1.1489 -5.1281,-2.5886 -7.4394,-4.294 z m -397.81,1.0315 c -2.3112,1.7054 -4.8054,3.1465 -7.438,4.2954 v 185.61 c 15.438,6.7378 24.683,22.75 22.799,39.489 l 160.74,92.806 c 2.3112,-1.7054 4.8069,-3.1465 7.4394,-4.2954 v -185.61 c -15.438,-6.7378 -24.683,-22.75 -22.799,-39.489 l -160.74,-92.81 z\\\"\\n       id=\\\"path12\\\"\\n       style=\\\"fill:url(#a)\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n  </g>\\n  <g\\n     transform=\\\"matrix(0.28867709,0,0,0.24999998,-9.9010468,-49.164992)\\\"\\n     id=\\\"g22\\\">\\n    <path\\n       d=\\\"m 256,708.66 221.7,-128 v -256 l -221.7,128 z\\\"\\n       id=\\\"path16\\\"\\n       inkscape:connector-curvature=\\\"0\\\"\\n       style=\\\"fill-opacity:0.25097997\\\" />\\n    <path\\n       d=\\\"m 256,708.66 v -256 l -221.7,-128 v 256 z\\\"\\n       id=\\\"path18\\\"\\n       inkscape:connector-curvature=\\\"0\\\"\\n       style=\\\"fill-opacity:0.03921599\\\" />\\n    <path\\n       d=\\\"m 34.298,324.66 221.7,128 221.7,-128 -221.7,-128 z\\\"\\n       id=\\\"path20\\\"\\n       inkscape:connector-curvature=\\\"0\\\"\\n       style=\\\"fill-opacity:0.13018003\\\" />\\n  </g>\\n</svg>\"\n        },\n        \"$:/ipfs/core/images/tiddlywiki\": {\n            \"title\": \"$:/ipfs/core/images/tiddlywiki\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"text\": \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" width=\\\"22pt\\\" height=\\\"22pt\\\" viewBox=\\\"0 0 128 128\\\">\\n  <path d=\\\"M64 0l54.56 32v64L64 128 9.44 96V32L64 0zm21.127 95.408c-3.578-.103-5.15-.094-6.974-3.152l-1.42.042c-1.653-.075-.964-.04-2.067-.097-1.844-.07-1.548-1.86-1.873-2.8-.52-3.202.687-6.43.65-9.632-.014-1.14-1.593-5.17-2.157-6.61-1.768.34-3.546.406-5.34.497-4.134-.01-8.24-.527-12.317-1.183-.8 3.35-3.16 8.036-1.21 11.44 2.37 3.52 4.03 4.495 6.61 4.707 2.572.212 3.16 3.18 2.53 4.242-.55.73-1.52.864-2.346 1.04l-1.65.08c-1.296-.046-2.455-.404-3.61-.955-1.93-1.097-3.925-3.383-5.406-5.024.345.658.55 1.938.24 2.53-.878 1.27-4.665 1.26-6.4.47-1.97-.89-6.73-7.162-7.468-11.86 1.96-3.78 4.812-7.07 6.255-11.186-3.146-2.05-4.83-5.384-4.61-9.16l.08-.44c-3.097.59-1.49.37-4.82.628-10.608-.032-19.935-7.37-14.68-18.774.34-.673.664-1.287 1.243-.994.466.237.4 1.18.166 2.227-3.005 13.627 11.67 13.732 20.69 11.21.89-.25 2.67-1.936 3.905-2.495 2.016-.91 4.205-1.282 6.376-1.55 5.4-.63 11.893 2.276 15.19 2.37 3.3.096 7.99-.805 10.87-.615 2.09.098 4.143.483 6.16 1.03 1.306-6.49 1.4-11.27 4.492-12.38 1.814.293 3.213 2.818 4.25 4.167 2.112-.086 4.12.46 6.115 1.066 3.61-.522 6.642-2.593 9.833-4.203-3.234 2.69-3.673 7.075-3.303 11.127.138 2.103-.444 4.386-1.164 6.54-1.348 3.507-3.95 7.204-6.97 7.014-1.14-.036-1.805-.695-2.653-1.4-.164 1.427-.81 2.7-1.434 3.96-1.44 2.797-5.203 4.03-8.687 7.016-3.484 2.985 1.114 13.65 2.23 15.594 1.114 1.94 4.226 2.652 3.02 4.406-.37.58-.936.785-1.54 1.01l-.82.11zm-40.097-8.85l.553.14c.694-.27 2.09.15 2.83.353-1.363-1.31-3.417-3.24-4.897-4.46-.485-1.47-.278-2.96-.174-4.46l.02-.123c-.582 1.205-1.322 2.376-1.72 3.645-.465 1.71 2.07 3.557 3.052 4.615l.336.3z\\\" fill-rule=\\\"evenodd\\\"/>\\n</svg>\"\n        },\n        \"$:/ipfs/core/images/user-cog\": {\n            \"title\": \"$:/ipfs/core/images/user-cog\",\n            \"caption\": \"user-cog (Solid)\",\n            \"tags\": \"$:/tags/Image [[Font Awesome 5]] Solid $:/ipfs/core $:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"_license_uri\": \"https://creativecommons.org/licenses/by/4.0\",\n            \"_project_uri\": \"https://fontawesome.com/\",\n            \"_source_uri\": \"http://fa5-free-svg.tiddlyspot.com/#%24%3A%2Fimages%2Ffa5%2Fsolid%2Fuser-cog\",\n            \"text\": \"<svg\\n  class=\\\"tc-image-button\\\"\\n  xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n  width=\\\"22pt\\\"\\n  height=\\\"22pt\\\"\\n  viewBox=\\\"0 0 640 512\\\"\\n>\\n  <path d=\\\"M610.5 373.3c2.6-14.1 2.6-28.5 0-42.6l25.8-14.9c3-1.7 4.3-5.2 3.3-8.5-6.7-21.6-18.2-41.2-33.2-57.4-2.3-2.5-6-3.1-9-1.4l-25.8 14.9c-10.9-9.3-23.4-16.5-36.9-21.3v-29.8c0-3.4-2.4-6.4-5.7-7.1-22.3-5-45-4.8-66.2 0-3.3.7-5.7 3.7-5.7 7.1v29.8c-13.5 4.8-26 12-36.9 21.3l-25.8-14.9c-2.9-1.7-6.7-1.1-9 1.4-15 16.2-26.5 35.8-33.2 57.4-1 3.3.4 6.8 3.3 8.5l25.8 14.9c-2.6 14.1-2.6 28.5 0 42.6l-25.8 14.9c-3 1.7-4.3 5.2-3.3 8.5 6.7 21.6 18.2 41.1 33.2 57.4 2.3 2.5 6 3.1 9 1.4l25.8-14.9c10.9 9.3 23.4 16.5 36.9 21.3v29.8c0 3.4 2.4 6.4 5.7 7.1 22.3 5 45 4.8 66.2 0 3.3-.7 5.7-3.7 5.7-7.1v-29.8c13.5-4.8 26-12 36.9-21.3l25.8 14.9c2.9 1.7 6.7 1.1 9-1.4 15-16.2 26.5-35.8 33.2-57.4 1-3.3-.4-6.8-3.3-8.5l-25.8-14.9zM496 400.5c-26.8 0-48.5-21.8-48.5-48.5s21.8-48.5 48.5-48.5 48.5 21.8 48.5 48.5-21.7 48.5-48.5 48.5zM224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm201.2 226.5c-2.3-1.2-4.6-2.6-6.8-3.9l-7.9 4.6c-6 3.4-12.8 5.3-19.6 5.3-10.9 0-21.4-4.6-28.9-12.6-18.3-19.8-32.3-43.9-40.2-69.6-5.5-17.7 1.9-36.4 17.9-45.7l7.9-4.6c-.1-2.6-.1-5.2 0-7.8l-7.9-4.6c-16-9.2-23.4-28-17.9-45.7.9-2.9 2.2-5.8 3.2-8.7-3.8-.3-7.5-1.2-11.4-1.2h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c10.1 0 19.5-3.2 27.2-8.5-1.2-3.8-2-7.7-2-11.8v-9.2z\\\"/>\\n</svg>\"\n        },\n        \"$:/ipfs/core/logo/bluelight\": {\n            \"title\": \"$:/ipfs/core/logo/bluelight\",\n            \"_canonical_uri\": \"ipfs://bafybeicbul2onp6mxb737el3skvhfohb4usmoeh7mvm2rg5ae6gyixlvhe/$:/ipfs/core/logo/bluelight.jpg\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isIpfs\",\n            \"type\": \"image/jpg\"\n        },\n        \"$:/tiddlywiki.ico\": {\n            \"title\": \"$:/tiddlywiki.ico\",\n            \"_canonical_uri\": \"ipfs://bafybeihh34pihp7uiroxnyeifrdto2owstdn2sryuatsu5h4lu32gy4yni/$_tiddlywiki.ico\",\n            \"altSourceUri\": \"https://dweb.link/ipfs/bafybeihh34pihp7uiroxnyeifrdto2owstdn2sryuatsu5h4lu32gy4yni/$_tiddlywiki.ico\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment $:/isIpfs\",\n            \"type\": \"image/x-icon\"\n        },\n        \"$:/boot/bundle\": {\n            \"title\": \"$:/boot/bundle\",\n            \"tags\": \"$:/boot/bundle\",\n            \"text\": \"\\\\rules only filteredtranscludeinline transcludeinline codeinline\\n\\n// boot modules\\n{{{ [is[system]type[application/javascript]boot-bundle[yes]] ||$:/core/templates/plain-text-tiddler}}}\\n\"\n        },\n        \"$:/config/PreferredSaver\": {\n            \"title\": \"$:/config/PreferredSaver\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"$:/core/modules/savers/download.js\"\n        },\n        \"$:/config/encryption\": {\n            \"title\": \"$:/config/encryption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"standford\"\n        },\n        \"$:/config/HtmlParser/DisableSandbox\": {\n            \"title\": \"$:/config/HtmlParser/DisableSandbox\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"no\"\n        },\n        \"$:/config/HtmlParser/SandboxTokens\": {\n            \"title\": \"$:/config/HtmlParser/SandboxTokens\",\n            \"tags\": \"$:/ipfs/core\",\n            \"_sandbox_source_uri\": \"https://developer.mozilla.org/fr/docs/Web/HTML/Element/iframe\"\n        },\n        \"$:/ipfs/build/ipns/cid\": {\n            \"title\": \"$:/ipfs/build/ipns/cid\",\n            \"tags\": \"$:/ipfs/core\",\n            \"peerId\": \"12D3KooWMLtu3emAahojNa4C7CHZShvQvafMcYHtFupb7Ep5LfK3\",\n            \"text\": \"ipns://k51qzi5uqu5dmj8zym08576inkibqy8apl49xg888d1x0q5vhk1lt2uj6sp2wl\"\n        },\n        \"$:/ipfs/http/long/timeout\": {\n            \"title\": \"$:/ipfs/http/long/timeout\",\n            \"tags\": \"$:/ipfs/core\",\n            \"timeout\": \"960000\"\n        },\n        \"$:/ipfs/http/short/timeout\": {\n            \"title\": \"$:/ipfs/http/short/timeout\",\n            \"tags\": \"$:/ipfs/core\",\n            \"timeout\": \"4000\"\n        },\n        \"$:/ipfs/raw/build/ipns/cid\": {\n            \"title\": \"$:/ipfs/raw/build/ipns/cid\",\n            \"tags\": \"$:/ipfs/core\",\n            \"peerId\": \"12D3KooWMLtu3emAahojNa4C7CHZShvQvafMcYHtFupb7Ep5LfK3\",\n            \"text\": \"ipns://k51qzi5uqu5dh9giahc358e235iqoncw9lpyc6vrn1aqguruj2nncupmbv9355\"\n        },\n        \"$:/ipfs/saver/api\": {\n            \"title\": \"$:/ipfs/saver/api\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"$:/ipfs/saver/api/https/ipfs.infura.io/5001\"\n        },\n        \"$:/ipfs/saver/directory/wrapped\": {\n            \"title\": \"$:/ipfs/saver/directory/wrapped\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"yes\"\n        },\n        \"$:/ipfs/saver/ens/domain\": {\n            \"title\": \"$:/ipfs/saver/ens/domain\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\"\n        },\n        \"$:/ipfs/saver/eth-link/resolve\": {\n            \"title\": \"$:/ipfs/saver/eth-link/resolve\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"no\"\n        },\n        \"$:/ipfs/saver/export\": {\n            \"title\": \"$:/ipfs/saver/export\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"json\"\n        },\n        \"$:/ipfs/saver/gateway\": {\n            \"title\": \"$:/ipfs/saver/gateway\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"$:/ipfs/saver/gateway/https/dweb.link\"\n        },\n        \"$:/ipfs/saver/ipns/cid\": {\n            \"title\": \"$:/ipfs/saver/ipns/cid\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\"\n        },\n        \"$:/ipfs/saver/ipns/key\": {\n            \"title\": \"$:/ipfs/saver/ipns/key\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\"\n        },\n        \"$:/ipfs/saver/ipns/resolve\": {\n            \"title\": \"$:/ipfs/saver/ipns/resolve\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"no\"\n        },\n        \"$:/ipfs/saver/pin\": {\n            \"title\": \"$:/ipfs/saver/pin\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"yes\"\n        },\n        \"$:/ipfs/saver/policy\": {\n            \"title\": \"$:/ipfs/saver/policy\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"gateway\"\n        },\n        \"$:/ipfs/saver/protocol\": {\n            \"title\": \"$:/ipfs/saver/protocol\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ipfs\"\n        },\n        \"$:/ipfs/saver/provider\": {\n            \"title\": \"$:/ipfs/saver/provider\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"http\"\n        },\n        \"$:/ipfs/saver/unpin\": {\n            \"title\": \"$:/ipfs/saver/unpin\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"no\"\n        },\n        \"$:/ipfs/saver/verbose\": {\n            \"title\": \"$:/ipfs/saver/verbose\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"yes\"\n        },\n        \"$:/boot/boot.css-build\": {\n            \"title\": \"$:/boot/boot.css-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/boot/css\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/boot/boot.css\",\n            \"version\": \"0.4.0-beta-tw-v5.1.24-pre-release+build-210512344\",\n            \"sourceSize\": \"1462\",\n            \"sourceExtension\": \"css\",\n            \"sourceFilename\": \"$_boot_boot.css\",\n            \"sourceUri\": \"ipfs://bafybeiduxtzrx7euyjw3v6dbp3qaotc2iycehc4ystbin3v4zbzawmmc5i/$_boot_boot.css-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.css\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeiduxtzrx7euyjw3v6dbp3qaotc2iycehc4ystbin3v4zbzawmmc5i/$_boot_boot.css-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.css\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/boot/boot.css.json-build\": {\n            \"title\": \"$:/boot/boot.css.json-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/boot/css\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/boot/boot.css.json\",\n            \"version\": \"0.4.0-beta-tw-v5.1.24-pre-release+build-210512344\",\n            \"sourceSize\": \"2014\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_boot_boot.css.json\",\n            \"sourceUri\": \"ipfs://bafybeia4nevwleqmappkfhaomcflnsahxhtfcrslpsmr5qveorrcchnkwu/$_boot_boot.css.json-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeia4nevwleqmappkfhaomcflnsahxhtfcrslpsmr5qveorrcchnkwu/$_boot_boot.css.json-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/boot/boot.js-build\": {\n            \"title\": \"$:/boot/boot.js-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/boot/bundle\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210514309\",\n            \"name\": \"$:/boot/boot.js\",\n            \"version\": \"0.4.0-beta-tw-v5.1.24-pre-release+build-210514309\",\n            \"sourceSize\": \"141333\",\n            \"sourceExtension\": \"js\",\n            \"sourceFilename\": \"$_boot_boot.js\",\n            \"sourceUri\": \"ipfs://bafybeidwmayt3mscgwy7wepkcas4xpy3gotjqlr7jxc6ytlsm73g4ozahu/$_boot_boot.js-0.4.0-beta-tw-v5.1.24-pre-release+build-210514309.js\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeidwmayt3mscgwy7wepkcas4xpy3gotjqlr7jxc6ytlsm73g4ozahu/$_boot_boot.js-0.4.0-beta-tw-v5.1.24-pre-release+build-210514309.js\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/boot/boot.js.json-build\": {\n            \"title\": \"$:/boot/boot.js.json-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/boot/bundle\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210514309\",\n            \"name\": \"$:/boot/boot.js.json\",\n            \"version\": \"0.4.0-beta-tw-v5.1.24-pre-release+build-210514309\",\n            \"sourceSize\": \"146850\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_boot_boot.js.json\",\n            \"sourceUri\": \"ipfs://bafybeigvc7u7dt5i5x4t4zmlcvj4ceewoptgjqjrpehinza3tezi5wadqq/$_boot_boot.js.json-0.4.0-beta-tw-v5.1.24-pre-release+build-210514309.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeigvc7u7dt5i5x4t4zmlcvj4ceewoptgjqjrpehinza3tezi5wadqq/$_boot_boot.js.json-0.4.0-beta-tw-v5.1.24-pre-release+build-210514309.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/boot/bootprefix.js-build\": {\n            \"title\": \"$:/boot/bootprefix.js-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/boot/bootprefix\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/boot/bootprefix.js\",\n            \"version\": \"0.4.0-beta-tw-v5.1.24-pre-release+build-210512344\",\n            \"sourceSize\": \"3384\",\n            \"sourceExtension\": \"js\",\n            \"sourceFilename\": \"$_boot_bootprefix.js\",\n            \"sourceUri\": \"ipfs://bafybeib755tzfb7jabag2pmx2ujyg4ixptpnef7zx72neh7qdwuxo6q6ie/$_boot_bootprefix.js-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.js\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeib755tzfb7jabag2pmx2ujyg4ixptpnef7zx72neh7qdwuxo6q6ie/$_boot_bootprefix.js-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.js\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/boot/bootprefix.js.json-build\": {\n            \"title\": \"$:/boot/bootprefix.js.json-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/boot/bootprefix\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/boot/bootprefix.js.json\",\n            \"version\": \"0.4.0-beta-tw-v5.1.24-pre-release+build-210512344\",\n            \"sourceSize\": \"3967\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_boot_bootprefix.js.json\",\n            \"sourceUri\": \"ipfs://bafybeihfpuohfodurcq2kjcsocsxr5dxyhqs5gkqusr6scec7bbxv3f54q/$_boot_bootprefix.js.json-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeihfpuohfodurcq2kjcsocsxr5dxyhqs5gkqusr6scec7bbxv3f54q/$_boot_bootprefix.js.json-0.4.0-beta-tw-v5.1.24-pre-release+build-210512344.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/core.json-build\": {\n            \"title\": \"$:/core.json-build\",\n            \"tags\": \"$:/core $:/ipfs/documentation\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512343\",\n            \"name\": \"$:/core.json\",\n            \"version\": \"0.4.0-beta-tw-v5.1.23+release+build-210512343\",\n            \"sourceSize\": \"2064875\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_core.json\",\n            \"sourceUri\": \"ipfs://bafybeib7usmiyt2wbish5im5kj7aakhsxh6wniwenvd2vv7izwfpvd27by/$_core.json-0.4.0-beta-tw-v5.1.23+release+build-210512343.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeib7usmiyt2wbish5im5kj7aakhsxh6wniwenvd2vv7izwfpvd27by/$_core.json-0.4.0-beta-tw-v5.1.23+release+build-210512343.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/core.zlib.ipfs-build\": {\n            \"title\": \"$:/core.zlib.ipfs-build\",\n            \"tags\": \"$:/core $:/ipfs/documentation\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512343\",\n            \"name\": \"$:/core.zlib.ipfs\",\n            \"version\": \"0.4.0-beta-tw-v5.1.23+release+build-210512343\",\n            \"sourceSize\": \"530\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_core.zlib.ipfs\",\n            \"sourceUri\": \"ipfs://bafybeigm7inczzf63tu3pbjmwm75skchy2yieijqdjsl7dtk663a3awfcy/$_core.zlib.ipfs-0.4.0-beta-tw-v5.1.23+release+build-210512343.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeigm7inczzf63tu3pbjmwm75skchy2yieijqdjsl7dtk663a3awfcy/$_core.zlib.ipfs-0.4.0-beta-tw-v5.1.23+release+build-210512343.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/core.zlib-build\": {\n            \"title\": \"$:/core.zlib-build\",\n            \"tags\": \"$:/core $:/ipfs/documentation\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512343\",\n            \"name\": \"$:/core.zlib\",\n            \"version\": \"0.4.0-beta-tw-v5.1.23+release+build-210512343\",\n            \"sourceSize\": \"452679\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_core.zlib\",\n            \"sourceUri\": \"ipfs://bafybeihnh7qq3l4r63a27suk5xpua4lkmjuqigl27tydlqrygkqvvcywkq/$_core.zlib-0.4.0-beta-tw-v5.1.23+release+build-210512343.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeihnh7qq3l4r63a27suk5xpua4lkmjuqigl27tydlqrygkqvvcywkq/$_core.zlib-0.4.0-beta-tw-v5.1.23+release+build-210512343.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/library/ipfs.js-build\": {\n            \"title\": \"$:/library/ipfs.js-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/library/ipfs\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/library/ipfs.js\",\n            \"version\": \"1.0.0+release-210512344\",\n            \"sourceSize\": \"129974\",\n            \"sourceExtension\": \"js\",\n            \"sourceFilename\": \"$_library_ipfs.js\",\n            \"sourceUri\": \"ipfs://bafybeihdjgfwyl7sh25nwyxidfnehnwpv7g7jtgdqu6crptk4rb5hf5olu/$_library_ipfs.js-1.0.0+release-210512344.js\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeihdjgfwyl7sh25nwyxidfnehnwpv7g7jtgdqu6crptk4rb5hf5olu/$_library_ipfs.js-1.0.0+release-210512344.js\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/library/ipfs.js.json-build\": {\n            \"title\": \"$:/library/ipfs.js.json-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/library/ipfs\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/library/ipfs.js.json\",\n            \"version\": \"1.0.0+release-210512344\",\n            \"sourceSize\": \"132986\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_library_ipfs.js.json\",\n            \"sourceUri\": \"ipfs://bafybeicnpptrffwo7s2ocht4tszvxnm2q5ewijx3fy7xuitltaasy45aom/$_library_ipfs.js.json-1.0.0+release-210512344.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeicnpptrffwo7s2ocht4tszvxnm2q5ewijx3fy7xuitltaasy45aom/$_library_ipfs.js.json-1.0.0+release-210512344.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/library/sjcl.js-build\": {\n            \"title\": \"$:/library/sjcl.js-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/library/sjcl\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/library/sjcl.js\",\n            \"version\": \"1.0.8+release-210512344\",\n            \"sourceSize\": \"25607\",\n            \"sourceExtension\": \"js\",\n            \"sourceFilename\": \"$_library_sjcl.js\",\n            \"sourceUri\": \"ipfs://bafybeiabrptlz4n6bdxnohidtqpchn5s62m4zqb76nnszkd37pybkn3dma/$_library_sjcl.js-1.0.8+release-210512344.js\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeiabrptlz4n6bdxnohidtqpchn5s62m4zqb76nnszkd37pybkn3dma/$_library_sjcl.js-1.0.8+release-210512344.js\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/library/sjcl.js.json-build\": {\n            \"title\": \"$:/library/sjcl.js.json-build\",\n            \"tags\": \"$:/ipfs/core $:/core $:/library/sjcl\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"build\": \"210512344\",\n            \"name\": \"$:/library/sjcl.js.json\",\n            \"version\": \"1.0.8+release-210512344\",\n            \"sourceSize\": \"26401\",\n            \"sourceExtension\": \"json\",\n            \"sourceFilename\": \"$_library_sjcl.js.json\",\n            \"sourceUri\": \"ipfs://bafybeihyse5zkqmiha2ujfow7rkjqvs3xc2fyindrrb4v6ex3itndttqhu/$_library_sjcl.js.json-1.0.8+release-210512344.json\",\n            \"altSourceUri\": \"https://bluelight.link/ipfs/bafybeihyse5zkqmiha2ujfow7rkjqvs3xc2fyindrrb4v6ex3itndttqhu/$_library_sjcl.js.json-1.0.8+release-210512344.json\",\n            \"text\": \"<$ipfslink value={{!!sourceUri}}>{{!!name}}-{{!!version}}</$ipfslink>\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Caption\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"mobile console\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Hint\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Load/Show/Hide Mobile Console\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Hide\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Hide\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Hide Mobile Console\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Load\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Load\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Load Mobile Console\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Show\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Show\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Show Mobile Console\"\n        },\n        \"$:/language/Buttons/Encryption/Hint\": {\n            \"title\": \"$:/language/Buttons/Encryption/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Set or clear a password or a public key for saving this wiki\"\n        },\n        \"$:/language/Buttons/Encryption/ClearPassword/Caption\": {\n            \"title\": \"$:/language/Buttons/Encryption/ClearPassword/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"clear password or public key\"\n        },\n        \"$:/language/Buttons/Encryption/ClearPassword/Hint\": {\n            \"title\": \"$:/language/Buttons/Encryption/ClearPassword/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Clear the password\"\n        },\n        \"$:/language/Buttons/Encryption/ClearEncryptionPublicKey/Hint\": {\n            \"title\": \"$:/language/Buttons/Encryption/ClearEncryptionPublicKey/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Clear the public encryption key\"\n        },\n        \"$:/language/Buttons/Encryption/SetPassword/Caption\": {\n            \"title\": \"$:/language/Buttons/Encryption/SetPassword/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"set password or public key\"\n        },\n        \"$:/language/Buttons/Encryption/SetPassword/Hint\": {\n            \"title\": \"$:/language/Buttons/Encryption/SetPassword/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Set a password for saving this wiki with Standford encryption\"\n        },\n        \"$:/language/Buttons/Encryption/SetEncryptionPublicKey/Hint\": {\n            \"title\": \"$:/language/Buttons/Encryption/SetEncryptionPublicKey/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Set a public encryption key for saving this wiki with Ethereum encryption\"\n        },\n        \"$:/language/Buttons/Ens/Manager/Open/Caption\": {\n            \"title\": \"$:/language/Buttons/Ens/Manager/Open/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"open ENS Manager\"\n        },\n        \"$:/language/Buttons/Ens/Manager/Open/Hint\": {\n            \"title\": \"$:/language/Buttons/Ens/Manager/Open/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open ENS Domain Manager\"\n        },\n        \"$:/language/Buttons/Ens/Publish/Caption\": {\n            \"title\": \"$:/language/Buttons/Ens/Publish/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"publish to ENS\"\n        },\n        \"$:/language/Buttons/Ens/Publish/Hint\": {\n            \"title\": \"$:/language/Buttons/Ens/Publish/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Publish this wiki to ENS\"\n        },\n        \"$:/language/Buttons/Ens/Resolve/And/Open/Caption\": {\n            \"title\": \"$:/language/Buttons/Ens/Resolve/And/Open/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"open ENS Domain\"\n        },\n        \"$:/language/Buttons/Ens/Resolve/And/Open/Hint\": {\n            \"title\": \"$:/language/Buttons/Ens/Resolve/And/Open/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open ENS Domain\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"export to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export this tiddler to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Attachment/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Attachment/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"export attachment to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Attachment/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Attachment/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export attachment to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Content/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Content/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"export content to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Content/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Content/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export this tiddler content to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Pin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Pin/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"pin to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Pin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Pin/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Pin this wiki to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Pin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Pin/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"pin to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Pin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Pin/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Pin tiddler resources to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"unpin from IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Unpin tiddler resources from IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Unpin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Unpin/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"unpin from IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Unpin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Unpin/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Unpin this wiki from IPFS\"\n        },\n        \"$:/language/Buttons/Ipns/Fetch/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Fetch/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"fetch from IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Fetch/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Fetch/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Fetch IPNS cid\"\n        },\n        \"$:/language/Buttons/Ipns/Generate/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Generate/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"generate IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Generate/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Generate/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Generate IPNS cid\"\n        },\n        \"$:/language/Buttons/Ipns/Publish/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Publish/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"publish to IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Publish/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Publish/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Publish this wiki to IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Publish/To/Ens/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Publish/To/Ens/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"publish to ENS\"\n        },\n        \"$:/language/Buttons/Ipns/Publish/To/Ens/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Publish/To/Ens/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"publish IPNS key to ENS\"\n        },\n        \"$:/language/Buttons/Ipns/Remove/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Remove/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"remove\"\n        },\n        \"$:/language/Buttons/Ipns/Remove/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Remove/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Remove IPNS key and IPNS cid\"\n        },\n        \"$:/language/Buttons/Ipns/Rename/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Rename/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"rename\"\n        },\n        \"$:/language/Buttons/Ipns/Rename/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Rename/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Rename IPNS key\"\n        },\n        \"$:/language/Buttons/Ipns/Resolve/And/Open/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Resolve/And/Open/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Resolve/And/Open/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Resolve/And/Open/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open IPNS\"\n        },\n        \"$:/language/Buttons/Tiddler/Refresh/Caption\": {\n            \"title\": \"$:/language/Buttons/Tiddler/Refresh/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"refresh\"\n        },\n        \"$:/language/Buttons/Tiddler/Refresh/Hint\": {\n            \"title\": \"$:/language/Buttons/Tiddler/Refresh/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Perform a full refresh of the tiddler\"\n        },\n        \"$:/language/ControlPanel/Appearance/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Appearance/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Ways to customise the appearance of your <b>~TiddlyWiki</b>.\"\n        },\n        \"$:/language/ControlPanel/Basics/Version/Prompt\": {\n            \"title\": \"$:/language/ControlPanel/Basics/Version/Prompt\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<b>~TiddlyWiki</b>:\"\n        },\n        \"$:/language/ControlPanel/Editor/Body/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Editor/Body/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Editor\"\n        },\n        \"$:/language/ControlPanel/Editor/Fields/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Editor/Fields/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Fields\"\n        },\n        \"$:/language/ControlPanel/Info/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Info/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Information about this <b>~TiddlyWiki</b>\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Build/Prompt\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Build/Prompt\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<b>IPFS</b>:\"\n        },\n        \"$:/language/ControlPanel/Saving/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Saving/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Settings used for saving the entire <b>~TiddlyWiki</b> as a single file via a saver module.\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Saver\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"These settings are only used when saving to IPFS.\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Verbose\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Verbose\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Saver Verbose\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Url\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Url\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Server URL\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/ApiUrl\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/ApiUrl\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"API\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/GatewayUrl\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/GatewayUrl\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Gateway\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Ens\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Ens\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ENS\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/EnsDomain\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/EnsDomain\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ENS domain\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Ipns\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Ipns\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/IpnsKey\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/IpnsKey\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS key\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/IpnsCid\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/IpnsCid\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS cid\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Resolved\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Resolved\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Resolved\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Global\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Global\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Global\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Verbose/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Verbose/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Verbose\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/IPNS/Resolve/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/IPNS/Resolve/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Resolve IPNS\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/ETH/Resolve/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/ETH/Resolve/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Resolve ETH\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Directory/Wrapped/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Directory/Wrapped/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Wrapped Directory\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Pin/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Pin/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Pin Current\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Unpin/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Unpin/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Unpin Previous\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Wait/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Wait/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Wait\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Policy\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Policy\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Relative URL Policy\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Policy/Origin/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Policy/Origin/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Origin\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Policy/Gateway/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Policy/Gateway/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Gateway\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Protocol\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Protocol\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Protocol\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Protocol/Ens/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Protocol/Ens/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ENS\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Protocol/Ipfs/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Protocol/Ipfs/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Protocol/Ipns/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Protocol/Ipns/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Export\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Export\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Export/Static/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Export/Static/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Static\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Export/Json/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Export/Json/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"JSON\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Export/Tid/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Export/Tid/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"TID\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Provider\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Provider\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Provider\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Provider/Default/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Provider/Default/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Default\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Provider/Window/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Provider/Window/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Companion\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Saver/Provider/HTTP/Description\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Saver/Provider/HTTP/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"HTTP Client\"\n        },\n        \"$:/language/ControlPanel/Settings/Compression/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Compression/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Compression\"\n        },\n        \"$:/language/ControlPanel/Settings/Compression/Description\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Compression/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Use Content Compression\"\n        },\n        \"$:/language/ControlPanel/Settings/Encryption/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Encryption/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Encryption\"\n        },\n        \"$:/language/ControlPanel/Settings/Encryption/Standford/Description\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Encryption/Standford/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Use Standford encryption\"\n        },\n        \"$:/language/ControlPanel/Settings/Encryption/Ethereum/Description\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Encryption/Ethereum/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Use Ethereum public key\"\n        },\n        \"$:/language/ControlPanel/Settings/Encryption/Signature/Description\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Encryption/Signature/Description\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Sign Ethereum encrypted content\"\n        },\n        \"$:/language/ControlPanel/Settings/PreferredSaver/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Settings/PreferredSaver/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Preferred Saver\"\n        },\n        \"$:/language/ControlPanel/Settings/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"These settings let you customise the behaviour of <b>~TiddlyWiki</b>.\"\n        },\n        \"$:/language/EditTemplate/Body/External/Hint\": {\n            \"title\": \"$:/language/EditTemplate/Body/External/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"This tiddler shows content stored outside of the main ~TiddlyWiki file.<br/>You can edit the tags and fields but cannot directly edit the content itself\"\n        },\n        \"$:/language/Export/Exported/Hint\": {\n            \"title\": \"$:/language/Export/Exported/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"The following tiddlers were exported:\"\n        },\n        \"$:/language/Export/Listing/Cancel/Caption\": {\n            \"title\": \"$:/language/Export/Listing/Cancel/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Cancel\"\n        },\n        \"$:/language/Export/Listing/Hint\": {\n            \"title\": \"$:/language/Export/Listing/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"These tiddlers are ready to be exported:\"\n        },\n        \"$:/language/Export/Listing/Export/Caption\": {\n            \"title\": \"$:/language/Export/Listing/Export/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export All\"\n        },\n        \"$:/language/Export/Listing/Title/Caption\": {\n            \"title\": \"$:/language/Export/Listing/Title/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Title\"\n        },\n        \"$:/language/Import/Deleted/Hint\": {\n            \"title\": \"$:/language/Import/Deleted/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"The following tiddlers were deleted:\"\n        },\n        \"$:/language/Import/Listing/Hint\": {\n            \"title\": \"$:/language/Import/Listing/Hint\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"These tiddlers are ready to be imported:\"\n        },\n        \"$:/language/Import/Listing/ImportAll/Caption\": {\n            \"title\": \"$:/language/Import/Listing/ImportAll/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Import\"\n        },\n        \"$:/language/Import/Listing/DeleteAll/Caption\": {\n            \"title\": \"$:/language/Import/Listing/DeleteAll/Caption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Delete\"\n        },\n        \"$:/language/NetworkError/Fetch\": {\n            \"title\": \"$:/language/NetworkError/Fetch\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Network Error while loading...\"\n        },\n        \"$:/language/LazyLoadingWarning\": {\n            \"title\": \"$:/language/LazyLoadingWarning\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<p>Trying to load external Tiddler content...</p>\"\n        },\n        \"$:/language/Encryption/ConfirmClearEncryptionPublicKey\": {\n            \"title\": \"$:/language/Encryption/ConfirmClearEncryptionPublicKey\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Do you wish to clear the encryption public key? This will remove the encryption applied when saving this wiki.\"\n        },\n        \"$:/ipfs/library/eruda\": {\n            \"title\": \"$:/ipfs/library/eruda\",\n            \"tags\": \"$:/ipfs/core\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/liriliri/eruda/master/LICENSE\",\n            \"_project_uri\": \"https://github.com/liriliri/eruda\",\n            \"_source_uri\": \"https://cdn.jsdelivr.net/npm/eruda@2.4.1/eruda.min.js\",\n            \"_source_sri\": \"sha384-nc47C28fBcDZCcelSM4kJI1x5Th9e2tkG9AdZK/7sJcbkRNdd184sr51K0dW+FIK\",\n            \"_module\": \"yes\"\n        },\n        \"$:/ipfs/library/eth-sig-util\": {\n            \"title\": \"$:/ipfs/library/eth-sig-util\",\n            \"tags\": \"$:/ipfs/core\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/xmaysonnave/eth-sig-util/master/LICENSE\",\n            \"_project_uri\": \"https://github.com/xmaysonnave/eth-sig-util\",\n            \"_source_uri\": \"https://cdn.jsdelivr.net/gh/xmaysonnave/eth-sig-util@3.0.2/eth-sig-util.umd.min.js\",\n            \"_source_sri\": \"sha384-KPw7aDyLzgZUSvyhLPirerXfcDl5Hq55j21FNjhwxCYCZWga3pBRynL/cPs5phFN\",\n            \"_module\": \"yes\"\n        },\n        \"$:/ipfs/library/ethers\": {\n            \"title\": \"$:/ipfs/library/ethers\",\n            \"tags\": \"$:/ipfs/core\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/ethers-io/ethers.js/master/LICENSE.md\",\n            \"_project_uri\": \"https://github.com/ethers-io/ethers.js/\",\n            \"_source_uri\": \"https://cdn.jsdelivr.net/npm/ethers@5.1.4/dist/ethers.umd.min.js\",\n            \"_source_sri\": \"sha384-cmAXnxAhPwGDIPqAfcx7VHUxNhX15X9BrUTRmwEOHYpD7K4xjaCIQ68HJUY2+gEV\",\n            \"_module\": \"yes\"\n        },\n        \"$:/ipfs/library/ipfs-http-client\": {\n            \"title\": \"$:/ipfs/library/ipfs-http-client\",\n            \"tags\": \"$:/ipfs/core\",\n            \"_license_uri\": \"https://raw.githubusercontent.com/ipfs/js-ipfs/master/packages/ipfs-http-client/LICENSE-MIT\",\n            \"_project_uri\": \"https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-http-client\",\n            \"_source_uri\": \"https://cdn.jsdelivr.net/npm/ipfs-http-client@50.0.0/dist/index.min.js\",\n            \"_source_sri\": \"sha384-xDGEptsXfljiftRc042cHgj3KEdFDa0+CjSYUrlZyxaf8XBItaI002p22TP58pt7\",\n            \"_module\": \"yes\"\n        },\n        \"$:/library/ipfs/bundle\": {\n            \"title\": \"$:/library/ipfs/bundle\",\n            \"tags\": \"$:/library/ipfs\",\n            \"text\": \"\\\\rules only filteredtranscludeinline transcludeinline codeinline\\n\\n// Ipfs Library modules\\n{{{ [is[system]type[application/javascript]library-ipfs[yes]] ||$:/core/templates/plain-text-tiddler}}}\\n\"\n        },\n        \"$:/core/modules/commands/clearkeys.js\": {\n            \"title\": \"$:/core/modules/commands/clearkeys.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/commands/clearkeys.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: command\\n\\nClear encryption public key for crypto operations\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.info = {\\n    name: 'clearkeys',\\n    synchronous: true,\\n  }\\n\\n  var Command = function (params, commander, callback) {\\n    this.params = params\\n    this.commander = commander\\n    this.callback = callback\\n  }\\n\\n  Command.prototype.execute = function () {\\n    $tw.crypto.setEncryptionKey(null, null)\\n    return null\\n  }\\n\\n  exports.Command = Command\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"command\"\n        },\n        \"$:/core/modules/commands/compress.js\": {\n            \"title\": \"$:/core/modules/commands/compress.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/commands/compress.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: command\\n\\nSet compression state\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.info = {\\n    name: 'compress',\\n    synchronous: true,\\n  }\\n\\n  var Command = function (params, commander, callback) {\\n    this.params = params\\n    this.commander = commander\\n    this.callback = callback\\n  }\\n\\n  Command.prototype.execute = function () {\\n    var compress = false\\n    if (this.params.length > 0) {\\n      compress = this.params[0] === 'yes'\\n    }\\n    $tw.compress.setCompressState(compress)\\n    return null\\n  }\\n\\n  exports.Command = Command\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"command\"\n        },\n        \"$:/core/modules/commands/encryptionkeys.js\": {\n            \"title\": \"$:/core/modules/commands/encryptionkeys.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/commands/encryptionkeys.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: command\\n\\nSave encryption public key for crypto operations\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.info = {\\n    name: 'encryptionkeys',\\n    synchronous: true,\\n  }\\n\\n  var Command = function (params, commander, callback) {\\n    this.params = params\\n    this.commander = commander\\n    this.callback = callback\\n  }\\n\\n  Command.prototype.execute = function () {\\n    if (this.params.length < 1) {\\n      return 'Missing encryption public key'\\n    }\\n    if (this.params.length < 2) {\\n      return 'Missing private key'\\n    }\\n    $tw.crypto.setEncryptionKey(this.params[0], this.params[1])\\n    return null\\n  }\\n\\n  exports.Command = Command\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"command\"\n        },\n        \"$:/core/modules/commands/encryptionpublickey.js\": {\n            \"title\": \"$:/core/modules/commands/encryptionpublickey.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/commands/encryptionpublickey.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: command\\n\\nSave encryption public key for crypto operations\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.info = {\\n    name: 'encryptionpublickey',\\n    synchronous: true,\\n  }\\n\\n  var Command = function (params, commander, callback) {\\n    this.params = params\\n    this.commander = commander\\n    this.callback = callback\\n  }\\n\\n  Command.prototype.execute = function () {\\n    if (this.params.length < 1) {\\n      return 'Missing encryption public key'\\n    }\\n    $tw.crypto.setEncryptionKey(this.params[0], null)\\n    return null\\n  }\\n\\n  exports.Command = Command\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"command\"\n        },\n        \"$:/core/modules/commands/ipfsmodules.js\": {\n            \"title\": \"$:/core/modules/commands/ipfsmodules.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/commands/ipfsmodules.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: command\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.info = {\\n    name: 'ipfsmodules',\\n    synchronous: true,\\n  }\\n\\n  var Command = function (params, commander, callback) {\\n    this.params = params\\n    this.commander = commander\\n    this.callback = callback\\n  }\\n\\n  Command.prototype.execute = function () {\\n    var ipfsmodules = false\\n    if (this.params.length > 0) {\\n      ipfsmodules = this.params[0] === 'yes'\\n    }\\n    $tw.modulesState.setModulesState(ipfsmodules)\\n    return null\\n  }\\n\\n  exports.Command = Command\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"command\"\n        },\n        \"$:/core/modules/commands/privatekey.js\": {\n            \"title\": \"$:/core/modules/commands/privatekey.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/commands/privatekey.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: command\\n\\nSave encryption public key for crypto operations\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.info = {\\n    name: 'privatekey',\\n    synchronous: true,\\n  }\\n\\n  var Command = function (params, commander, callback) {\\n    this.params = params\\n    this.commander = commander\\n    this.callback = callback\\n  }\\n\\n  Command.prototype.execute = function () {\\n    if (this.params.length < 1) {\\n      return 'Missing private key'\\n    }\\n    $tw.crypto.setEncryptionKey(null, this.params[0])\\n    return null\\n  }\\n\\n  exports.Command = Command\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"command\"\n        },\n        \"$:/plugins/ipfs/ipfs-deserializer.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-deserializer.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-deserializer.js\\ntags: $:/ipfs/core\\ntype: application/javascript\\nmodule-type: tiddlerdeserializer\\n\\nFunctions to deserialise tiddlers from a block of text\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /**\\n   * Utility function to parse an old-style tiddler DIV in a *.tid file. It looks like this:\\n   *\\n   * <div title=\\\"Title\\\" creator=\\\"JoeBloggs\\\" modifier=\\\"JoeBloggs\\\" created=\\\"201102111106\\\" modified=\\\"201102111310\\\" tags=\\\"myTag [[my long tag]]\\\">\\n   *   <pre>The text of the tiddler (without the expected HTML encoding).</pre>\\n   * </div>\\n   *\\n   * Note that the field attributes are HTML encoded, but that the body of the <PRE> tag is not encoded.\\n   *\\n   * When these tiddler DIVs are encountered within a TiddlyWiki HTML file then the body is encoded in the usual way.\\n   */\\n  var parseTiddlerDiv = function (text /* [,fields] */) {\\n    // Slot together the default results\\n    var result = {}\\n    if (arguments.length > 1) {\\n      for (var f = 1; f < arguments.length; f++) {\\n        var fields = arguments[f]\\n        for (var t in fields) {\\n          result[t] = fields[t]\\n        }\\n      }\\n    }\\n    // Parse the DIV body\\n    var startRegExp = /^\\\\s*<div\\\\s+([^>]*)>(\\\\s*<pre>)?/gi\\n    var endRegExp\\n    var match = startRegExp.exec(text)\\n    if (match) {\\n      // Old-style DIVs don't have the <pre> tag\\n      if (match[2]) {\\n        endRegExp = /<\\\\/pre>\\\\s*<\\\\/div>\\\\s*$/gi\\n      } else {\\n        endRegExp = /<\\\\/div>\\\\s*$/gi\\n      }\\n      var endMatch = endRegExp.exec(text)\\n      if (endMatch) {\\n        // Extract the text\\n        result.text = text.substring(match.index + match[0].length, endMatch.index)\\n        // Process the attributes\\n        var attrRegExp = /\\\\s*([^=\\\\s]+)\\\\s*=\\\\s*(?:\\\"([^\\\"]*)\\\"|'([^']*)')/gi\\n        var attrMatch\\n        do {\\n          attrMatch = attrRegExp.exec(match[1])\\n          if (attrMatch) {\\n            var name = attrMatch[1]\\n            var value = attrMatch[2] !== undefined ? attrMatch[2] : attrMatch[3]\\n            result[name] = value\\n          }\\n        } while (attrMatch)\\n        return result\\n      }\\n    }\\n    return undefined\\n  }\\n\\n  exports['application/x-tiddler-html-div'] = function (text, fields) {\\n    return [parseTiddlerDiv(text, fields)]\\n  }\\n\\n  exports['application/json'] = function (text, fields) {\\n    const inflated = $tw.utils.inflate(text)\\n    if (inflated !== null) {\\n      return inflated\\n    }\\n    var incoming\\n    var results = []\\n    try {\\n      incoming = JSON.parse(text)\\n    } catch (e) {\\n      incoming = [\\n        {\\n          title: 'JSON error: ' + e,\\n          text: '',\\n        },\\n      ]\\n    }\\n    if (!$tw.utils.isArray(incoming)) {\\n      incoming = [incoming]\\n    }\\n    for (var t = 0; t < incoming.length; t++) {\\n      var incomingFields = incoming[t]\\n      var fields = {}\\n      for (var f in incomingFields) {\\n        if (typeof incomingFields[f] === 'string') {\\n          fields[f] = incomingFields[f]\\n        }\\n      }\\n      results.push(fields)\\n    }\\n    return results\\n  }\\n\\n  /**\\n   * Parse an HTML file into tiddlers. There are three possibilities:\\n   * A TiddlyWiki classic HTML file containing `text/x-tiddlywiki` tiddlers\\n   * A TiddlyWiki5 HTML file containing `text/vnd.tiddlywiki` tiddlers\\n   * An ordinary HTML file\\n   */\\n  exports['text/html'] = function (text, fields) {\\n    // Check if we've got a store area\\n    var storeAreaMarkerRegExp = /<div id=[\\\"']?storeArea['\\\"]?( style=[\\\"']?display:none;[\\\"']?)?>/gi\\n    var match = storeAreaMarkerRegExp.exec(text)\\n    if (match) {\\n      // If so, it's either a classic TiddlyWiki file or an unencrypted TW5 file\\n      // First read the normal tiddlers\\n      var results = deserializeTiddlyWikiFile(text, storeAreaMarkerRegExp.lastIndex, !!match[1], fields)\\n      // Then any system tiddlers\\n      var systemAreaMarkerRegExp = /<div id=[\\\"']?systemArea['\\\"]?( style=[\\\"']?display:none;[\\\"']?)?>/gi\\n      var sysMatch = systemAreaMarkerRegExp.exec(text)\\n      if (sysMatch) {\\n        results.push.apply(results, deserializeTiddlyWikiFile(text, systemAreaMarkerRegExp.lastIndex, !!sysMatch[1], fields))\\n      }\\n      return results\\n    } else {\\n      // Check whether this is a compressed TiddlyWiki file\\n      var compressedStoreArea = $tw.utils.extractCompressedStoreArea(text)\\n      if (compressedStoreArea) {\\n        return $tw.utils.inflate(compressedStoreArea)\\n      } else {\\n        // Check whether this is an encrypted TiddlyWiki file\\n        var encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(text)\\n        if (encryptedStoreArea) {\\n          // If so, attempt to decrypt it using the current password\\n          return $tw.utils.decryptStoreArea(encryptedStoreArea)\\n        } else {\\n          // It's not a TiddlyWiki so we'll return the entire HTML file as a tiddler\\n          return deserializeHtmlFile(text, fields)\\n        }\\n      }\\n    }\\n  }\\n\\n  function deserializeHtmlFile (text, fields) {\\n    var result = {}\\n    $tw.utils.each(fields, function (value, name) {\\n      result[name] = value\\n    })\\n    result.text = text\\n    result.type = 'text/html'\\n    return [result]\\n  }\\n\\n  function deserializeTiddlyWikiFile (text, storeAreaEnd, isTiddlyWiki5, fields) {\\n    var results = []\\n    var endOfDivRegExp = /(<\\\\/div>\\\\s*)/gi\\n    var startPos = storeAreaEnd\\n    var defaultType = isTiddlyWiki5 ? undefined : 'text/x-tiddlywiki'\\n    endOfDivRegExp.lastIndex = startPos\\n    var match = endOfDivRegExp.exec(text)\\n    while (match) {\\n      var endPos = endOfDivRegExp.lastIndex\\n      var tiddlerFields = parseTiddlerDiv(text.substring(startPos, endPos), fields, { type: defaultType })\\n      if (!tiddlerFields) {\\n        break\\n      }\\n      $tw.utils.each(tiddlerFields, function (value, name) {\\n        if (typeof value === 'string') {\\n          tiddlerFields[name] = $tw.utils.htmlDecode(value)\\n        }\\n      })\\n      if (tiddlerFields.text !== null) {\\n        results.push(tiddlerFields)\\n      }\\n      startPos = endPos\\n      match = endOfDivRegExp.exec(text)\\n    }\\n    return results\\n  }\\n})()\\n\",\n            \"tags\": \"$:/ipfs/core\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"tiddlerdeserializer\"\n        },\n        \"$:/plugins/ipfs/filenamify.js\": {\n            \"title\": \"$:/plugins/ipfs/filenamify.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/filenamify.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: filteroperator\\n\\n\\n\\\\*/\\n;(function () {\\n  'use strict'\\n\\n  /**\\n   * Export our filter functions\\n   */\\n  exports.filenamify = function (source, operator, options) {\\n    var results = []\\n    var filenamify = $tw.node ? globalThis.filenamify || require('filenamify') : $tw.ipfs.filenamify\\n    source(function (tiddler, title) {\\n      results.push(filenamify(title, { replacement: '_' }))\\n    })\\n    return results\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"filteroperator\"\n        },\n        \"$:/core/modules/filters/savers.js\": {\n            \"title\": \"$:/core/modules/filters/savers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/filters/savers.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: filteroperator\\n\\nThis Filter operator return savers title\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*\\n  Export our filter function\\n  */\\n  exports.savers = function (source, operator, options) {\\n    var results = []\\n    for (var i in $tw.saverHandler.savers) {\\n      results.push($tw.saverHandler.savers[i].title)\\n    }\\n    return results\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"filteroperator\"\n        },\n        \"$:/plugins/ipfs/ens-action.js\": {\n            \"title\": \"$:/plugins/ipfs/ens-action.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ens-action.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nENS Action\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const ipfsKeyword = 'ipfs'\\n  const ipnsKeyword = 'ipns'\\n\\n  const name = 'ens-action'\\n\\n  var EnsAction = function () {\\n    this.once = false\\n  }\\n\\n  EnsAction.prototype.init = function () {\\n    // Init once\\n    if (this.once) {\\n      return\\n    }\\n    const self = this\\n    $tw.rootWidget.addEventListener('tm-ens-manager-open', function (event) {\\n      return self.handleOpenEnsManager(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ens-resolve-and-open', async function (event) {\\n      return await self.handleEnsResolveAndOpen(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ens-publish', async function (event) {\\n      return await self.handlePublishToEns(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-publish-to-ens', async function (event) {\\n      return await self.handlePublishIpnsToEns(event)\\n    })\\n    // Init once\\n    this.once = true\\n  }\\n\\n  EnsAction.prototype.handleOpenEnsManager = function (event) {\\n    var ensDomain = $tw.utils.getIpfsEnsDomain()\\n    if (ensDomain == null) {\\n      window.open('https://app.ens.domains', '_blank', 'noopener,noreferrer')\\n    } else {\\n      window.open(`https://app.ens.domains/name/${ensDomain}`, '_blank', 'noopener,noreferrer')\\n    }\\n    return true\\n  }\\n\\n  EnsAction.prototype.handleEnsResolveAndOpen = async function (event) {\\n    var ensDomain = $tw.utils.getIpfsEnsDomain()\\n    if (ensDomain == null) {\\n      $tw.utils.alert(name, 'Undefined ENS domain...')\\n      return false\\n    }\\n    try {\\n      var { resolvedUrl } = await $tw.ipfs.resolveUrl(ensDomain, $tw.utils.getIpnsResolve(), false, $tw.utils.getEthLinkResolve())\\n      if (resolvedUrl !== null) {\\n        window.open(resolvedUrl.href, '_blank', 'noopener,noreferrer')\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    return true\\n  }\\n\\n  EnsAction.prototype.handlePublishToEns = async function (event) {\\n    var ipfsCid = null\\n    var ipnsCid = null\\n    const wiki = $tw.ipfs.getDocumentUrl()\\n    var ensDomain = $tw.utils.getIpfsEnsDomain()\\n    if (ensDomain == null) {\\n      $tw.utils.alert(name, 'Undefined ENS domain...')\\n      return false\\n    }\\n    try {\\n      var { ipfsCid, ipnsCid } = await $tw.ipfs.resolveUrl(wiki, false, false, false)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    if (ipfsCid == null && ipnsCid == null) {\\n      $tw.utils.alert(name, 'Undefined IPFS identifier...')\\n      return false\\n    }\\n    if (ipfsCid !== null) {\\n      return await this.publishToEns(ensDomain, ipfsKeyword, ipfsCid)\\n    }\\n    return await this.publishToEns(ensDomain, ipnsKeyword, ipnsCid)\\n  }\\n\\n  EnsAction.prototype.handlePublishIpnsToEns = async function (event) {\\n    var ipnsCid = null\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    var ensDomain = $tw.utils.getIpfsEnsDomain()\\n    if (ensDomain == null) {\\n      $tw.utils.alert(name, 'Undefined ENS domain...')\\n      return false\\n    }\\n    try {\\n      var { ipnsCid } = await $tw.ipfs.resolveUrl(`/${ipnsKeyword}/${ipnsKey}`, false, false, false)\\n      if (ipnsCid == null) {\\n        $tw.utils.alert(name, 'Undefined IPFS identifier...')\\n        return false\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    return await this.publishToEns(ensDomain, ipnsKeyword, ipnsCid)\\n  }\\n\\n  EnsAction.prototype.publishToEns = async function (ensDomain, protocol, identifier) {\\n    var account = null\\n    var ipfsCid = null\\n    var ipnsCid = null\\n    var resolvedUrl = null\\n    var web3 = null\\n    try {\\n      var { account, web3 } = await $tw.ipfs.getEnabledWeb3Provider()\\n      var { ipfsCid, ipnsCid, resolvedUrl } = await $tw.ipfs.resolveUrl(ensDomain, $tw.utils.getIpnsResolve(), false, true, null, web3)\\n      if (protocol === ipfsKeyword && identifier === ipfsCid) {\\n        $tw.utils.alert(name, 'The current resolved ENS domain content is up to date...')\\n        return false\\n      }\\n      if (protocol === ipnsKeyword && identifier === ipnsCid) {\\n        $tw.utils.alert(name, 'The current resolved ENS domain content is up to date...')\\n        return false\\n      }\\n      const isOwner = await $tw.ipfs.isEnsOwner(ensDomain, web3, account)\\n      if (isOwner === false) {\\n        const err = new Error('Unauthorized Account...')\\n        err.name = 'OwnerError'\\n        throw err\\n      }\\n    } catch (error) {\\n      if (error.name !== 'OwnerError') {\\n        $tw.ipfs.getLogger().error(error)\\n      }\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    $tw.ipfs\\n      .addToUnpin(resolvedUrl !== null ? resolvedUrl.pathname : null)\\n      .then(unpin => {\\n        if (unpin) {\\n          $tw.ipfs.removeFromPinUnpin(resolvedUrl.pathname)\\n        }\\n        $tw.ipfs\\n          .setContentHash(ensDomain, `/${protocol}/${identifier}`, web3, account)\\n          .then(data => {\\n            $tw.utils.alert(name, 'Published to ENS...')\\n          })\\n          .catch(error => {\\n            if (error.name !== 'OwnerError' && error.name !== 'RejectedUserRequest' && error.name !== 'UnauthorizedUserAccount') {\\n              $tw.ipfs.getLogger().error(error)\\n            }\\n            $tw.utils.alert(name, error.message)\\n            $tw.ipfs.addToPin(resolvedUrl !== null ? resolvedUrl.pathname : null)\\n          })\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n    return true\\n  }\\n\\n  exports.EnsAction = EnsAction\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ens-wrapper.js\": {\n            \"title\": \"$:/plugins/ipfs/ens-wrapper.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ens-wrapper.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nENS Wrapper\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n  const name = 'ens-wrapper'\\n\\n  var EnsWrapper = function (ensLibrary) {\\n    this.ensLibrary = ensLibrary\\n  }\\n\\n  EnsWrapper.prototype.getContentHash = async function (domain, web3) {\\n    try {\\n      var { content, protocol } = await this.ensLibrary.getContentHash(domain, web3)\\n      if (content !== null && protocol !== null) {\\n        // Success\\n        return {\\n          content: content,\\n          protocol: protocol,\\n        }\\n      }\\n      $tw.utils.alert(name, 'Unassigned ENS domain content...')\\n      return {\\n        content: null,\\n        protocol: null,\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      throw new Error('Unable to fetch ENS domain content...')\\n    }\\n  }\\n\\n  EnsWrapper.prototype.setContentHash = async function (domain, identifier, web3, account) {\\n    try {\\n      await this.ensLibrary.setContentHash(domain, identifier, web3, account)\\n    } catch (error) {\\n      if (error.name === 'OwnerError' || error.name === 'RejectedUserRequest' || error.name === 'UnauthorizedUserAccount') {\\n        throw error\\n      }\\n      $tw.ipfs.getLogger().error(error)\\n      throw new Error('Unable to set ENS domain content...')\\n    }\\n  }\\n\\n  exports.EnsWrapper = EnsWrapper\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-action.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-action.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-action.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Action\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const ipnsKeyword = 'ipns'\\n\\n  const name = 'ipfs-action'\\n\\n  var IpfsAction = function () {\\n    this.once = false\\n    this.console = false\\n    this.ipnsKey = $tw.utils.getIpnsKey()\\n    this.ipnsCid = $tw.utils.getIpnsCid()\\n  }\\n\\n  IpfsAction.prototype.init = function () {\\n    // Init once\\n    if (this.once) {\\n      return\\n    }\\n    const self = this\\n    // Widget\\n    $tw.rootWidget.addEventListener('tm-ipfs-export', async function (event) {\\n      return await self.handleExportToIpfs(event, false)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipfs-export-content', async function (event) {\\n      return await self.handleExportToIpfs(event, true)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-fetch', async function (event) {\\n      return await self.handleFetchIpnsCid(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-generate', async function (event) {\\n      return await self.handleGenerateIpnsCid(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-console-mobile', async function (event) {\\n      return await self.handleMobileConsole(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipfs-export-attachment', async function (event) {\\n      return await self.handleExportAttachmentToIpfs(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-publish', async function (event) {\\n      return await self.handlePublishToIpns(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-remove', async function (event) {\\n      return await self.handleRemoveIpnsKey(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-rename', async function (event) {\\n      return await self.handleRenameIpnsKey(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipns-resolve-and-open', async function (event) {\\n      return await self.handleResolveIpnsKeyAndOpen(event)\\n    })\\n    // Init once\\n    this.once = true\\n  }\\n\\n  IpfsAction.prototype.handleExportToIpfs = async function (event, child) {\\n    var tiddler = $tw.wiki.getTiddler(event.tiddlerTitle)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    // Do not process if _export_uri is set\\n    const exportUri =\\n      tiddler.fields._export_uri !== undefined && tiddler.fields._export_uri !== null && tiddler.fields._export_uri.trim() !== '' ? tiddler.fields._export_uri.trim() : null\\n    const { content, extension } = await $tw.utils.exportTiddler(tiddler, child)\\n    if (content === undefined || content == null) {\\n      return false\\n    }\\n    var filename = '/'\\n    var incomingName = ''\\n    if ($tw.utils.getWrappedDirectory()) {\\n      try {\\n        var path = null\\n        if (exportUri !== null) {\\n          const { ipnsCid, normalizedUrl } = await $tw.ipfs.resolveUrl(exportUri, false, false, true)\\n          if (ipnsCid !== null) {\\n            const pathname = normalizedUrl.pathname.slice(`/ipns/${ipnsCid}`.length)\\n            if (pathname !== undefined && pathname !== null && pathname.trim() !== '') {\\n              path = pathname.substring(0, pathname.lastIndexOf('/'))\\n              if (path !== undefined && path !== null && path.trim() !== '') {\\n                const incoming = pathname.split('/').pop()\\n                if (incoming !== undefined && incoming !== null && incoming.trim() !== '') {\\n                  incomingName = decodeURI(incoming)\\n                  filename = `${path}/${incomingName}`\\n                }\\n              }\\n            }\\n          }\\n        }\\n        if (filename === '/') {\\n          const url = $tw.ipfs.getUrl(event.tiddlerTitle, $tw.ipfs.getIpfsBaseUrl())\\n          if (path === undefined || path == null || path.trim() === '') {\\n            path = url.pathname.substring(0, url.pathname.lastIndexOf('/'))\\n          }\\n          if (path !== undefined && path !== null && path.trim() !== '') {\\n            const incoming = url.pathname.split('/').pop()\\n            if (incoming !== undefined && incoming !== null && incoming.trim() !== '') {\\n              incomingName = decodeURI(incoming)\\n              filename = `${path}/${incomingName}`\\n            }\\n          }\\n        }\\n      } catch (error) {\\n        // Ignore\\n      }\\n      if (filename === '/') {\\n        incomingName = $tw.ipfs.filenamify(event.tiddlerTitle)\\n        filename = `${filename}${incomingName}`\\n      } else {\\n        incomingName = $tw.ipfs.filenamify(filename.substring(filename.lastIndexOf('/') + 1))\\n        filename = `/${incomingName}`\\n      }\\n      if (filename.endsWith(extension) === false) {\\n        incomingName = `${incomingName}${extension}`\\n        filename = `${filename}${extension}`\\n      }\\n    }\\n    if (child) {\\n      $tw.ipfs.getLogger().info(`Export transcluded content: ${content.length} bytes`)\\n    } else {\\n      $tw.ipfs.getLogger().info(`Export content: ${content.length} bytes`)\\n    }\\n    // Beware async...\\n    $tw.utils.exportToIpfs(tiddler, content, [], '_export_uri', filename, incomingName)\\n  }\\n\\n  IpfsAction.prototype.handleExportAttachmentToIpfs = async function (event) {\\n    const title = event.tiddlerTitle\\n    var tiddler = $tw.wiki.getTiddler(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    // Do not process if _canonical_uri is set and the text field is empty\\n    const canonicalUri = tiddler.fields._canonical_uri\\n    if (canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '') {\\n      $tw.utils.alert(name, 'Attachment is already exported...')\\n      return false\\n    }\\n    if (tiddler.fields.text === undefined || tiddler.fields.text == null || tiddler.fields.text === '') {\\n      $tw.utils.alert(name, 'Empty attachment...')\\n      return false\\n    }\\n    const { type, info } = $tw.utils.getContentType(tiddler)\\n    try {\\n      const content = await $tw.ipfs.processContent(tiddler, tiddler.fields.text, info.encoding, type)\\n      var filename = '/'\\n      var incomingName = ''\\n      if ($tw.utils.getWrappedDirectory()) {\\n        try {\\n          const url = $tw.ipfs.getUrl(title, $tw.ipfs.getIpfsBaseUrl())\\n          const path = url.pathname.substring(0, url.pathname.lastIndexOf('/'))\\n          if (path !== undefined && path !== null && path.trim() !== '') {\\n            const incoming = url.pathname.split('/').pop()\\n            if (incoming !== undefined && incoming !== null && incoming.trim() !== '') {\\n              incomingName = decodeURI(incoming)\\n              filename = `${path}/${incomingName}`\\n            }\\n          }\\n        } catch (error) {\\n          // Ignore\\n        }\\n        if (filename === '/') {\\n          incomingName = $tw.ipfs.filenamify(tiddler.fields.title)\\n          filename = `${filename}${incomingName}`\\n        } else {\\n          incomingName = $tw.ipfs.filenamify(filename.substring(filename.lastIndexOf('/') + 1))\\n          filename = `/${incomingName}`\\n        }\\n        if (filename.endsWith(info.extension) === false) {\\n          incomingName = `${incomingName}${info.extension}`\\n          filename = `${filename}${info.extension}`\\n        }\\n      }\\n      const fields = [{ key: 'text', value: '' }]\\n      // Beware async...\\n      $tw.utils.exportToIpfs(tiddler, content, fields, '_canonical_uri', filename, incomingName)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handleRenameIpnsKey = async function (event) {\\n    var ipnsCid = null\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    if (this.ipnsKey == null || this.ipnsKey === ipnsKey) {\\n      $tw.utils.alert(name, 'Nothing to rename....')\\n      return false\\n    }\\n    try {\\n      var { ipnsCid, ipnsKey } = await $tw.ipfs.renameIpnsKey(this.ipnsKey, ipnsKey)\\n      $tw.utils.alert(name, `Renamed IPNS key: '${ipnsKey}'...`)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/cid')\\n    if (tiddler !== undefined && this.ipnsCid !== ipnsCid) {\\n      tiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: ipnsCid }],\\n      })\\n      $tw.wiki.addTiddler(tiddler)\\n    }\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/key')\\n    if (tiddler !== undefined && this.ipnsKey !== ipnsKey) {\\n      tiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: ipnsKey }],\\n      })\\n      $tw.wiki.addTiddler(tiddler)\\n    }\\n    this.ipnsCid = ipnsCid\\n    this.ipnsKey = ipnsKey\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handleGenerateIpnsCid = async function (event) {\\n    var ipnsCid = null\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    try {\\n      var ipnsCid = await $tw.ipfs.generateIpnsCid(ipnsKey)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/cid')\\n    if (tiddler !== undefined && this.ipnsCid !== ipnsCid) {\\n      tiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: ipnsCid }],\\n      })\\n      $tw.wiki.addTiddler(tiddler)\\n    }\\n    this.ipnsCid = ipnsCid\\n    this.ipnsKey = ipnsKey\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handleRemoveIpnsKey = async function (event) {\\n    var resolvedUrl = null\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    try {\\n      var { resolvedUrl } = await $tw.ipfs.resolveUrl(`/ipns/${ipnsKey}`, $tw.utils.getIpnsResolve(), false, true)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    // Async\\n    $tw.ipfs\\n      .addToUnpin(resolvedUrl !== null ? resolvedUrl.pathname : null)\\n      .then(unpin => {\\n        $tw.ipfs\\n          .removeIpnsKey(ipnsKey)\\n          .then(data => {\\n            $tw.utils.alert(name, `Removed IPNS key: '${ipnsKey}'...`)\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n            $tw.utils.alert(name, error.message)\\n          })\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/key')\\n    if (tiddler !== undefined) {\\n      const updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: '' }],\\n      })\\n      $tw.wiki.addTiddler(updatedTiddler)\\n    }\\n    tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/cid')\\n    if (tiddler !== undefined) {\\n      const updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: '' }],\\n      })\\n      $tw.wiki.addTiddler(updatedTiddler)\\n    }\\n    this.ipnsCid = null\\n    this.ipnsKey = null\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handleFetchIpnsCid = async function (event) {\\n    var ipnsCid = null\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    try {\\n      var { ipnsCid } = await $tw.ipfs.getIpnsIdentifier(ipnsKey)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/cid')\\n    if (tiddler !== undefined && this.ipnsCid !== ipnsCid) {\\n      tiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: ipnsCid }],\\n      })\\n      $tw.wiki.addTiddler(tiddler)\\n    }\\n    this.ipnsCid = ipnsCid\\n    this.ipnsKey = ipnsKey\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handleResolveIpnsKeyAndOpen = async function (event) {\\n    var ipnsCid = null\\n    var resolvedUrl = null\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    try {\\n      var { ipnsCid, resolvedUrl } = await $tw.ipfs.resolveUrl(`${ipnsKeyword}://${ipnsKey}`, $tw.utils.getIpnsResolve(), false, false)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/cid')\\n    if (tiddler !== undefined && ipnsCid !== null && this.ipnsCid !== ipnsCid) {\\n      tiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: ipnsCid }],\\n      })\\n      $tw.wiki.addTiddler(tiddler)\\n    }\\n    if (ipnsCid !== null) {\\n      this.ipnsCid = ipnsCid\\n    }\\n    if (resolvedUrl !== null) {\\n      window.open(resolvedUrl.href, '_blank', 'noopener,noreferrer')\\n    }\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handleMobileConsole = async function (event) {\\n    // Show or Hide\\n    if (typeof globalThis.eruda !== 'undefined') {\\n      if (this.console === false) {\\n        globalThis.eruda.show()\\n        globalThis.eruda.show('console')\\n        this.console = true\\n      } else {\\n        globalThis.eruda.hide()\\n        this.console = false\\n      }\\n      $tw.rootWidget.refresh($tw.utils.getChangedTiddler('$:/core/ui/Buttons/ipfs/console/mobile'))\\n      return true\\n    }\\n    // Load library\\n    try {\\n      if (typeof globalThis.eruda === 'undefined') {\\n        await $tw.ipfs.loadErudaLibrary()\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    const erudaContainer = window.document.createElement('div')\\n    window.document.body.appendChild(erudaContainer)\\n    globalThis.eruda.init({\\n      container: erudaContainer,\\n      tool: ['console'],\\n      useShadowDom: true,\\n      autoScale: true,\\n    })\\n    // Inherit font\\n    erudaContainer.style.fontFamily = 'inherit'\\n    // Preserve user preference if any, default is 80\\n    if (globalThis.eruda.get().config.get('displaySize') === 80) {\\n      globalThis.eruda.get().config.set('displaySize', 40)\\n    }\\n    // Preserve user preference if any, default is 0.95\\n    if (globalThis.eruda.get().config.get('transparency') === 0.95) {\\n      globalThis.eruda.get().config.set('transparency', 1)\\n    }\\n    // Hide Eruda button\\n    if (globalThis.eruda._shadowRoot !== undefined) {\\n      const btn = globalThis.eruda._shadowRoot.querySelector('.eruda-entry-btn')\\n      if (btn !== undefined) {\\n        btn.style.display = 'none'\\n      }\\n    }\\n    // Init Logger\\n    const log = window.log.getLogger('eruda')\\n    if ($tw.utils.getIpfsVerbose()) {\\n      log.setLevel('info', false)\\n    } else {\\n      log.setLevel('warn', false)\\n    }\\n    // Log\\n    log.info('Mobile console has been loaded...')\\n    // Show\\n    globalThis.eruda.show()\\n    globalThis.eruda.show('console')\\n    this.console = true\\n    $tw.rootWidget.refresh($tw.utils.getChangedTiddler('$:/core/ui/Buttons/ipfs/console/mobile'))\\n    return true\\n  }\\n\\n  IpfsAction.prototype.handlePublishToIpns = async function (event) {\\n    var ipnsCid = null\\n    var resolvedurl = null\\n    var wikiCid = null\\n    var wikiIpnsCid = null\\n    const wiki = $tw.ipfs.getDocumentUrl()\\n    var ipnsKey = $tw.utils.getIpnsKey()\\n    if (ipnsKey == null) {\\n      $tw.utils.alert(name, 'Undefined IPNS key....')\\n      return false\\n    }\\n    try {\\n      var { ipfsCid: wikiCid, ipnsCid: wikiIpnsCid } = await $tw.ipfs.resolveUrl(wiki, true, false, true)\\n      var { ipnsCid, resolvedUrl } = await $tw.ipfs.resolveUrl(`${ipnsKeyword}://${ipnsKey}`, $tw.utils.getIpnsResolve(), false, false)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n      return false\\n    }\\n    if (wikiCid == null && wikiIpnsCid == null) {\\n      $tw.utils.alert(name, 'Undefined IPFS identifier...')\\n      return false\\n    }\\n    if (wikiIpnsCid !== null && wikiIpnsCid === ipnsCid) {\\n      $tw.utils.alert(name, 'Default IPNS cid matches current IPNS cid....')\\n      return false\\n    }\\n    $tw.ipfs\\n      .publishIpnsKey(wikiCid, ipnsCid, ipnsKey)\\n      .then(data => {\\n        $tw.utils.alert(name, 'Published IPNS key: ' + ipnsKey)\\n        $tw.ipfs.addToUnpin(resolvedurl !== null ? resolvedUrl.pathname : null)\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n    return true\\n  }\\n\\n  exports.IpfsAction = IpfsAction\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-bundle.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-bundle.js\",\n            \"text\": \"(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.IpfsBundle = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\\\"function\\\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\\\"Cannot find module '\\\"+i+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\\\"function\\\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\\n/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-bundle.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Bundle\\n\\n\\\\*/\\n'use strict';\\n\\nrequire(\\\"core-js/modules/es.typed-array.uint8-array.js\\\");\\n\\nrequire(\\\"core-js/modules/es.string.replace.js\\\");\\n\\nrequire(\\\"core-js/modules/web.dom-collections.iterator.js\\\");\\n\\nrequire(\\\"core-js/modules/web.url.js\\\");\\n\\nrequire(\\\"core-js/modules/web.url.to-json.js\\\");\\n\\nconst CID = require('cids');\\n\\nconst uint8ArrayFromString = require('uint8arrays/from-string');\\n\\nconst EnsLibrary = require('core/modules/library/ipfs-bundle/ens-library.js').EnsLibrary;\\n\\nconst EthereumLibrary = require('core/modules/library/ipfs-bundle/ethereum-library.js').EthereumLibrary;\\n\\nconst IpfsLibrary = require('core/modules/library/ipfs-bundle/ipfs-library.js').IpfsLibrary;\\n\\nconst IpfsLoader = require('core/modules/library/ipfs-bundle/ipfs-loader.js').IpfsLoader;\\n\\nconst IpfsUrl = require('core/modules/library/ipfs-bundle/ipfs-url.js').IpfsUrl;\\n\\nconst cidInspector = 'https://cid.ipfs.io/#';\\nconst libp2pKey = 'libp2p-key';\\nconst dagPb = 'dag-pb';\\n\\nvar IpfsBundle = function () {\\n  this.once = false;\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n\\n  this.name = 'ipfs-bundle';\\n};\\n\\nIpfsBundle.prototype.getLogger = function () {\\n  const log = globalThis.log !== undefined && globalThis.log !== null ? globalThis.log : null;\\n\\n  if (log !== undefined && log !== null) {\\n    const loggers = log.getLoggers();\\n    const eruda = loggers.eruda;\\n\\n    if (eruda !== undefined && eruda !== null) {\\n      return eruda;\\n    }\\n\\n    var ipfs = loggers.ipfs;\\n\\n    if (ipfs === undefined || ipfs == null) {\\n      ipfs = log.getLogger('ipfs');\\n      ipfs.setLevel('info', false);\\n      ipfs.info('Loglevel is starting up...');\\n    }\\n\\n    return ipfs;\\n  }\\n\\n  return console;\\n};\\n\\nIpfsBundle.prototype.init = function () {\\n  // Init once\\n  if (this.once) {\\n    return;\\n  }\\n\\n  this.ipfsLoader = new IpfsLoader(this);\\n  this.ethereumLibrary = new EthereumLibrary(this);\\n  this.ethereumLibrary.init();\\n  this.ensLibrary = new EnsLibrary(this);\\n  this.ipfsLibrary = new IpfsLibrary(this);\\n  this.ipfsUrl = new IpfsUrl(this); // Init once\\n\\n  this.once = true;\\n};\\n\\nIpfsBundle.prototype.filenamify = function (name, options) {\\n  return this.ipfsUrl.filenamify(name, options);\\n};\\n\\nIpfsBundle.prototype.getBase = function (base) {\\n  return this.ipfsUrl.getBase(base);\\n};\\n\\nIpfsBundle.prototype.getIpfsBaseUrl = function () {\\n  return this.ipfsUrl.getIpfsBaseUrl();\\n};\\n\\nIpfsBundle.prototype.normalizeUrl = function (value, base) {\\n  return this.ipfsUrl.normalizeUrl(value, base);\\n};\\n\\nIpfsBundle.prototype.getDocumentUrl = function () {\\n  return this.ipfsUrl.getDocumentUrl();\\n};\\n\\nIpfsBundle.prototype.getIpfsDefaultApiUrl = function () {\\n  return this.ipfsUrl.getIpfsDefaultApiUrl();\\n};\\n\\nIpfsBundle.prototype.getIpfsDefaultGatewayUrl = function () {\\n  return this.ipfsUrl.getIpfsDefaultGatewayUrl();\\n};\\n\\nIpfsBundle.prototype.getIpfsDefaultApi = function () {\\n  return this.ipfsUrl.getIpfsDefaultApi();\\n};\\n\\nIpfsBundle.prototype.getIpfsDefaultGateway = function () {\\n  return this.ipfsUrl.getIpfsDefaultGateway();\\n};\\n\\nIpfsBundle.prototype.getIpfsApiUrl = function () {\\n  return this.ipfsUrl.getIpfsApiUrl();\\n};\\n\\nIpfsBundle.prototype.getIpfsGatewayUrl = function () {\\n  return this.ipfsUrl.getIpfsGatewayUrl();\\n};\\n\\nIpfsBundle.prototype.getUrl = function (url, base) {\\n  return this.ipfsUrl.getUrl(url, base);\\n};\\n\\nIpfsBundle.prototype.getENSRegistry = function () {\\n  return this.ensLibrary.getENSRegistry();\\n};\\n\\nIpfsBundle.prototype.getBlockExplorerRegistry = function () {\\n  return this.ethereumLibrary.getBlockExplorerRegistry();\\n};\\n\\nIpfsBundle.prototype.getNetworkRegistry = function () {\\n  return this.ethereumLibrary.getNetworkRegistry();\\n};\\n\\nIpfsBundle.prototype.loadErudaLibrary = async function () {\\n  try {\\n    if (typeof globalThis.eruda === 'undefined') {\\n      await this.ipfsLoader.loadErudaLibrary();\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  if (typeof globalThis.eruda === 'undefined') {\\n    throw new Error('Unavailable Eruda library...');\\n  }\\n};\\n\\nIpfsBundle.prototype.loadEthSigUtilLibrary = async function () {\\n  try {\\n    if (typeof globalThis.sigUtil === 'undefined') {\\n      await this.ipfsLoader.loadEthSigUtilLibrary();\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  if (typeof globalThis.sigUtil === 'undefined') {\\n    throw new Error('Unavailable eth-sig-util library...');\\n  }\\n};\\n\\nIpfsBundle.prototype.loadEthersJsLibrary = async function () {\\n  try {\\n    if (typeof globalThis.ethers === 'undefined') {\\n      await this.ipfsLoader.loadEtherJsLibrary();\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  if (typeof globalThis.ethers === 'undefined') {\\n    throw new Error('Unavailable Ethereum library...');\\n  }\\n};\\n\\nIpfsBundle.prototype.loadIpfsHttpLibrary = async function () {\\n  try {\\n    if (typeof globalThis.IpfsHttpClient === 'undefined') {\\n      await this.ipfsLoader.loadIpfsHttpLibrary();\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  if (typeof globalThis.IpfsHttpClient === 'undefined') {\\n    throw new Error('Unavailable IPFS HTTP Client library...');\\n  }\\n};\\n\\nIpfsBundle.prototype.isJson = function (content) {\\n  return this.ipfsLoader.isJson(content);\\n};\\n\\nIpfsBundle.prototype.loadToBase64 = async function (url, password) {\\n  return await this.ipfsLoader.loadToBase64(url, password);\\n};\\n\\nIpfsBundle.prototype.loadToUtf8 = async function (url, password) {\\n  return await this.ipfsLoader.loadToUtf8(url, password);\\n};\\n\\nIpfsBundle.prototype.fetchUint8Array = async function (url) {\\n  return await this.ipfsLoader.fetchUint8Array(url);\\n};\\n\\nIpfsBundle.prototype.getPublicEncryptionKey = async function (provider) {\\n  try {\\n    return await this.ethereumLibrary.getPublicEncryptionKey(provider);\\n  } catch (error) {\\n    if (error.name === 'RejectedUserRequest') {\\n      throw error;\\n    }\\n\\n    this.getLogger().error(error);\\n    throw new Error('Unable to retrieve an Ethereum Public Encryption Key...');\\n  }\\n};\\n\\nIpfsBundle.prototype.personalRecover = async function (message, signature) {\\n  return await this.ethereumLibrary.personalRecover(message, signature);\\n};\\n\\nIpfsBundle.prototype.personalSign = async function (message, provider) {\\n  try {\\n    return await this.ethereumLibrary.personalSign(message, provider);\\n  } catch (error) {\\n    if (error.name === 'RejectedUserRequest') {\\n      throw error;\\n    }\\n\\n    this.getLogger().error(error);\\n    throw new Error('Unable to sign content...');\\n  }\\n};\\n\\nIpfsBundle.prototype.decrypt = async function (text, provider) {\\n  try {\\n    return await this.ethereumLibrary.decrypt(text, provider);\\n  } catch (error) {\\n    if (error.name === 'RejectedUserRequest') {\\n      throw error;\\n    }\\n\\n    this.getLogger().error(error);\\n    throw new Error('Unable to decrypt content...');\\n  }\\n};\\n\\nIpfsBundle.prototype.getBlockExplorerRegistry = function () {\\n  return this.ethereumLibrary.getBlockExplorerRegistry();\\n};\\n\\nIpfsBundle.prototype.getEnabledWeb3Provider = async function (provider) {\\n  return await this.ethereumLibrary.getEnabledWeb3Provider(provider);\\n};\\n\\nIpfsBundle.prototype.getWeb3Provider = async function (provider) {\\n  return await this.ethereumLibrary.getWeb3Provider(provider);\\n};\\n\\nIpfsBundle.prototype.isEnsOwner = async function (domain, web3, account) {\\n  return await this.ensLibrary.isOwner(domain, web3, account);\\n};\\n/*\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md\\n * https://eips.ethereum.org/EIPS/eip-1193\\n * https://docs.metamask.io/guide/ethereum-provider.html#methods-current-api\\n */\\n\\n\\nIpfsBundle.prototype.getEthereumProvider = async function () {\\n  return await this.ethereumLibrary.getEthereumProvider();\\n};\\n\\nIpfsBundle.prototype.getEnabledWeb3Provider = async function () {\\n  var account = null;\\n  var chainId = null;\\n  var web3 = null;\\n  const explorer = this.getBlockExplorerRegistry();\\n  const network = this.getNetworkRegistry();\\n  const provider = await this.getEthereumProvider();\\n\\n  try {\\n    var {\\n      account,\\n      chainId,\\n      web3\\n    } = await this.ethereumLibrary.getEnabledWeb3Provider(provider);\\n  } catch (error) {\\n    if (error.name === 'RejectedUserRequest') {\\n      throw error;\\n    }\\n\\n    this.getLogger().error(error);\\n    throw new Error('Unable to retrieve an enabled Ethereum Provider...');\\n  } // Log\\n\\n\\n  this.getLogger().info(`New Enabled Web3 provider:\\nChain: ${network[chainId]}\\nAccount: ${explorer[chainId]}/address/${account}`);\\n  return {\\n    account: account,\\n    chainId: chainId,\\n    provider: provider,\\n    web3: web3\\n  };\\n};\\n\\nIpfsBundle.prototype.getWeb3Provider = async function () {\\n  var chainId = null;\\n  var web3 = null;\\n  const network = this.getNetworkRegistry();\\n  const provider = await this.getEthereumProvider();\\n\\n  try {\\n    var {\\n      web3,\\n      chainId\\n    } = await this.ethereumLibrary.getWeb3Provider(provider);\\n  } catch (error) {\\n    this.getLogger().error(error);\\n    throw new Error('Unable to retrieve an Ethereum Provider...');\\n  } // Log\\n\\n\\n  this.getLogger().info(`New Web3 provider:\\n${network[chainId]}`);\\n  return {\\n    chainId: chainId,\\n    provider: provider,\\n    web3: web3\\n  };\\n};\\n\\nIpfsBundle.prototype.decode = function (b64) {\\n  return Base64Binary.decode(b64);\\n}; // https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer/21797381\\n// https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\\n\\n/*\\n * Copyright (c) 2011, Daniel Guerrero\\n * All rights reserved.\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n * Redistributions of source code must retain the above copyright\\n * notice, this list of conditions and the following disclaimer.\\n * Redistributions in binary form must reproduce the above copyright\\n * notice, this list of conditions and the following disclaimer in the\\n * documentation and/or other materials provided with the distribution.\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND\\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL DANIEL GUERRERO BE LIABLE FOR ANY\\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n/**\\n * Uses the new array typed in javascript to binary base64 encode/decode\\n * at the moment just decodes a binary base64 encoded\\n * into either an ArrayBuffer (decodeArrayBuffer)\\n * or into an Uint8Array (decode)\\n *\\n * References:\\n * https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer\\n * https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array\\n */\\n\\n\\nvar Base64Binary = {\\n  _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\\n\\n  /* will return a  Uint8Array type */\\n  decodeArrayBuffer: function (input) {\\n    var bytes = input.length / 4 * 3;\\n    var ab = new ArrayBuffer(bytes);\\n    this.decode(input, ab);\\n    return ab;\\n  },\\n  removePaddingChars: function (input) {\\n    var lkey = this._keyStr.indexOf(input.charAt(input.length - 1));\\n\\n    if (lkey === 64) {\\n      return input.substring(0, input.length - 1);\\n    }\\n\\n    return input;\\n  },\\n  decode: function (input, ab) {\\n    //get last chars to see if are valid\\n    input = this.removePaddingChars(input);\\n    input = this.removePaddingChars(input);\\n    var bytes = parseInt(input.length / 4 * 3, 10);\\n    var ua;\\n    var chr1, chr2, chr3;\\n    var enc1, enc2, enc3, enc4;\\n    var i = 0;\\n    var j = 0;\\n    if (ab) ua = new Uint8Array(ab);else ua = new Uint8Array(bytes);\\n    /*eslint no-useless-escape:\\\"off\\\"*/\\n\\n    input = input.replace(/[^A-Za-z0-9\\\\+\\\\/\\\\=]/g, '');\\n\\n    for (i = 0; i < bytes; i += 3) {\\n      //get the 3 octects in 4 ascii chars\\n      enc1 = this._keyStr.indexOf(input.charAt(j++));\\n      enc2 = this._keyStr.indexOf(input.charAt(j++));\\n      enc3 = this._keyStr.indexOf(input.charAt(j++));\\n      enc4 = this._keyStr.indexOf(input.charAt(j++));\\n      chr1 = enc1 << 2 | enc2 >> 4;\\n      chr2 = (enc2 & 15) << 4 | enc3 >> 2;\\n      chr3 = (enc3 & 3) << 6 | enc4;\\n      ua[i] = chr1;\\n      if (enc3 !== 64) ua[i + 1] = chr2;\\n      if (enc4 !== 64) ua[i + 2] = chr3;\\n    }\\n\\n    return ua;\\n  }\\n};\\n\\nIpfsBundle.prototype.analyzePinType = function (type) {\\n  return this.ipfsLibrary.analyzePinType(type);\\n};\\n\\nIpfsBundle.prototype.addAll = async function (client, source, options) {\\n  return await this.ipfsLibrary.addAll(client, source, options);\\n};\\n\\nIpfsBundle.prototype.hasPin = async function (client, key, type, ipfsPath) {\\n  return await this.ipfsLibrary.hasPin(client, key, type, ipfsPath);\\n};\\n\\nIpfsBundle.prototype.dagGet = async function (client, cid, options) {\\n  return await this.ipfsLibrary.dagGet(client, cid, options);\\n};\\n\\nIpfsBundle.prototype.dagPut = async function (client, dagNode, options) {\\n  return await this.ipfsLibrary.dagPut(client, dagNode, options);\\n};\\n\\nIpfsBundle.prototype.dagResolve = async function (client, ipfsPath, timeout) {\\n  return await this.ipfsLibrary.dagResolve(client, ipfsPath, timeout);\\n};\\n\\nIpfsBundle.prototype.filesStat = async function (client, ipfsPath, timeout) {\\n  return await this.ipfsLibrary.filesStat(client, ipfsPath, timeout);\\n};\\n\\nIpfsBundle.prototype.get = async function (client, ipfsPath, timeout) {\\n  return await this.ipfsLibrary.get(client, ipfsPath, timeout);\\n};\\n\\nIpfsBundle.prototype.isDirectory = function (ua) {\\n  return this.ipfsLibrary.isDirectory(ua);\\n};\\n\\nIpfsBundle.prototype.isIpfsDirectory = async function (client, cid, timeout) {\\n  return await this.ipfsLibrary.isIpfsDirectory(client, cid, timeout);\\n};\\n\\nIpfsBundle.prototype.ls = async function (client, ipfsPath) {\\n  return await this.ipfsLibrary.ls(client, ipfsPath);\\n};\\n\\nIpfsBundle.prototype.namePublish = async function (client, ipnsKey, cid, options) {\\n  return await this.ipfsLibrary.namePublish(client, ipnsKey, cid, options);\\n};\\n\\nIpfsBundle.prototype.nameResolve = async function (client, value, options) {\\n  return await this.ipfsLibrary.nameResolve(client, value, options);\\n};\\n\\nIpfsBundle.prototype.objectData = async function (client, cid, timeout) {\\n  return await this.ipfsLibrary.objectData(client, cid, timeout);\\n};\\n\\nIpfsBundle.prototype.objectStat = async function (client, cid, timeout) {\\n  return await this.ipfsLibrary.objectStat(client, cid, timeout);\\n};\\n\\nIpfsBundle.prototype.pinAdd = async function (client, ipfsPath, options) {\\n  return await this.ipfsLibrary.pinAdd(client, ipfsPath, options);\\n};\\n\\nIpfsBundle.prototype.pinRm = async function (client, ipfsPath, options) {\\n  return await this.ipfsLibrary.pinRm(client, ipfsPath, options);\\n};\\n\\nIpfsBundle.prototype.resolveIpfs = async function (client, value, timeout) {\\n  if (value === undefined || value == null || value.toString().trim() === '') {\\n    return {\\n      cid: null,\\n      remainderPath: ''\\n    };\\n  }\\n\\n  if (value instanceof URL === false) {\\n    try {\\n      value = this.getUrl(value, this.getIpfsBaseUrl());\\n    } catch (error) {\\n      return {\\n        cid: null,\\n        remainderPath: ''\\n      };\\n    }\\n  } // Pathname\\n\\n\\n  var cid = null;\\n  var ipfsPath = null;\\n  var {\\n    ipfsCid: cid,\\n    ipnsIdentifier,\\n    path\\n  } = this.decodePathname(value.pathname);\\n\\n  if (cid !== null) {\\n    ipfsPath = `/ipfs/${cid}${path}`;\\n  } else if (ipnsIdentifier !== null) {\\n    ipfsPath = `/ipns/${ipnsIdentifier}${path}`;\\n  }\\n\\n  if (ipfsPath !== null) {\\n    var {\\n      cid,\\n      remainderPath\\n    } = await this.dagResolve(client, ipfsPath, timeout);\\n    return {\\n      cid: cid,\\n      remainderPath: remainderPath\\n    };\\n  } // Hostname\\n\\n\\n  var {\\n    ipfsCid: cid,\\n    ipnsIdentifier,\\n    path\\n  } = this.decodeHostname(value.hostname);\\n\\n  if (cid !== null) {\\n    ipfsPath = `/ipfs/${cid}${path}`;\\n  } else if (ipnsIdentifier !== null) {\\n    ipfsPath = `/ipns/${ipnsIdentifier}${path}`;\\n  }\\n\\n  if (ipfsPath !== null) {\\n    var {\\n      cid,\\n      remainderPath\\n    } = await this.dagResolve(client, ipfsPath, timeout);\\n    return {\\n      cid: cid,\\n      remainderPath: remainderPath\\n    };\\n  }\\n\\n  return {\\n    cid: null,\\n    remainderPath: ''\\n  };\\n};\\n\\nIpfsBundle.prototype.resolveIpfsContainer = async function (client, value, timeout) {\\n  if (value === undefined || value == null || value.toString().trim() === '') {\\n    return null;\\n  }\\n\\n  if (value instanceof URL === false) {\\n    try {\\n      value = this.getUrl(value, this.getIpfsBaseUrl());\\n    } catch (error) {\\n      return null;\\n    }\\n  }\\n\\n  const self = this;\\n\\n  const resolveContainer = async function (client, ipfsPath, base, timeout) {\\n    const currentUrl = self.getUrl(ipfsPath, base);\\n    const {\\n      cid\\n    } = await self.resolveIpfs(client, currentUrl, timeout);\\n\\n    if (cid == null) {\\n      return null;\\n    }\\n\\n    if (await self.isIpfsDirectory(client, cid, timeout)) {\\n      return cid;\\n    }\\n\\n    var nextPath = '';\\n    const members = value.pathname.split('/');\\n\\n    for (var i = 0; i < members.length; i++) {\\n      if (members[i].trim() === '') {\\n        continue;\\n      }\\n\\n      if (i !== members.length - 1) {\\n        nextPath = `${nextPath}/${members[i]}`;\\n      }\\n    }\\n\\n    const nextUrl = self.getUrl(nextPath, base);\\n    const innerCid = await self.resolveIpfsContainer(client, nextUrl, timeout);\\n\\n    if (innerCid == null) {\\n      return cid;\\n    }\\n\\n    return innerCid;\\n  };\\n\\n  const base = this.getUrl(`${value.protocol}//${value.host}`); // Pathname\\n\\n  var ipfsPath = null;\\n  var {\\n    ipfsCid: innerCid,\\n    ipnsIdentifier,\\n    path\\n  } = this.decodePathname(value.pathname);\\n\\n  if (innerCid !== null) {\\n    ipfsPath = `/ipfs/${innerCid}${path}`;\\n  } else if (ipnsIdentifier !== null) {\\n    ipfsPath = `/ipns/${ipnsIdentifier}${path}`;\\n  }\\n\\n  if (ipfsPath !== null) {\\n    return await resolveContainer(client, ipfsPath, base, timeout);\\n  } // Hostname\\n\\n\\n  var {\\n    ipfsCid: innerCid,\\n    ipnsIdentifier,\\n    path\\n  } = this.decodeHostname(value.hostname);\\n\\n  if (innerCid !== null) {\\n    ipfsPath = `/ipfs/${innerCid}${path}`;\\n  } else if (ipnsIdentifier !== null) {\\n    ipfsPath = `/ipns/${ipnsIdentifier}${path}`;\\n  }\\n\\n  if (ipfsPath !== null) {\\n    return await resolveContainer(client, ipfsPath, base, timeout);\\n  }\\n\\n  return null;\\n};\\n\\nIpfsBundle.prototype.getIpfsIdentifier = function (value) {\\n  if (value === undefined || value == null) {\\n    return {\\n      hostname: null,\\n      ipfsCid: null,\\n      ipnsIdentifier: null,\\n      ipfsPath: ''\\n    };\\n  }\\n\\n  if (value instanceof CID) {\\n    return {\\n      hostname: null,\\n      ipfsCid: value,\\n      ipnsIdentifier: null,\\n      ipfsPath: ''\\n    };\\n  }\\n\\n  var ipfsCid = null;\\n  var hostname = null;\\n  var ipnsIdentifier = null;\\n  var path = null;\\n  var url = null;\\n\\n  if (value instanceof URL === false) {\\n    try {\\n      url = this.getUrl(encodeURI(value), this.getIpfsBaseUrl());\\n    } catch (error) {\\n      url = null;\\n    }\\n  } else {\\n    url = value;\\n  }\\n\\n  if (url !== null) {\\n    var {\\n      hostname,\\n      ipfsCid,\\n      ipnsIdentifier,\\n      path\\n    } = this.decodeUrl(url);\\n  } else {\\n    var {\\n      hostname,\\n      ipfsCid,\\n      ipnsIdentifier,\\n      path\\n    } = this.decodeHostname(value);\\n\\n    if (ipfsCid == null && ipnsIdentifier == null) {\\n      var {\\n        ipfsCid,\\n        ipnsIdentifier,\\n        path\\n      } = this.decodePathname(value);\\n    }\\n  }\\n\\n  return {\\n    hostname: hostname,\\n    ipfsCid: ipfsCid,\\n    ipnsIdentifier: ipnsIdentifier,\\n    ipfsPath: path !== undefined && path !== null ? path : ''\\n  };\\n};\\n\\nIpfsBundle.prototype.decodeUrl = function (url) {\\n  url = url !== undefined && url !== null && url.toString().trim() !== '' ? url : null;\\n\\n  if (url instanceof URL === false) {\\n    return {\\n      hostname: null,\\n      ipfsCid: null,\\n      ipnsIdentifier: null,\\n      path: ''\\n    };\\n  }\\n\\n  var hostname = null;\\n  var ipfsCid = null;\\n  var ipnsIdentifier = null;\\n  var protocol = null;\\n  var path = `${url.pathname}${url.search}${url.hash}`;\\n\\n  if (url.protocol === 'ipfs:' || url.protocol === 'ipns:') {\\n    if (url.hostname !== undefined && url.hostname !== null && url.hostname.trim() !== '') {\\n      if (url.protocol === 'ipns:') {\\n        ipnsIdentifier = url.hostname;\\n        protocol = 'ipns';\\n      } else if (url.protocol === 'ipfs:' && this.getCid(url.hostname) !== null) {\\n        ipfsCid = url.hostname;\\n        protocol = 'ipfs';\\n      }\\n    } else if (url.pathname !== undefined && url.pathname !== null && url.pathname.trim() !== '') {\\n      var pathname = null;\\n\\n      if (url.pathname.startsWith('//')) {\\n        pathname = `/${protocol}/${url.pathname.slice(2)}${url.search}${url.hash}`;\\n      } else {\\n        pathname = `/${protocol}/${url.pathname}${url.search}${url.hash}`;\\n      }\\n\\n      var {\\n        ipfsCid,\\n        ipnsIdentifier,\\n        path\\n      } = this.decodePathname(pathname);\\n    }\\n\\n    return {\\n      hostname: null,\\n      ipfsCid: ipfsCid,\\n      ipnsIdentifier: ipnsIdentifier,\\n      path: path\\n    };\\n  }\\n\\n  var {\\n    hostname,\\n    ipfsCid,\\n    ipnsIdentifier\\n  } = this.decodeHostname(url.hostname);\\n\\n  if (ipfsCid == null && ipnsIdentifier == null) {\\n    var {\\n      ipfsCid,\\n      ipnsIdentifier,\\n      path: innerPath\\n    } = this.decodePathname(url.pathname);\\n\\n    if (innerPath !== null) {\\n      path = `${innerPath}${url.search}${url.hash}`;\\n    }\\n  }\\n\\n  return {\\n    hostname: hostname,\\n    ipfsCid: ipfsCid,\\n    ipnsIdentifier: ipnsIdentifier,\\n    path: path\\n  };\\n};\\n\\nIpfsBundle.prototype.decodePathname = function (pathname) {\\n  pathname = pathname !== undefined && pathname !== null && pathname.trim() !== '' ? decodeURI(pathname.trim()) : null;\\n\\n  if (pathname == null || pathname === '/') {\\n    return {\\n      ipfsCid: null,\\n      ipnsIdentifier: null,\\n      path: pathname\\n    };\\n  }\\n\\n  var identifier = null;\\n  var protocol = null;\\n  var path = ''; // Parse\\n\\n  const members = pathname.split('/');\\n\\n  for (var i = 0; i < members.length; i++) {\\n    if (members[i].trim() === '') {\\n      continue;\\n    }\\n\\n    if (protocol == null) {\\n      protocol = members[i];\\n      continue;\\n    }\\n\\n    if (identifier == null) {\\n      identifier = members[i];\\n      continue;\\n    }\\n\\n    path = `${path}/${members[i]}`;\\n  }\\n\\n  if (pathname.slice(-1) === '/') {\\n    path = `${path}/`;\\n  }\\n\\n  if (protocol == null || identifier == null) {\\n    return {\\n      ipfsCid: null,\\n      ipnsIdentifier: null,\\n      path: pathname\\n    };\\n  }\\n\\n  var ipfsCid = null;\\n  var ipnsIdentifier = null;\\n\\n  if (protocol === 'ipns' || protocol === 'ipns:') {\\n    ipnsIdentifier = identifier;\\n  } else if ((protocol === 'ipfs' || protocol === 'ipfs:') && this.getCid(identifier) !== null) {\\n    ipfsCid = identifier;\\n  } else {\\n    protocol = null;\\n  }\\n\\n  return {\\n    ipfsCid: ipfsCid,\\n    ipnsIdentifier: ipnsIdentifier,\\n    path: protocol !== null ? path : pathname\\n  };\\n};\\n\\nIpfsBundle.prototype.decodeHostname = function (hostname) {\\n  hostname = hostname !== undefined && hostname !== null && hostname.trim() !== '' ? hostname.trim() : null;\\n\\n  if (hostname == null) {\\n    return {\\n      hostname: null,\\n      ipfsCid: null,\\n      ipnsIdentifier: null,\\n      path: '/'\\n    };\\n  }\\n\\n  var domain = null;\\n  var identifier = null;\\n  var protocol = null;\\n  var path = '/'; // Parse\\n\\n  const members = hostname.split('.');\\n\\n  for (var i = 0; i < members.length; i++) {\\n    if (members[i].trim() === '') {\\n      continue;\\n    }\\n\\n    if (identifier == null) {\\n      identifier = members[i];\\n      continue;\\n    }\\n\\n    if (protocol == null) {\\n      protocol = members[i];\\n      continue;\\n    }\\n\\n    const search = members[i].split('/', 1);\\n\\n    if (search[0] !== members[i]) {\\n      if (domain) {\\n        domain = `${domain}.${search[0]}`;\\n      } else {\\n        domain = search[0];\\n      }\\n\\n      path = search[1];\\n    } else {\\n      if (domain) {\\n        domain = `${domain}.${members[i]}`;\\n      } else {\\n        domain = members[i];\\n      }\\n    }\\n  }\\n\\n  if (identifier == null || protocol == null) {\\n    return {\\n      hostname: null,\\n      ipfsCid: null,\\n      ipnsIdentifier: null,\\n      path: '/'\\n    };\\n  }\\n\\n  var ipfsCid = null;\\n  var ipnsIdentifier = null;\\n\\n  if (protocol === 'ipns' || protocol === 'ipns:') {\\n    ipnsIdentifier = identifier;\\n  } else if ((protocol === 'ipfs' || protocol === 'ipfs:') && this.getCid(identifier) !== null) {\\n    ipfsCid = identifier;\\n  }\\n\\n  if (ipfsCid == null && ipnsIdentifier == null) {\\n    if (domain == null) {\\n      domain = `${identifier}.${protocol}`;\\n    } else {\\n      domain = `${identifier}.${protocol}.${domain}`;\\n    }\\n  }\\n\\n  return {\\n    hostname: domain,\\n    ipfsCid: ipfsCid,\\n    ipnsIdentifier: ipnsIdentifier,\\n    path: path !== undefined && path !== null ? path : '/'\\n  };\\n};\\n\\nIpfsBundle.prototype.getCid = function (cid) {\\n  try {\\n    const newCid = new CID(cid.toString());\\n\\n    if (CID.isCID(newCid)) {\\n      return newCid;\\n    }\\n  } catch (error) {// Ignore\\n  }\\n\\n  return null;\\n};\\n\\nIpfsBundle.prototype.cidToBase58CidV0 = function (cid, log) {\\n  return this.convertCidToBase58CidV0(cid, log);\\n};\\n\\nIpfsBundle.prototype.convertCidToBase58CidV0 = function (cid, log) {\\n  cid = new CID(cid.toString());\\n  const {\\n    codec: cidCodec\\n  } = cid.toJSON();\\n\\n  if (cid.version === 1) {\\n    const converted = new CID(0, dagPb, cid.multihash, 'base58btc'); // Log\\n\\n    if (log) {\\n      const {\\n        codec: convertedCodec\\n      } = converted.toJSON();\\n      this.getLogger().info(`Converted:\\n'${cidCodec}' \\\"cidv1\\\" (${cid.multibaseName}): ${cidInspector}${cid}\\nto '${convertedCodec}' \\\"cidv0\\\" (base58btc): ${cidInspector}${converted}`);\\n    }\\n\\n    return converted;\\n  } // Convert\\n\\n\\n  if (cidCodec !== dagPb || cid.multibaseName !== 'base58btc') {\\n    cid = this.convertCidToCid(cid, 0, dagPb, 'base58btc', log);\\n  }\\n\\n  return cid;\\n};\\n\\nIpfsBundle.prototype.cidToCidV1 = function (cid, protocol, log) {\\n  return this.convertCidToCidV1(cid, protocol, log);\\n};\\n\\nIpfsBundle.prototype.convertCidToCidV1 = function (cid, protocol, log) {\\n  cid = new CID(cid.toString());\\n  const {\\n    codec: cidCodec\\n  } = cid.toJSON();\\n  var codec = protocol !== undefined && protocol !== null ? protocol === 'ipns' ? libp2pKey : dagPb : dagPb;\\n  var multibaseName = codec === libp2pKey ? 'base36' : 'base32'; // Convert\\n\\n  if (cid.version === 0) {\\n    const converted = new CID(1, codec, cid.multihash, multibaseName);\\n\\n    if (log) {\\n      this.getLogger().info(`Converted:\\n'${cidCodec}' \\\"cidv0\\\" (${cid.multibaseName}): ${cidInspector}${cid}\\nto '${codec}' \\\"cidv1\\\" (${multibaseName}): ${cidInspector}${converted}`);\\n    }\\n\\n    return converted;\\n  } // Convert\\n\\n\\n  if (cidCodec !== codec || cid.multibaseName !== multibaseName) {\\n    cid = this.convertCidToCid(cid, 1, codec, multibaseName, log);\\n  }\\n\\n  return cid;\\n};\\n\\nIpfsBundle.prototype.cidToLibp2pKeyCidV1 = function (cid, multibaseName, log) {\\n  return this.convertCidToCid(cid, 1, 'libp2p-key', multibaseName, log);\\n};\\n\\nIpfsBundle.prototype.convertCidToCid = function (cid, version, codec, multibaseName, log) {\\n  cid = new CID(cid.toString());\\n  const {\\n    codec: cidCodec,\\n    version: cidVersion\\n  } = cid.toJSON();\\n\\n  if (cid.version === version && cidCodec === codec && cid.multibaseName === multibaseName) {\\n    return cid;\\n  }\\n\\n  const converted = new CID(version, codec, cid.multihash, multibaseName);\\n\\n  if (log) {\\n    const {\\n      codec: convertedCodec,\\n      version: convertedVersion\\n    } = converted.toJSON();\\n    this.getLogger().info(`Converted:\\n'${cidCodec}' \\\"cidv${cidVersion}\\\" (${cid.multibaseName}): ${cidInspector}${cid}\\nto '${convertedCodec}' \\\"cidv${convertedVersion}\\\" (${multibaseName}): ${cidInspector}${converted}`);\\n  }\\n\\n  return converted;\\n};\\n\\nIpfsBundle.prototype.Base64ToUint8Array = function (b64) {\\n  return Base64Binary.decode(b64);\\n}; // https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string\\n\\n\\nIpfsBundle.prototype.Uint8ArrayToBase64 = function (uint8) {\\n  var CHUNK_SIZE = 0x8000; //arbitrary number\\n\\n  var index = 0;\\n  var length = uint8.length;\\n  var str = '';\\n  var slice;\\n\\n  while (index < length) {\\n    slice = uint8.subarray(index, Math.min(index + CHUNK_SIZE, length));\\n    str += String.fromCharCode.apply(null, slice);\\n    index += CHUNK_SIZE;\\n  }\\n\\n  return btoa(str);\\n}; // String to uint array\\n\\n\\nIpfsBundle.prototype.StringToUint8Array = function (string) {\\n  return uint8ArrayFromString(string);\\n}; // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\\n\\n/*\\n * utf.js - UTF-8 <=> UTF-16 convertion\\n *\\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\\n * Version: 1.0\\n * LastModified: Dec 25 1999\\n * This library is free.  You can redistribute it and/or modify it.\\n */\\n\\n\\nIpfsBundle.prototype.Utf8ArrayToStr = function (array) {\\n  var c, char2, char3;\\n  var out = '';\\n  var len = array.length;\\n  var i = 0;\\n\\n  while (i < len) {\\n    c = array[i++];\\n\\n    switch (c >> 4) {\\n      case 0:\\n      case 1:\\n      case 2:\\n      case 3:\\n      case 4:\\n      case 5:\\n      case 6:\\n      case 7:\\n        // 0xxxxxxx\\n        out += String.fromCharCode(c);\\n        break;\\n\\n      case 12:\\n      case 13:\\n        // 110x xxxx   10xx xxxx\\n        char2 = array[i++];\\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\\n        break;\\n\\n      case 14:\\n        // 1110 xxxx  10xx xxxx  10xx xxxx\\n        char2 = array[i++];\\n        char3 = array[i++];\\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\\n        break;\\n    }\\n  }\\n\\n  return out;\\n};\\n\\nIpfsBundle.prototype.deflate = function (str) {\\n  var tStart = new Date();\\n  var ua = globalThis.pako.deflate(str, {\\n    raw: false\\n  });\\n  var b64 = this.Uint8ArrayToBase64(ua);\\n  var tStop = new Date() - tStart;\\n  var ratio = Math.floor(b64.length * 100 / str.length);\\n  this.getLogger().info(`Deflate: ${tStop}ms, In: ${str.length} bytes, Out: ${b64.length} bytes, Ratio: ${ratio}%`);\\n  return b64;\\n};\\n\\nIpfsBundle.prototype.inflate = function (b64) {\\n  var tStart = new Date();\\n  var ua = this.decode(b64);\\n  var str = globalThis.pako.inflate(ua, {\\n    to: 'string'\\n  });\\n  var tStop = new Date() - tStart;\\n  var ratio = Math.floor(str.length * 100 / b64.length);\\n  this.getLogger().info(`Inflate: ${tStop}ms, In: ${b64.length} bytes, Out: ${str.length} bytes, Ratio: ${ratio}%`);\\n  return str;\\n};\\n\\nexports.IpfsBundle = IpfsBundle;\\n\\n},{\\\"cids\\\":19,\\\"core-js/modules/es.string.replace.js\\\":133,\\\"core-js/modules/es.typed-array.uint8-array.js\\\":135,\\\"core-js/modules/web.dom-collections.iterator.js\\\":149,\\\"core-js/modules/web.url.js\\\":151,\\\"core-js/modules/web.url.to-json.js\\\":152,\\\"core/modules/library/ipfs-bundle/ens-library.js\\\":2,\\\"core/modules/library/ipfs-bundle/ethereum-library.js\\\":3,\\\"core/modules/library/ipfs-bundle/ipfs-library.js\\\":4,\\\"core/modules/library/ipfs-bundle/ipfs-loader.js\\\":5,\\\"core/modules/library/ipfs-bundle/ipfs-url.js\\\":6,\\\"uint8arrays/from-string\\\":203}],2:[function(require,module,exports){\\n/*\\\\\\ntitle: $:/plugins/ipfs/ens-library.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\n\\\\*/\\n'use strict';\\n\\nrequire(\\\"core-js/modules/es.typed-array.from.js\\\");\\n\\nrequire(\\\"core-js/modules/es.typed-array.uint8-array.js\\\");\\n\\nconst basex = require('@multiformats/base-x');\\n\\nconst CID = require('cids');\\n\\nconst concat = require('uint8arrays').concat;\\n\\nconst fromString = require('uint8arrays').fromString;\\n\\nconst multiC = require('multicodec');\\n\\nconst multiH = require('multihashes');\\n/*eslint no-unused-vars:\\\"off\\\"*/\\n\\n\\nconst BASE58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\\nconst bs58 = basex(BASE58); // https://github.com/ensdomains/resolvers\\n\\nvar EnsLibrary = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle;\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n\\n  this.name = 'ens-library'; // https://docs.ens.domains/ens-deployments\\n  // https://github.com/ensdomains/ui/blob/master/src/ens.js\\n\\n  this.registry = {\\n    0x1: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\\n    0x3: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\\n    0x4: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\\n    0x5: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\\n  };\\n};\\n\\nEnsLibrary.prototype.getLogger = function () {\\n  return $tw.ipfsBundle.getLogger();\\n};\\n\\nEnsLibrary.prototype.getENSRegistry = function () {\\n  return this.registry;\\n};\\n\\nEnsLibrary.prototype.hexStringToUint8Array = function (hex) {\\n  const prefix = hex.slice(0, 2);\\n  const value = hex.slice(2);\\n  var res = '';\\n\\n  if (prefix === '0x') {\\n    res = value;\\n  } else {\\n    res = hex;\\n  }\\n\\n  return multiH.fromHexString(res);\\n};\\n\\nEnsLibrary.prototype.getCodec = function (hash) {\\n  const ua = this.hexStringToUint8Array(hash);\\n  return multiC.getCodec(ua);\\n};\\n\\nEnsLibrary.prototype.b58MultiHash = function (hash) {\\n  const ua = this.hexStringToUint8Array(hash);\\n  const value = multiC.rmPrefix(ua);\\n  const cid = new CID(value);\\n  return multiH.toB58String(cid.multihash);\\n}; // https://github.com/ensdomains/ui/blob/master/src/utils/contents.js\\n\\n\\nEnsLibrary.prototype.decodeContenthash = function (encoded) {\\n  var decoded = null;\\n  var protocol = null;\\n\\n  if (encoded.error) {\\n    throw new Error(encoded.error);\\n  }\\n\\n  if (encoded) {\\n    try {\\n      const codec = this.getCodec(encoded);\\n      decoded = this.b58MultiHash(encoded);\\n\\n      if (codec === 'ipfs-ns') {\\n        protocol = 'ipfs';\\n        decoded = this.ipfsBundle.cidToCidV1(decoded, protocol, true);\\n      } else if (codec === 'ipns-ns') {\\n        protocol = 'ipns';\\n        decoded = this.ipfsBundle.cidToCidV1(decoded, protocol, true);\\n      } else {\\n        throw new Error(`Unsupported ENS Content Hash codec: ${codec}`);\\n      }\\n\\n      decoded = decoded.toString();\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n  }\\n\\n  return {\\n    decoded: decoded,\\n    protocol: protocol\\n  };\\n}; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1577.md\\n// https://github.com/ensdomains/ui/blob/master/src/utils/contents.js\\n\\n\\nEnsLibrary.prototype.encodeContenthash = function (content) {\\n  var type = null;\\n  var text = null;\\n  var encoded = null;\\n  content = content === undefined || content == null || content.trim() === '' ? null : content.trim();\\n\\n  if (content == null) {\\n    return null;\\n  }\\n\\n  const matched = content.match(/^(ipfs|ipns|bzz|onion|onion3):\\\\/\\\\/(.*)/) || content.match(/\\\\/(ipfs)\\\\/(.*)/) || content.match(/\\\\/(ipns)\\\\/(.*)/);\\n\\n  if (matched) {\\n    type = matched[1];\\n    text = matched[2];\\n  } // https://stackoverflow.com/questions/39225161/convert-uint8array-into-hex-string-equivalent-in-node-js\\n\\n\\n  function i2hex(i) {\\n    return ('0' + i.toString(16)).slice(-2);\\n  }\\n\\n  if (type === 'ipfs') {\\n    encoded = this.ipfsBundle.cidToBase58CidV0(text, true);\\n    encoded = new CID(1, 'dag-pb', multiH.fromB58String(encoded.toString()));\\n    encoded = multiC.addPrefix('ipfs-ns', encoded.bytes);\\n    encoded = Array.from(encoded).map(i2hex).join('');\\n    encoded = `0x${encoded}`;\\n  } else if (type === 'ipns') {\\n    var ua = [Uint8Array.from([0, text.length]), fromString(text)];\\n    ua = concat(ua, 2 + text.length);\\n    encoded = bs58.encode(ua);\\n    encoded = new CID(1, 'dag-pb', multiH.fromB58String(encoded));\\n    encoded = multiC.addPrefix('ipns-ns', encoded.bytes);\\n    encoded = Array.from(encoded).map(i2hex).join('');\\n    encoded = `0x${encoded}`;\\n  } else {\\n    throw new Error(`Unsupported ENS Content Hash type: ${type}`);\\n  }\\n\\n  return {\\n    encoded: encoded\\n  };\\n};\\n\\nEnsLibrary.prototype.getRegistry = async function (web3) {\\n  if (web3 === undefined || web3 == null) {\\n    throw new Error('Undefined Web3 provider...');\\n  } // Retrieve network\\n\\n\\n  const network = await web3.getNetwork();\\n  const chainId = parseInt(network.chainId); // Retrieve an Ethereum ENS Registry address\\n\\n  var registry = null;\\n\\n  try {\\n    registry = this.registry[chainId];\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  if (registry === undefined || registry == null) {\\n    throw new Error(`Unsupported Ethereum network: ${chainId}`);\\n  } // Return registry address\\n\\n\\n  return {\\n    chainId: chainId,\\n    registry: registry\\n  };\\n};\\n\\nEnsLibrary.prototype.getResolver = async function (web3, registry, node) {\\n  if (web3 === undefined || web3 == null) {\\n    throw new Error('Undefined Web3 provider...');\\n  }\\n\\n  node = node === undefined || node == null || node.trim() === '' ? null : node.trim();\\n\\n  if (node == null) {\\n    throw new Error('Undefined ENS domain resolver...');\\n  }\\n\\n  registry = registry === undefined || registry == null || registry.trim() === '' ? null : registry.trim();\\n\\n  if (registry == null) {\\n    throw new Error('Undefined ENS registry address...');\\n  }\\n\\n  const abi = ['function resolver(bytes32 node) external view returns (address)'];\\n  const iface = new globalThis.ethers.utils.Interface(abi);\\n  const data = iface.encodeFunctionData('resolver', [node]);\\n  const result = await web3.call({\\n    to: registry,\\n    data: data\\n  });\\n\\n  if (result === undefined || result == null || result === '0x') {\\n    return null;\\n  }\\n\\n  try {\\n    const decoded = iface.decodeFunctionResult('resolver', result);\\n\\n    if (decoded !== undefined && decoded !== null && Array.isArray(decoded) && decoded.length > 0) {\\n      return decoded[0];\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  } // Return\\n\\n\\n  return null;\\n}; // https://eips.ethereum.org/EIPS/eip-165\\n\\n\\nEnsLibrary.prototype.checkEip165 = async function (web3, address) {\\n  if (web3 === undefined || web3 == null) {\\n    throw new Error('Undefined Web3 provider...');\\n  }\\n\\n  address = address === undefined || address == null || address.trim() === '' ? null : address.trim();\\n\\n  if (address == null) {\\n    throw new Error('Undefined Ethereum address...');\\n  }\\n\\n  var abi = ['function supportsInterface(bytes4 interfaceID) public pure returns(bool)'];\\n  var iface = new globalThis.ethers.utils.Interface(abi);\\n  var data = iface.encodeFunctionData('supportsInterface', ['0x01ffc9a7']);\\n  var result = await web3.call({\\n    to: address,\\n    data: data\\n  });\\n\\n  if (result === undefined || result == null || result === '0x') {\\n    return false;\\n  }\\n\\n  try {\\n    var decoded = iface.decodeFunctionResult('supportsInterface', result);\\n\\n    if (decoded !== undefined && decoded !== null && Array.isArray(decoded) && decoded.length > 0) {\\n      if (decoded[0] === false) {\\n        return false;\\n      }\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n    return false;\\n  }\\n\\n  data = iface.encodeFunctionData('supportsInterface', ['0xffffffff']);\\n  result = await web3.call({\\n    to: address,\\n    data: data\\n  });\\n\\n  if (result === undefined || result == null || result === '0x') {\\n    return false;\\n  }\\n\\n  try {\\n    var decoded = iface.decodeFunctionResult('supportsInterface', result);\\n\\n    if (decoded !== undefined && decoded !== null && Array.isArray(decoded) && decoded.length > 0) {\\n      // conform to spec\\n      if (decoded[0] === false) {\\n        return true;\\n      }\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  } // do not conform to spec\\n\\n\\n  return false;\\n}; // https://eips.ethereum.org/EIPS/eip-1577\\n\\n\\nEnsLibrary.prototype.checkEip1577 = async function (web3, address) {\\n  if (web3 === undefined || web3 == null) {\\n    throw new Error('Undefined Web3 provider...');\\n  }\\n\\n  address = address === undefined || address == null || address.trim() === '' ? null : address.trim();\\n\\n  if (address == null) {\\n    throw new Error('Undefined Ethereum address...');\\n  } // contenthash, true when interfaceID is 0xbc1c58d1\\n\\n\\n  var abi = ['function supportsInterface(bytes4 interfaceID) public pure returns(bool)'];\\n  var iface = new globalThis.ethers.utils.Interface(abi);\\n  var data = iface.encodeFunctionData('supportsInterface', ['0xbc1c58d1']);\\n  var result = await web3.call({\\n    to: address,\\n    data: data\\n  });\\n\\n  if (result === undefined || result == null || result === '0x') {\\n    return false;\\n  }\\n\\n  try {\\n    var decoded = iface.decodeFunctionResult('supportsInterface', result);\\n\\n    if (decoded !== undefined && decoded !== null && Array.isArray(decoded) && decoded.length > 0) {\\n      return decoded[0];\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  return false;\\n};\\n\\nEnsLibrary.prototype.getContentHash = async function (domain, web3) {\\n  domain = domain === undefined || domain == null || domain.trim() === '' ? null : domain.trim();\\n\\n  if (domain == null) {\\n    throw new Error('Undefined ENS domain...');\\n  }\\n\\n  if (web3 === undefined) {\\n    var {\\n      web3\\n    } = await this.ipfsBundle.getWeb3Provider();\\n  }\\n\\n  const explorer = this.ipfsBundle.getBlockExplorerRegistry(); // Resolve domain as namehash\\n\\n  const domainHash = globalThis.ethers.utils.namehash(domain); // Fetch ens registry address\\n\\n  const {\\n    chainId,\\n    registry\\n  } = await this.getRegistry(web3);\\n  this.getLogger().info(`ENS registry:\\n${explorer[chainId]}/address/${registry}`); // Fetch resolver address\\n\\n  var resolver = await this.getResolver(web3, registry, domainHash); // Check\\n\\n  if (resolver == null || /^0x0+$/.test(resolver) === true) {\\n    throw new Error('Undefined ENS domain resolver...');\\n  } // Log\\n\\n\\n  this.getLogger().info(`ENS domain resolver:\\n${explorer[chainId]}/address/${resolver}`); // Check if resolver is EIP165\\n\\n  const eip165 = await this.checkEip165(web3, resolver);\\n\\n  if (eip165 === false) {\\n    throw new Error('ENS domain resolver do not conform to EIP165...');\\n  } // Check if resolver is EIP1577\\n\\n\\n  const eip1577 = await this.checkEip1577(web3, resolver);\\n\\n  if (eip1577 === false) {\\n    throw new Error('ENS domain resolver do not conform to EIP1577...');\\n  } // Retrieve content hash\\n\\n\\n  this.getLogger().info('Retrieving ENS domain content...');\\n  const abi = ['function contenthash(bytes32 node) external view returns (bytes memory)'];\\n  const iface = new globalThis.ethers.utils.Interface(abi);\\n  const data = iface.encodeFunctionData('contenthash', [domainHash]);\\n  const result = await web3.call({\\n    to: resolver,\\n    data: data\\n  });\\n\\n  if (result === undefined || result == null || result === '0x') {\\n    return {\\n      content: null,\\n      protocol: null\\n    };\\n  }\\n\\n  var content = iface.decodeFunctionResult('contenthash', result);\\n\\n  if (content !== undefined && content !== null && Array.isArray(content) && content.length > 0) {\\n    var {\\n      decoded,\\n      protocol\\n    } = this.decodeContenthash(content[0]);\\n    return {\\n      content: decoded,\\n      protocol: protocol\\n    };\\n  }\\n\\n  return {\\n    content: null,\\n    protocol: null\\n  };\\n};\\n\\nEnsLibrary.prototype.isOwner = async function (domain, web3, account) {\\n  domain = domain === undefined || domain == null || domain.trim() === '' ? null : domain.trim();\\n\\n  if (domain == null) {\\n    throw new Error('Undefined ENS domain...');\\n  }\\n\\n  if (account === undefined || account == null || web3 === undefined || web3 == null) {\\n    var {\\n      account,\\n      web3\\n    } = await this.ipfsBundle.getEnabledWeb3Provider();\\n  }\\n\\n  const explorer = this.ipfsBundle.getBlockExplorerRegistry(); // Resolve domain as namehash\\n\\n  const domainHash = globalThis.ethers.utils.namehash(domain); // Fetch ens registry address\\n\\n  const {\\n    chainId,\\n    registry\\n  } = await this.getRegistry(web3);\\n  this.getLogger().info(`ENS registry:\\n${explorer[chainId]}/address/${registry}`);\\n  const abi = ['function owner(bytes32 node) public view returns(address)'];\\n  const iface = new globalThis.ethers.utils.Interface(abi);\\n  const data = iface.encodeFunctionData('owner', [domainHash]);\\n  const result = await web3.call({\\n    to: registry,\\n    data: data\\n  });\\n\\n  if (result === undefined || result == null || result === '0x') {\\n    return false;\\n  } // decode if applicable\\n\\n\\n  try {\\n    var decoded = iface.decodeFunctionResult('owner', result);\\n\\n    if (decoded !== undefined && decoded !== null && Array.isArray(decoded) && decoded.length > 0) {\\n      return decoded[0].toLowerCase() === account.toLowerCase();\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  return false;\\n};\\n\\nEnsLibrary.prototype.setContentHash = async function (domain, identifier, web3, account) {\\n  identifier = identifier !== undefined && identifier !== null && identifier.toString().trim() !== '' ? identifier.toString().trim() : null;\\n\\n  if (identifier == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  }\\n\\n  domain = domain !== undefined && domain !== null && domain.trim() !== '' ? domain.trim() : null;\\n\\n  if (domain == null) {\\n    throw new Error('Undefined ENS domain...');\\n  }\\n\\n  if (account === undefined || web3 === undefined) {\\n    var {\\n      account,\\n      web3\\n    } = await this.ipfsBundle.getEnabledWeb3Provider();\\n  }\\n\\n  const explorer = this.ipfsBundle.getBlockExplorerRegistry(); // Resolve domain as namehash\\n\\n  const domainHash = globalThis.ethers.utils.namehash(domain); // Fetch ens registry address\\n\\n  const {\\n    chainId,\\n    registry\\n  } = await this.getRegistry(web3);\\n  this.getLogger().info(`ENS registry:\\n${explorer[chainId]}/address/${registry}`);\\n  var resolver = await this.getResolver(web3, registry, domainHash);\\n\\n  if (resolver == null || /^0x0+$/.test(resolver) === true) {\\n    throw new Error('Undefined ENS resolver...');\\n  }\\n\\n  this.getLogger().info(`ENS domain resolver:\\n${explorer[chainId]}/address/${resolver}`); // Check if resolver is EIP165\\n\\n  const eip165 = await this.checkEip165(web3, resolver);\\n\\n  if (eip165 === false) {\\n    throw new Error('ENS resolver do not conform to EIP165...');\\n  } // Check if resolver is EIP1577\\n\\n\\n  const eip1577 = await this.checkEip1577(web3, resolver);\\n\\n  if (eip1577 === false) {\\n    throw new Error('ENS resolver do not conform to EIP1577...');\\n  } // Encode identifier\\n\\n\\n  const {\\n    encoded\\n  } = this.encodeContenthash(identifier); // Set Contenthash\\n\\n  this.getLogger().info('Processing ENS domain content...');\\n  const abi = ['function setContenthash(bytes32 node, bytes calldata hash)'];\\n  const iface = new globalThis.ethers.utils.Interface(abi);\\n  const data = iface.encodeFunctionData('setContenthash', [domainHash, encoded]);\\n\\n  try {\\n    const signer = web3.getSigner(account);\\n    const tx = await signer.sendTransaction({\\n      to: resolver,\\n      data: data\\n    });\\n    this.getLogger().info(`Processing Transaction:\\n${explorer[chainId]}/tx/${tx.hash}`); // Wait for transaction completion\\n\\n    await tx.wait();\\n    this.getLogger().info('Processed ENS domain content...');\\n  } catch (error) {\\n    // EIP 1193 user Rejected Request\\n    if (error.code === 4001) {\\n      const err = new Error('Rejected User Request...');\\n      err.name = 'RejectedUserRequest';\\n      throw err;\\n    }\\n\\n    if (error.code === 4100) {\\n      const err = new Error('Unauthorized User Account...');\\n      err.name = 'UnauthorizedUserAccount';\\n      throw err;\\n    }\\n\\n    throw error;\\n  }\\n};\\n\\nexports.EnsLibrary = EnsLibrary;\\n\\n},{\\\"@multiformats/base-x\\\":7,\\\"cids\\\":19,\\\"core-js/modules/es.typed-array.from.js\\\":134,\\\"core-js/modules/es.typed-array.uint8-array.js\\\":135,\\\"multicodec\\\":184,\\\"multihashes\\\":195,\\\"uint8arrays\\\":204}],3:[function(require,module,exports){\\n/*\\\\\\ntitle: $:/plugins/ipfs/ethereum-library.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\n\\\\*/\\n'use strict'; // https://github.com/ensdomains/resolvers\\n\\nvar EthereumLibrary = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle;\\n  this.name = 'ethereum-library';\\n  this.network = {\\n    0x1: 'Ethereum Main Network: \\\"Mainnet\\\", chainId: \\\"0x1\\\": \\\"1\\\"',\\n    0x2a: 'Ethereum Test Network (PoA): \\\"Kovan\\\", chainId: \\\"0x2a\\\": \\\"42\\\"',\\n    0x3: 'Ethereum Test Network (PoW): \\\"Ropsten\\\", chainId: \\\"0x3\\\": \\\"3\\\"',\\n    0x38: 'Binance Smart Chain Main Network (bsc-mainnet): \\\"0x38\\\": \\\"56\\\"',\\n    // https://bsc-dataseed.binance.org/\\n    0x4: 'Ethereum Test Network (PoA): \\\"Rinkeby\\\", chainId: \\\"0x4\\\": \\\"4\\\"',\\n    0x5: 'Ethereum Test Network (PoA): \\\"Goerli\\\", chainId: \\\"0x5\\\": \\\"5\\\"',\\n    0x61: 'Binance Smart Chain Test Network (bsc-testnet): \\\"0x61\\\": \\\"97\\\"',\\n    // https://data-seed-prebsc-1-s1.binance.org:8545/\\n    0x64: 'xDai Main Network: \\\"Mainnet\\\", chainId: \\\"0x64\\\": \\\"100\\\"',\\n    // https://rpc.xdaichain.com/\\n    0x89: 'Polygon Main Network, chainId: \\\"0x89\\\": \\\"127\\\"' // https://rpc-mainnet.maticvigil.com/\\n\\n  };\\n  this.explorer = {\\n    0x1: 'https://etherscan.io',\\n    0x2a: 'https://kovan.etherscan.io',\\n    0x3: 'https://ropsten.etherscan.io',\\n    0x38: 'https://bscscan.com',\\n    0x4: 'https://rinkeby.etherscan.io',\\n    0x5: 'https://goerli.etherscan.io',\\n    0x61: 'https://testnet.bscscan.com/',\\n    0x64: 'https://blockscout.com/poa/xdai',\\n    0x89: 'https://explorer.matic.network'\\n  };\\n  this.once = false;\\n  this.provider = null;\\n};\\n\\nEthereumLibrary.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger();\\n};\\n\\nEthereumLibrary.prototype.getEthereumProvider = async function () {\\n  if (this.provider == null) {\\n    this.provider = await this.detectEthereumProvider();\\n  }\\n\\n  return this.provider;\\n};\\n/*\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md\\n * https://eips.ethereum.org/EIPS/eip-1193\\n * https://docs.metamask.io/guide/ethereum-provider.html#methods-current-api\\n */\\n\\n\\nEthereumLibrary.prototype.init = async function () {\\n  // Init once\\n  if (this.once) {\\n    return;\\n  }\\n\\n  const self = this;\\n\\n  try {\\n    const provider = await this.getEthereumProvider();\\n    const chainId = await this.getChainId(provider);\\n    this.getLogger().info(`Chain: ${this.network[chainId]}`); // Init Ethereum listener\\n\\n    provider.on('accountsChanged', accounts => {\\n      self.accounts(provider, accounts);\\n    });\\n    provider.on('chainChanged', chainId => {\\n      const id = parseInt(chainId, 16);\\n      self.getLogger().info(`Chain: ${self.network[id]}`);\\n    });\\n    provider.on('connect', chainId => {\\n      const id = parseInt(chainId, 16);\\n      self.getLogger().info(`Chain: ${self.network[id]}`);\\n    });\\n    provider.on('disconnect', (code, reason) => {\\n      self.disconnectedFromAllChains(code, reason);\\n    });\\n    provider.on('message', message => {\\n      self.providerMessage(message);\\n    });\\n  } catch (error) {\\n    if (error.name !== 'MissingBrowserExtension') {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(this.name, error.message);\\n    }\\n  } // Init once\\n\\n\\n  this.once = true;\\n};\\n\\nEthereumLibrary.prototype.getChainId = async function (provider) {\\n  if (provider === undefined || provider == null) {\\n    provider = await this.getEthereumProvider();\\n  }\\n\\n  var chainId = await provider.request({\\n    method: 'eth_chainId'\\n  });\\n  chainId = chainId !== undefined && chainId !== null && chainId.trim() !== '' ? chainId.trim() : null;\\n  return chainId !== null ? parseInt(chainId, 16) : null;\\n};\\n\\nEthereumLibrary.prototype.accounts = async function (provider, accounts) {\\n  if (accounts !== undefined && accounts !== null && Array.isArray(accounts) === true && accounts.length > 0) {\\n    try {\\n      const chainId = await this.getChainId(provider);\\n      this.getLogger().info(`Chain: ${this.network[chainId]}`);\\n      this.getLogger().info(`Ethereum account: ${this.explorer[chainId]}/address/${accounts[0]}`);\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(this.name, error.message);\\n    }\\n  } else {\\n    this.getLogger().info('Unavailable Ethereum account...');\\n  }\\n};\\n\\nEthereumLibrary.prototype.disconnectedFromAllChains = function (code, reason) {\\n  this.getLogger().info(`Ethereum Provider is disconnected: ${reason}. Code: ${code}`);\\n};\\n\\nEthereumLibrary.prototype.providerMessage = function (message) {\\n  this.getLogger().info(`Ethereum Provider message: ${message}`);\\n};\\n\\nEthereumLibrary.prototype.getBlockExplorerRegistry = function () {\\n  return this.explorer;\\n};\\n\\nEthereumLibrary.prototype.getNetworkRegistry = function () {\\n  return this.network;\\n};\\n\\nEthereumLibrary.prototype.personalSign = async function (message, provider) {\\n  message = message !== undefined && message !== null && message.trim() !== '' ? message.trim() : null;\\n\\n  if (message == null) {\\n    throw new Error('Undefined Message....');\\n  }\\n\\n  try {\\n    if (provider === undefined || provider == null) {\\n      provider = await this.getEthereumProvider();\\n    }\\n\\n    const account = await this.getAccount(provider);\\n    const signature = await provider.request({\\n      method: 'personal_sign',\\n      params: [message, account]\\n    });\\n    return signature;\\n  } catch (error) {\\n    // EIP 1193 user Rejected Request\\n    if (error.code === 4001) {\\n      const err = new Error('Rejected User Request...');\\n      err.name = 'RejectedUserRequest';\\n      throw err;\\n    }\\n\\n    throw error;\\n  }\\n};\\n\\nEthereumLibrary.prototype.personalRecover = async function (message, signature) {\\n  message = message !== undefined && message !== null && message.trim() !== '' ? message.trim() : null;\\n\\n  if (message == null) {\\n    throw new Error('Undefined Message....');\\n  }\\n\\n  signature = signature !== undefined && signature !== null && signature.trim() !== '' ? signature.trim() : null;\\n\\n  if (signature == null) {\\n    throw new Error('Undefined Signature....');\\n  }\\n\\n  if (typeof globalThis.sigUtil === 'undefined') {\\n    await this.ipfsBundle.loadEthSigUtilLibrary();\\n  }\\n\\n  const msgParams = {\\n    data: message,\\n    sig: signature\\n  };\\n  const recovered = globalThis.sigUtil.recoverPersonalSignature(msgParams);\\n\\n  if (recovered === undefined || recovered == null) {\\n    const err = new Error('Unrecoverable signature...');\\n    err.name = 'UnrecoverableSignature';\\n    throw err;\\n  }\\n\\n  return recovered;\\n};\\n\\nEthereumLibrary.prototype.decrypt = async function (text, provider) {\\n  text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null;\\n\\n  if (text == null) {\\n    throw new Error('Undefined Text....');\\n  }\\n\\n  try {\\n    if (provider === undefined || provider == null) {\\n      provider = await this.getEthereumProvider();\\n    }\\n\\n    const account = await this.getAccount(provider);\\n    var tStart = new Date();\\n    const decryptedText = await provider.request({\\n      method: 'eth_decrypt',\\n      params: [text, account]\\n    });\\n\\n    if (decryptedText !== undefined || decryptedText !== null) {\\n      var tStop = new Date() - tStart;\\n      var ratio = Math.floor(decryptedText.length * 100 / text.length);\\n      this.getLogger().info(`Ethereum Decrypt: ${tStop}ms, In: ${text.length}, Out: ${decryptedText.length}, Ratio: ${ratio}%`);\\n    }\\n\\n    return decryptedText;\\n  } catch (error) {\\n    // EIP 1193 user Rejected Request\\n    if (error.code === 4001) {\\n      const err = new Error('Rejected User Request...');\\n      err.name = 'RejectedUserRequest';\\n      throw err;\\n    }\\n\\n    throw error;\\n  }\\n};\\n\\nEthereumLibrary.prototype.getPublicEncryptionKey = async function (provider, account) {\\n  try {\\n    if (provider === undefined || provider == null) {\\n      provider = await this.getEthereumProvider();\\n    }\\n\\n    if (account === undefined) {\\n      account = await this.getAccount(provider);\\n    }\\n\\n    const encryptionKey = await provider.request({\\n      method: 'eth_getEncryptionPublicKey',\\n      params: [account]\\n    });\\n    return encryptionKey;\\n  } catch (error) {\\n    // EIP 1193 user Rejected Request\\n    if (error.code === 4001) {\\n      const err = new Error('Rejected User Request...');\\n      err.name = 'RejectedUserRequest';\\n      throw err;\\n    }\\n\\n    throw error;\\n  }\\n};\\n/*\\n * https://eips.ethereum.org/EIPS/eip-1102\\n * https://eips.ethereum.org/EIPS/eip-1193\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md\\n * https://eips.ethereum.org/EIPS/eip-2255\\n * https://docs.metamask.io/guide/ethereum-provider.html#methods-current-api\\n */\\n\\n\\nEthereumLibrary.prototype.detectEthereumProvider = async function () {\\n  var provider = null;\\n\\n  try {\\n    if (typeof globalThis.detectEthereumProvider === 'function') {\\n      provider = await globalThis.detectEthereumProvider({\\n        mustBeMetaMask: true\\n      });\\n\\n      if (provider !== undefined && provider !== null) {\\n        provider.autoRefreshOnNetworkChange = false;\\n      }\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  if (provider === undefined || provider == null) {\\n    const err = new Error('Please install MetaMask...');\\n    err.name = 'MissingBrowserExtension';\\n    throw err;\\n  }\\n\\n  return provider;\\n};\\n\\nEthereumLibrary.prototype.checkAccountPermission = async function (provider) {\\n  if (provider === undefined || provider == null) {\\n    provider = await this.getEthereumProvider();\\n  }\\n\\n  if (typeof provider.request === 'function') {\\n    const permissions = await provider.request({\\n      method: 'wallet_getPermissions'\\n    });\\n    const accountsPermission = permissions.find(permission => permission.parentCapability === 'eth_accounts');\\n\\n    if (accountsPermission) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n\\nEthereumLibrary.prototype.requestAccountPermission = async function (provider) {\\n  if (provider === undefined || provider == null) {\\n    provider = await this.getEthereumProvider();\\n  }\\n\\n  if (typeof provider.request === 'function') {\\n    const permissions = await provider.request({\\n      method: 'wallet_requestPermissions',\\n      params: [{\\n        eth_accounts: {}\\n      }]\\n    });\\n    const accountsPermission = permissions.find(permission => permission.parentCapability === 'eth_accounts');\\n\\n    if (accountsPermission) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n/*\\n * https://docs.metamask.io/guide/provider-migration.html#migrating-to-the-new-provider-api\\n */\\n\\n\\nEthereumLibrary.prototype.getAccount = async function (provider) {\\n  if (provider === undefined || provider == null) {\\n    provider = await this.getEthereumProvider();\\n  }\\n\\n  try {\\n    var accounts = null;\\n    var permission = false; // Permission Attempt\\n\\n    try {\\n      permission = await this.checkAccountPermission(provider);\\n\\n      if (permission === false) {\\n        permission = await this.requestAccountPermission(provider);\\n      }\\n    } catch (error) {\\n      if (error.code === 4001) {\\n        throw error;\\n      }\\n\\n      this.getLogger().error(error);\\n    } // Request Accounts attempt\\n\\n\\n    try {\\n      if (permission === false || (await provider._metamask.isUnlocked()) === false) {\\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\\n        accounts = await provider.request({\\n          method: 'eth_requestAccounts'\\n        });\\n      }\\n\\n      if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {\\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md\\n        accounts = await provider.request({\\n          method: 'eth_accounts'\\n        });\\n      }\\n    } catch (error) {\\n      if (error.code === 4001) {\\n        throw error;\\n      }\\n\\n      this.getLogger().error(error);\\n    } // Enable attempt\\n\\n\\n    if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {\\n      if (typeof provider.enable === 'function') {\\n        accounts = await provider.enable();\\n      }\\n    }\\n\\n    if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {\\n      throw new Error('Unable to retrieve any Ethereum accounts...');\\n    }\\n\\n    await this.accounts(provider, accounts);\\n    return accounts[0];\\n  } catch (error) {\\n    // EIP 1193 user Rejected Request\\n    if (error.code === 4001) {\\n      const err = new Error('Rejected User Request...');\\n      err.name = 'RejectedUserRequest';\\n      throw err;\\n    }\\n\\n    throw error;\\n  }\\n};\\n\\nEthereumLibrary.prototype.getEnabledWeb3Provider = async function (provider) {\\n  if (provider === undefined || provider == null) {\\n    provider = await this.getEthereumProvider();\\n  }\\n\\n  if (typeof globalThis.ethers === 'undefined') {\\n    await this.ipfsBundle.loadEthersJsLibrary();\\n  } // Enable provider\\n  // https://github.com/ethers-io/ethers.js/issues/433\\n\\n\\n  const account = await this.getAccount(provider); // Instantiate a Web3Provider\\n\\n  const web3 = new globalThis.ethers.providers.Web3Provider(provider, 'any'); // Retrieve current network\\n\\n  const network = await web3.getNetwork();\\n  const chainId = parseInt(network.chainId, 16);\\n  return {\\n    account: account,\\n    chainId: chainId,\\n    web3: web3\\n  };\\n};\\n\\nEthereumLibrary.prototype.getWeb3Provider = async function (provider) {\\n  if (provider === undefined || provider == null) {\\n    provider = await this.getEthereumProvider();\\n  }\\n\\n  if (typeof globalThis.ethers === 'undefined') {\\n    await this.ipfsBundle.loadEthersJsLibrary();\\n  } // Instantiate an ethers Web3Provider\\n\\n\\n  const web3 = new globalThis.ethers.providers.Web3Provider(provider, 'any'); // Retrieve current network\\n\\n  const network = await web3.getNetwork();\\n  const chainId = parseInt(network.chainId, 16);\\n  return {\\n    web3: web3,\\n    chainId: chainId\\n  };\\n};\\n\\nexports.EthereumLibrary = EthereumLibrary;\\n\\n},{}],4:[function(require,module,exports){\\n/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-library.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\n\\\\*/\\n'use strict';\\n\\nrequire(\\\"core-js/modules/esnext.map.delete-all.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.every.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.filter.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.find.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.find-key.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.includes.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.key-of.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.map-keys.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.map-values.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.merge.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.reduce.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.some.js\\\");\\n\\nrequire(\\\"core-js/modules/esnext.map.update.js\\\");\\n\\nrequire(\\\"core-js/modules/web.dom-collections.iterator.js\\\");\\n\\nrequire(\\\"core-js/modules/es.string.replace.js\\\");\\n\\nrequire(\\\"core-js/modules/web.url.js\\\");\\n\\nconst fromString = require('uint8arrays').fromString;\\n\\nconst getIpfs = require('ipfs-provider').getIpfs;\\n\\nconst Mutex = require('async-mutex').Mutex;\\n\\nconst providers = require('ipfs-provider').providers;\\n\\nconst {\\n  httpClient,\\n  windowIpfs\\n} = providers;\\nconst shortTimeout = 4000;\\nconst longTimeout = 4 * 60 * shortTimeout;\\nconst dagDirectory = fromString('\\\\u0008\\\\u0001');\\n/*\\n * https://infura.io/docs\\n * https://cid.ipfs.io\\n * https://github.com/ipfs/js-ipfs/tree/master/docs/core-api\\n **/\\n\\nvar IpfsLibrary = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle;\\n  this.ipfsClients = new Map();\\n  this.mutex = new Mutex();\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n\\n  this.name = 'ipfs-library';\\n};\\n\\nIpfsLibrary.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger();\\n};\\n\\nIpfsLibrary.prototype.add = async function (client, content, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (content === undefined || content == null) {\\n    throw new Error('Undefined content...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['add']\\n    });\\n  }\\n\\n  if (client === undefined || client.add === undefined) {\\n    throw new Error('Undefined IPFS add...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      chunker: 'rabin-262144-524288-1048576',\\n      cidVersion: 0,\\n      hashAlg: 'sha2-256',\\n      pin: true,\\n      rawLeaves: false\\n    };\\n  } // 1 - https://github.com/ipfs/go-ipfs/issues/5683\\n  // default chunker: \\\"size-262144\\\"\\n  // chunker: \\\"rabin-262144-524288-1048576\\\"\\n  // 2 - TODO: small content generates an incnsistent cid when cidVersion: 1 is set.\\n  // Not a 'dag-pb' but a 'raw' multicodec instead\\n  // We generate a V0 and convert it to a V1\\n  // https://github.com/xmaysonnave/tiddlywiki-ipfs/issues/14\\n\\n\\n  const result = await client.add(content, options);\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var cid = null;\\n\\n  if (result.cid !== undefined && result.cid !== null) {\\n    cid = result.cid;\\n  }\\n\\n  const mode = result.mode;\\n  const mtime = result.mtime;\\n  var path = null;\\n\\n  if (result.path !== undefined && result.path !== null) {\\n    path = result.path;\\n  }\\n\\n  var size = null;\\n\\n  if (result.size !== undefined && result.size !== null) {\\n    size = result.size;\\n  }\\n\\n  if (cid == null || path == null || size == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  const cidV1 = this.ipfsBundle.cidToCidV1(cid, 'ipfs', true);\\n  return {\\n    cid: cidV1,\\n    mode: mode,\\n    mtime: mtime,\\n    path: path,\\n    size: size\\n  };\\n};\\n\\nIpfsLibrary.prototype.addAll = async function (client, content, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (content === undefined || content == null) {\\n    throw new Error('Undefined content...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['addAll']\\n    });\\n  }\\n\\n  if (client === undefined || client.addAll === undefined) {\\n    throw new Error('Undefined IPFS addAll...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      chunker: 'rabin-262144-524288-1048576',\\n      cidVersion: 0,\\n      hashAlg: 'sha2-256',\\n      pin: false,\\n      rawLeaves: false\\n    };\\n  }\\n\\n  const added = new Map();\\n\\n  for await (const result of client.addAll(content, options)) {\\n    if (result === undefined || result == null) {\\n      const err = new Error('IPFS returned an unknown result...');\\n      err.name = 'IPFSUnknownResult';\\n      throw err;\\n    }\\n\\n    var cid = null;\\n\\n    if (result.cid !== undefined && result.cid !== null) {\\n      cid = result.cid;\\n    }\\n\\n    var path = null;\\n\\n    if (result.path !== undefined && result.path !== null) {\\n      path = result.path;\\n    }\\n\\n    const mode = result.mode;\\n    const mtime = result.mtime;\\n    var size = null;\\n\\n    if (result.size !== undefined && result.size !== null) {\\n      size = result.size;\\n    }\\n\\n    if (cid == null || path == null || size == null) {\\n      const err = new Error('IPFS returned an unknown result...');\\n      err.name = 'IPFSUnknownResult';\\n      throw err;\\n    }\\n\\n    const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n    added.set(cidV1, {\\n      path: path,\\n      mode: mode,\\n      mtime: mtime,\\n      size: size\\n    });\\n  }\\n\\n  return added;\\n};\\n\\nIpfsLibrary.prototype.analyzePinType = function (type) {\\n  type = type !== undefined && type !== null && type.trim() !== '' ? type.trim() : null;\\n\\n  if (type == null) {\\n    return {\\n      parentCid: null,\\n      type: null\\n    };\\n  }\\n\\n  var res = type.split(' ');\\n\\n  if (res.length === 1) {\\n    return {\\n      parentCid: null,\\n      type: res[0]\\n    };\\n  }\\n\\n  if (res.length !== 3 && res.length !== 4) {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  const index = res.length % 3;\\n\\n  if (res[index] !== 'indirect') {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  if (res[index + 1] !== 'through') {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  const parentCid = this.ipfsBundle.getCid(res[index + 2]);\\n\\n  if (parentCid == null) {\\n    throw new Error(`Unknown pin type: ${type}`);\\n  }\\n\\n  return {\\n    parentCid: parentCid,\\n    type: res[0]\\n  };\\n};\\n\\nIpfsLibrary.prototype.dagGet = async function (client, cid, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  cid = this.ipfsBundle.getCid(cid) !== null ? cid : null;\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS cid...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['dag']\\n    });\\n  }\\n\\n  if (client === undefined || client.dag === undefined || client.dag.get === undefined) {\\n    throw new Error('Undefined IPFS dag get...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      localResolve: false\\n    };\\n  }\\n\\n  const result = await client.dag.get(cid, options);\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return result;\\n}; // https://discuss.ipfs.io/t/what-is-the-data-in-object/5221\\n// https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.pb.go\\n\\n\\nIpfsLibrary.prototype.dagPut = async function (client, dagNode, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (dagNode === undefined || dagNode == null) {\\n    throw new Error('Undefined DAG node...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['dag']\\n    });\\n  }\\n\\n  if (client === undefined || client.dag === undefined || client.dag.put === undefined) {\\n    throw new Error('Undefined IPFS dag put...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      format: 'dag-pb',\\n      hashAlg: 'sha2-256',\\n      pin: false\\n    };\\n  }\\n\\n  const result = await client.dag.put(dagNode, options);\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  const stat = await this.objectStat(client, result, options.timeout);\\n  const cidV1 = this.ipfsBundle.cidToCidV1(result);\\n  return {\\n    cid: `${cidV1}`,\\n    size: stat.CumulativeSize\\n  };\\n};\\n\\nIpfsLibrary.prototype.dagResolve = async function (client, ipfsPath, timeout) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null;\\n\\n  if (this.ipfsBundle.getCid(ipfsPath) == null) {\\n    ipfsPath = ipfsPath.replace(/\\\\/$/, '');\\n  }\\n\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['dag']\\n    });\\n  }\\n\\n  if (client === undefined || client.dag === undefined || client.dag.resolve === undefined) {\\n    throw new Error('Undefined IPFS dag resolve...');\\n  }\\n\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null;\\n  var result = null;\\n\\n  if (timeout == null) {\\n    result = await client.dag.resolve(ipfsPath);\\n  } else {\\n    result = await client.dag.resolve(ipfsPath, {\\n      timeout: timeout\\n    });\\n  }\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var cid = null;\\n\\n  if (result.cid !== undefined && result.cid !== null) {\\n    cid = result.cid;\\n  }\\n\\n  var remainderPath = null;\\n\\n  if (result.remainderPath !== undefined && result.remainderPath !== null) {\\n    remainderPath = result.remainderPath;\\n  }\\n\\n  if (cid == null || remainderPath == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n  return {\\n    cid: cidV1,\\n    remainderPath: remainderPath\\n  };\\n};\\n\\nIpfsLibrary.prototype.filesStat = async function (client, ipfsPath, timeout) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.trim() !== '' ? ipfsPath.trim() : null;\\n\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['files']\\n    });\\n  }\\n\\n  if (client === undefined || client.files === undefined || client.files.stat === undefined) {\\n    throw new Error('Undefined IPFS files stat...');\\n  }\\n\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null;\\n  var result = null;\\n\\n  if (timeout == null) {\\n    result = await client.files.stat(ipfsPath);\\n  } else {\\n    result = await client.files.stat(ipfsPath, {\\n      timeout: timeout\\n    });\\n  }\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var cid = null;\\n\\n  if (result.cid !== undefined && result.cid !== null) {\\n    cid = result.cid;\\n  }\\n\\n  var blocks = null;\\n\\n  if (result.blocks !== undefined && result.blocks !== null) {\\n    blocks = result.blocks;\\n  }\\n\\n  var cumulativeSize = null;\\n\\n  if (result.cumulativeSize !== undefined && result.cumulativeSize !== null) {\\n    cumulativeSize = result.cumulativeSize;\\n  }\\n\\n  var local = null;\\n\\n  if (result.local !== undefined && result.local !== null) {\\n    local = result.local;\\n  }\\n\\n  var size = null;\\n\\n  if (result.size !== undefined && result.size !== null) {\\n    size = result.size;\\n  }\\n\\n  var sizeLocal = null;\\n\\n  if (result.sizeLocal !== undefined && result.sizeLocal !== null) {\\n    sizeLocal = result.sizeLocal;\\n  }\\n\\n  var type = null;\\n\\n  if (result.type !== undefined && result.type !== null) {\\n    type = result.type;\\n  }\\n\\n  var withLocality = null;\\n\\n  if (result.withLocality !== undefined && result.withLocality !== null) {\\n    withLocality = result.withLocality;\\n  }\\n\\n  if (cid == null || blocks == null || cumulativeSize == null || size == null || type == null || withLocality == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  if (withLocality) {\\n    if (local == null || sizeLocal == null) {\\n      const err = new Error('IPFS returned an unknown result...');\\n      err.name = 'IPFSUnknownResult';\\n      throw err;\\n    }\\n  }\\n\\n  const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n  return {\\n    cid: cidV1,\\n    blocks: blocks,\\n    cumulativeSize: cumulativeSize,\\n    local: local,\\n    size: size,\\n    sizeLocal: sizeLocal,\\n    type: type,\\n    withLocality: withLocality\\n  };\\n}; // https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/KEY.md#keygen\\n// https://github.com/libp2p/js-libp2p-crypto/issues/145\\n\\n\\nIpfsLibrary.prototype.genKey = async function (client, ipnsKey) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.trim() !== '' ? ipnsKey.trim() : null;\\n\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client === undefined || client.key === undefined || client.key.gen === undefined) {\\n    throw new Error('Undefined IPFS key gen...');\\n  }\\n\\n  const key = await client.key.gen(ipnsKey, {\\n    type: 'ed25519'\\n  });\\n\\n  if (key === undefined || key == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var ipnsCid = null;\\n\\n  if (key.id !== undefined && key.id !== null) {\\n    ipnsCid = key.id;\\n  }\\n\\n  if (ipnsCid == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return ipnsCid;\\n};\\n\\nIpfsLibrary.prototype.get = async function (client, ipfsPath, timeout) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null;\\n\\n  if (this.ipfsBundle.getCid(ipfsPath) == null) {\\n    ipfsPath = ipfsPath.replace(/\\\\/$/, '');\\n  }\\n\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['get']\\n    });\\n  }\\n\\n  if (client === undefined || client.get === undefined) {\\n    throw new Error('Undefined IPFS get...');\\n  }\\n\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null;\\n  const content = [];\\n\\n  if (timeout == null) {\\n    for await (const file of client.get(ipfsPath)) {\\n      if (file.content === undefined || file.content == null) {\\n        const err = new Error('IPFS returned an unknown result...');\\n        err.name = 'IPFSUnknownResult';\\n        throw err;\\n      }\\n\\n      for await (const chunk of file.content) {\\n        content.push(chunk);\\n      }\\n    }\\n  } else {\\n    for await (const file of client.get(ipfsPath, {\\n      timeout: timeout\\n    })) {\\n      if (file.content === undefined || file.content == null) {\\n        const err = new Error('IPFS returned an unknown result...');\\n        err.name = 'IPFSUnknownResult';\\n        throw err;\\n      }\\n\\n      for await (const chunk of file.content) {\\n        content.push(chunk);\\n      }\\n    }\\n  }\\n\\n  return content;\\n}; // Default\\n\\n\\nIpfsLibrary.prototype.getDefaultIpfs = async function (apiUrl) {\\n  // IPFS Companion first\\n  try {\\n    const {\\n      ipfs,\\n      provider\\n    } = await this.getWindowIpfs();\\n\\n    if (ipfs !== null) {\\n      return {\\n        ipfs: ipfs,\\n        provider: provider\\n      };\\n    }\\n  } catch (error) {// IPFS Companion failed\\n  } // Load IpfsHttpClient\\n\\n\\n  try {\\n    const {\\n      ipfs,\\n      provider\\n    } = await this.getHttpIpfs(apiUrl);\\n\\n    if (ipfs !== null) {\\n      return {\\n        ipfs: ipfs,\\n        provider: provider\\n      };\\n    }\\n  } catch (error) {// IPFS HTTP client failed\\n  }\\n\\n  throw new Error('Unable to retrieve IPFS Companion and IPFS API URL...');\\n}; // ipfs-http-client\\n\\n\\nIpfsLibrary.prototype.getHttpIpfs = async function (apiUrl) {\\n  apiUrl = apiUrl !== undefined && apiUrl !== null && apiUrl.toString().trim() !== '' ? apiUrl : null;\\n\\n  if (apiUrl == null) {\\n    throw new Error('Undefined IPFS API URL...');\\n  }\\n\\n  if (apiUrl instanceof URL === false) {\\n    apiUrl = this.ipfsBundle.getUrl(apiUrl);\\n  }\\n\\n  const self = this;\\n\\n  try {\\n    if (typeof globalThis.IpfsHttpClient === 'undefined') {\\n      await this.ipfsBundle.loadIpfsHttpLibrary();\\n    }\\n\\n    const client = this.ipfsClients.get(apiUrl.toString());\\n\\n    if (client !== undefined) {\\n      return {\\n        ipfs: client.ipfs,\\n        provider: client.provider\\n      };\\n    }\\n\\n    const {\\n      ipfs,\\n      provider\\n    } = await this.mutex.runExclusive(async () => {\\n      const protocol = apiUrl.protocol.slice(0, -1);\\n      var port = apiUrl.port;\\n\\n      if (port === undefined || port == null || port.trim() === '') {\\n        port = 443;\\n\\n        if (protocol === 'http') {\\n          port = 80;\\n        }\\n      }\\n\\n      const client = self.ipfsClients.get(apiUrl.toString());\\n\\n      if (client !== undefined) {\\n        return {\\n          ipfs: client.ipfs,\\n          provider: client.provider\\n        };\\n      }\\n\\n      const {\\n        ipfs,\\n        provider\\n      } = await getIpfs({\\n        providers: [httpClient({\\n          // loadHttpClientModule: () => require('ipfs-http-client'),\\n          loadHttpClientModule: () => globalThis.IpfsHttpClient.create,\\n          apiAddress: {\\n            protocol: protocol,\\n            host: apiUrl.hostname,\\n            port: port,\\n            timeout: $tw.utils.getLongTimeout()\\n          }\\n        })]\\n      });\\n      self.ipfsClients.set(apiUrl.toString(), {\\n        ipfs,\\n        provider\\n      }); // ??? Logger do not provide any output...\\n\\n      console.info(`New IPFS provider: \\\"${apiUrl}\\\"`);\\n      return {\\n        ipfs: ipfs,\\n        provider: provider\\n      };\\n    });\\n    return {\\n      ipfs: ipfs,\\n      provider: `${provider}, ${apiUrl}`\\n    };\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n}; // IPFS companion\\n\\n\\nIpfsLibrary.prototype.getWindowIpfs = async function () {\\n  try {\\n    this.getLogger().info('Processing connection to IPFS Companion...');\\n    const {\\n      ipfs,\\n      provider\\n    } = await getIpfs({\\n      providers: [windowIpfs()]\\n    });\\n    return {\\n      ipfs: ipfs,\\n      provider: provider\\n    };\\n  } catch (error) {\\n    this.getLogger().error(error);\\n  }\\n\\n  throw new Error('Unreachable IPFS Companion...');\\n};\\n\\nIpfsLibrary.prototype.hasPin = async function (client, key, type, ipfsPath) {\\n  try {\\n    if (ipfsPath) {\\n      ipfsPath = `${key}${ipfsPath}`;\\n    } else {\\n      ipfsPath = key;\\n    }\\n\\n    for await (var {\\n      cid,\\n      type: fetchedType\\n    } of client.pin.ls({\\n      paths: [ipfsPath]\\n    })) {\\n      if (cid !== undefined && cid !== null) {\\n        var {\\n          type: fetchedType,\\n          parentCid\\n        } = this.analyzePinType(fetchedType);\\n        const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n        const parentCidV1 = parentCid !== null ? this.ipfsBundle.cidToCidV1(parentCid) : null;\\n\\n        if (type) {\\n          if (type === fetchedType) {\\n            return {\\n              cid: cidV1,\\n              parentCid: parentCidV1,\\n              type: type\\n            };\\n          }\\n        }\\n\\n        return {\\n          cid: cidV1,\\n          parentCid: parentCidV1,\\n          type: fetchedType\\n        };\\n      }\\n    }\\n  } catch (error) {// Ignore\\n  }\\n\\n  return {\\n    cid: '',\\n    parentCid: null,\\n    type: ''\\n  };\\n};\\n\\nIpfsLibrary.prototype.isDirectory = function (ua) {\\n  if (ua.byteLength !== dagDirectory.byteLength) return false;\\n  return ua.every((val, i) => val === dagDirectory[i]);\\n};\\n\\nIpfsLibrary.prototype.isIpfsDirectory = async function (client, cid, timeout) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  cid = this.ipfsBundle.getCid(cid) !== null ? cid : null;\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS cid...');\\n  }\\n\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null;\\n  var stat = null;\\n\\n  if (timeout == null) {\\n    stat = await this.objectStat(client, cid);\\n  } else {\\n    stat = await this.objectStat(client, cid, timeout);\\n  }\\n\\n  if (stat.DataSize === 2) {\\n    var ua = null;\\n\\n    if (timeout == null) {\\n      ua = await this.objectData(client, cid);\\n    } else {\\n      ua = await this.objectData(client, cid, timeout);\\n    }\\n\\n    return this.isDirectory(ua);\\n  }\\n\\n  return false;\\n};\\n\\nIpfsLibrary.prototype.keyList = async function (client) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client === undefined || client.key === undefined || client.key.list === undefined) {\\n    throw new Error('Undefined IPFS key list...');\\n  }\\n\\n  const result = await client.key.list();\\n\\n  if (result === undefined || result == null || Array.isArray(result) === false) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return result;\\n};\\n\\nIpfsLibrary.prototype.keyRename = async function (client, oldIpnsKey, newIpnsKey) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  oldIpnsKey = oldIpnsKey !== undefined && oldIpnsKey !== null || oldIpnsKey.trim() !== '' ? oldIpnsKey.trim() : null;\\n\\n  if (oldIpnsKey == null) {\\n    throw new Error('Undefined Old IPNS key...');\\n  }\\n\\n  newIpnsKey = newIpnsKey !== undefined && newIpnsKey !== null && newIpnsKey.trim() !== '' ? newIpnsKey.trim() : null;\\n\\n  if (newIpnsKey == null) {\\n    throw new Error('Undefined New IPNS key...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client === undefined || client.key === undefined || client.key.rename === undefined) {\\n    throw new Error('Undefined IPFS key rename...');\\n  }\\n\\n  const key = await client.key.rename(oldIpnsKey, newIpnsKey);\\n\\n  if (key === undefined || key == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var ipnsCid = null;\\n\\n  if (key.id !== undefined && key.id !== null) {\\n    ipnsCid = key.id;\\n  }\\n\\n  var was = null;\\n\\n  if (key.was !== undefined && key.was !== null) {\\n    was = key.was;\\n  }\\n\\n  var now = null;\\n\\n  if (key.now !== undefined && key.now !== null) {\\n    now = key.now;\\n  }\\n\\n  var overwrite = null;\\n\\n  if (key.overwrite !== undefined && key.overwrite !== null) {\\n    overwrite = key.overwrite;\\n  }\\n\\n  if (ipnsCid == null || was == null || now == null || overwrite == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return {\\n    ipnsCid: ipnsCid,\\n    now: now,\\n    overwrite: overwrite,\\n    was: was\\n  };\\n};\\n\\nIpfsLibrary.prototype.ls = async function (client, ipfsPath) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null;\\n\\n  if (this.ipfsBundle.getCid(ipfsPath) == null) {\\n    ipfsPath = ipfsPath.replace(/\\\\/$/, '');\\n  }\\n\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['ls']\\n    });\\n  }\\n\\n  if (client === undefined || client.ls === undefined) {\\n    throw new Error('Undefined IPFS ls...');\\n  }\\n\\n  const content = new Map();\\n\\n  for await (const result of client.ls(ipfsPath)) {\\n    if (result === undefined || result == null) {\\n      const err = new Error('IPFS returned an unknown result...');\\n      err.name = 'IPFSUnknownResult';\\n      throw err;\\n    }\\n\\n    var cid = null;\\n\\n    if (result.cid !== undefined && result.cid !== null) {\\n      cid = result.cid;\\n    }\\n\\n    var depth = null;\\n\\n    if (result.depth !== undefined && result.depth !== null) {\\n      depth = result.depth;\\n    }\\n\\n    const mode = result.mode;\\n    const mtime = result.mtime;\\n    var name = null;\\n\\n    if (result.name !== undefined && result.name !== null) {\\n      name = result.name;\\n    }\\n\\n    var path = null;\\n\\n    if (result.path !== undefined && result.path !== null) {\\n      path = result.path;\\n    }\\n\\n    var size = null;\\n\\n    if (result.size !== undefined && result.size !== null) {\\n      size = result.size;\\n    }\\n\\n    var type = null;\\n\\n    if (result.type !== undefined && result.type !== null) {\\n      type = result.type;\\n    }\\n\\n    if (cid == null || depth == null || name == null || path == null || size == null || type == null) {\\n      const err = new Error('IPFS returned an unknown result...');\\n      err.name = 'IPFSUnknownResult';\\n      throw err;\\n    }\\n\\n    const cidV1 = this.ipfsBundle.cidToCidV1(cid);\\n    content.set(cidV1, {\\n      depth: depth,\\n      mode: mode,\\n      mtime: mtime,\\n      name: name,\\n      path: path,\\n      size: size,\\n      type: type\\n    });\\n  }\\n\\n  return content;\\n};\\n\\nIpfsLibrary.prototype.namePublish = async function (client, ipnsKey, cid, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.trim() !== '' ? ipnsKey.trim() : null;\\n\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...');\\n  }\\n\\n  cid = this.ipfsBundle.getCid(cid) !== null ? cid : null;\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['name']\\n    });\\n  }\\n\\n  if (client === undefined || client.name === undefined || client.name.publish === undefined) {\\n    throw new Error('Undefined IPFS name publish...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      resolve: false,\\n      key: ipnsKey,\\n      allowOffline: false\\n    };\\n  }\\n\\n  const result = await client.name.publish(`/ipfs/${cid}`, options);\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var name = null;\\n\\n  if (result.name !== undefined && result.name !== null) {\\n    name = result.name;\\n  }\\n\\n  var value = null;\\n\\n  if (result.value !== undefined && result.value !== null) {\\n    value = result.value;\\n  }\\n\\n  if (name == null || value == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return {\\n    name: name,\\n    value: value\\n  };\\n};\\n\\nIpfsLibrary.prototype.nameResolve = async function (client, value, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  value = value !== undefined && value !== null && value.trim() !== '' ? value.trim() : null;\\n\\n  if (value == null) {\\n    throw new Error('Undefined IPNS address...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['name']\\n    });\\n  }\\n\\n  if (client === undefined || client.name === undefined || client.name.resolve === undefined) {\\n    throw new Error('Undefined IPFS name resolve...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      nocache: false,\\n      recursive: true\\n    };\\n  }\\n\\n  const resolvedPaths = await client.name.resolve(value, options);\\n\\n  if (resolvedPaths === undefined || resolvedPaths == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var lastPath = null; // https://gist.github.com/alanshaw/04b2ddc35a6fff25c040c011ac6acf26\\n\\n  for await (const path of resolvedPaths) {\\n    lastPath = path !== undefined || path !== null ? path : null;\\n  }\\n\\n  if (lastPath == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return lastPath;\\n};\\n\\nIpfsLibrary.prototype.objectData = async function (client, cid, timeout) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  cid = this.ipfsBundle.getCid(cid) !== null ? cid : null;\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['object']\\n    });\\n  }\\n\\n  if (client === undefined || client.object === undefined || client.object.data === undefined) {\\n    throw new Error('Undefined IPFS object data...');\\n  }\\n\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null;\\n  var ua = null;\\n\\n  if (timeout == null) {\\n    ua = await client.object.data(cid);\\n  } else {\\n    ua = await client.object.data(cid, {\\n      timeout: timeout\\n    });\\n  }\\n\\n  if (ua === undefined || ua == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return ua;\\n};\\n\\nIpfsLibrary.prototype.objectStat = async function (client, cid, timeout) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  cid = this.ipfsBundle.getCid(cid) !== null ? cid : null;\\n\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS identifier...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['object']\\n    });\\n  }\\n\\n  if (client === undefined || client.object === undefined || client.object.stat === undefined) {\\n    throw new Error('Undefined IPFS object stat...');\\n  }\\n\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null;\\n  var stat = null;\\n\\n  if (timeout == null) {\\n    stat = await client.object.stat(cid);\\n  } else {\\n    stat = await client.object.stat(cid, {\\n      timeout: timeout\\n    });\\n  }\\n\\n  if (stat === undefined || stat == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var Hash = null;\\n\\n  if (stat.Hash !== undefined && stat.Hash !== null) {\\n    Hash = stat.Hash;\\n  }\\n\\n  var NumLinks = null;\\n\\n  if (stat.NumLinks !== undefined && stat.NumLinks !== null) {\\n    NumLinks = stat.NumLinks;\\n  }\\n\\n  var BlockSize = null;\\n\\n  if (stat.BlockSize !== undefined && stat.BlockSize !== null) {\\n    BlockSize = stat.BlockSize;\\n  }\\n\\n  var LinksSize = null;\\n\\n  if (stat.LinksSize !== undefined && stat.LinksSize !== null) {\\n    LinksSize = stat.LinksSize;\\n  }\\n\\n  var DataSize = null;\\n\\n  if (stat.DataSize !== undefined && stat.DataSize !== null) {\\n    DataSize = stat.DataSize;\\n  }\\n\\n  var CumulativeSize = null;\\n\\n  if (stat.CumulativeSize !== undefined && stat.CumulativeSize !== null) {\\n    CumulativeSize = stat.CumulativeSize;\\n  }\\n\\n  if (Hash == null || NumLinks == null || BlockSize == null || LinksSize == null || DataSize == null || CumulativeSize == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  const cidV1 = this.ipfsBundle.cidToCidV1(Hash);\\n  return {\\n    Hash: cidV1,\\n    NumLinks: NumLinks,\\n    BlockSize: BlockSize,\\n    LinksSize: LinksSize,\\n    DataSize: DataSize,\\n    CumulativeSize: CumulativeSize\\n  };\\n};\\n\\nIpfsLibrary.prototype.pinAdd = async function (client, ipfsPath, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null;\\n\\n  if (this.ipfsBundle.getCid(ipfsPath) == null) {\\n    ipfsPath = ipfsPath.replace(/\\\\/$/, '');\\n  }\\n\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['pin']\\n    });\\n  }\\n\\n  if (client === undefined || client.pin === undefined || client.pin.add === undefined) {\\n    throw new Error('Undefined IPFS pin add...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      recursive: true\\n    };\\n  }\\n\\n  const result = await client.pin.add(ipfsPath, options);\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return this.ipfsBundle.cidToCidV1(result, 'ipfs', true);\\n};\\n\\nIpfsLibrary.prototype.pinRm = async function (client, ipfsPath, options) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null;\\n\\n  if (this.ipfsBundle.getCid(ipfsPath) == null) {\\n    ipfsPath = ipfsPath.replace(/\\\\/$/, '');\\n  }\\n\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['pin']\\n    });\\n  }\\n\\n  if (client === undefined || client.pin === undefined || client.pin.rm === undefined) {\\n    throw new Error('Undefined IPFS pin rm...');\\n  }\\n\\n  if (options === undefined || options == null) {\\n    options = {\\n      recursive: true\\n    };\\n  }\\n\\n  const result = await client.pin.rm(ipfsPath, options);\\n\\n  if (result === undefined || result == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return this.ipfsBundle.cidToCidV1(result, 'ipfs', true);\\n};\\n\\nIpfsLibrary.prototype.rmKey = async function (client, ipnsKey) {\\n  if (client === undefined || client == null) {\\n    throw new Error('Undefined IPFS provider...');\\n  }\\n\\n  ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.trim() !== '' ? ipnsKey.trim() : null;\\n\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...');\\n  }\\n\\n  if (client.enable) {\\n    client = await client.enable({\\n      commands: ['key']\\n    });\\n  }\\n\\n  if (client === undefined || client.key === undefined || client.key.rm === undefined) {\\n    throw new Error('Undefined IPFS key rm...');\\n  }\\n\\n  const key = await client.key.rm(ipnsKey);\\n\\n  if (key === undefined || key == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  var ipnsCid = null;\\n\\n  if (key.id !== undefined && key.id !== null) {\\n    ipnsCid = key.id;\\n  }\\n\\n  if (ipnsCid == null) {\\n    const err = new Error('IPFS returned an unknown result...');\\n    err.name = 'IPFSUnknownResult';\\n    throw err;\\n  }\\n\\n  return ipnsCid;\\n};\\n\\nexports.IpfsLibrary = IpfsLibrary;\\n\\n},{\\\"async-mutex\\\":11,\\\"core-js/modules/es.string.replace.js\\\":133,\\\"core-js/modules/esnext.map.delete-all.js\\\":136,\\\"core-js/modules/esnext.map.every.js\\\":137,\\\"core-js/modules/esnext.map.filter.js\\\":138,\\\"core-js/modules/esnext.map.find-key.js\\\":139,\\\"core-js/modules/esnext.map.find.js\\\":140,\\\"core-js/modules/esnext.map.includes.js\\\":141,\\\"core-js/modules/esnext.map.key-of.js\\\":142,\\\"core-js/modules/esnext.map.map-keys.js\\\":143,\\\"core-js/modules/esnext.map.map-values.js\\\":144,\\\"core-js/modules/esnext.map.merge.js\\\":145,\\\"core-js/modules/esnext.map.reduce.js\\\":146,\\\"core-js/modules/esnext.map.some.js\\\":147,\\\"core-js/modules/esnext.map.update.js\\\":148,\\\"core-js/modules/web.dom-collections.iterator.js\\\":149,\\\"core-js/modules/web.url.js\\\":151,\\\"ipfs-provider\\\":161,\\\"uint8arrays\\\":204}],5:[function(require,module,exports){\\n/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-loader.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\n\\\\*/\\n'use strict';\\n\\nrequire(\\\"core-js/modules/web.dom-collections.iterator.js\\\");\\n\\nrequire(\\\"core-js/modules/web.url.js\\\");\\n\\nrequire(\\\"core-js/modules/es.typed-array.uint8-array.js\\\");\\n\\nconst Mutex = require('async-mutex').Mutex;\\n\\nvar IpfsLoader = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle;\\n  this.mutex = new Mutex();\\n  this.name = 'ipfs-loader';\\n};\\n\\nIpfsLoader.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger();\\n}; // https://github.com/liriliri/eruda\\n\\n\\nIpfsLoader.prototype.loadErudaLibrary = async function () {\\n  if (typeof globalThis.eruda === 'undefined') {\\n    await this.loadTiddlerLibrary('$:/ipfs/library/eruda', 'eruda');\\n  }\\n}; // https://github.com/ethers-io/ethers.js/\\n\\n\\nIpfsLoader.prototype.loadEtherJsLibrary = async function () {\\n  if (typeof globalThis.ethers === 'undefined') {\\n    await this.loadTiddlerLibrary('$:/ipfs/library/ethers', 'ethers');\\n  }\\n}; // https://github.com/xmaysonnave/eth-sig-util\\n\\n\\nIpfsLoader.prototype.loadEthSigUtilLibrary = async function () {\\n  if (typeof globalThis.sigUtil === 'undefined') {\\n    await this.loadTiddlerLibrary('$:/ipfs/library/eth-sig-util', 'sigUtil');\\n  }\\n}; // https://github.com/ipfs/js-ipfs-http-client\\n\\n\\nIpfsLoader.prototype.loadIpfsHttpLibrary = async function () {\\n  if (typeof globalThis.IpfsHttpClient === 'undefined') {\\n    await this.loadTiddlerLibrary('$:/ipfs/library/ipfs-http-client', 'IpfsHttpClient');\\n  }\\n}; // https://gist.github.com/ebidel/3201b36f59f26525eb606663f7b487d0\\n\\n\\nIpfsLoader.prototype.supportDynamicImport = function () {\\n  try {\\n    /*eslint no-new:\\\"off\\\",no-new-func:\\\"off\\\"*/\\n    new Function('import(\\\"\\\")');\\n    return true;\\n  } catch (error) {\\n    return false;\\n  }\\n}; // https://www.srihash.org/\\n\\n\\nIpfsLoader.prototype.loadTiddlerLibrary = async function (title, obj) {\\n  if (globalThis[obj] !== undefined && globalThis[obj] !== null) {\\n    return;\\n  }\\n\\n  const self = this;\\n  const tiddler = $tw.wiki.getTiddler(title);\\n\\n  if (tiddler === undefined || tiddler == null) {\\n    throw new Error(`Undefined Library: ${title}`);\\n  }\\n\\n  const sourceUri = tiddler.fields._source_uri;\\n  const sourceSri = tiddler.fields._source_sri;\\n  const isModule = tiddler.fields._module === 'yes';\\n  await this.mutex.runExclusive(async () => {\\n    if (globalThis[obj] === undefined || globalThis[obj] == null) {\\n      const loaded = await self.loadLibrary(title, sourceUri, sourceSri, isModule);\\n\\n      if (loaded !== undefined && loaded !== null && globalThis[obj] !== undefined && globalThis[obj] !== null) {\\n        self.getLogger().info(`Loaded ${title}:\\n ${sourceUri}`);\\n        return;\\n      }\\n\\n      throw new Error(`Unable to load Library: ${title}`);\\n    }\\n  });\\n}; // https://observablehq.com/@bryangingechen/dynamic-import-polyfill\\n\\n\\nIpfsLoader.prototype.loadLibrary = function (id, url, sri, isModule) {\\n  const self = this;\\n  return new Promise((resolve, reject) => {\\n    const script = globalThis.document.createElement('script');\\n\\n    const cleanup = () => {\\n      try {\\n        delete globalThis[id];\\n        script.onerror = null;\\n        script.onload = null;\\n        script.remove();\\n        URL.revokeObjectURL(script.src);\\n        script.src = '';\\n      } catch (error) {\\n        self.getLogger().error(error);\\n      }\\n    };\\n\\n    script.onload = () => {\\n      resolve(globalThis[id]);\\n      cleanup();\\n    };\\n\\n    script.onerror = () => {\\n      reject(new Error(`Failed to load: ${url}`));\\n      cleanup();\\n    };\\n\\n    if (isModule) {\\n      script.type = 'module';\\n    } else {\\n      script.type = 'text/javascript';\\n    }\\n\\n    script.id = id;\\n    script.async = false;\\n    script.defer = 'defer';\\n\\n    if (sri) {\\n      script.integrity = sri;\\n    }\\n\\n    script.crossOrigin = 'anonymous';\\n    script.src = url; // Load\\n\\n    globalThis.document.head.appendChild(script);\\n  });\\n};\\n\\nIpfsLoader.prototype.isJson = function (content) {\\n  if (content !== undefined && content !== null && typeof content === 'string') {\\n    try {\\n      JSON.parse(content);\\n      return true;\\n    } catch (error) {// Ignore\\n    }\\n  }\\n\\n  return false;\\n};\\n\\nIpfsLoader.prototype.fetchUint8Array = async function (url) {\\n  var options = null;\\n  const optionsController = new AbortController();\\n  const optionsId = globalThis.setTimeout(() => optionsController.abort(), $tw.utils.getLongTimeout()); // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\\n\\n  var fetchHeaders = {\\n    'Accept-Encoding': 'identity;q=0\\\", *;q=0'\\n  };\\n\\n  try {\\n    const params = {\\n      method: 'options',\\n      signal: optionsController.signal\\n    };\\n    options = await fetch(url, params);\\n\\n    if (options === undefined || options == null || options.ok === false) {\\n      throw new Error(`Unexpected response ${options.statusText}`);\\n    }\\n  } catch (error) {\\n    if (error.name === 'AbortError') {\\n      this.getLogger().error(`*** Timeout exceeded: ${$tw.utils.getLongTimeout()} ms ***`);\\n    } else {\\n      this.getLogger().error(`*** Options error: ${error.message} ***`);\\n    }\\n  }\\n\\n  globalThis.clearTimeout(optionsId);\\n\\n  try {\\n    const responseController = new AbortController();\\n    const responseId = globalThis.setTimeout(() => responseController.abort(), $tw.utils.getLongTimeout()); // https://fetch.spec.whatwg.org/#cors-safelisted-method\\n    // https://fetch.spec.whatwg.org/#cors-safelisted-request-header\\n\\n    const params = {\\n      headers: fetchHeaders,\\n      method: 'get',\\n      mode: 'cors',\\n      signal: responseController.signal\\n    };\\n    var newUrl = null;\\n\\n    if (options && options.ok && options.url) {\\n      newUrl = new URL(options.url);\\n    }\\n\\n    if (options && options.ok && newUrl == null && options.headers.get('Location') !== undefined) {\\n      newUrl = new URL(options.headers.get('Location'));\\n    }\\n\\n    if (newUrl == null) {\\n      newUrl = url;\\n    }\\n\\n    const response = await fetch(newUrl, params);\\n    globalThis.clearTimeout(responseId);\\n\\n    if (response === undefined || response == null || response.ok === false) {\\n      throw new Error(`Unexpected response ${response.statusText}`);\\n    }\\n\\n    if ($tw.browser && !$tw.node) {\\n      const ab = await response.arrayBuffer();\\n      const ua = new Uint8Array(ab);\\n      this.getLogger().info(`[${response.status}] Loaded:\\n ${response.url}`);\\n      return ua;\\n    }\\n\\n    return await response.buffer();\\n  } catch (error) {\\n    if (error.name === 'AbortError') {\\n      this.getLogger().error(`*** Timeout exceeded: ${$tw.utils.getLongTimeout()} ms ***`);\\n    } else {\\n      this.getLogger().error(`*** [${error.message}] ${$tw.language.getString('NetworkError/Fetch')} ***`);\\n    }\\n  }\\n\\n  throw new Error(`${$tw.language.getString('NetworkError/Fetch')}`);\\n};\\n\\nIpfsLoader.prototype.xhrToJson = async function (url) {\\n  return await this.httpRequest(url, 'post', 'json');\\n};\\n\\nIpfsLoader.prototype.xhrToUint8Array = async function (url) {\\n  return await this.httpRequest(url, 'get', 'arraybuffer');\\n};\\n\\nIpfsLoader.prototype.httpRequest = function (url, method, responseType) {\\n  const self = this;\\n  const xhr = new XMLHttpRequest();\\n  return new Promise(function (resolve, reject) {\\n    xhr.responseType = responseType;\\n\\n    xhr.onreadystatechange = function () {\\n      if (xhr.readyState === 4 && xhr.status !== 0) {\\n        if (xhr.status >= 300) {\\n          reject(new Error($tw.language.getString('NetworkError/Fetch')));\\n          return;\\n        }\\n\\n        try {\\n          var result = null;\\n\\n          if (responseType === 'arraybuffer') {\\n            result = new Uint8Array(this.response);\\n          } else {\\n            result = this.response;\\n          }\\n\\n          self.getLogger().info(`[${xhr.status}] Loaded:\\n ${xhr.responseURL}`);\\n          resolve(result);\\n        } catch (error) {\\n          reject(error);\\n        }\\n      }\\n    };\\n\\n    xhr.onerror = function () {\\n      reject(new Error($tw.language.getString('NetworkError/Fetch')));\\n    };\\n\\n    try {\\n      xhr.open(method, url, true);\\n      xhr.send();\\n    } catch (error) {\\n      reject(error);\\n    }\\n  });\\n};\\n\\nIpfsLoader.prototype.checkMessage = async function (message, keccak256, signature) {\\n  message = message !== undefined && message !== null && message.trim() !== '' ? message.trim() : null;\\n\\n  if (message == null) {\\n    throw new Error('Undefined encrypted content...');\\n  }\\n\\n  if (keccak256) {\\n    const hash = $tw.crypto.keccak256(message);\\n\\n    if (keccak256 !== hash) {\\n      throw new Error('Tampered encrypted content, signature do not match...');\\n    }\\n  }\\n\\n  if (signature) {\\n    try {\\n      const recovered = await this.ipfsBundle.personalRecover(keccak256, signature);\\n      this.getLogger().info(`Signed from: https://app.ens.domains/address/${recovered}`);\\n      $tw.utils.alert(this.name, `Signed from: <a class=\\\"tc-tiddlylink-external\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\" href=\\\"https://app.ens.domains/address/${recovered}\\\">${recovered}</a>`);\\n    } catch (error) {\\n      if (error.name === 'UnrecoverableSignature') {\\n        throw new Error(`Tampered encrypted content. ${error.message}`);\\n      }\\n\\n      throw error;\\n    }\\n  }\\n};\\n/**\\n * Load to Base64\\n */\\n\\n\\nIpfsLoader.prototype.loadToBase64 = async function (url, password) {\\n  url = url !== undefined && url !== null && url.toString().trim() !== '' ? url.toString().trim() : null;\\n\\n  if (url == null) {\\n    throw new Error('Undefined URL...');\\n  }\\n\\n  password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null;\\n  const ua = await this.fetchUint8Array(url);\\n\\n  if (ua === undefined || ua == null || ua.length === undefined || ua.length === 0) {\\n    return '';\\n  }\\n\\n  var content = this.ipfsBundle.Utf8ArrayToStr(ua);\\n\\n  if (content.match(/^{\\\"compressed\\\":/)) {\\n    const json = JSON.parse(content);\\n\\n    if (json.compressed.match(/^{\\\"iv\\\":/)) {\\n      if (password == null && $tw.crypto.hasPassword() === false) {\\n        content = await $tw.boot.decryptFromPasswordPrompt(json.compressed);\\n      } else {\\n        content = $tw.crypto.decrypt(json.compressed, password);\\n      }\\n\\n      content = this.ipfsBundle.inflate(content);\\n    } else if (json.compressed.match(/^{\\\"version\\\":/)) {\\n      if (json.signature) {\\n        const signature = await this.ipfsBundle.decrypt(json.signature);\\n        await this.checkMessage(json.compressed, json.keccak256, signature);\\n      }\\n\\n      content = await this.ipfsBundle.decrypt(json.compressed);\\n      content = this.ipfsBundle.inflate(content);\\n    } else {\\n      content = this.ipfsBundle.inflate(json.compressed);\\n    }\\n  } else if (content.match(/^{\\\"encrypted\\\":/)) {\\n    const json = JSON.parse(content);\\n\\n    if (json.signature) {\\n      const signature = await this.ipfsBundle.decrypt(json.signature);\\n      await this.checkMessage(json.encrypted, json.keccak256, signature);\\n    }\\n\\n    content = await this.ipfsBundle.decrypt(json.encrypted);\\n    content = btoa(content);\\n  } else if (content.match(/^{\\\"iv\\\":/)) {\\n    if (password == null && $tw.crypto.hasPassword() === false) {\\n      content = await $tw.boot.decryptFromPasswordPrompt(content);\\n    } else {\\n      content = $tw.crypto.decrypt(content, password);\\n    }\\n\\n    content = btoa(content);\\n  } else {\\n    content = this.ipfsBundle.Uint8ArrayToBase64(ua);\\n  }\\n\\n  return content;\\n};\\n/**\\n * Load to UTF-8\\n */\\n\\n\\nIpfsLoader.prototype.loadToUtf8 = async function (url, password) {\\n  url = url !== undefined && url !== null && url.toString().trim() !== '' ? url.toString().trim() : null;\\n\\n  if (url == null) {\\n    throw new Error('Undefined URL...');\\n  }\\n\\n  password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null;\\n  const ua = await this.fetchUint8Array(url);\\n\\n  if (ua === undefined || ua == null || ua.length === undefined || ua.length === 0) {\\n    return '';\\n  }\\n\\n  var content = this.ipfsBundle.Utf8ArrayToStr(ua);\\n\\n  if (content.match(/^{\\\"compressed\\\":/)) {\\n    const compressedStoreArea = $tw.utils.extractCompressedStoreArea(content);\\n\\n    if (compressedStoreArea) {\\n      content = compressedStoreArea;\\n    }\\n\\n    const json = JSON.parse(content);\\n\\n    if (json.compressed.match(/^{\\\"iv\\\":/)) {\\n      if (password == null && $tw.crypto.hasPassword() === false) {\\n        content = await $tw.boot.decryptFromPasswordPrompt(json.compressed);\\n      } else {\\n        content = $tw.crypto.decrypt(json.compressed, password);\\n      }\\n\\n      content = this.ipfsBundle.inflate(content);\\n    } else if (json.compressed.match(/^{\\\"version\\\":/)) {\\n      if (json.signature) {\\n        const signature = await this.ipfsBundle.decrypt(json.signature);\\n        await this.checkMessage(json.compressed, json.keccak256, signature);\\n      }\\n\\n      content = await this.ipfsBundle.decrypt(json.compressed);\\n      content = this.ipfsBundle.inflate(content);\\n    } else {\\n      content = this.ipfsBundle.inflate(json.compressed);\\n    }\\n  } else if (content.match(/^{\\\"encrypted\\\":/)) {\\n    const encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(content);\\n\\n    if (encryptedStoreArea) {\\n      content = encryptedStoreArea;\\n    }\\n\\n    const json = JSON.parse(content);\\n\\n    if (json.signature) {\\n      const signature = await this.ipfsBundle.decrypt(json.signature);\\n      await this.checkMessage(json.encrypted, json.keccak256, signature);\\n    }\\n\\n    content = await this.ipfsBundle.decrypt(json.encrypted);\\n  } else if (content.match(/^{\\\"iv\\\":/)) {\\n    const encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(content);\\n\\n    if (encryptedStoreArea) {\\n      content = encryptedStoreArea;\\n    }\\n\\n    if (password == null && $tw.crypto.hasPassword() === false) {\\n      content = await $tw.boot.decryptFro€€