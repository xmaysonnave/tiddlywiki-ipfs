
ÓøÉøe, true, ensDomain, null, web3)\\n        await $tw.ipfs.requestToUnpin(ensCid)\\n      }\\n      // Upload\\n      $tw.ipfs.getLogger().info(`Uploading wiki: ${text.length} bytes`)\\n      const { added } = await $tw.ipfs.addToIpfs(text)\\n      pathname = `/${ipfsKeyword}/${added}`\\n      // Pin\\n      await $tw.ipfs.requestToPin(added)\\n      // Publish to IPNS\\n      if (ipnsKey !== null && ipnsName !== null) {\\n        $tw.utils.alert(name, `Publishing IPNS name: ${ipnsName}`)\\n        try {\\n          await $tw.ipfs.publishIpnsName(added, ipnsKey, ipnsName)\\n          pathname = `/${ipnsKeyword}/${ipnsKey}`\\n          $tw.utils.alert(name, `Successfully Published IPNS name: ${ipnsName}`)\\n        } catch (error) {\\n          $tw.ipfs.getLogger().warn(error)\\n          $tw.utils.alert(name, error.message)\\n          await $tw.ipfs.requestToPin(ipnsCid)\\n        }\\n      }\\n      // Publish to ENS\\n      if ($tw.utils.getIpfsProtocol() === ensKeyword) {\\n        try {\\n          $tw.utils.alert(name, `Publishing to ENS: ${ensDomain}`)\\n          await $tw.ipfs.setContentHash(ensDomain, `/${ipfsKeyword}/${added}`, web3, account)\\n          $tw.utils.alert(name, `Successfully published to ENS: ${ensDomain}`)\\n        } catch (error) {\\n          $tw.ipfs.getLogger().warn(error)\\n          $tw.utils.alert(name, error.message)\\n          await $tw.ipfs.requestToPin(ensCid)\\n        }\\n      }\\n      // Unpin\\n      if ($tw.utils.getIpfsUnpin()) {\\n        for (var i in $tw.ipfs.unpin) {\\n          try {\\n            const unpin = $tw.ipfs.unpin[i]\\n            await $tw.ipfs.unpinFromIpfs(unpin)\\n          } catch (error) {\\n            $tw.ipfs.getLogger().warn(error)\\n            $tw.utils.alert(name, error.message)\\n          }\\n        }\\n      }\\n      $tw.ipfs.unpin = []\\n      // Pin\\n      if ($tw.utils.getIpfsPin()) {\\n        for (var i in $tw.ipfs.pin) {\\n          try {\\n            const pin = $tw.ipfs.pin[i]\\n            await $tw.ipfs.pinToIpfs(pin)\\n          } catch (error) {\\n            $tw.ipfs.getLogger().warn(error)\\n            $tw.utils.alert(name, error.message)\\n          }\\n        }\\n      }\\n      $tw.ipfs.pin = []\\n      // Callback\\n      callback(null)\\n      // Next\\n      const next = $tw.ipfs.getUrl(`${protocol}//${credential}${host}${pathname}${search}${hash}`)\\n      if (next.host !== wiki.host || next.pathname !== wiki.pathname) {\\n        $tw.ipfs.getLogger().info(`Loading: '${next.href}'`)\\n        window.location.assign(next.href)\\n      }\\n    } catch (error) {\\n      if (error.name !== 'OwnerError' && error.name !== 'RejectedUserRequest' && error.name !== 'UnauthorizedUserAccount') {\\n        $tw.ipfs.getLogger().error(error)\\n      }\\n      callback(error)\\n      return true\\n    }\\n    callback(null)\\n    return true\\n  }\\n\\n  /*\\n   * Information about this saver\\n   */\\n  IpfsSaver.prototype.info = {\\n    name: 'Ipfs',\\n    priority: 3100,\\n    capabilities: ['save'],\\n  }\\n\\n  /*\\n   * Static method that returns true if this saver is capable of working\\n   */\\n  exports.canSave = function (wiki) {\\n    return true\\n  }\\n\\n  /*\\n   * Create an instance of this saver\\n   */\\n  exports.create = function (wiki) {\\n    return new IpfsSaver(wiki)\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"saver\"\n        },\n        \"$:/core/modules/saver-handler.js\": {\n            \"title\": \"$:/core/modules/saver-handler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/saver-handler.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: global\\n\\nThe saver handler tracks changes to the store and handles saving the entire wiki via saver modules.\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /**\\n   * Instantiate the saver handler with the following options:\\n   * wiki: wiki to be synced\\n   * dirtyTracking: true if dirty tracking should be performed\\n   */\\n  function SaverHandler (options) {\\n    var self = this\\n    this.wiki = options.wiki\\n    this.dirtyTracking = options.dirtyTracking\\n    this.preloadDirty = options.preloadDirty || []\\n    this.pendingAutoSave = false\\n    // Make a logger\\n    this.logger = new $tw.utils.Logger('saver-handler')\\n    // Initialise our savers\\n    if ($tw.browser) {\\n      this.initSavers()\\n    }\\n    // Only do dirty tracking if required\\n    if ($tw.browser && this.dirtyTracking) {\\n      // Compile the dirty tiddler filter\\n      this.filterFn = this.wiki.compileFilter(this.wiki.getTiddlerText(this.titleSyncFilter))\\n      // Count of changes that have not yet been saved\\n      var filteredChanges = self.filterFn.call(self.wiki, function (iterator) {\\n        $tw.utils.each(self.preloadDirty, function (title) {\\n          var tiddler = self.wiki.getTiddler(title)\\n          iterator(tiddler, title)\\n        })\\n      })\\n      this.numChanges = filteredChanges.length\\n      // Listen out for changes to tiddlers\\n      this.wiki.addEventListener('change', async function (changes) {\\n        // Filter the changes so that we only count changes to tiddlers that we care about\\n        var filteredChanges = self.filterFn.call(self.wiki, function (iterator) {\\n          $tw.utils.each(changes, function (change, title) {\\n            var tiddler = self.wiki.getTiddler(title)\\n            iterator(tiddler, title)\\n          })\\n        })\\n        // Adjust the number of changes\\n        self.numChanges += filteredChanges.length\\n        self.updateDirtyStatus()\\n        // Do any autosave if one is pending and there's no more change events\\n        if (self.pendingAutoSave && self.wiki.getSizeOfTiddlerEventQueue() === 0) {\\n          // Check if we're dirty\\n          if (self.numChanges > 0) {\\n            await self.saveWiki({\\n              method: 'autosave',\\n              downloadType: 'text/plain',\\n            })\\n          }\\n          self.pendingAutoSave = false\\n        }\\n      })\\n      // Listen for the autosave event\\n      $tw.rootWidget.addEventListener('tm-auto-save-wiki', async function (event) {\\n        // Do the autosave unless there are outstanding tiddler change events\\n        if (self.wiki.getSizeOfTiddlerEventQueue() === 0) {\\n          // Check if we're dirty\\n          if (self.numChanges > 0) {\\n            await self.saveWiki({\\n              method: 'autosave',\\n              downloadType: 'text/plain',\\n            })\\n          }\\n        } else {\\n          // Otherwise put ourselves in the \\\"pending autosave\\\" state and wait for the change event before we do the autosave\\n          self.pendingAutoSave = true\\n        }\\n      })\\n      // Set up our beforeunload handler\\n      $tw.addUnloadTask(function (event) {\\n        var confirmationMessage\\n        if (self.isDirty()) {\\n          confirmationMessage = $tw.language.getString('UnsavedChangesWarning')\\n          event.returnValue = confirmationMessage // Gecko\\n        }\\n        return confirmationMessage\\n      })\\n    }\\n    // Install the save action handlers\\n    if ($tw.browser) {\\n      $tw.rootWidget.addEventListener('tm-save-wiki', async function (event) {\\n        await self.saveWiki({\\n          template: event.param,\\n          downloadType: 'text/plain',\\n          variables: event.paramObject,\\n        })\\n      })\\n      $tw.rootWidget.addEventListener('tm-download-file', async function (event) {\\n        await self.saveWiki({\\n          method: 'download',\\n          template: event.param,\\n          downloadType: 'text/plain',\\n          variables: event.paramObject,\\n        })\\n      })\\n    }\\n  }\\n\\n  SaverHandler.prototype.titleSyncFilter = '$:/config/SaverFilter'\\n  SaverHandler.prototype.titleAutoSave = '$:/config/AutoSave'\\n  SaverHandler.prototype.titleSavedNotification = '$:/language/Notifications/Save/Done'\\n\\n  /**\\n   * Select the appropriate saver modules and set them up\\n   */\\n  SaverHandler.prototype.initSavers = function (moduleType) {\\n    moduleType = moduleType || 'saver'\\n    // Instantiate the available savers\\n    this.savers = []\\n    var self = this\\n    $tw.modules.forEachModuleOfType(moduleType, function (title, module) {\\n      if (module.canSave(self)) {\\n        self.savers.push({ title: title, module: module.create(self.wiki) })\\n      }\\n    })\\n    // Sort savers\\n    this.sortSavers()\\n  }\\n\\n  /*\\n   * Sort the savers into priority order\\n   */\\n  SaverHandler.prototype.sortSavers = function () {\\n    this.savers.sort(function (a, b) {\\n      if (a.module.info.priority < b.module.info.priority) {\\n        return -1\\n      } else {\\n        if (a.module.info.priority > b.module.info.priority) {\\n          return +1\\n        } else {\\n          return 0\\n        }\\n      }\\n    })\\n  }\\n\\n  /**\\n   * Save the wiki contents. Options are:\\n   * method: \\\"save\\\", \\\"autosave\\\" or \\\"download\\\"\\n   * template: the tiddler containing the template to save\\n   * downloadType: the content type for the saved file\\n   */\\n  SaverHandler.prototype.saveWiki = async function (options) {\\n    options = options || {}\\n    var self = this\\n    var method = options.method || 'save'\\n    // Ignore autosave if disabled\\n    if (method === 'autosave' && this.wiki.getTiddlerText(this.titleAutoSave, 'yes') !== 'yes') {\\n      return false\\n    }\\n    if ($tw.browser && typeof $tw.crypto.hasEncryptionPublicKey === 'function' && $tw.crypto.hasEncryptionPublicKey()) {\\n      await $tw.ipfs.loadEthSigUtilLibrary()\\n    }\\n    var variables = options.variables || {}\\n    var template = options.template || '$:/core/save/all'\\n    var downloadType = options.downloadType || 'text/plain'\\n    var text = await this.wiki.renderTiddlerAndSign(downloadType, template, options)\\n    var callback = function (err) {\\n      if (err) {\\n        alert($tw.language.getString('Error/WhileSaving') + ':\\\\n\\\\n' + err)\\n      } else {\\n        // Clear the task queue if we're saving (rather than downloading)\\n        if (method !== 'download') {\\n          self.numChanges = 0\\n          self.updateDirtyStatus()\\n        }\\n        $tw.notifier.display(self.titleSavedNotification)\\n        if (options.callback) {\\n          options.callback()\\n        }\\n      }\\n    }\\n    // Process preferred if any\\n    var ignorePreferred = null\\n    var preferredSaver = $tw.wiki.getTiddler('$:/config/PreferredSaver')\\n    if (preferredSaver !== undefined && preferredSaver !== null) {\\n      var title = preferredSaver.fields.text\\n      title = title !== undefined && title !== null && title.trim() !== '' ? title.trim() : null\\n      if (title !== null) {\\n        var saver = this.getSaver(title)\\n        if (saver !== null && saver.module !== undefined) {\\n          if (await this.save(saver.module, method, variables, text, callback)) {\\n            return true\\n          }\\n        }\\n        ignorePreferred = title\\n      }\\n    }\\n\\n    // Call the highest priority saver that supports this method\\n    for (var t = this.savers.length - 1; t >= 0; t--) {\\n      // Ignore failed preferred if any\\n      if (this.savers[t].title === ignorePreferred) {\\n        continue\\n      }\\n      // Process\\n      if (await this.save(this.savers[t].module, method, variables, text, callback)) {\\n        return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  SaverHandler.prototype.getSaver = function (title) {\\n    // Locate saver\\n    var saver = null\\n    for (var i = 0; i < this.savers.length; i++) {\\n      var current = this.savers[i]\\n      if (current.title === title) {\\n        saver = current\\n        break\\n      }\\n    }\\n    return saver\\n  }\\n\\n  SaverHandler.prototype.save = async function (saver, method, variables, text, callback) {\\n    if (saver.info.capabilities.indexOf(method) !== -1) {\\n      var saved = await saver.save(text, method, callback, {\\n        variables: { filename: variables.filename },\\n      })\\n      if (saved) {\\n        this.logger.log('Saved wiki with method', method, 'through saver', saver.info.name)\\n        return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  /**\\n   * Checks whether the wiki is dirty (ie the window shouldn't be closed)\\n   */\\n  SaverHandler.prototype.isDirty = function () {\\n    return this.numChanges > 0\\n  }\\n\\n  /**\\n   * Update the document body with the class \\\"tc-dirty\\\" if the wiki has unsaved/unsynced changes\\n   */\\n  SaverHandler.prototype.updateDirtyStatus = function () {\\n    var self = this\\n    if ($tw.browser) {\\n      $tw.utils.toggleClass(document.body, 'tc-dirty', this.isDirty())\\n      $tw.utils.each($tw.windows, function (win) {\\n        $tw.utils.toggleClass(win.document.body, 'tc-dirty', self.isDirty())\\n      })\\n    }\\n  }\\n\\n  exports.SaverHandler = SaverHandler\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"global\"\n        },\n        \"$:/core/modules/startup/compress.js\": {\n            \"title\": \"$:/core/modules/startup/compress.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/startup/compress.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: startup\\n\\nCompression handling\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  // Export name and synchronous status\\n  exports.name = 'compress'\\n  exports.platforms = ['browser']\\n  exports.after = ['startup']\\n  exports.synchronous = true\\n\\n  exports.startup = function () {\\n    // Ensure that $:/isCompressed is maintained properly\\n    $tw.wiki.addEventListener('change', function (changes) {\\n      if ($tw.utils.hop(changes, '$:/isCompressed')) {\\n        const tiddler = $tw.wiki.getTiddler('$:/isCompressed')\\n        $tw.compress.setCompressState(tiddler.fields.text === 'yes')\\n      }\\n    })\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/ipfs/ipfs-password.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-password.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-password.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: startup\\n\\nCompression handling\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const name = 'ipfs-password'\\n\\n  // Export name and synchronous status\\n  exports.name = 'ipfs-password'\\n  exports.platforms = ['browser']\\n  exports.after = ['startup']\\n  exports.synchronous = true\\n\\n  exports.startup = function () {\\n    const setPassword = function () {\\n      $tw.passwordPrompt.createPrompt({\\n        serviceName: $tw.language.getString('Encryption/PromptSetPassword'),\\n        noUserName: true,\\n        submitText: $tw.language.getString('Encryption/SetPassword'),\\n        canCancel: true,\\n        repeatPassword: true,\\n        callback: function (data) {\\n          if (data) {\\n            $tw.crypto.setPassword(data.password)\\n          } else {\\n            $tw.crypto.setPassword(null)\\n          }\\n          return true // Get rid of the password prompt\\n        },\\n      })\\n    }\\n    // Ensure that $:/isEncrypted is maintained properly\\n    $tw.wiki.addEventListener('change', function (changes) {\\n      if ($tw.utils.hop(changes, '$:/config/encryption')) {\\n        const encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\\n        if (encrypted.fields.text === 'yes') {\\n          const hasPassword = $tw.crypto.hasPassword()\\n          const encryption = $tw.wiki.getTiddler('$:/config/encryption')\\n          if (!hasPassword && encryption.fields.text === 'standford') {\\n            setPassword()\\n          } else if (hasPassword) {\\n            $tw.rootWidget.dispatchEvent({ type: 'tm-clear-password' })\\n          }\\n        }\\n      }\\n    })\\n    $tw.rootWidget.addEventListener('tm-set-password', async function (event) {\\n      const encryption = $tw.wiki.getTiddler('$:/config/encryption')\\n      if (encryption.fields.text === 'standford') {\\n        if ($tw.crypto.hasPassword() === false) {\\n          setPassword()\\n        }\\n      } else {\\n        try {\\n          const encryptionKey = await $tw.ipfs.getPublicEncryptionKey()\\n          $tw.crypto.setEncryptionKey(encryptionKey)\\n        } catch (error) {\\n          if (error.name !== 'RejectedUserRequest') {\\n            $tw.ipfs.getLogger().error(error)\\n          }\\n          $tw.utils.alert(name, error.message)\\n          $tw.crypto.setEncryptionKey()\\n        }\\n      }\\n    })\\n    $tw.rootWidget.addEventListener('tm-clear-password', async function (event) {\\n      if ($tw.browser) {\\n        const hasPassword = $tw.crypto.hasPassword()\\n        const hasEncryptionPublicKey = $tw.crypto.hasEncryptionPublicKey()\\n        if (hasPassword) {\\n          if (!confirm($tw.language.getString('Encryption/ConfirmClearPassword'))) {\\n            return\\n          }\\n          $tw.crypto.setPassword()\\n        } else if (hasEncryptionPublicKey) {\\n          if (!confirm($tw.language.getString('Encryption/ConfirmClearEncryptionPublicKey'))) {\\n            return\\n          }\\n          $tw.crypto.setEncryptionKey()\\n        }\\n      }\\n    })\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/ipfs/ipfs-startup.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-startup.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-startup.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: startup\\n\\nStartup initialisation\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  exports.platforms = ['browser']\\n  exports.before = ['startup']\\n  exports.synchronous = true\\n\\n  exports.startup = function () {\\n    var getLogger = function () {\\n      if (window.log !== undefined && window.log !== null) {\\n        return window.log.getLogger('ipfs')\\n      }\\n      return console\\n    }\\n    // Logger\\n    if (window.log !== undefined && window.log !== null) {\\n      const log = window.log.getLogger('ipfs')\\n      if ($tw.utils.getIpfsVerbose()) {\\n        log.setLevel('info', false)\\n      } else {\\n        log.setLevel('warn', false)\\n      }\\n      log.info('loglevel is set up...')\\n    }\\n    // Missing Media Types\\n    $tw.utils.registerFileType('application/gzip', 'base64', '.gz')\\n    $tw.utils.registerFileType('application/x-tiddler-dictionary', 'utf8', '.dict')\\n    $tw.utils.registerFileType('application/zlib', 'base64', '.zlib')\\n    $tw.utils.registerFileType('audio/mpeg', 'base64', '.mp2')\\n    $tw.utils.registerFileType('image/jpg', 'base64', ['.jpg', '.jpeg'], {\\n      flags: ['image'],\\n    })\\n    $tw.utils.registerFileType('text/csv', 'utf8', '.csv')\\n    $tw.utils.registerFileType('video/quicktime', 'base64', ['.mov', '.qt'])\\n    $tw.utils.registerFileType('text/x-tiddlywiki', 'utf8', '.tid', {\\n      deserializerType: 'text/html',\\n    })\\n    // Log\\n    getLogger().info('ipfs-startup is starting up...')\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/ipfs/utils/compress.js\": {\n            \"title\": \"$:/plugins/ipfs/utils/compress.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/utils/compress.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nUtility functions related to compression.\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /**\\n   * Look for a compression store area in the text of a TiddlyWiki file\\n   */\\n  exports.extractCompressedStoreArea = function (text) {\\n    const compressedStoreAreaStartMarker = '<pre id=\\\"compressedStoreArea\\\" type=\\\"text/plain\\\" style=\\\"display:none;\\\">'\\n    const compressedStoreAreaStart = text.indexOf(compressedStoreAreaStartMarker)\\n    if (compressedStoreAreaStart !== -1) {\\n      const compressedStoreAreaEnd = text.indexOf('</pre>', compressedStoreAreaStart)\\n      if (compressedStoreAreaEnd !== -1) {\\n        return $tw.utils.htmlDecode(text.substring(compressedStoreAreaStart + compressedStoreAreaStartMarker.length, compressedStoreAreaEnd - 1))\\n      }\\n    }\\n    return null\\n  }\\n\\n  exports.inflateCompressedStoreArea = function (compressedStoreArea, callback) {\\n    if (compressedStoreArea) {\\n      if (compressedStoreArea.match(/{\\\"compressed\\\":/)) {\\n        const json = JSON.parse(compressedStoreArea)\\n        if (json) {\\n          if (json.compressed.match(/{\\\"iv\\\":/)) {\\n            $tw.utils.decryptStoreAreaInteractive(json.compressed, function (decrypted) {\\n              $tw.utils.inflateTiddlers(decrypted, function (tiddlers) {\\n                if (tiddlers) {\\n                  callback(tiddlers)\\n                }\\n              })\\n            })\\n            return true\\n          } else if (json.compressed.match(/{\\\"version\\\":/)) {\\n            $tw.utils.decryptFromMetamaskPrompt(json.compressed, json.keccak256, json.signature, function (decrypted) {\\n              $tw.utils.inflateTiddlers(decrypted, function (tiddlers) {\\n                if (tiddlers) {\\n                  callback(tiddlers)\\n                }\\n              })\\n            })\\n            return true\\n          }\\n        }\\n      }\\n    }\\n    return false\\n  }\\n\\n  exports.inflate = function (compressed, password, privateKey) {\\n    if (compressed) {\\n      if (compressed.match(/{\\\"compressed\\\":/)) {\\n        var data = null\\n        const json = JSON.parse(compressed)\\n        if (json && json.compressed) {\\n          if (json.compressed.match(/{\\\"iv\\\":/) || json.compressed.match(/{\\\"version\\\":/)) {\\n            const b64 = $tw.crypto.decrypt(json.compressed, password, privateKey)\\n            data = $tw.compress.inflate(b64)\\n          } else {\\n            data = $tw.compress.inflate(json.compressed)\\n          }\\n        }\\n        if (data) {\\n          return $tw.utils.loadTiddlers(data)\\n        }\\n      }\\n    }\\n    return null\\n  }\\n\\n  exports.inflateTiddlers = function (b64, callback) {\\n    if (b64) {\\n      const data = $tw.compress.inflate(b64)\\n      if (data) {\\n        const tiddlers = $tw.utils.loadTiddlers(data)\\n        if (tiddlers) {\\n          callback(tiddlers)\\n        }\\n      }\\n    }\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/ipfs/utils/crypto.js\": {\n            \"title\": \"$:/plugins/ipfs/utils/crypto.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/utils/crypto.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nUtility functions related to crypto.\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /**\\n   * Look for an encrypted store area in the text of a TiddlyWiki file\\n   */\\n  exports.extractEncryptedStoreArea = function (text) {\\n    const encryptedStoreAreaStartMarker = '<pre id=\\\"encryptedStoreArea\\\" type=\\\"text/plain\\\" style=\\\"display:none;\\\">'\\n    const encryptedStoreAreaStart = text.indexOf(encryptedStoreAreaStartMarker)\\n    if (encryptedStoreAreaStart !== -1) {\\n      const encryptedStoreAreaEnd = text.indexOf('</pre>', encryptedStoreAreaStart)\\n      if (encryptedStoreAreaEnd !== -1) {\\n        return $tw.utils.htmlDecode(text.substring(encryptedStoreAreaStart + encryptedStoreAreaStartMarker.length, encryptedStoreAreaEnd - 1))\\n      }\\n    }\\n    return null\\n  }\\n\\n  exports.decrypt = function (encrypted, callback) {\\n    if (encrypted) {\\n      if (encrypted.match(/{\\\"iv\\\":/)) {\\n        $tw.utils.decryptStoreAreaInteractive(encrypted, function (decrypted) {\\n          const tiddlers = $tw.utils.loadTiddlers(decrypted)\\n          if (tiddlers) {\\n            callback(tiddlers)\\n          }\\n        })\\n        return true\\n      } else if (encrypted.match(/{\\\"encrypted\\\":/)) {\\n        const json = JSON.parse(encrypted)\\n        if (json) {\\n          $tw.utils.decryptFromMetamaskPrompt(json.encrypted, json.keccak256, json.signature, function (decrypted) {\\n            const tiddlers = $tw.utils.loadTiddlers(decrypted)\\n            if (tiddlers) {\\n              callback(tiddlers)\\n            }\\n          })\\n          return true\\n        }\\n      }\\n    }\\n    return false\\n  }\\n\\n  /**\\n   * Attempt to extract the tiddlers from an encrypted store area using the current password.\\n   * If the password is not provided then the password in the password store will be used\\n   */\\n  exports.decryptStoreArea = function (encryptedStoreArea, password, privateKey) {\\n    const json = JSON.parse(encryptedStoreArea)\\n    return $tw.utils.loadTiddlers($tw.crypto.decrypt(json.encrypted, password, privateKey))\\n  }\\n\\n  exports.decryptFromMetamaskPrompt = function (encryptedStoreArea, keccak256, signature, callback) {\\n    // Try to decrypt with the current password\\n    const decrypted = $tw.utils.decryptStoreArea(encryptedStoreArea)\\n    if (decrypted) {\\n      callback(decrypted)\\n    } else {\\n      $tw.boot.metamaskPrompt(encryptedStoreArea, keccak256, signature, function (decrypted) {\\n        if (decrypted) {\\n          callback(decrypted)\\n        }\\n      })\\n    }\\n  }\\n\\n  /**\\n   * Attempt to extract the tiddlers from an encrypted store area using the current password.\\n   * If that fails, the user is prompted for a password.\\n   *\\n   * encryptedStoreArea: text of the TiddlyWiki encrypted store area\\n   * callback: function(tiddlers) called with the array of decrypted tiddlers\\n   *\\n   * The following configuration settings are supported:\\n   *\\n   * $tw.config.usePasswordVault: causes any password entered by the user to also be put into the system password vault\\n   */\\n  exports.decryptStoreAreaInteractive = function (encryptedStoreArea, callback, options) {\\n    // Try to decrypt with the current password\\n    const decrypted = $tw.utils.decryptStoreArea(encryptedStoreArea)\\n    if (decrypted) {\\n      callback(decrypted)\\n    } else {\\n      // Prompt for a new password and keep trying\\n      $tw.passwordPrompt.createPrompt({\\n        serviceName: 'Enter a password to decrypt the imported TiddlyWiki',\\n        noUserName: true,\\n        canCancel: true,\\n        submitText: 'Decrypt',\\n        callback: function (data) {\\n          // Exit if the user cancelled\\n          if (!data) {\\n            return false\\n          }\\n          // Attempt to decrypt the tiddlers\\n          const text = $tw.crypto.decrypt(encryptedStoreArea, data.password)\\n          if (text) {\\n            if ($tw.config.usePasswordVault) {\\n              $tw.crypto.setPassword(data.password)\\n            }\\n            callback(text)\\n            // Exit and remove the password prompt\\n            return true\\n          } else {\\n            // We didn't decrypt everything, so continue to prompt for password\\n            return false\\n          }\\n        },\\n      })\\n    }\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/core/modules/utils/dom/dragndrop.js\": {\n            \"title\": \"$:/core/modules/utils/dom/dragndrop.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/utils/dom/dragndrop.js\\ntype: application/javascript\\nmodule-type: utils\\n\\nBrowser data transfer utilities, used with the clipboard and drag and drop\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  const IpfsImport = require('$:/plugins/ipfs/ipfs-import.js').IpfsImport\\n\\n  exports.handleImportURL = async function (title, url) {\\n    const dummy = new $tw.Tiddler({\\n      title: title,\\n    })\\n    try {\\n      const ipfsImport = new IpfsImport()\\n      const data = await ipfsImport.import(null, url, dummy)\\n      if (data.merged.size > 0 || data.deleted.size > 0) {\\n        return data\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n    }\\n    return null\\n  }\\n\\n  /**\\n   * Options:\\n   *\\n   * domNode: dom node to make draggable\\n   * dragImageType: \\\"pill\\\" or \\\"dom\\\"\\n   * dragTiddlerFn: optional function to retrieve the title of tiddler to drag\\n   * dragFilterFn: optional function to retreive the filter defining a list of tiddlers to drag\\n   * widget: widget to use as the contect for the filter\\n   */\\n  exports.makeDraggable = function (options) {\\n    var dragImageType = options.dragImageType || 'dom'\\n    var dragImage\\n    var domNode = options.domNode\\n    // Make the dom node draggable (not necessary for anchor tags)\\n    if ((domNode.tagName || '').toLowerCase() !== 'a') {\\n      domNode.setAttribute('draggable', 'true')\\n    }\\n    // Add event handlers\\n    $tw.utils.addEventListeners(domNode, [\\n      {\\n        name: 'dragstart',\\n        handlerFunction: function (event) {\\n          if (event.dataTransfer === undefined) {\\n            return false\\n          }\\n          // Collect the tiddlers being dragged\\n          var dragTiddler = options.dragTiddlerFn && options.dragTiddlerFn()\\n          var dragFilter = options.dragFilterFn && options.dragFilterFn()\\n          var titles = dragTiddler ? [dragTiddler] : []\\n          var startActions = options.startActions\\n          if (dragFilter) {\\n            titles.push.apply(titles, options.widget.wiki.filterTiddlers(dragFilter, options.widget))\\n          }\\n          var titleString = $tw.utils.stringifyList(titles)\\n          // Check that we've something to drag\\n          if (titles.length > 0 && event.target === domNode) {\\n            // Mark the drag in progress\\n            $tw.dragInProgress = domNode\\n            // Set the dragging class on the element being dragged\\n            $tw.utils.addClass(event.target, 'tc-dragging')\\n            // Invoke drag-start actions if given\\n            if (startActions !== undefined) {\\n              options.widget.invokeActionString(startActions, options.widget, event, { actionTiddler: titleString })\\n            }\\n            // Create the drag image elements\\n            dragImage = options.widget.document.createElement('div')\\n            dragImage.className = 'tc-tiddler-dragger'\\n            var inner = options.widget.document.createElement('div')\\n            inner.className = 'tc-tiddler-dragger-inner'\\n            inner.appendChild(options.widget.document.createTextNode(titles.length === 1 ? titles[0] : titles.length + ' tiddlers'))\\n            dragImage.appendChild(inner)\\n            options.widget.document.body.appendChild(dragImage)\\n            // Set the data transfer properties\\n            var dataTransfer = event.dataTransfer\\n            // Set up the image\\n            dataTransfer.effectAllowed = 'all'\\n            if (dataTransfer.setDragImage) {\\n              if (dragImageType === 'pill') {\\n                dataTransfer.setDragImage(dragImage.firstChild, -16, -16)\\n              } else {\\n                var r = domNode.getBoundingClientRect()\\n                dataTransfer.setDragImage(domNode, event.clientX - r.left, event.clientY - r.top)\\n              }\\n            }\\n            // Set up the data transfer\\n            if (dataTransfer.clearData) {\\n              dataTransfer.clearData()\\n            }\\n            var jsonData = []\\n            if (titles.length > 1) {\\n              titles.forEach(function (title) {\\n                jsonData.push(options.widget.wiki.getTiddlerAsJson(title))\\n              })\\n              jsonData = '[' + jsonData.join(',') + ']'\\n            } else {\\n              jsonData = options.widget.wiki.getTiddlerAsJson(titles[0])\\n            }\\n            // IE doesn't like these content types\\n            if (!$tw.browser.isIE) {\\n              dataTransfer.setData('text/vnd.tiddler', jsonData)\\n              dataTransfer.setData('text/plain', titleString)\\n              dataTransfer.setData('text/x-moz-url', 'data:text/vnd.tiddler,' + encodeURIComponent(jsonData))\\n            }\\n            dataTransfer.setData('URL', 'data:text/vnd.tiddler,' + encodeURIComponent(jsonData))\\n            dataTransfer.setData('Text', titleString)\\n            event.stopPropagation()\\n          }\\n          return false\\n        },\\n      },\\n      {\\n        name: 'dragend',\\n        handlerFunction: function (event) {\\n          if (event.target === domNode) {\\n            // Collect the tiddlers being dragged\\n            var dragTiddler = options.dragTiddlerFn && options.dragTiddlerFn()\\n            var dragFilter = options.dragFilterFn && options.dragFilterFn()\\n            var titles = dragTiddler ? [dragTiddler] : []\\n            var endActions = options.endActions\\n            if (dragFilter) {\\n              titles.push.apply(titles, options.widget.wiki.filterTiddlers(dragFilter, options.widget))\\n            }\\n            var titleString = $tw.utils.stringifyList(titles)\\n            $tw.dragInProgress = null\\n            // Invoke drag-end actions if given\\n            if (endActions !== undefined) {\\n              options.widget.invokeActionString(endActions, options.widget, event, { actionTiddler: titleString })\\n            }\\n            // Remove the dragging class on the element being dragged\\n            $tw.utils.removeClass(event.target, 'tc-dragging')\\n            // Delete the drag image element\\n            if (dragImage) {\\n              dragImage.parentNode.removeChild(dragImage)\\n              dragImage = null\\n            }\\n          }\\n          return false\\n        },\\n      },\\n    ])\\n  }\\n\\n  exports.importDataTransfer = async function (dataTransfer, fallbackTitle, callback) {\\n    // Try each provided data type in turn\\n    if ($tw.log.IMPORT) {\\n      console.log('Available data types:')\\n      for (var type = 0; type < dataTransfer.types.length; type++) {\\n        console.log('type', dataTransfer.types[type], dataTransfer.getData(dataTransfer.types[type]))\\n      }\\n    }\\n    for (var t = 0; t < importDataTypes.length; t++) {\\n      if (!$tw.browser.isIE || importDataTypes[t].IECompatible) {\\n        // Get the data\\n        var dataType = importDataTypes[t]\\n        var data = dataTransfer.getData(dataType.type)\\n        // Import the tiddlers in the data\\n        if (data !== null && data !== '') {\\n          if ($tw.log.IMPORT) {\\n            console.log(\\\"Importing data type '\\\" + dataType.type + \\\"', data: '\\\" + data + \\\"'\\\")\\n          }\\n          var tiddlerFields = await dataType.toTiddlerFieldsArray(data, fallbackTitle)\\n          if (tiddlerFields && !tiddlerFields.merged) {\\n            const merged = new Map()\\n            merged.set(fallbackTitle, tiddlerFields)\\n            tiddlerFields = { merged: merged, deleted: new Map() }\\n          }\\n          callback(tiddlerFields)\\n          return\\n        }\\n      }\\n    }\\n  }\\n\\n  var importDataTypes = [\\n    {\\n      type: 'text/vnd.tiddler',\\n      IECompatible: false,\\n      toTiddlerFieldsArray: async function (data, fallbackTitle) {\\n        const imported = await $tw.utils.handleImportURL(fallbackTitle, data)\\n        if (imported) {\\n          return imported\\n        }\\n        return parseJSONTiddlers(data, fallbackTitle)\\n      },\\n    },\\n    {\\n      type: 'URL',\\n      IECompatible: true,\\n      toTiddlerFieldsArray: async function (data, fallbackTitle) {\\n        // Check for tiddler data URI\\n        var match = decodeURIComponent(data).match(/^data:text\\\\/vnd\\\\.tiddler,(.*)/i)\\n        if (match) {\\n          return parseJSONTiddlers(match[1], fallbackTitle)\\n        }\\n        var imported = await $tw.utils.handleImportURL(fallbackTitle, data)\\n        if (imported) {\\n          return imported\\n        }\\n        // Fallback\\n        return [{ title: fallbackTitle, text: data }] // As URL string\\n      },\\n    },\\n    {\\n      type: 'text/x-moz-url',\\n      IECompatible: false,\\n      toTiddlerFieldsArray: async function (data, fallbackTitle) {\\n        // Check for tiddler data URI\\n        var match = decodeURIComponent(data).match(/^data:text\\\\/vnd\\\\.tiddler,(.*)/i)\\n        if (match) {\\n          return parseJSONTiddlers(match[1], fallbackTitle)\\n        }\\n        var parts = data.split('\\\\n')\\n        var url = parts[0]\\n        fallbackTitle = parts[1]\\n        var imported = await $tw.utils.handleImportURL(fallbackTitle, url)\\n        if (imported) {\\n          return imported\\n        }\\n        // Fallback\\n        return [{ title: fallbackTitle, text: data }] // As URL string\\n      },\\n    },\\n    {\\n      type: 'text/html',\\n      IECompatible: false,\\n      toTiddlerFieldsArray: function (data, fallbackTitle) {\\n        return [{ title: fallbackTitle, text: data }]\\n      },\\n    },\\n    {\\n      type: 'text/plain',\\n      IECompatible: false,\\n      toTiddlerFieldsArray: function (data, fallbackTitle) {\\n        return [{ title: fallbackTitle, text: data }]\\n      },\\n    },\\n    {\\n      type: 'Text',\\n      IECompatible: true,\\n      toTiddlerFieldsArray: function (data, fallbackTitle) {\\n        return [{ title: fallbackTitle, text: data }]\\n      },\\n    },\\n    {\\n      type: 'text/uri-list',\\n      IECompatible: false,\\n      toTiddlerFieldsArray: function (data, fallbackTitle) {\\n        return [{ title: fallbackTitle, text: data }]\\n      },\\n    },\\n  ]\\n\\n  function parseJSONTiddlers (json, fallbackTitle) {\\n    var data = JSON.parse(json)\\n    if (!$tw.utils.isArray(data)) {\\n      data = [data]\\n    }\\n    data.forEach(function (fields) {\\n      fields.title = fields.title || fallbackTitle\\n    })\\n    return data\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/ipfs/utils/ipfs-default.js\": {\n            \"title\": \"$:/plugins/ipfs/utils/ipfs-default.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/utils/ipfs-default.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nIPFS Default\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n  const ipfsDefaultName = 'ipfs-default'\\n\\n  /*\\n   * Retrieve ipfs saver export protocol with default value if applicable\\n   */\\n  exports.getIpfsExport = function () {\\n    var output = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/export')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        output = text\\n      }\\n    }\\n    if (output == null) {\\n      output = $tw.utils.getIpfsDefaultExport()\\n    }\\n    return output\\n  }\\n\\n  /*\\n   * Default Export\\n   */\\n  exports.getIpfsDefaultExport = function () {\\n    return 'json'\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver protocol with default value if applicable\\n   */\\n  exports.getIpfsProtocol = function () {\\n    var protocol = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/protocol')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        protocol = text\\n      }\\n    }\\n    if (protocol == null) {\\n      protocol = $tw.utils.getIpfsDefaultProtocol()\\n    }\\n    return protocol\\n  }\\n\\n  /*\\n   * Default Protocol\\n   */\\n  exports.getIpfsDefaultProtocol = function () {\\n    return 'ipfs'\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver api url with default value if applicable\\n   */\\n  exports.getIpfsSaverApiUrl = function () {\\n    var api = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/api')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        api = text\\n      }\\n    }\\n    if (api !== null) {\\n      tiddler = $tw.wiki.getTiddler(api)\\n      if (tiddler !== undefined && tiddler !== null) {\\n        var text = tiddler.fields.text\\n        text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n        if (text !== null) {\\n          api = text\\n        }\\n      }\\n    }\\n    if (api == null) {\\n      api = $tw.ipfs.getIpfsDefaultApi()\\n    }\\n    return api\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver gateway url with default value if applicable\\n   */\\n  exports.getIpfsSaverGatewayUrl = function () {\\n    var gateway = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/gateway')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        gateway = text\\n      }\\n    }\\n    if (gateway !== null) {\\n      tiddler = $tw.wiki.getTiddler(gateway)\\n      if (tiddler !== undefined && tiddler !== null) {\\n        var text = tiddler.fields.text\\n        text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n        if (text !== null) {\\n          gateway = text\\n        }\\n      }\\n    }\\n    if (gateway == null) {\\n      gateway = $tw.ipfs.getIpfsDefaultGateway()\\n    }\\n    return gateway\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver ens domain with default value if applicable\\n   */\\n  exports.getIpfsEnsDomain = function () {\\n    var ensDomain = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ens/domain')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        ensDomain = text\\n      }\\n    }\\n    return ensDomain\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver ipns name with default value if applicable\\n   */\\n  exports.getIpfsIpnsName = function () {\\n    var ipnsName = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/name')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        ipnsName = text\\n      }\\n    }\\n    return ipnsName\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver ipns key with default value if applicable\\n   */\\n  exports.getIpfsIpnsKey = function () {\\n    var ipnsKey = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/ipns/key')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        ipnsKey = text\\n      }\\n    }\\n    return ipnsKey\\n  }\\n\\n  /*\\n   * Retrieve ipfs verbose preference with default value if applicable\\n   */\\n  exports.getIpfsVerbose = function () {\\n    var verbose = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/verbose')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        verbose = text\\n      }\\n    }\\n    if (verbose == null) {\\n      verbose = true // default, see Ipfs.tid\\n    } else {\\n      verbose = verbose === 'yes'\\n    }\\n    return verbose\\n  }\\n\\n  /*\\n   * Retrieve ipfs pin preference with default value if applicable\\n   */\\n  exports.getIpfsPin = function () {\\n    var pin = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/pin')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        pin = text\\n      }\\n    }\\n    if (pin == null) {\\n      pin = true // default, see Ipfs.tid\\n    } else {\\n      pin = pin === 'yes'\\n    }\\n    return pin\\n  }\\n\\n  /*\\n   * Retrieve ipfs unpin preference with default value if applicable\\n   */\\n  exports.getIpfsUnpin = function () {\\n    var unpin = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/unpin')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        unpin = text\\n      }\\n    }\\n    if (unpin == null) {\\n      unpin = false // default, see Ipfs.tid\\n    } else {\\n      unpin = unpin === 'yes'\\n    }\\n    return unpin\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver url policy with default value if applicable\\n   */\\n  exports.getIpfsUrlPolicy = function () {\\n    var policy = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/policy')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        policy = text\\n      }\\n    }\\n    if (policy == null) {\\n      policy = $tw.utils.getIpfsDefaultPolicy()\\n    }\\n    return policy\\n  }\\n\\n  /*\\n   * Default Policy\\n   */\\n  exports.getIpfsDefaultPolicy = function () {\\n    return 'gateway'\\n  }\\n\\n  /*\\n   * Retrieve ipfs saver provider with default value if applicable\\n   */\\n  exports.getIpfsProvider = function () {\\n    var provider = null\\n    var tiddler = $tw.wiki.getTiddler('$:/ipfs/saver/provider')\\n    if (tiddler !== undefined && tiddler !== null) {\\n      var text = tiddler.fields.text\\n      text = text !== undefined && text !== null && text.trim() !== '' ? text.trim() : null\\n      if (text !== null) {\\n        provider = text\\n      }\\n    }\\n    if (provider == null) {\\n      provider = $tw.utils.getIpfsDefaultProvider()\\n    }\\n    return provider\\n  }\\n\\n  /*\\n   * Default Provider\\n   */\\n  exports.getIpfsDefaultProvider = function () {\\n    return 'http'\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/ipfs/utils/ipfs-utils.js\": {\n            \"title\": \"$:/plugins/ipfs/utils/ipfs-utils.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/utils/ipfs-utils.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nIPFS utils\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const ipfsUtilsName = 'ipfs-utils'\\n\\n  /**\\n   * $:/core/modules/utils/logger.js\\n   *\\n   * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n   *\\n   * Copyright (c) 2004-2007, Jeremy Ruston\\n   * Copyright (c) 2007-2018, UnaMesa Association\\n   * Copyright (c) 2019-2020, Blue Light\\n   * All rights reserved.\\n   *\\n   * Redistribution and use in source and binary forms, with or without\\n   * modification, are permitted provided that the following conditions are met:\\n   *\\n   * * Redistributions of source code must retain the above copyright notice, this\\n   *   list of conditions and the following disclaimer.\\n   *\\n   * * Redistributions in binary form must reproduce the above copyright notice,\\n   *   this list of conditions and the following disclaimer in the documentation\\n   *   and/or other materials provided with the distribution.\\n   *\\n   * * Neither the name of the copyright holder nor the names of its\\n   *   contributors may be used to endorse or promote products derived from\\n   *   this software without specific prior written permission.\\n   *\\n   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n   */\\n\\n  /*\\n   * from $:/core/modules/utils/logger.js\\n   **/\\n  exports.alert = function (callee, text) {\\n    if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {\\n      return\\n    }\\n    const ALERT_TAG = '$:/tags/Alert'\\n    // Prepare the text of the alert\\n    // var text = Array.prototype.join.call(arguments,\\\" \\\");\\n    // Check if there is an existing alert with the same text and the same component\\n    var existingAlerts = $tw.wiki.getTiddlersWithTag(ALERT_TAG)\\n    var alertFields\\n    var existingCount\\n    var self = this\\n    $tw.utils.each(existingAlerts, function (title) {\\n      var tiddler = $tw.wiki.getTiddler(title)\\n      if (\\n        tiddler.fields.text === text &&\\n        tiddler.fields.component === self.componentName &&\\n        tiddler.fields.modified &&\\n        (!alertFields || tiddler.fields.modified < alertFields.modified)\\n      ) {\\n        alertFields = $tw.utils.extend({}, tiddler.fields)\\n      }\\n    })\\n    if (alertFields) {\\n      existingCount = alertFields.count || 1\\n    } else {\\n      alertFields = {\\n        title: $tw.wiki.generateNewTitle('$:/temp/alerts/alert', {\\n          prefix: '',\\n        }),\\n        text: text,\\n        tags: [ALERT_TAG],\\n        component: callee,\\n      }\\n      existingCount = 0\\n    }\\n    alertFields.modified = new Date()\\n    if (++existingCount > 1) {\\n      alertFields.count = existingCount\\n    } else {\\n      alertFields.count = undefined\\n    }\\n    $tw.wiki.addTiddler(new $tw.Tiddler(alertFields))\\n  }\\n\\n  exports.getChangedTiddler = function (object) {\\n    // Holder\\n    const changedTiddler = Object.create(null)\\n    // Check\\n    if (object === undefined || object == null) {\\n      return changedTiddler\\n    }\\n    if (object instanceof $tw.Tiddler === false && typeof object !== 'string') {\\n      return changedTiddler\\n    }\\n    // Retrieve title\\n    var title = null\\n    if (typeof object === 'string') {\\n      title = object\\n    }\\n    if (object instanceof $tw.Tiddler) {\\n      title = object.fields.title\\n    }\\n    // Check\\n    if (title === undefined || title == null) {\\n      return changedTiddler\\n    }\\n    // Process title\\n    changedTiddler[title] = Object.create(null)\\n    // Done\\n    return changedTiddler\\n  }\\n\\n  exports.updateTiddler = function (updates) {\\n    // Is there anything to do\\n    if (updates === undefined || updates == null || updates.tiddler === undefined || updates.tiddler == null) {\\n      return null\\n    }\\n    // Prepare updates\\n    const fields = $tw.wiki.getModificationFields()\\n    // Tags\\n    fields.tags = (updates.tiddler.fields.tags || []).slice(0)\\n    // Process add tags\\n    if (updates.addTags !== undefined && updates.addTags !== null && Array.isArray(updates.addTags)) {\\n      for (var i = 0; i < updates.addTags.length; i++) {\\n        const tag = updates.addTags[i]\\n        if (fields.tags.indexOf(tag) === -1) {\\n          $tw.utils.pushTop(fields.tags, tag)\\n        }\\n      }\\n    }\\n    // Process remove tags\\n    if (updates.removeTags !== undefined && updates.removeTags !== null && Array.isArray(updates.removeTags)) {\\n      for (var i = 0; i < updates.removeTags.length; i++) {\\n        const tag = updates.removeTags[i]\\n        const index = fields.tags.indexOf(tag)\\n        if (index !== -1) {\\n          fields.tags.splice(index, 1)\\n        }\\n      }\\n    }\\n    // Process fields\\n    if (updates.fields !== undefined && updates.fields !== null && Array.isArray(updates.fields)) {\\n      for (var i = 0; i < updates.fields.length; i++) {\\n        const field = updates.fields[i]\\n        if (field.key !== undefined && field.key !== null) {\\n          fields[field.key] = field.value\\n        }\\n      }\\n    }\\n    // Update tiddler\\n    return new $tw.Tiddler(updates.tiddler, fields)\\n  }\\n\\n  exports.getContentType = function (title, type) {\\n    type = type !== undefined && type !== null && type.trim() !== '' ? type.trim() : null\\n    if (type == null) {\\n      type = 'text/vnd.tiddlywiki'\\n    }\\n    var info = $tw.config.contentTypeInfo[type]\\n    if (info === undefined || info == null) {\\n      const url = $tw.ipfs.getDocumentUrl()\\n      url.hash = title\\n      $tw.ipfs.getLogger().info(\\n        `Unknown Content-Type: \\\"${type}\\\", default: \\\"text/vnd.tiddlywiki\\\":\\n ${url}`\\n      )\\n      type = 'text/vnd.tiddlywiki'\\n      info = $tw.config.contentTypeInfo[type]\\n    }\\n    return {\\n      type: type,\\n      info: info,\\n    }\\n  }\\n\\n  exports.loadTiddlers = function (text) {\\n    if (text) {\\n      var json = JSON.parse(text)\\n      var tiddlers = []\\n      for (var title in json) {\\n        if (title !== '$:/isEncrypted' && title !== '$:/isCompressed') {\\n          tiddlers.push(json[title])\\n        }\\n      }\\n      return tiddlers\\n    }\\n    return null\\n  }\\n\\n  exports.exportToIpfs = async function (target, content) {\\n    // Check\\n    if (content === undefined || content == null) {\\n      return false\\n    }\\n    var account = null\\n    var added = null\\n    var cid = null\\n    var fields = []\\n    var ipnsKey = null\\n    var ipnsName = null\\n    var normalizedUrl = null\\n    var web3 = null\\n    const ipfsKeyword = 'ipfs'\\n    var exportUri = target.fields._export_uri\\n    try {\\n      var { cid, ipnsKey, ipnsName, normalizedUrl } = await $tw.ipfs.resolveUrl(true, true, exportUri)\\n      if (normalizedUrl !== null && normalizedUrl.hostname.endsWith('.eth')) {\\n        var { account, web3 } = await $tw.ipfs.getEnabledWeb3Provider()\\n        const isOwner = await $tw.ipfs.isOwner(normalizedUrl.hostname, web3, account)\\n        if (isOwner === false) {\\n          const err = new Error('Unauthorized Account...')\\n          err.name = 'OwnerError'\\n          throw err\\n        }\\n      }\\n    } catch (error) {\\n      if (error.name !== 'OwnerError') {\\n        $tw.ipfs.getLogger().error(error)\\n      }\\n      $tw.utils.alert(ipfsUtilsName, error.message)\\n      return false\\n    }\\n    $tw.ipfs.getLogger().info(`Uploading Tiddler: ${content.length}`)\\n    try {\\n      var { added } = await $tw.ipfs.addToIpfs(content)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(ipfsUtilsName, error.message)\\n      return false\\n    }\\n    // Prepare New value\\n    fields.push({ key: '_export_uri', value: `${ipfsKeyword}://${added}` })\\n    var updatedTiddler = $tw.utils.updateTiddler({\\n      tiddler: target,\\n      addTags: ['$:/isExported', '$:/isIpfs'],\\n      fields: fields,\\n    })\\n    $tw.wiki.addTiddler(updatedTiddler)\\n    if (ipnsKey !== null && ipnsName !== null) {\\n      $tw.utils.alert(ipfsUtilsName, `Publishing IPNS name: ${ipnsName}`)\\n      $tw.ipfs\\n        .pinToIpfs(added)\\n        .then(data => {\\n          $tw.ipfs\\n            .publishIpnsName(added, ipnsKey, ipnsName)\\n            .then(data => {\\n              fields.push({ key: '_export_uri', value: exportUri })\\n              const updatedTiddler = $tw.utils.updateTiddler({\\n                tiddler: target,\\n                addTags: ['$:/isExported', '$:/isIpfs'],\\n                fields: fields,\\n              })\\n              $tw.wiki.addTiddler(updatedTiddler)\\n              $tw.utils.alert(ipfsUtilsName, `Successfully Published IPNS name: ${ipnsName}`)\\n              if ($tw.utils.getIpfsUnpin()) {\\n                $tw.ipfs\\n                  .unpinFromIpfs(cid)\\n                  .then(data => {\\n                    if (data !== undefined && data !== null) {\\n                      $tw.ipfs.removeFromPinUnpin(cid, normalizedUrl)\\n                    }\\n                  })\\n                  .catch(error => {\\n                    $tw.ipfs.getLogger().error(error)\\n                    $tw.utils.alert(ipfsUtilsName, error.message)\\n                  })\\n              }\\n            })\\n            .catch(error => {\\n              $tw.ipfs.getLogger().error(error)\\n              $tw.utils.alert(ipfsUtilsName, error.message)\\n              $tw.ipfs.requestToUnpin(added)\\n            })\\n        })\\n        .catch(error => {\\n          $tw.ipfs.getLogger().error(error)\\n          $tw.utils.alert(ipfsUtilsName, error.message)\\n        })\\n    } else if (normalizedUrl !== null && normalizedUrl.hostname.endsWith('.eth')) {\\n      $tw.utils.alert(ipfsUtilsName, `Publishing to ENS: ${normalizedUrl.hostname}`)\\n      $tw.ipfs\\n        .pinToIpfs(added)\\n        .then(data => {\\n          $tw.ipfs\\n            .setContentHash(normalizedUrl.hostname, `/${ipfsKeyword}/${added}`, web3, account)\\n            .then(data => {\\n              fields.push({ key: '_export_uri', value: exportUri })\\n              const updatedTiddler = $tw.utils.updateTiddler({\\n                tiddler: target,\\n                addTags: ['$:/isExported', '$:/isIpfs'],\\n                fields: fields,\\n              })\\n              $tw.wiki.addTiddler(updatedTiddler)\\n              $tw.utils.alert(ipfsUtilsName, 'Successfully Published to ENS...')\\n              if ($tw.utils.getIpfsUnpin()) {\\n                $tw.ipfs\\n                  .unpinFromIpfs(cid)\\n                  .then(data => {\\n                    if (data !== undefined && data !== null) {\\n                      $tw.ipfs.removeFromPinUnpin(cid, normalizedUrl)\\n                    }\\n                  })\\n                  .catch(error => {\\n                    $tw.ipfs.getLogger().error(error)\\n                    $tw.utils.alert(ipfsUtilsName, error.message)\\n                  })\\n              }\\n            })\\n            .catch(error => {\\n              if (error.name !== 'OwnerError' && error.name !== 'RejectedUserRequest' && error.name !== 'UnauthorizedUserAccount') {\\n                $tw.ipfs.getLogger().error(error)\\n              }\\n              $tw.utils.alert(ipfsUtilsName, error.message)\\n              $tw.ipfs.requestToUnpin(added)\\n            })\\n        })\\n        .catch(error => {\\n          $tw.ipfs.getLogger().error(error)\\n          $tw.utils.alert(ipfsUtilsName, error.message)\\n        })\\n    }\\n    return true\\n  }\\n\\n  exports.locateNavigatorWidget = function (element) {\\n    if (element.parseTreeNode.type === 'navigator') {\\n      return element\\n    }\\n    if (element.children) {\\n      for (var i = 0; i < element.children.length; i++) {\\n        const found = $tw.utils.locateNavigatorWidget(element.children[i])\\n        if (found) {\\n          return found\\n        }\\n      }\\n    }\\n    return null\\n  }\\n\\n  exports.exportTiddlersAsJson = async function (tiddlers, exportUri, spaces) {\\n    var json\\n    var data = []\\n    var spaces = spaces !== undefined && spaces !== null ? spaces : $tw.config.preferences.jsonSpaces\\n    const ipnsKeyword = 'ipns'\\n    // Process Tiddlers\\n    if (tiddlers) {\\n      for (var t = 0; t < tiddlers.length; t++) {\\n        // Load Tiddler\\n        var current = $tw.wiki.getTiddler(tiddlers[t])\\n        // Process\\n        var fields = {}\\n        // Process fields\\n        for (var field in current.fields) {\\n          // Discard\\n          if (field === 'tags' || field === '_export_uri') {\\n            continue\\n          }\\n          var ipnsKey = null\\n          var fieldValue = current.getFieldString(field)\\n          if (field === '_canonical_uri' && fieldValue === exportUri) {\\n            continue\\n          }\\n          if (field === '_import_uri' && fieldValue === exportUri) {\\n            continue\\n          }\\n          try {\\n            var { ipnsKey } = await $tw.ipfs.resolveUrl(false, false, fieldValue)\\n          } catch (error) {\\n            $tw.ipfs.getLogger().error(error)\\n            $tw.utils.alert(ipfsUtilsName, error.message)\\n            return null\\n          }\\n          // IPNS\\n          if (ipnsKey !== null) {\\n            fieldValue = `${ipnsKeyword}://${ipnsKey}`\\n          }\\n          // Store field\\n          fields[field] = fieldValue\\n        }\\n        // Process tags\\n        var tags = current.fields.tags\\n        if (tags !== undefined && tags !== null) {\\n          var tagValues = ''\\n          for (var i = 0; i < tags.length; i++) {\\n            const tag = tags[i]\\n            // Discard\\n            if (tag === '$:/isExported' || tag === '$:/isImported') {\\n              continue\\n            }\\n            tagValues = (tagValues.length === 0 ? '[[' : `${tagValues} [[`) + `${tag}]]`\\n          }\\n          // Store tags\\n          fields.tags = tagValues\\n        }\\n        // Store\\n        data.push(fields)\\n      }\\n      json = JSON.stringify(data, null, spaces)\\n    }\\n    return json\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/core/modules/widgets/button.js\": {\n            \"title\": \"$:/core/modules/widgets/button.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/button.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nButton widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var ButtonWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /*\\n   * Inherit from the base widget class\\n   */\\n  ButtonWidget.prototype = new Widget()\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  ButtonWidget.prototype.render = function (parent, nextSibling) {\\n    var self = this\\n    var tag = 'button'\\n    var domNode\\n    // Remember parent\\n    this.parentDomNode = parent\\n    // Compute attributes and execute state\\n    this.computeAttributes()\\n    this.execute()\\n    // Create element\\n    if (this.buttonTag && $tw.config.htmlUnsafeElements.indexOf(this.buttonTag) === -1) {\\n      tag = this.buttonTag\\n    }\\n    domNode = this.document.createElement(tag)\\n    this.domNode = domNode\\n    // Assign classes\\n    var classes = this.class.split(' ') || []\\n    var isPoppedUp = (this.popup || this.popupTitle) && this.isPoppedUp()\\n    if (this.selectedClass) {\\n      if ((this.set || this.setTitle) && this.setTo && this.isSelected()) {\\n        $tw.utils.pushTop(classes, this.selectedClass.split(' '))\\n      }\\n      if (isPoppedUp) {\\n        $tw.utils.pushTop(classes, this.selectedClass.split(' '))\\n      }\\n    }\\n    if (isPoppedUp) {\\n      $tw.utils.pushTop(classes, 'tc-popup-handle')\\n    }\\n    domNode.className = classes.join(' ')\\n    // Assign other attributes\\n    if (this.style) {\\n      domNode.setAttribute('style', this.style)\\n    }\\n    if (this.tooltip) {\\n      domNode.setAttribute('title', this.tooltip)\\n    }\\n    if (this['aria-label']) {\\n      domNode.setAttribute('aria-label', this['aria-label'])\\n    }\\n    // Set the tabindex\\n    if (this.tabIndex) {\\n      domNode.setAttribute('tabindex', this.tabIndex)\\n    }\\n    if (this.isDisabled === 'yes') {\\n      domNode.setAttribute('disabled', true)\\n    }\\n    // Add a click event handler\\n    domNode.addEventListener(\\n      'click',\\n      function (event) {\\n        var handled = false\\n        if (self.invokeActions(self, event)) {\\n          handled = true\\n        }\\n        if (self.to) {\\n          self.navigateTo(event)\\n          handled = true\\n        }\\n        if (self.message) {\\n          self.dispatchMessage(event)\\n          handled = true\\n        }\\n        if (self.popup || self.popupTitle) {\\n          self.triggerPopup(event)\\n          handled = true\\n        }\\n        if (self.set || self.setTitle) {\\n          self.setTiddler()\\n          handled = true\\n        }\\n        if (self.actions) {\\n          var modifierKey = $tw.keyboardManager.getEventModifierKeyDescriptor(event)\\n          self.invokeActionString(self.actions, self, event, { modifier: modifierKey })\\n        }\\n        if (handled) {\\n          event.preventDefault()\\n          event.stopPropagation()\\n        }\\n        return handled\\n      },\\n      false\\n    )\\n    // Make it draggable if required\\n    if (this.dragTiddler || this.dragFilter) {\\n      $tw.utils.makeDraggable({\\n        domNode: domNode,\\n        dragTiddlerFn: function () {\\n          return self.dragTiddler\\n        },\\n        dragFilterFn: function () {\\n          return self.dragFilter\\n        },\\n        widget: this,\\n      })\\n    }\\n    // Insert element\\n    parent.insertBefore(domNode, nextSibling)\\n    this.renderChildren(domNode, null)\\n    this.domNodes.push(domNode)\\n  }\\n\\n  /*\\n   * We don't allow actions to propagate because we trigger actions ourselves\\n   */\\n  ButtonWidget.prototype.allowActionPropagation = function () {\\n    return false\\n  }\\n\\n  ButtonWidget.prototype.getBoundingClientRect = function () {\\n    return this.domNodes[0].getBoundingClientRect()\\n  }\\n\\n  ButtonWidget.prototype.isSelected = function () {\\n    return this.setTitle\\n      ? (this.setField\\n          ? this.wiki.getTiddler(this.setTitle).getFieldString(this.setField) === this.setTo\\n          : this.setIndex\\n          ? this.wiki.extractTiddlerDataItem(this.setTitle, this.setIndex) === this.setTo\\n          : this.wiki.getTiddlerText(this.setTitle)) ||\\n          this.defaultSetValue ||\\n          this.getVariable('currentTiddler')\\n      : this.wiki.getTextReference(this.set, this.defaultSetValue, this.getVariable('currentTiddler')) === this.setTo\\n  }\\n\\n  ButtonWidget.prototype.isPoppedUp = function () {\\n    var tiddler = this.popupTitle ? this.wiki.getTiddler(this.popupTitle) : this.wiki.getTiddler(this.popup)\\n    var result = tiddler && tiddler.fields.text ? $tw.popup.readPopupState(tiddler.fields.text) : false\\n    return result\\n  }\\n\\n  ButtonWidget.prototype.navigateTo = function (event) {\\n    var bounds = this.getBoundingClientRect()\\n    this.dispatchEvent({\\n      type: 'tm-navigate',\\n      navigateTo: this.to,\\n      navigateFromTitle: this.getVariable('storyTiddler'),\\n      navigateFromNode: this,\\n      navigateFromClientRect: {\\n        top: bounds.top,\\n        left: bounds.left,\\n        width: bounds.width,\\n        right: bounds.right,\\n        bottom: bounds.bottom,\\n        height: bounds.height,\\n      },\\n      navigateSuppressNavigation: event.metaKey || event.ctrlKey || event.button === 1,\\n      event: event,\\n    })\\n  }\\n\\n  ButtonWidget.prototype.dispatchMessage = function (event) {\\n    this.dispatchEvent({\\n      type: this.message,\\n      param: this.param,\\n      tiddlerTitle: this.getVariable('currentTiddler'),\\n      event: event,\\n    })\\n  }\\n\\n  ButtonWidget.prototype.triggerPopup = function (event) {\\n    if (this.popupTitle) {\\n      $tw.popup.triggerPopup({\\n        domNode: this.domNodes[0],\\n        title: this.popupTitle,\\n        wiki: this.wiki,\\n        noStateReference: true,\\n      })\\n    } else {\\n      $tw.popup.triggerPopup({\\n        domNode: this.domNodes[0],\\n        title: this.popup,\\n        wiki: this.wiki,\\n      })\\n    }\\n  }\\n\\n  ButtonWidget.prototype.setTiddler = function () {\\n    if (this.setTitle) {\\n      this.setField\\n        ? this.wiki.setText(this.setTitle, this.setField, undefined, this.setTo)\\n        : this.setIndex\\n        ? this.wiki.setText(this.setTitle, undefined, this.setIndex, this.setTo)\\n        : this.wiki.setText(this.setTitle, 'text', undefined, this.setTo)\\n    } else {\\n      this.wiki.setTextReference(this.set, this.setTo, this.getVariable('currentTiddler'))\\n    }\\n  }\\n\\n  /*\\n   * Compute the internal state of the widget\\n   */\\n  ButtonWidget.prototype.execute = function () {\\n    // Get attributes\\n    this.actions = this.getAttribute('actions')\\n    this.to = this.getAttribute('to')\\n    this.message = this.getAttribute('message')\\n    this.param = this.getAttribute('param')\\n    this.set = this.getAttribute('set')\\n    this.setTo = this.getAttribute('setTo')\\n    this.popup = this.getAttribute('popup')\\n    this.hover = this.getAttribute('hover')\\n    this['aria-label'] = this.getAttribute('aria-label')\\n    this.tooltip = this.getAttribute('tooltip')\\n    this.style = this.getAttribute('style')\\n    this.class = this.getAttribute('class', '')\\n    this.selectedClass = this.getAttribute('selectedClass')\\n    this.defaultSetValue = this.getAttribute('default', '')\\n    this.buttonTag = this.getAttribute('tag')\\n    this.dragTiddler = this.getAttribute('dragTiddler')\\n    this.dragFilter = this.getAttribute('dragFilter')\\n    this.setTitle = this.getAttribute('setTitle')\\n    this.setField = this.getAttribute('setField')\\n    this.setIndex = this.getAttribute('setIndex')\\n    this.popupTitle = this.getAttribute('popupTitle')\\n    this.tabIndex = this.getAttribute('tabindex')\\n    this.isDisabled = this.getAttribute('disabled', 'no')\\n    // Make child widgets\\n    this.makeChildWidgets()\\n  }\\n\\n  ButtonWidget.prototype.updateDomNodeClasses = function () {\\n    var domNodeClasses = this.domNode.className.split(' ')\\n    var oldClasses = this.class.split(' ')\\n    var newClasses\\n    this.class = this.getAttribute('class', '')\\n    newClasses = this.class.split(' ')\\n    //Remove classes assigned from the old value of class attribute\\n    $tw.utils.each(oldClasses, function (oldClass) {\\n      var i = domNodeClasses.indexOf(oldClass)\\n      if (i !== -1) {\\n        domNodeClasses.splice(i, 1)\\n      }\\n    })\\n    //Add new classes from updated class attribute.\\n    $tw.utils.pushTop(domNodeClasses, newClasses)\\n    this.domNode.className = domNodeClasses.join(' ')\\n  }\\n\\n  /*\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  ButtonWidget.prototype.refresh = function (changedTiddlers) {\\n    var changedAttributes = this.computeAttributes()\\n    if (\\n      changedAttributes.tooltip ||\\n      changedAttributes.actions ||\\n      changedAttributes.to ||\\n      changedAttributes.message ||\\n      changedAttributes.param ||\\n      changedAttributes.set ||\\n      changedAttributes.setTo ||\\n      changedAttributes.popup ||\\n      changedAttributes.hover ||\\n      changedAttributes.selectedClass ||\\n      changedAttributes.style ||\\n      changedAttributes.dragFilter ||\\n      changedAttributes.dragTiddler ||\\n      (this.set && changedTiddlers[this.set]) ||\\n      (this.popup && changedTiddlers[this.popup]) ||\\n      (this.popupTitle && changedTiddlers[this.popupTitle]) ||\\n      changedAttributes.setTitle ||\\n      changedAttributes.setField ||\\n      changedAttributes.setIndex ||\\n      changedAttributes.popupTitle ||\\n      changedAttributes.disabled\\n    ) {\\n      this.refreshSelf()\\n      return true\\n    } else if (changedAttributes.class) {\\n      this.updateDomNodeClasses()\\n    }\\n    return this.refreshChildren(changedTiddlers)\\n  }\\n\\n  exports.button = ButtonWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/checkbox.js\": {\n            \"title\": \"$:/core/modules/widgets/checkbox.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/checkbox.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nCheckbox widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var CheckboxWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /*\\nInherit from the base widget class\\n*/\\n  CheckboxWidget.prototype = new Widget()\\n\\n  /*\\nRender this widget into the DOM\\n*/\\n  CheckboxWidget.prototype.render = function (parent, nextSibling) {\\n    // Save the parent dom node\\n    this.parentDomNode = parent\\n    // Compute our attributes\\n    this.computeAttributes()\\n    // Execute our logic\\n    this.execute()\\n    // Create our elements\\n    this.labelDomNode = this.document.createElement('label')\\n    this.labelDomNode.setAttribute('class', this.checkboxClass)\\n    this.inputDomNode = this.document.createElement('input')\\n    this.inputDomNode.setAttribute('type', 'checkbox')\\n    if (this.getValue()) {\\n      this.inputDomNode.setAttribute('checked', 'true')\\n    }\\n    if (this.isDisabled === 'yes') {\\n      this.inputDomNode.setAttribute('disabled', true)\\n    }\\n    this.inputDomNode.setAttribute('title', this.checkboxTooltip)\\n    this.labelDomNode.appendChild(this.inputDomNode)\\n    this.spanDomNode = this.document.createElement('span')\\n    this.labelDomNode.appendChild(this.spanDomNode)\\n    // Add a click event handler\\n    $tw.utils.addEventListeners(this.inputDomNode, [\\n      {\\n        name: 'change',\\n        handlerObject: this,\\n        handlerMethod: 'handleChangeEvent',\\n      },\\n    ])\\n    // Insert the label into the DOM and render any children\\n    parent.insertBefore(this.labelDomNode, nextSibling)\\n    this.renderChildren(this.spanDomNode, null)\\n    this.domNodes.push(this.labelDomNode)\\n  }\\n\\n  CheckboxWidget.prototype.getValue = function () {\\n    var tiddler = this.wiki.getTiddler(this.checkboxTitle)\\n    if (tiddler) {\\n      if (this.checkboxTag) {\\n        if (this.checkboxInvertTag) {\\n          return !tiddler.hasTag(this.checkboxTag)\\n        } else {\\n          return tiddler.hasTag(this.checkboxTag)\\n        }\\n      }\\n      if (this.checkboxField) {\\n        var value\\n        if ($tw.utils.hop(tiddler.fields, this.checkboxField)) {\\n          value = tiddler.fields[this.checkboxField] || ''\\n        } else {\\n          value = this.checkboxDefault || ''\\n        }\\n        if (value === this.checkboxChecked) {\\n          return true\\n        }\\n        if (value === this.checkboxUnchecked) {\\n          return false\\n        }\\n      }\\n      if (this.checkboxIndex) {\\n        var value = this.wiki.extractTiddlerDataItem(tiddler, this.checkboxIndex, this.checkboxDefault || '')\\n        if (value === this.checkboxChecked) {\\n          return true\\n        }\\n        if (value === this.checkboxUnchecked) {\\n          return false\\n        }\\n      }\\n    } else {\\n      if (this.checkboxTag) {\\n        return false\\n      }\\n      if (this.checkboxField) {\\n        if (this.checkboxDefault === this.checkboxChecked) {\\n          return true\\n        }\\n        if (this.checkboxDefault === this.checkboxUnchecked) {\\n          return false\\n        }\\n      }\\n    }\\n    return false\\n  }\\n\\n  CheckboxWidget.prototype.handleChangeEvent = function (event) {\\n    var checked = this.inputDomNode.checked\\n    var tiddler = this.wiki.getTiddler(this.checkboxTitle)\\n    var fallbackFields = { text: '' }\\n    var newFields = { title: this.checkboxTitle }\\n    var hasChanged = false\\n    var tagCheck = false\\n    var hasTag = tiddler && tiddler.hasTag(this.checkboxTag)\\n    var value = checked ? this.checkboxChecked : this.checkboxUnchecked\\n    if (this.checkboxTag && this.checkboxInvertTag === 'yes') {\\n      tagCheck = hasTag === checked\\n    } else {\\n      tagCheck = hasTag !== checked\\n    }\\n    // Set the tag if specified\\n    if (this.checkboxTag && (!tiddler || tagCheck)) {\\n      newFields.tags = tiddler ? (tiddler.fields.tags || []).slice(0) : []\\n      var pos = newFields.tags.indexOf(this.checkboxTag)\\n      if (pos !== -1) {\\n        newFields.tags.splice(pos, 1)\\n      }\\n      if (this.checkboxInvertTag === 'yes' && !checked) {\\n        newFields.tags.push(this.checkboxTag)\\n      } else if (this.checkboxInvertTag !== 'yes' && checked) {\\n        newFields.tags.push(this.checkboxTag)\\n      }\\n      hasChanged = true\\n    }\\n    // Set the field if specified\\n    if (this.checkboxField) {\\n      if (!tiddler || tiddler.fields[this.checkboxField] !== value) {\\n        newFields[this.checkboxField] = value\\n        hasChanged = true\\n      }\\n    }\\n    // Set the index if specified\\n    if (this.checkboxIndex) {\\n      var indexValue = this.wiki.extractTiddlerDataItem(this.checkboxTitle, this.checkboxIndex)\\n      if (!tiddler || indexValue !== value) {\\n        hasChanged = true\\n      }\\n    }\\n    if (hasChanged) {\\n      if (this.checkboxIndex) {\\n        this.wiki.setText(this.checkboxTitle, '', this.checkboxIndex, value)\\n      } else {\\n        this.wiki.addTiddler(new $tw.Tiddler(this.wiki.getCreationFields(), fallbackFields, tiddler, newFields, this.wiki.getModificationFields()))\\n      }\\n    }\\n    // Trigger actions\\n    if (this.checkboxActions) {\\n      this.invokeActionString(this.checkboxActions, this, event)\\n    }\\n    if (this.checkboxCheckActions && checked) {\\n      this.invokeActionString(this.checkboxCheckActions, this, event)\\n    }\\n    if (this.checkboxUncheckActions && !checked) {\\n      this.invokeActionString(this.checkboxUncheckActions, this, event)\\n    }\\n  }\\n\\n  /**\\n   * Compute the internal state of the widget\\n   */\\n  CheckboxWidget.prototype.execute = function () {\\n    // Get the parameters from the attributes\\n    this.checkboxActions = this.getAttribute('actions')\\n    this.checkboxCheckActions = this.getAttribute('checkactions')\\n    this.checkboxUncheckActions = this.getAttribute('uncheckactions')\\n    this.checkboxTooltip = this.getAttribute('title')\\n    this.checkboxTitle = this.getAttribute('tiddler', this.getVariable('currentTiddler'))\\n    this.checkboxTag = this.getAttribute('tag')\\n    this.checkboxField = this.getAttribute('field')\\n    this.checkboxIndex = this.getAttribute('index')\\n    this.checkboxChecked = this.getAttribute('checked')\\n    this.checkboxUnchecked = this.getAttribute('unchecked')\\n    this.checkboxDefault = this.getAttribute('default')\\n    this.checkboxClass = this.getAttribute('class', '')\\n    this.checkboxInvertTag = this.getAttribute('invertTag', '')\\n    this.isDisabled = this.getAttribute('disabled', 'no')\\n    // Make the child widgets\\n    this.makeChildWidgets()\\n  }\\n\\n  /**\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  CheckboxWidget.prototype.refresh = function (changedTiddlers) {\\n    var changedAttributes = this.computeAttributes()\\n    if (\\n      changedAttributes.title ||\\n      changedAttributes.tiddler ||\\n      changedAttributes.tag ||\\n      changedAttributes.invertTag ||\\n      changedAttributes.field ||\\n      changedAttributes.index ||\\n      changedAttributes.checked ||\\n      changedAttributes.unchecked ||\\n      changedAttributes.default ||\\n      changedAttributes.class ||\\n      changedAttributes.disabled\\n    ) {\\n      this.refreshSelf()\\n      return true\\n    } else {\\n      var refreshed = false\\n      if (changedTiddlers[this.checkboxTitle]) {\\n        this.inputDomNode.checked = this.getValue()\\n        refreshed = true\\n      }\\n      return this.refreshChildren(changedTiddlers) || refreshed\\n    }\\n  }\\n\\n  exports.checkbox = CheckboxWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/compress.js\": {\n            \"title\": \"$:/core/modules/widgets/compress.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/compress.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nCompress widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var CompressWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /*\\n   * Inherit from the base widget class\\n   */\\n  CompressWidget.prototype = new Widget()\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  CompressWidget.prototype.render = function (parent, nextSibling) {\\n    this.parentDomNode = parent\\n    this.computeAttributes()\\n    this.execute()\\n    var textNode = this.document.createTextNode(this.encryptedText)\\n    if ($tw.crypto.hasEncryptionPublicKey()) {\\n      var sign = $tw.wiki.getTiddler('$:/isSigned')\\n      sign = sign !== undefined ? sign.fields.text === 'yes' : false\\n      if (sign) {\\n        textNode.sign = true\\n      }\\n    }\\n    parent.insertBefore(textNode, nextSibling)\\n    this.domNodes.push(textNode)\\n  }\\n\\n  /*\\n   * Compute the internal state of the widget\\n   */\\n  CompressWidget.prototype.execute = function () {\\n    // Get parameters from our attributes\\n    this.filter = this.getAttribute('filter', '[!is[system]]')\\n    // Compress the filtered tiddlers\\n    var tiddlers = this.wiki.filterTiddlers(this.filter)\\n    var json = {}\\n    var self = this\\n    $tw.utils.each(tiddlers, function (title) {\\n      var tiddler = self.wiki.getTiddler(title)\\n      var jsonTiddler = {}\\n      for (var f in tiddler.fields) {\\n        jsonTiddler[f] = tiddler.getFieldString(f)\\n      }\\n      json[title] = jsonTiddler\\n    })\\n    var content = { compressed: $tw.compress.deflate(JSON.stringify(json)) }\\n    var encrypt = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypt = encrypt !== undefined ? encrypt.fields.text === 'yes' : false\\n    if (encrypt) {\\n      content.compressed = $tw.crypto.encrypt(content.compressed)\\n      if ($tw.crypto.hasEncryptionPublicKey()) {\\n        content.keccak256 = $tw.crypto.keccak256(content.compressed)\\n      }\\n    }\\n    content = JSON.stringify(content)\\n    this.encryptedText = $tw.utils.htmlEncode(content)\\n  }\\n\\n  /*\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  CompressWidget.prototype.refresh = function (changedTiddlers) {\\n    // We don't need to worry about refreshing because the compress widget isn't for interactive use\\n    return false\\n  }\\n\\n  exports.compress = CompressWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/dropzone.js\": {\n            \"title\": \"$:/core/modules/widgets/dropzone.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/dropzone.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nDropzone widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var DropZoneWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /**\\n   * Inherit from the base widget class\\n   */\\n  DropZoneWidget.prototype = new Widget()\\n\\n  /**\\n   * Render this widget into the DOM\\n   */\\n  DropZoneWidget.prototype.render = function (parent, nextSibling) {\\n    // Remember parent\\n    this.parentDomNode = parent\\n    // Compute attributes and execute state\\n    this.computeAttributes()\\n    this.execute()\\n    // Create element\\n    var domNode = this.document.createElement('div')\\n    domNode.className = this.dropzoneClass || 'tc-dropzone'\\n    // Add event handlers\\n    if (this.dropzoneEnable) {\\n      $tw.utils.addEventListeners(domNode, [\\n        { name: 'dragenter', handlerObject: this, handlerMethod: 'handleDragEnterEvent' },\\n        { name: 'dragover', handlerObject: this, handlerMethod: 'handleDragOverEvent' },\\n        { name: 'dragleave', handlerObject: this, handlerMethod: 'handleDragLeaveEvent' },\\n        { name: 'drop', handlerObject: this, handlerMethod: 'handleDropEvent' },\\n        { name: 'paste', handlerObject: this, handlerMethod: 'handlePasteEvent' },\\n        { name: 'dragend', handlerObject: this, handlerMethod: 'handleDragEndEvent' },\\n      ])\\n    }\\n    domNode.addEventListener('click', function (event) {}, false)\\n    // Insert element\\n    parent.insertBefore(domNode, nextSibling)\\n    this.renderChildren(domNode, null)\\n    this.domNodes.push(domNode)\\n    // Stack of outstanding enter/leave events\\n    this.currentlyEntered = []\\n  }\\n\\n  DropZoneWidget.prototype.enterDrag = function (event) {\\n    if (this.currentlyEntered.indexOf(event.target) === -1) {\\n      this.currentlyEntered.push(event.target)\\n    }\\n    // If we're entering for the first time we need to apply highlighting\\n    $tw.utils.addClass(this.domNodes[0], 'tc-dragover')\\n  }\\n\\n  DropZoneWidget.prototype.leaveDrag = function (event) {\\n    var pos = this.currentlyEntered.indexOf(event.target)\\n    if (pos !== -1) {\\n      this.currentlyEntered.splice(pos, 1)\\n    }\\n    // Remove highlighting if we're leaving externally\\n    if (this.currentlyEntered.length === 0) {\\n      $tw.utils.removeClass(this.domNodes[0], 'tc-dragover')\\n    }\\n  }\\n\\n  DropZoneWidget.prototype.handleDragEnterEvent = function (event) {\\n    // Check for this window being the source of the drag\\n    if ($tw.dragInProgress) {\\n      return false\\n    }\\n    this.enterDrag(event)\\n    // Tell the browser that we're ready to handle the drop\\n    event.preventDefault()\\n    // Tell the browser not to ripple the drag up to any parent drop handlers\\n    event.stopPropagation()\\n  }\\n\\n  DropZoneWidget.prototype.handleDragOverEvent = function (event) {\\n    // Check for being over a TEXTAREA or INPUT\\n    if (['TEXTAREA', 'INPUT'].indexOf(event.target.tagName) !== -1) {\\n      return false\\n    }\\n    // Check for this window being the source of the drag\\n    if ($tw.dragInProgress) {\\n      return false\\n    }\\n    // Tell the browser that we're still interested in the drop\\n    event.preventDefault()\\n    event.dataTransfer.dropEffect = 'copy' // Explicitly show this is a copy\\n  }\\n\\n  DropZoneWidget.prototype.handleDragLeaveEvent = function (event) {\\n    this.leaveDrag(event)\\n  }\\n\\n  DropZoneWidget.prototype.handleDragEndEvent = function (event) {\\n    $tw.utils.removeClass(this.domNodes[0], 'tc-dragover')\\n  }\\n\\n  DropZoneWidget.prototype.handleDropEvent = function (event) {\\n    var self = this\\n    var readFileCallback = function (tiddlerFieldsArray) {\\n      if (tiddlerFieldsArray.merged) {\\n        self.dispatchEvent({\\n          type: 'tm-ipfs-import-tiddlers',\\n          param: tiddlerFieldsArray,\\n          autoOpenOnImport: self.autoOpenOnImport,\\n          importTitle: self.importTitle,\\n        })\\n      } else {\\n        self.dispatchEvent({\\n          type: 'tm-import-tiddlers',\\n          param: tiddlerFieldsArray,\\n          autoOpenOnImport: self.autoOpenOnImport,\\n          importTitle: self.importTitle,\\n        })\\n      }\\n    }\\n    this.leaveDrag(event)\\n    // Check for being over a TEXTAREA or INPUT\\n    if (['TEXTAREA', 'INPUT'].indexOf(event.target.tagName) !== -1) {\\n      return false\\n    }\\n    // Check for this window being the source of the drag\\n    if ($tw.dragInProgress) {\\n      return false\\n    }\\n    var self = this\\n    var dataTransfer = event.dataTransfer\\n    // Remove highlighting\\n    $tw.utils.removeClass(this.domNodes[0], 'tc-dragover')\\n    // Import any files in the drop\\n    var hasFiles = dataTransfer.files && dataTransfer.files.length > 0\\n    if (hasFiles) {\\n      this.wiki.readFiles(dataTransfer.files, {\\n        callback: readFileCallback,\\n        deserializer: this.dropzoneDeserializer,\\n      })\\n    }\\n    // Try to import the various data types we understand\\n    if (hasFiles === false) {\\n      $tw.utils.importDataTransfer(dataTransfer, this.wiki.generateNewTitle('Untitled'), readFileCallback)\\n    }\\n    // Tell the browser that we handled the drop\\n    event.preventDefault()\\n    event.stopPropagation()\\n  }\\n\\n  DropZoneWidget.prototype.handlePasteEvent = function (event) {\\n    var self = this\\n    var readFileCallback = function (tiddlerFieldsArray) {\\n      if (tiddlerFieldsArray.merged) {\\n        self.dispatchEvent({\\n          type: 'tm-ipfs-import-tiddlers',\\n          param: tiddlerFieldsArray,\\n          autoOpenOnImport: self.autoOpenOnImport,\\n          importTitle: self.importTitle,\\n        })\\n      } else {\\n        self.dispatchEvent({\\n          type: 'tm-import-tiddlers',\\n          param: tiddlerFieldsArray,\\n          autoOpenOnImport: self.autoOpenOnImport,\\n          importTitle: self.importTitle,\\n        })\\n      }\\n    }\\n    // Let the browser handle it if we're in a textarea or input box\\n    if (['TEXTAREA', 'INPUT'].indexOf(event.target.tagName) === -1 && !event.target.isContentEditable) {\\n      var self = this\\n      var items = event.clipboardData.items\\n      // Enumerate the clipboard items\\n      for (var t = 0; t < items.length; t++) {\\n        var item = items[t]\\n        if (item.kind === 'file') {\\n          // Import any files\\n          this.wiki.readFile(item.getAsFile(), {\\n            callback: readFileCallback,\\n            deserializer: this.dropzoneDeserializer,\\n          })\\n        } else if (item.kind === 'string') {\\n          // Create tiddlers from string items\\n          var type = item.type\\n          item.getAsString(function (str) {\\n            var tiddlerFields = {\\n              title: self.wiki.generateNewTitle('Untitled'),\\n              text: str,\\n              type: type,\\n            }\\n            if ($tw.log.IMPORT) {\\n              console.log(\\\"Importing string '\\\" + str + \\\"', type: '\\\" + type + \\\"'\\\")\\n            }\\n            self.dispatchEvent({\\n              type: 'tm-import-tiddlers',\\n              param: JSON.stringify([tiddlerFields]),\\n              autoOpenOnImport: self.autoOpenOnImport,\\n              importTitle: self.importTitle,\\n            })\\n          })\\n        }\\n      }\\n      // Tell the browser that we've handled the paste\\n      event.stopPropagation()\\n      event.preventDefault()\\n    }\\n  }\\n\\n  /**\\n   * Compute the internal state of the widget\\n   */\\n  DropZoneWidget.prototype.execute = function () {\\n    this.dropzoneClass = this.getAttribute('class')\\n    this.dropzoneDeserializer = this.getAttribute('deserializer')\\n    this.dropzoneEnable = (this.getAttribute('enable') || 'yes') === 'yes'\\n    this.autoOpenOnImport = this.getAttribute('autoOpenOnImport')\\n    this.importTitle = this.getAttribute('importTitle')\\n    // Make child widgets\\n    this.makeChildWidgets()\\n  }\\n\\n  /**\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  DropZoneWidget.prototype.refresh = function (changedTiddlers) {\\n    var changedAttributes = this.computeAttributes()\\n    if (changedAttributes.enable || changedAttributes.autoOpenOnImport || changedAttributes.importTitle || changedAttributes.deserializer || changedAttributes.class) {\\n      this.refreshSelf()\\n      return true\\n    }\\n    return this.refreshChildren(changedTiddlers)\\n  }\\n\\n  exports.dropzone = DropZoneWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/encrypt.js\": {\n            \"title\": \"$:/core/modules/widgets/encrypt.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/encrypt.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nEncrypt widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var EncryptWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /**\\n   * Inherit from the base widget class\\n   */\\n  EncryptWidget.prototype = new Widget()\\n\\n  /**\\n   * Render this widget into the DOM\\n   */\\n  EncryptWidget.prototype.render = function (parent, nextSibling) {\\n    this.parentDomNode = parent\\n    this.computeAttributes()\\n    this.execute()\\n    var textNode = this.document.createTextNode(this.encryptedText)\\n    if ($tw.crypto.hasEncryptionPublicKey()) {\\n      var sign = $tw.wiki.getTiddler('$:/isSigned')\\n      sign = sign !== undefined ? sign.fields.text === 'yes' : false\\n      if (sign) {\\n        textNode.sign = true\\n      }\\n    }\\n    parent.insertBefore(textNode, nextSibling)\\n    this.domNodes.push(textNode)\\n  }\\n\\n  /**\\n   * Compute the internal state of the widget\\n   */\\n  EncryptWidget.prototype.execute = function () {\\n    // Get parameters from our attributes\\n    this.filter = this.getAttribute('filter', '[!is[system]]')\\n    // Encrypt the filtered tiddlers\\n    var tiddlers = this.wiki.filterTiddlers(this.filter)\\n    var json = {}\\n    var self = this\\n    $tw.utils.each(tiddlers, function (title) {\\n      var tiddler = self.wiki.getTiddler(title)\\n      var jsonTiddler = {}\\n      for (var f in tiddler.fields) {\\n        jsonTiddler[f] = tiddler.getFieldString(f)\\n      }\\n      json[title] = jsonTiddler\\n    })\\n    var content = $tw.crypto.encrypt(JSON.stringify(json))\\n    if ($tw.crypto.hasEncryptionPublicKey()) {\\n      content = JSON.stringify({\\n        encrypted: content,\\n        keccak256: $tw.crypto.keccak256(content),\\n      })\\n    }\\n    this.encryptedText = $tw.utils.htmlEncode(content)\\n  }\\n\\n  /**\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  EncryptWidget.prototype.refresh = function (changedTiddlers) {\\n    // We don't need to worry about refreshing because the encrypt widget isn't for interactive use\\n    return false\\n  }\\n\\n  exports.encrypt = EncryptWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/image.js\": {\n            \"title\": \"$:/core/modules/widgets/image.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/image.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nThe image widget displays an image referenced with an external URI or with a local tiddler title.\\n\\n```\\n<$image src=\\\"TiddlerTitle\\\" width=\\\"320\\\" height=\\\"400\\\" class=\\\"classnames\\\">\\n```\\n\\nThe image source can be the title of an existing tiddler or the URL of an external image.\\n\\nExternal images always generate an HTML `<img>` tag.\\n\\nTiddlers that have a _canonical_uri field generate an HTML `<img>` tag with the src attribute containing the URI.\\n\\nTiddlers that contain image data generate an HTML `<img>` tag with the src attribute containing a base64 representation of the image.\\n\\nTiddlers that contain wikitext could be rendered to a DIV of the usual size of a tiddler, and then transformed to the size requested.\\n\\nThe width and height attributes are interpreted as a number of pixels, and do not need to include the \\\"px\\\" suffix.\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var name = 'ipfs-image'\\n\\n  var ImageWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /*\\nInherit from the base widget class\\n*/\\n  ImageWidget.prototype = new Widget()\\n\\n  /*\\nRender this widget into the DOM\\n*/\\n  ImageWidget.prototype.render = function (parent, nextSibling) {\\n    this.parentDomNode = parent\\n    this.computeAttributes()\\n    this.execute()\\n    // Create element\\n    // Determine what type of image it is\\n    var tiddler = this.wiki.getTiddler(this.imageSource)\\n    // Create default element\\n    var domNode = this.document.createElement('img')\\n    if (!tiddler) {\\n      // The source isn't the title of a tiddler, so we'll assume it's a URL\\n      domNode.setAttribute(\\n        'src',\\n        this.getVariable('tv-get-export-image-link', {\\n          params: [{ name: 'src', value: this.imageSource }],\\n          defaultValue: this.imageSource,\\n        })\\n      )\\n    } else {\\n      // Check if it is an image tiddler\\n      if (this.wiki.isImageTiddler(this.imageSource)) {\\n        var type = tiddler.fields.type\\n        var text = tiddler.fields.text\\n        var canonicalUri = tiddler.fields._canonical_uri\\n        canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n        // If the tiddler has body text then it doesn't need to be lazily loaded\\n        if (text) {\\n          // Render the appropriate element for the image type\\n          switch (type) {\\n            case 'application/pdf':\\n              domNode = this.document.createElement('embed')\\n              domNode.setAttribute('src', 'data:application/pdf;base64,' + text)\\n              break\\n            case 'image/svg+xml':\\n              domNode.setAttribute('src', 'data:image/svg+xml,' + encodeURIComponent(text))\\n              break\\n            default:\\n              domNode.setAttribute('src', 'data:' + type + ';base64,' + text)\\n              break\\n          }\\n        } else if (canonicalUri) {\\n          var password = tiddler.fields._password\\n          password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n          $tw.ipfs\\n            .resolveUrl(false, true, canonicalUri)\\n            .then(data => {\\n              var { normalizedUrl, resolvedUrl } = data\\n              var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n              if (url !== null) {\\n                switch (type) {\\n                  case 'application/pdf':\\n                    domNode = this.document.createElement('embed')\\n                    $tw.ipfs\\n                      .loadToBase64(url, password)\\n                      .then(data => {\\n                        if (data !== undefined && data !== null) {\\n                          domNode.setAttribute('src', 'data:application/pdf;base64,' + data)\\n                        }\\n                      })\\n                      .catch(error => {\\n                        $tw.ipfs.getLogger().error(error)\\n                        $tw.utils.alert(name, error.message)\\n                      })\\n                    break\\n                  case 'image/svg+xml':\\n                    $tw.ipfs\\n                      .loadToUtf8(url, password)\\n                      .then(data => {\\n                        if (data !== undefined && data !== null) {\\n                          domNode.setAttribute('src', 'data:image/svg+xml,' + encodeURIComponent(data))\\n                        }\\n                      })\\n                      .catch(error => {\\n                        $tw.ipfs.getLogger().error(error)\\n                        $tw.utils.alert(name, error.message)\\n                      })\\n                    break\\n                  default:\\n                    $tw.ipfs\\n                      .loadToBase64(url, password)\\n                      .then(data => {\\n                        if (data !== undefined && data !== null) {\\n                          domNode.setAttribute('src', 'data:' + type + ';base64,' + data)\\n                        }\\n                      })\\n                      .catch(error => {\\n                        $tw.ipfs.getLogger().error(error)\\n                        $tw.utils.alert(name, error.message)\\n                      })\\n                    break\\n                }\\n              }\\n            })\\n            .catch(error => {\\n              $tw.ipfs.getLogger().error(error)\\n            })\\n        } else {\\n          // Just trigger loading of the tiddler\\n          this.wiki.getTiddlerText(this.imageSource)\\n          domNode.setAttribute('src', '')\\n        }\\n      }\\n    }\\n    // Assign the attributes\\n    if (this.imageClass) {\\n      domNode.setAttribute('class', this.imageClass)\\n    }\\n    if (this.imageWidth) {\\n      domNode.setAttribute('width', this.imageWidth)\\n    }\\n    if (this.imageHeight) {\\n      domNode.setAttribute('height', this.imageHeight)\\n    }\\n    if (this.imageTooltip) {\\n      domNode.setAttribute('title', this.imageTooltip)\\n    }\\n    if (this.imageAlt) {\\n      domNode.setAttribute('alt', this.imageAlt)\\n    }\\n    // Insert element\\n    parent.insertBefore(domNode, nextSibling)\\n    this.domNodes.push(domNode)\\n  }\\n\\n  /*\\nCompute the internal state of the widget\\n*/\\n  ImageWidget.prototype.execute = function () {\\n    // Get our parameters\\n    this.imageSource = this.getAttribute('source')\\n    this.imageWidth = this.getAttribute('width')\\n    this.imageHeight = this.getAttribute('height')\\n    this.imageClass = this.getAttribute('class')\\n    this.imageTooltip = this.getAttribute('tooltip')\\n    this.imageAlt = this.getAttribute('alt')\\n  }\\n\\n  /*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\n  ImageWidget.prototype.refresh = function (changedTiddlers) {\\n    var changedAttributes = this.computeAttributes()\\n    if (\\n      changedAttributes.source ||\\n      changedAttributes.width ||\\n      changedAttributes.height ||\\n      changedAttributes.class ||\\n      changedAttributes.tooltip ||\\n      changedTiddlers[this.imageSource]\\n    ) {\\n      this.refreshSelf()\\n      return true\\n    } else {\\n      return false\\n    }\\n  }\\n\\n  exports.image = ImageWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/ipfs/modules/widgets/ipfs-link.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/widgets/ipfs-link.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/widgets/ipfs-link.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nIPFS link widget\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  const name = 'ipfs-link'\\n\\n  var IpfsLinkWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /*\\n   * Inherit from the base widget class\\n   */\\n  IpfsLinkWidget.prototype = new Widget()\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.render = function (parent, nextSibling) {\\n    var self = this\\n    // Save the parent dom node\\n    this.parentDomNode = parent\\n    // Compute our attributes\\n    this.computeAttributes()\\n    // Execute our logic\\n    this.execute()\\n    // Tiddler link\\n    var value = this.url !== undefined ? this.url : this.value\\n    var tiddler = $tw.wiki.getTiddler(value)\\n    if (tiddler) {\\n      this.renderTiddlerLink(parent, nextSibling)\\n    } else {\\n      this.renderText(parent, nextSibling)\\n      $tw.ipfs\\n        .resolveUrl(false, false, value)\\n        .then(data => {\\n          var { normalizedUrl } = data\\n          if (normalizedUrl !== null) {\\n            const sibling = self.findNextSiblingDomNode()\\n            self.removeChildDomNodes()\\n            self.renderExternalLink(parent, nextSibling !== null ? nextSibling : sibling, normalizedUrl)\\n          }\\n        })\\n        .catch(error => {\\n          $tw.ipfs.getLogger().error(error)\\n        })\\n    }\\n  }\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.renderExternalLink = function (parent, nextSibling, url) {\\n    // Sanitise the specified tag\\n    var tag = this.linkTag\\n    if ($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {\\n      tag = 'a'\\n    }\\n    // Create our element\\n    var namespace = this.getVariable('namespace', {\\n      defaultValue: 'http://www.w3.org/1999/xhtml',\\n    })\\n    var domNode = this.document.createElementNS(namespace, tag)\\n    domNode.setAttribute('href', url.toString())\\n    // Add a click event handler\\n    $tw.utils.addEventListeners(domNode, [\\n      {\\n        name: 'click',\\n        handlerObject: this,\\n        handlerMethod: 'handleExternalClickEvent',\\n      },\\n    ])\\n    // Assign classes\\n    var classes = []\\n    if (this.classes) {\\n      classes.push(this.classes)\\n    }\\n    if (classes.length > 0) {\\n      domNode.setAttribute('class', classes.join(' '))\\n    }\\n    if (this['aria-label']) {\\n      domNode.setAttribute('aria-label', this['aria-label'])\\n    }\\n    parent.insertBefore(domNode, nextSibling)\\n    this.renderChildren(domNode, null)\\n    this.domNodes.push(domNode)\\n  }\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.renderTiddlerLink = function (parent, nextSibling) {\\n    // self\\n    var self = this\\n    // Sanitise the specified tag\\n    var tag = this.linkTag\\n    if ($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {\\n      tag = 'a'\\n    }\\n    var value = this.url !== undefined ? this.url : this.value\\n    var isMissing = !this.wiki.tiddlerExists(value)\\n    var isShadow = this.wiki.isShadowTiddler(value)\\n    // Create our element\\n    var namespace = this.getVariable('namespace', {\\n      defaultValue: 'http://www.w3.org/1999/xhtml',\\n    })\\n    var domNode = this.document.createElementNS(namespace, tag)\\n    // Assign classes\\n    var classes = []\\n    if (this.overrideClasses === undefined) {\\n      classes.push('tc-tiddlylink')\\n      if (isShadow) {\\n        classes.push('tc-tiddlylink-shadow')\\n      }\\n      if (isMissing && !isShadow) {\\n        classes.push('tc-tiddlylink-missing')\\n      } else {\\n        if (!isMissing) {\\n          classes.push('tc-tiddlylink-resolves')\\n        }\\n      }\\n      if (this.linkClasses) {\\n        classes.push(this.linkClasses)\\n      }\\n    } else if (this.overrideClasses !== '') {\\n      classes.push(this.overrideClasses)\\n    }\\n    if (classes.length > 0) {\\n      domNode.setAttribute('class', classes.join(' '))\\n    }\\n    // Set an href\\n    var wikilinkTransformFilter = this.getVariable('tv-filter-export-link')\\n    var wikiLinkText\\n    if (wikilinkTransformFilter) {\\n      // Use the filter to construct the href\\n      wikiLinkText = this.wiki.filterTiddlers(wikilinkTransformFilter, this, function (iterator) {\\n        iterator(self.wiki.getTiddler(value), value)\\n      })[0]\\n    } else {\\n      // Expand the tv-wikilink-template variable to construct the href\\n      var wikiLinkTemplateMacro = this.getVariable('tv-wikilink-template')\\n      var wikiLinkTemplate = wikiLinkTemplateMacro ? wikiLinkTemplateMacro.trim() : '#$uri_encoded$'\\n      wikiLinkText = $tw.utils.replaceString(wikiLinkTemplate, '$uri_encoded$', encodeURIComponent(value))\\n      wikiLinkText = $tw.utils.replaceString(wikiLinkText, '$uri_doubleencoded$', encodeURIComponent(encodeURIComponent(value)))\\n    }\\n    // Override with the value of tv-get-export-link if defined\\n    wikiLinkText = this.getVariable('tv-get-export-link', {\\n      params: [{ name: 'to', value: value }],\\n      defaultValue: wikiLinkText,\\n    })\\n    if (tag === 'a') {\\n      var namespaceHref = namespace === 'http://www.w3.org/2000/svg' ? 'http://www.w3.org/1999/xlink' : undefined\\n      domNode.setAttributeNS(namespaceHref, 'href', wikiLinkText)\\n    }\\n    // Set the tabindex\\n    if (this.tabIndex) {\\n      domNode.setAttribute('tabindex', this.tabIndex)\\n    }\\n    // Set the tooltip\\n    // HACK: Performance issues with re-parsing the tooltip prevent us defaulting the tooltip to \\\"<$transclude field='tooltip'><$transclude field='title'/></$transclude>\\\"\\n    var tooltipWikiText = this.tooltip || this.getVariable('tv-wikilink-tooltip')\\n    if (tooltipWikiText) {\\n      var tooltipText = this.wiki.renderText('text/plain', 'text/vnd.tiddlywiki', tooltipWikiText, {\\n        parseAsInline: true,\\n        variables: {\\n          currentTiddler: value,\\n        },\\n        parentWidget: this,\\n      })\\n      domNode.setAttribute('title', tooltipText)\\n    }\\n    if (this['aria-label']) {\\n      domNode.setAttribute('aria-label', this['aria-label'])\\n    }\\n    // Add a click event handler\\n    $tw.utils.addEventListeners(domNode, [\\n      {\\n        name: 'click',\\n        handlerObject: this,\\n        handlerMethod: 'handleTiddlerClickEvent',\\n      },\\n    ])\\n    // Make the link draggable if required\\n    if (this.draggable === 'yes') {\\n      $tw.utils.makeDraggable({\\n        domNode: domNode,\\n        dragTiddlerFn: function () {\\n          return value\\n        },\\n        widget: this,\\n      })\\n    }\\n    parent.insertBefore(domNode, nextSibling)\\n    this.renderChildren(domNode, null)\\n    this.domNodes.push(domNode)\\n  }\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.renderText = function (parent, nextSibling) {\\n    const domNode = this.document.createElement('span')\\n    parent.insertBefore(domNode, nextSibling)\\n    this.renderChildren(domNode, null)\\n    this.domNodes.push(domNode)\\n  }\\n\\n  IpfsLinkWidget.prototype.handleExternalClickEvent = function (event) {\\n    const value = this.url !== undefined ? this.url : this.value\\n    $tw.ipfs\\n      .resolveUrl(true, true, value)\\n      .then(data => {\\n        const { resolvedUrl } = data\\n        if (resolvedUrl !== null) {\\n          window.open(resolvedUrl.href, '_blank', 'noopener,noreferrer')\\n        }\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n    event.preventDefault()\\n    event.stopPropagation()\\n    return false\\n  }\\n\\n  IpfsLinkWidget.prototype.handleTiddlerClickEvent = function (event) {\\n    // Send the click on its way as a navigate event\\n    const bounds = this.domNodes[0].getBoundingClientRect()\\n    const value = this.url !== undefined ? this.url : this.value\\n    this.dispatchEvent({\\n      type: 'tm-navigate',\\n      navigateTo: value,\\n      navigateFromTitle: this.getVariable('storyTiddler'),\\n      navigateFromNode: this,\\n      navigateFromClientRect: {\\n        top: bounds.top,\\n        left: bounds.left,\\n        width: bounds.width,\\n        right: bounds.right,\\n        bottom: bounds.bottom,\\n        height: bounds.height,\\n      },\\n      navigateSuppressNavigation: event.metaKey || event.ctrlKey || event.button === 1,\\n      metaKey: event.metaKey,\\n      ctrlKey: event.ctrlKey,\\n      altKey: event.altKey,\\n      shiftKey: event.shiftKey,\\n    })\\n    if (this.domNodes[0].hasAttribute('href')) {\\n      event.preventDefault()\\n    }\\n    event.stopPropagation()\\n    return false\\n  }\\n\\n  /*\\n   * Compute the internal state of the widget\\n   */\\n  IpfsLinkWidget.prototype.execute = function () {\\n    // Pick up our attributes\\n    this.url = undefined\\n    this.tiddler = this.getAttribute('tiddler') ? this.getAttribute('tiddler') : this.getVariable('currentTiddler')\\n    var tiddler\\n    if (this.tiddler) {\\n      tiddler = $tw.wiki.getTiddler(this.tiddler)\\n    }\\n    this.field = this.getAttribute('field')\\n    this.value = this.getAttribute('value')\\n    this.value = this.value ? this.value : tiddler && tiddler.getFieldString(this.field) !== '' ? tiddler.getFieldString(this.field) : this.tiddler\\n    this.text = this.getAttribute('text')\\n    this.text = this.text ? (tiddler && tiddler.getFieldString(this.text) !== '' ? tiddler.getFieldString(this.text) : this.tiddler) : this.value\\n    if (tiddler && this.getAttribute('value') && tiddler.getFieldString(this.getAttribute('value')) !== '') {\\n      this.url = tiddler.getFieldString(this.getAttribute('value'))\\n    }\\n    this.tooltip = this.getAttribute('tooltip')\\n    this['aria-label'] = this.getAttribute('aria-label')\\n    this.linkClasses = this.getAttribute('class') || 'tc-ipfs-link-external'\\n    this.overrideClasses = this.getAttribute('overrideClass')\\n    this.tabIndex = this.getAttribute('tabindex')\\n    this.draggable = this.getAttribute('draggable', 'yes')\\n    this.linkTag = this.getAttribute('tag', 'a')\\n    var templateTree\\n    if (this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {\\n      templateTree = this.parseTreeNode.children\\n    } else {\\n      templateTree = [{ type: 'text', text: this.text }]\\n    }\\n    this.makeChildWidgets(templateTree)\\n  }\\n\\n  /*\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  IpfsLinkWidget.prototype.refresh = function (changedTiddlers) {\\n    const changedAttributes = this.computeAttributes()\\n    const tiddler = $tw.wiki.getTiddler(this.tiddler)\\n    var value = null\\n    if (tiddler && this.field !== undefined && this.field !== null) {\\n      value = tiddler.getFieldString(this.field)\\n    }\\n    if (\\n      changedAttributes.text ||\\n      changedAttributes.field ||\\n      changedTiddlers[this.field] ||\\n      changedAttributes.value ||\\n      changedTiddlers[this.value] ||\\n      changedAttributes.tooltip ||\\n      changedAttributes['aria-label'] ||\\n      changedTiddlers['$:/ipfs/saver/gateway'] ||\\n      changedTiddlers['$:/ipfs/saver/policy'] ||\\n      (value !== null && value !== this.value)\\n    ) {\\n      this.refreshSelf()\\n      return true\\n    }\\n    return this.refreshChildren(changedTiddlers)\\n  }\\n\\n  exports.ipfslink = IpfsLinkWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/navigator.js\": {\n            \"title\": \"$:/core/modules/widgets/navigator.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/navigator.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: widget\\n\\nNavigator widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var IMPORT_TITLE = '$:/Import'\\n  var IPFS_IMPORT_TITLE = '$:/IpfsImport'\\n  var IPFS_EXPORT_TITLE = '$:/IpfsExport'\\n\\n  var Widget = require('$:/core/modules/widgets/widget.js').widget\\n\\n  var NavigatorWidget = function (parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options)\\n  }\\n\\n  /*\\nInherit from the base widget class\\n*/\\n  NavigatorWidget.prototype = new Widget()\\n\\n  /*\\nRender this widget into the DOM\\n*/\\n  NavigatorWidget.prototype.render = function (parent, nextSibling) {\\n    this.addEventListeners([\\n      { type: 'tm-navigate', handler: 'handleNavigateEvent' },\\n      { type: 'tm-edit-tiddler', handler: 'handleEditTiddlerEvent' },\\n      { type: 'tm-delete-tiddler', handler: 'handleDeleteTiddlerEvent' },\\n      { type: 'tm-save-tiddler', handler: 'handleSaveTiddlerEvent' },\\n      { type: 'tm-cancel-tiddler', handler: 'handleCancelTiddlerEvent' },\\n      { type: 'tm-close-tiddler', handler: 'handleCloseTiddlerEvent' },\\n      { type: 'tm-close-all-tiddlers', handler: 'handleCloseAllTiddlersEvent' },\\n      {\\n        type: 'tm-close-other-tiddlers',\\n        handler: 'handleCloseOtherTiddlersEvent',\\n      },\\n      { type: 'tm-new-tiddler', handler: 'handleNewTiddlerEvent' },\\n      {\\n        type: 'tm-ipfs-export-tiddlers',\\n        handler: 'handleIpfsExportTiddlersEvent',\\n      },\\n      { type: 'tm-import-tiddlers', handler: 'handleImportTiddlersEvent' },\\n      {\\n        type: 'tm-ipfs-import-tiddlers',\\n        handler: 'handleIpfsImportTiddlersEvent',\\n      },\\n      {\\n        type: 'tm-perform-ipfs-export',\\n        handler: 'handlePerformIpfsExportEvent',\\n      },\\n      { type: 'tm-perform-import', handler: 'handlePerformImportEvent' },\\n      {\\n        type: 'tm-perform-ipfs-import',\\n        handler: 'handlePerformIpfsImportEvent',\\n      },\\n      { type: 'tm-fold-tiddler', handler: 'handleFoldTiddlerEvent' },\\n      {\\n        type: 'tm-fold-other-tiddlers',\\n        handler: 'handleFoldOtherTiddlersEvent',\\n      },\\n      { type: 'tm-fold-all-tiddlers', handler: 'handleFoldAllTiddlersEvent' },\\n      {\\n        type: 'tm-unfold-all-tiddlers',\\n        handler: 'handleUnfoldAllTiddlersEvent',\\n      },\\n      { type: 'tm-rename-tiddler', handler: 'handleRenameTiddlerEvent' },\\n    ])\\n    this.parentDomNode = parent\\n    this.computeAttributes()\\n    this.execute()\\n    this.renderChildren(parent, nextSibling)\\n  }\\n\\n  /**\\n   * Compute the internal state of the widget\\n   */\\n  NavigatorWidget.prototype.execute = function () {\\n    // Get our parameters\\n    this.storyTitle = this.getAttribute('story')\\n    this.historyTitle = this.getAttribute('history')\\n    this.setVariable('tv-story-list', this.storyTitle)\\n    this.setVariable('tv-history-list', this.historyTitle)\\n    this.story = new $tw.Story({\\n      wiki: this.wiki,\\n      storyTitle: this.storyTitle,\\n      historyTitle: this.historyTitle,\\n    })\\n    // Construct the child widgets\\n    this.makeChildWidgets()\\n  }\\n\\n  /**\\n   * Selectively refreshes the widget if needed.\\n   * Returns true if the widget or any of its children needed re-rendering\\n   */\\n  NavigatorWidget.prototype.refresh = function (changedTiddlers) {\\n    var changedAttributes = this.computeAttributes()\\n    if (changedAttributes.story || changedAttributes.history) {\\n      this.refreshSelf()\\n      return true\\n    } else {\\n      return this.refreshChildren(changedTiddlers)\\n    }\\n  }\\n\\n  NavigatorWidget.prototype.getStoryList = function () {\\n    return this.storyTitle ? this.wiki.getTiddlerList(this.storyTitle) : null\\n  }\\n\\n  NavigatorWidget.prototype.saveStoryList = function (storyList) {\\n    if (this.storyTitle) {\\n      var storyTiddler = this.wiki.getTiddler(this.storyTitle)\\n      this.wiki.addTiddler(\\n        new $tw.Tiddler({ title: this.storyTitle }, storyTiddler, {\\n          list: storyList,\\n        })\\n      )\\n    }\\n  }\\n\\n  NavigatorWidget.prototype.removeTitleFromStory = function (storyList, title) {\\n    if (storyList) {\\n      var p = storyList.indexOf(title)\\n      while (p !== -1) {\\n        storyList.splice(p, 1)\\n        p = storyList.indexOf(title)\\n      }\\n    }\\n  }\\n\\n  NavigatorWidget.prototype.replaceFirstTitleInStory = function (storyList, oldTitle, newTitle) {\\n    if (storyList) {\\n      var pos = storyList.indexOf(oldTitle)\\n      if (pos !== -1) {\\n        storyList[pos] = newTitle\\n        do {\\n          pos = storyList.indexOf(oldTitle, pos + 1)\\n          if (pos !== -1) {\\n            storyList.splice(pos, 1)\\n          }\\n        } while (pos !== -1)\\n      } else {\\n        storyList.splice(0, 0, newTitle)\\n      }\\n    }\\n  }\\n\\n  NavigatorWidget.prototype.addToStory = function (title, fromTitle) {\\n    if (this.storyTitle) {\\n      this.story.addToStory(title, fromTitle, {\\n        openLinkFromInsideRiver: this.getAttribute('openLinkFromInsideRiver', 'top'),\\n        openLinkFromOutsideRiver: this.getAttribute('openLinkFromOutsideRiver', 'top'),\\n      })\\n    }\\n  }\\n\\n  /**\\n   * Add a new record to the top of the history stack\\n   * title: a title string or an array of title strings\\n   * fromPageRect: page coordinates of the origin of the navigation\\n   */\\n  NavigatorWidget.prototype.addToHistory = function (title, fromPageRect) {\\n    this.story.addToHistory(title, fromPageRect, this.historyTitle)\\n  }\\n\\n  /**\\n   * Handle a tm-navigate event\\n   */\\n  NavigatorWidget.prototype.handleNavigateEvent = function (event) {\\n    event = $tw.hooks.invokeHook('th-navigating', event)\\n    if (event.navigateTo) {\\n      this.addToStory(event.navigateTo, event.navigateFromTitle)\\n      if (!event.navigateSuppressNavigation) {\\n        this.addToHistory(event.navigateTo, event.navigateFromClientRect)\\n      }\\n    }\\n    return false\\n  }\\n\\n  // Close a specified tiddler\\n  NavigatorWidget.prototype.handleCloseTiddlerEvent = function (event) {\\n    var title = event.param || event.tiddlerTitle\\n    var storyList = this.getStoryList()\\n    // Look for tiddlers with this title to close\\n    this.removeTitleFromStory(storyList, title)\\n    this.saveStoryList(storyList)\\n    return false\\n  }\\n\\n  // Close all tiddlers\\n  NavigatorWidget.prototype.handleCloseAllTiddlersEvent = function (event) {\\n    this.saveStoryList([])\\n    return false\\n  }\\n\\n  // Close other tiddlers\\n  NavigatorWidget.prototype.handleCloseOtherTiddlersEvent = function (event) {\\n    var title = event.param || event.tiddlerTitle\\n    this.saveStoryList([title])\\n    return false\\n  }\\n\\n  // Place a tiddler in edit mode\\n  NavigatorWidget.prototype.handleEditTiddlerEvent = function (event) {\\n    var editTiddler = $tw.hooks.invokeHook('th-editing-tiddler', event)\\n    if (!editTiddler) {\\n      return false\\n    }\\n    var self = this\\n    function isUnmodifiedShadow (title) {\\n      return self.wiki.isShadowTiddler(title) && !self.wiki.tiddlerExists(title)\\n    }\\n    function confirmEditShadow (title) {\\n      return confirm(\\n        $tw.language.getString('ConfirmEditShadowTiddler', {\\n          variables: { title: title },\\n        })\\n      )\\n    }\\n    var title = event.param || event.tiddlerTitle\\n    if (isUnmodifiedShadow(title) && !confirmEditShadow(title)) {\\n      return false\\n    }\\n    // Replace the specified tiddler with a draft in edit mode\\n    var draftTiddler = this.makeDraftTiddler(title)\\n    // Update the story and history if required\\n    if (!event.paramObject || event.paramObject.suppressNavigation !== 'yes') {\\n      var draftTitle = draftTiddler.fields.title\\n      var storyList = this.getStoryList()\\n      this.removeTitleFromStory(storyList, draftTitle)\\n      this.replaceFirstTitleInStory(storyList, title, draftTitle)\\n      this.addToHistory(draftTitle, event.navigateFromClientRect)\\n      this.saveStoryList(storyList)\\n      return false\\n    }\\n  }\\n\\n  // Delete a tiddler\\n  NavigatorWidget.prototype.handleDeleteTiddlerEvent = function (event) {\\n    // Get the tiddler we're deleting\\n    var title = event.param || event.tiddlerTitle\\n    var tiddler = this.wiki.getTiddler(title)\\n    var storyList = this.getStoryList()\\n    var originalTitle = tiddler ? tiddler.fields['draft.of'] : ''\\n    var originalTiddler = originalTitle ? this.wiki.getTiddler(originalTitle) : undefined\\n    var confirmationTitle\\n    if (!tiddler) {\\n      return false\\n    }\\n    // Check if the tiddler we're deleting is in draft mode\\n    if (originalTitle) {\\n      // If so, we'll prompt for confirmation referencing the original tiddler\\n      confirmationTitle = originalTitle\\n    } else {\\n      // If not a draft, then prompt for confirmation referencing the specified tiddler\\n      confirmationTitle = title\\n    }\\n    // Seek confirmation\\n    if (\\n      (this.wiki.getTiddler(originalTitle) || (tiddler.fields.text || '') !== '') &&\\n      !confirm(\\n        $tw.language.getString('ConfirmDeleteTiddler', {\\n          variables: { title: confirmationTitle },\\n        })\\n      )\\n    ) {\\n      return false\\n    }\\n    // Delete the original tiddler\\n    if (originalTitle) {\\n      if (originalTiddler) {\\n        $tw.hooks.invokeHook('th-deleting-tiddler', originalTiddler)\\n      }\\n      this.wiki.deleteTiddler(originalTitle)\\n      this.removeTitleFromStory(storyList, originalTitle)\\n    }\\n    // Invoke the hook function and delete this tiddler\\n    $tw.hooks.invokeHook('th-deleting-tiddler', tiddler)\\n    this.wiki.deleteTiddler(title)\\n    // Remove the closed tiddler from the story\\n    this.removeTitleFromStory(storyList, title)\\n    this.saveStoryList(storyList)\\n    // Trigger an autosave\\n    $tw.rootWidget.dispatchEvent({ type: 'tm-auto-save-wiki' })\\n    return false\\n  }\\n\\n  /**\\n   * Create/reuse the draft tiddler for a given title\\n   */\\n  NavigatorWidget.prototype.makeDraftTiddler = function (targetTitle) {\\n    // See if there is already a draft tiddler for this tiddler\\n    var draftTitle = this.wiki.findDraft(targetTitle)\\n    if (draftTitle) {\\n      return this.wiki.getTiddler(draftTitle)\\n    }\\n    // Get the current value of the tiddler we're editing\\n    var tiddler = this.wiki.getTiddler(targetTitle)\\n    // Save the initial value of the draft tiddler\\n    draftTitle = this.generateDraftTitle(targetTitle)\\n    var draftTiddler = new $tw.Tiddler(\\n      {\\n        text: '',\\n      },\\n      tiddler,\\n      {\\n        title: draftTitle,\\n        'draft.title': targetTitle,\\n        'draft.of': targetTitle,\\n      },\\n      this.wiki.getModificationFields()\\n    )\\n    this.wiki.addTiddler(draftTiddler)\\n    return draftTiddler\\n  }\\n\\n  /**\\n   * Generate a title for the draft of a given tiddler\\n   */\\n  NavigatorWidget.prototype.generateDraftTitle = function (title) {\\n    return this.wiki.generateDraftTitle(title)\\n  }\\n\\n  // Take a tiddler out of edit mode, saving the changes\\n  NavigatorWidget.prototype.handleSaveTiddlerEvent = function (event) {\\n    var title = event.param || event.tiddlerTitle\\n    var tiddler = this.wiki.getTiddler(title)\\n    var storyList = this.getStoryList()\\n    // Replace the original tiddler with the draft\\n    if (tiddler) {\\n      var draftTitle = (tiddler.fields['draft.title'] || '').trim()\\n      var draftOf = (tiddler.fields['draft.of'] || '').trim()\\n      if (draftTitle) {\\n        var isRename = draftOf !== draftTitle\\n        var isConfirmed = true\\n        if (isRename && this.wiki.tiddlerExists(draftTitle)) {\\n          isConfirmed = confirm(\\n            $tw.language.getString('ConfirmOverwriteTiddler', {\\n              variables: { title: draftTitle },\\n            })\\n          )\\n        }\\n        if (isConfirmed) {\\n          // Create the new tiddler and pass it through the th-saving-tiddler hook\\n          var newTiddler = new $tw.Tiddler(\\n            this.wiki.getCreationFields(),\\n            tiddler,\\n            {\\n              title: draftTitle,\\n              'draft.title': undefined,\\n              'draft.of': undefined,\\n            },\\n            this.wiki.getModificationFields()\\n          )\\n          newTiddler = $tw.hooks.invokeHook('th-saving-tiddler', newTiddler, tiddler)\\n          this.wiki.addTiddler(newTiddler)\\n          // If enabled, relink references to renamed tiddler\\n          var shouldRelink =\\n            this.getAttribute('relinkOnRename', 'no')\\n              .toLowerCase()\\n              .trim() === 'yes'\\n          if (isRename && shouldRelink && this.wiki.tiddlerExists(draftOf)) {\\n            this.wiki.relinkTiddler(draftOf, draftTitle)\\n          }\\n          // Remove the draft tiddler\\n          this.wiki.deleteTiddler(title)\\n          // Remove the original tiddler if we're renaming it\\n          if (isRename) {\\n            this.wiki.deleteTiddler(draftOf)\\n          }\\n          // #2381 always remove new title & old\\n          this.removeTitleFromStory(storyList, draftTitle)\\n          this.removeTitleFromStory(storyList, draftOf)\\n          if (!event.paramObject || event.paramObject.suppressNavigation !== 'yes') {\\n            // Replace the draft in the story with the original\\n            this.replaceFirstTitleInStory(storyList, title, draftTitle)\\n            this.addToHistory(draftTitle, event.navigateFromClientRect)\\n            if (draftTitle !== this.storyTitle) {\\n              this.saveStoryList(storyList)\\n            }\\n          }\\n          // Trigger an autosave\\n          $tw.rootWidget.dispatchEvent({ type: 'tm-auto-save-wiki' })\\n        }\\n      }\\n    }\\n    return false\\n  }\\n\\n  // Take a tiddler out of edit mode without saving the changes\\n  NavigatorWidget.prototype.handleCancelTiddlerEvent = function (event) {\\n    event = $tw.hooks.invokeHook('th-cancelling-tiddler', event)\\n    // Flip the specified tiddler from draft back to the original\\n    var draftTitle = event.param || event.tiddlerTitle\\n    var draftTiddler = this.wiki.getTiddler(draftTitle)\\n    var originalTitle = draftTiddler && draftTiddler.fields['draft.of']\\n    if (draftTiddler && originalTitle) {\\n      // Ask for confirmation if the tiddler text has changed\\n      var isConfirmed = true\\n      var originalTiddler = this.wiki.getTiddler(originalTitle)\\n      var storyList = this.getStoryList()\\n      if (this.wiki.isDraftModified(draftTitle)) {\\n        isConfirmed = confirm(\\n          $tw.language.getString('ConfirmCancelTiddler', {\\n            variables: { title: draftTitle },\\n          })\\n        )\\n      }\\n      // Remove the draft tiddler\\n      if (isConfirmed) {\\n        this.wiki.deleteTiddler(draftTitle)\\n        if (!event.paramObject || event.paramObject.suppressNavigation !== 'yes') {\\n          if (originalTiddler) {\\n            this.replaceFirstTitleInStory(storyList, draftTitle, originalTitle)\\n            this.addToHistory(originalTitle, event.navigateFromClientRect)\\n          } else {\\n            this.removeTitleFromStory(storyList, draftTitle)\\n          }\\n          this.saveStoryList(storyList)\\n        }\\n      }\\n    }\\n    return false\\n  }\\n\\n  // Create a new draft tiddler\\n  // event.param can either be the title of a template tiddler, or a hashmap of fields.\\n  //\\n  // The title of the newly created tiddler follows these rules:\\n  // * If a hashmap was used and a title field was specified, use that title\\n  // * If a hashmap was used without a title field, use a default title, if necessary making it unique with a numeric suffix\\n  // * If a template tiddler was used, use the title of the template, if necessary making it unique with a numeric suffix\\n  //\\n  // If a draft of the target tiddler already exists then it is reused\\n  NavigatorWidget.prototype.handleNewTiddlerEvent = function (event) {\\n    event = $tw.hooks.invokeHook('th-new-tiddler', event)\\n    // Get the story details\\n    var storyList = this.getStoryList()\\n    var templateTiddler\\n    var additionalFields\\n    var title\\n    var draftTitle\\n    var existingTiddler\\n    // Get the template tiddler (if any)\\n    if (typeof event.param === 'string') {\\n      // Get the template tiddler\\n      templateTiddler = this.wiki.getTiddler(event.param)\\n      // Generate a new title\\n      title = this.wiki.generateNewTitle(event.param || $tw.language.getString('DefaultNewTiddlerTitle'))\\n    }\\n    // Get the specified additional fields\\n    if (typeof event.paramObject === 'object') {\\n      additionalFields = event.paramObject\\n    }\\n    if (typeof event.param === 'object') {\\n      // Backwards compatibility with 5.1.3\\n      additionalFields = event.param\\n    }\\n    if (additionalFields && additionalFields.title) {\\n      title = additionalFields.title\\n    }\\n    // Make a copy of the additional fields excluding any blank ones\\n    var filteredAdditionalFields = $tw.utils.extend({}, additionalFields)\\n    Object.keys(filteredAdditionalFields).forEach(function (fieldName) {\\n      if (filteredAdditionalFields[fieldName] === '') {\\n        delete filteredAdditionalFields[fieldName]\\n      }\\n    })\\n    // Generate a title if we don't have one\\n    title = title || this.wiki.generateNewTitle($tw.language.getString('DefaultNewTiddlerTitle'))\\n    // Find any existing draft for this tiddler\\n    draftTitle = this.wiki.findDraft(title)\\n    // Pull in any existing tiddler\\n    if (draftTitle) {\\n      existingTiddler = this.wiki.getTiddler(draftTitle)\\n    } else {\\n      draftTitle = this.generateDraftTitle(title)\\n      existingTiddler = this.wiki.getTiddler(title)\\n    }\\n    // Merge the tags\\n    var mergedTags = []\\n    if (existingTiddler && existingTiddler.fields.tags) {\\n      $tw.utils.pushTop(mergedTags, existingTiddler.fields.tags)\\n    }\\n    if (additionalFields && additionalFields.tags) {\\n      // Merge tags\\n      mergedTags = $tw.utils.pushTop(mergedTags, $tw.utils.parseStringArray(additionalFields.tags))\\n    }\\n    if (templateTiddler && templateTiddler.fields.tags) {\\n      // Merge tags\\n      mergedTags = $tw.utils.pushTop(mergedTags, templateTiddler.fields.tags)\\n    }\\n    // Save the draft tiddler\\n    var draftTiddler = new $tw.Tiddler(\\n      {\\n        text: '',\\n        'draft.title': title,\\n      },\\n      templateTiddler,\\n      additionalFields,\\n      this.wiki.getCreationFields(),\\n      existingTiddler,\\n      filteredAdditionalFields,\\n      {\\n        title: draftTitle,\\n        'draft.of': title,\\n        tags: mergedTags,\\n      },\\n      this.wiki.getModificationFields()\\n    )\\n    this.wiki.addTiddler(draftTiddler)\\n    // Update the story to insert the new draft at the top and remove any existing tiddler\\n    if (storyList && storyList.indexOf(draftTitle) === -1) {\\n      var slot = storyList.indexOf(event.navigateFromTitle)\\n      if (slot === -1) {\\n        slot = this.getAttribute('openLinkFromOutsideRiver', 'top') === 'bottom' ? storyList.length - 1 : slot\\n      }\\n      storyList.splice(slot + 1, 0, draftTitle)\\n    }\\n    if (storyList && storyList.indexOf(title) !== -1) {\\n      storyList.splice(storyList.indexOf(title), 1)\\n    }\\n    this.saveStoryList(storyList)\\n    // Add a new record to the top of the history stack\\n    this.addToHistory(draftTitle)\\n    return false\\n  }\\n\\n  // Export JSON tiddlers\\n  NavigatorWidget.prototype.handleIpfsExportTiddlersEvent = function (event) {\\n    // Get the tiddlers\\n    var tiddlers = []\\n    try {\\n      tiddlers = JSON.parse(event.param)\\n    } catch (e) {}\\n    // Get the current $:/Export tiddler\\n    var exportTitle = event.exportTitle ? event.exportTitle : IPFS_EXPORT_TITLE\\n    var exportTiddler = this.wiki.getTiddler(exportTitle)\\n    var exportData = this.wiki.getTiddlerData(exportTitle, {})\\n    var newFields = {\\n      title: exportTitle,\\n      type: 'application/json',\\n      'plugin-type': 'ipfs-export',\\n      status: 'pending',\\n      target: event.target,\\n    }\\n    var outgoingTiddlers = []\\n    // Process each tiddler\\n    exportData.tiddlers = exportData.tiddlers || {}\\n    $tw.utils.each(tiddlers, function (tiddlerFields) {\\n      tiddlerFields.title = $tw.utils.trim(tiddlerFields.title)\\n      var title = tiddlerFields.title\\n      if (title) {\\n        outgoingTiddlers.push(title)\\n        exportData.tiddlers[title] = tiddlerFields\\n      }\\n    })\\n    // Deselect any suppressed tiddlers\\n    $tw.utils.each(exportData.tiddlers, function (tiddler, title) {\\n      if ($tw.utils.count(tiddler) === 0) {\\n        newFields['selection-' + title] = 'unchecked'\\n      }\\n    })\\n    // Save the $:/Export tiddler\\n    newFields.text = JSON.stringify(exportData, null, $tw.config.preferences.jsonSpaces)\\n    this.wiki.addTiddler(new $tw.Tiddler(exportTiddler, newFields))\\n    // Update the story and history details\\n    var storyList = this.getStoryList()\\n    var history = []\\n    // Add it to the story\\n    if (storyList && storyList.indexOf(exportTitle) === -1) {\\n      storyList.unshift(exportTitle)\\n    }\\n    // And to history\\n    history.push(exportTitle)\\n    // Save the updated story and history\\n    this.saveStoryList(storyList)\\n    this.addToHistory(history)\\n    return false\\n  }\\n\\n  NavigatorWidget.prototype.handlePerformIpfsExportEvent = async function (event) {\\n    var exportTiddler = this.wiki.getTiddler(event.param)\\n    var target = this.wiki.getTiddler(exportTiddler.fields.target)\\n    var exportData = this.wiki.getTiddlerDataCached(event.param, {\\n      tiddlers: {},\\n    })\\n    var tiddlers = []\\n    var exportReport = []\\n    exportReport.push($tw.language.getString('Export/Exported/Hint') + '\\\\n')\\n    $tw.utils.each(exportData.tiddlers, function (tiddlerFields) {\\n      var title = tiddlerFields.title\\n      if (title && exportTiddler && exportTiddler.fields['selection-' + title] !== 'unchecked') {\\n        tiddlers.push(tiddlerFields.title)\\n        exportReport.push('# [[' + tiddlerFields.title + ']]')\\n      }\\n    })\\n    var content = await $tw.utils.exportTiddlersAsJson(tiddlers, target.fields._export_uri)\\n    if (content) {\\n      content = await $tw.ipfs.processContent(target, content, 'utf8')\\n    }\\n    if (content) {\\n      if (await $tw.utils.exportToIpfs(target, content)) {\\n        // Replace the $:/Export tiddler with an export report\\n        this.wiki.addTiddler(\\n          new $tw.Tiddler({\\n            title: exportTiddler.fields.title,\\n            text: exportReport.join('\\\\n'),\\n            status: 'complete',\\n          })\\n        )\\n      }\\n      // Navigate to the $:/Export tiddler\\n      this.addToHistory([event.param])\\n    }\\n  }\\n\\n  // Import IPFS JSON tiddlers into a pending import tiddler\\n  NavigatorWidget.prototype.handleIpfsImportTiddlersEvent = function (event) {\\n    // Get the new or updated tiddlers\\n    var tiddlers = []\\n    try {\\n      tiddlers = Array.from(event.param.merged.values())\\n    } catch (e) {}\\n    // Get the deleted tiddlers\\n    var deleted = []\\n    try {\\n      deleted = Array.from(event.param.deleted.values())\\n    } catch (e) {}\\n    // Get the current $:/IpfsImport tiddler\\n    var importTitle = event.importTitle ? event.importTitle : IPFS_IMPORT_TITLE\\n    var importTiddler = this.wiki.getTiddler(importTitle)\\n    var importData = this.wiki.getTiddlerData(importTitle, {})\\n    var newFields = {\\n      title: importTitle,\\n      type: 'application/json',\\n      'plugin-type': 'ipfs-import',\\n      status: 'pending',\\n    }\\n    var incomingTiddlers = []\\n    // Process each new or updated tiddler\\n    importData.tiddlers = importData.tiddlers || {}\\n    $tw.utils.each(tiddlers, function (tiddlerFields) {\\n      tiddlerFields.title = $tw.utils.trim(tiddlerFields.title)\\n      var title = tiddlerFields.title\\n      if (title) {\\n        incomingTiddlers.push(title)\\n        importData.tiddlers[title] = tiddlerFields\\n        newFields['import-' + title] = 'yes'\\n      }\\n    })\\n    // Give the active upgrader modules a chance to process the incoming tiddlers\\n    var messages = this.wiki.invokeUpgraders(incomingTiddlers, importData.tiddlers)\\n    $tw.utils.each(messages, function (message, title) {\\n      newFields['message-' + title] = message\\n    })\\n    // Deselect any suppressed tiddlers\\n    $tw.utils.each(importData.tiddlers, function (tiddler, title) {\\n      if ($tw.utils.count(tiddler) === 0) {\\n        newFields['importSelection-' + title] = 'unchecked'\\n      }\\n    })\\n    // Process each deleted tiddler\\n    importData.tiddlers = importData.tiddlers || {}\\n    $tw.utils.each(deleted, function (tiddlerFields) {\\n      tiddlerFields.title = $tw.utils.trim(tiddlerFields.title)\\n      var title = tiddlerFields.title\\n      if (title) {\\n        incomingTiddlers.push(title)\\n        importData.tiddlers[title] = tiddlerFields\\n        newFields['delete-' + title] = 'yes'\\n      }\\n    })\\n    // Save the $:/IpfsImport tiddler\\n    newFields.text = JSON.stringify(importData, null, $tw.config.preferences.jsonSpaces)\\n    this.wiki.addTiddler(new $tw.Tiddler(importTiddler, newFields))\\n    // Update the story and history details\\n    var autoOpenOnImport = event.autoOpenOnImport ? event.autoOpenOnImport : this.getVariable('tv-auto-open-on-import')\\n    if (autoOpenOnImport !== 'no') {\\n      var storyList = this.getStoryList()\\n      var history = []\\n      // Add it to the story\\n      if (storyList && storyList.indexOf(importTitle) === -1) {\\n        storyList.unshift(importTitle)\\n      }\\n      // And to history\\n      history.push(importTitle)\\n      // Save the updated story and history\\n      this.saveStoryList(storyList)\\n      this.addToHistory(history)\\n    }\\n    return false\\n  }\\n\\n  // Import JSON tiddlers into a pending import tiddler\\n  NavigatorWidget.prototype.handleImportTiddlersEvent = function (event) {\\n    // Get the tiddlers\\n    var tiddlers = []\\n    try {\\n      tiddlers = JSON.parse(event.param)\\n    } catch (e) {}\\n    // Get the current $:/Import tiddler\\n    var importTitle = event.importTitle ? event.importTitle : IMPORT_TITLE\\n    var importTiddler = this.wiki.getTiddler(importTitle)\\n    var importData = this.wiki.getTiddlerData(importTitle, {})\\n    var newFields = {\\n      title: importTitle,\\n      type: 'application/json',\\n      'plugin-type': 'import',\\n      status: 'pending',\\n    }\\n    var incomingTiddlers = []\\n    // Process each tiddler\\n    importData.tiddlers = importData.tiddlers || {}\\n    $tw.utils.each(tiddlers, function (tiddlerFields) {\\n      tiddlerFields.title = $tw.utils.trim(tiddlerFields.title)\\n      var title = tiddlerFields.title\\n      if (title) {\\n        incomingTiddlers.push(title)\\n        importData.tiddlers[title] = tiddlerFields\\n      }\\n    })\\n    // Give the active upgrader modules a chance to process the incoming tiddlers\\n    var messages = this.wiki.invokeUpgraders(incomingTiddlers, importData.tiddlers)\\n    $tw.utils.each(messages, function (message, title) {\\n      newFields['message-' + title] = message\\n    })\\n    // Deselect any suppressed tiddlers\\n    $tw.utils.each(importData.tiddlers, function (tiddler, title) {\\n      if ($tw.utils.count(tiddler) === 0) {\\n        newFields['selection-' + title] = 'unchecked'\\n        newFields['suppressed-' + title] = 'yes'\\n      }\\n    })\\n    // Save the $:/Import tiddler\\n    newFields.text = JSON.stringify(importData, null, $tw.config.preferences.jsonSpaces)\\n    this.wiki.addTiddler(new $tw.Tiddler(importTiddler, newFields))\\n    // Update the story and history details\\n    var autoOpenOnImport = event.autoOpenOnImport ? event.autoOpenOnImport : this.getVariable('tv-auto-open-on-import')\\n    if (autoOpenOnImport !== 'no') {\\n      var storyList = this.getStoryList()\\n      var history = []\\n      // Add it to the story\\n      if (storyList && storyList.indexOf(importTitle) === -1) {\\n        storyList.unshift(importTitle)\\n      }\\n      // And to history\\n      history.push(importTitle)\\n      // Save the updated story and history\\n      this.saveStoryList(storyList)\\n      this.addToHistory(history)\\n    }\\n    return false\\n  }\\n\\n  //\\n  NavigatorWidget.prototype.handlePerformImportEvent = function (event) {\\n    var self = this\\n    var importTiddler = this.wiki.getTiddler(event.param)\\n    var importData = this.wiki.getTiddlerDataCached(event.param, {\\n      tiddlers: {},\\n    })\\n    var importReport = []\\n    // Add the tiddlers to the store\\n    importReport.push($tw.language.getString('Import/Imported/Hint') + '\\\\n')\\n    $tw.utils.each(importData.tiddlers, function (tiddlerFields) {\\n      var title = tiddlerFields.title\\n      if (title && importTiddler && importTiddler.fields['selection-' + title] !== 'unchecked') {\\n        if ($tw.utils.hop(importTiddler.fields, ['rename-' + title])) {\\n          var tiddler = new $tw.Tiddler(tiddlerFields, {\\n            title: importTiddler.fields['rename-' + title],\\n          })\\n        } else {\\n          var tiddler = new $tw.Tiddler(tiddlerFields)\\n        }\\n        tiddler = $tw.hooks.invokeHook('th-importing-tiddler', tiddler)\\n        self.wiki.addTiddler(tiddler)\\n        importReport.push('# [[' + tiddlerFields.title + ']]')\\n      }\\n    })\\n    // Replace the $:/Import tiddler with an import report\\n    this.wiki.addTiddler(\\n      new $tw.Tiddler({\\n        title: event.param,\\n        text: importReport.join('\\\\n'),\\n        status: 'complete',\\n      })\\n    )\\n    // Navigate to the $:/Import tiddler\\n    this.addToHistory([event.param])\\n    // Trigger an autosave\\n    $tw.rootWidget.dispatchEvent({ type: 'tm-auto-save-wiki' })\\n  }\\n\\n  //\\n  NavigatorWidget.prototype.handlePerformIpfsImportEvent = function (event) {\\n    var self = this\\n    var importTiddler = this.wiki.getTiddler(event.param)\\n    var importData = this.wiki.getTiddlerDataCached(event.param, {\\n      tiddlers: {},\\n    })\\n    var importReport = []\\n    // Add the tiddlers to the store\\n    importReport.push($tw.language.getString('Import/Imported/Hint') + '\\\\n')\\n    $tw.utils.each(importData.tiddlers, function (tiddlerFields) {\\n      var title = tiddlerFields.title\\n      if (title && importTiddler && importTiddler.fields['import-' + title] === 'yes' && importTiddler.fields['importSelection-' + title] !== 'unchecked') {\\n        if ($tw.utils.hop(importTiddler.fields, ['rename-' + title])) {\\n          var tiddler = new $tw.Tiddler(tiddlerFields, {\\n            title: importTiddler.fields['rename-' + title],\\n          })\\n        } else {\\n          var tiddler = new $tw.Tiddler(tiddlerFields)\\n        }\\n        tiddler = $tw.hooks.invokeHook('th-importing-tiddler', tiddler)\\n        self.wiki.addTiddler(tiddler)\\n        importReport.push('# [[' + tiddlerFields.title + ']]')\\n      }\\n    })\\n    importReport.push('\\\\n')\\n    // Delete tiddlers from the store\\n    importReport.push($tw.language.getString('Import/Deleted/Hint') + '\\\\n')\\n    $tw.utils.each(importData.tiddlers, function (tiddlerFields) {\\n      var title = tiddlerFields.title\\n      if (title && importTiddler && importTiddler.fields['delete-' + title] === 'yes' && importTiddler.fields['deleteSelection-' + title] !== 'unchecked') {\\n        var tiddler = self.wiki.getTiddler(title)\\n        if (tiddler) {\\n          self.handleDeleteTiddlerEvent({ param: tiddlerFields.title })\\n          tiddler = self.wiki.getTiddler(title)\\n          if (tiddler === undefined) {\\n            importReport.push('# [[' + tiddlerFields.title + ']]')\\n          }\\n        }\\n      }\\n    })\\n    // Replace the $:/IpfsImport tiddler with an import report\\n    this.wiki.addTiddler(\\n      new $tw.Tiddler({\\n        title: event.param,\\n        text: importReport.join('\\\\n'),\\n        status: 'complete',\\n      })\\n    )\\n    // Navigate to the $:/IpfsImport tiddler\\n    this.addToHistory([event.param])\\n    // Trigger an autosave\\n    $tw.rootWidget.dispatchEvent({ type: 'tm-auto-save-wiki' })\\n  }\\n\\n  NavigatorWidget.prototype.handleFoldTiddlerEvent = function (event) {\\n    var paramObject = event.paramObject || {}\\n    if (paramObject.foldedState) {\\n      var foldedState = this.wiki.getTiddlerText(paramObject.foldedState, 'show') === 'show' ? 'hide' : 'show'\\n      this.wiki.setText(paramObject.foldedState, 'text', null, foldedState)\\n    }\\n  }\\n\\n  NavigatorWidget.prototype.handleFoldOtherTiddlersEvent = function (event) {\\n    var self = this\\n    var paramObject = event.paramObject || {}\\n    var prefix = paramObject.foldedStatePrefix\\n    $tw.utils.each(this.getStoryList(), function (title) {\\n      self.wiki.setText(prefix + title, 'text', null, event.param === title ? 'show' : 'hide')\\n    })\\n  }\\n\\n  NavigatorWidget.prototype.handleFoldAllTiddlersEvent = function (event) {\\n    var self = this\\n    var paramObject = event.paramObject || {}\\n    var prefix = paramObject.foldedStatePrefix || '$:/state/folded/'\\n    $tw.utils.each(this.getStoryList(), function (title) {\\n      self.wiki.setText(prefix + title, 'text', null, 'hide')\\n    })\\n  }\\n\\n  NavigatorWidget.prototype.handleUnfoldAllTiddlersEvent = function (event) {\\n    var self = this\\n    var paramObject = event.paramObject || {}\\n    var prefix = paramObject.foldedStatePrefix\\n    $tw.utils.each(this.getStoryList(), function (title) {\\n      self.wiki.setText(prefix + title, 'text', null, 'show')\\n    })\\n  }\\n\\n  NavigatorWidget.prototype.handleRenameTiddlerEvent = function (event) {\\n    var options = {}\\n    var paramObject = event.paramObject || {}\\n    var from = paramObject.from || event.tiddlerTitle\\n    var to = paramObject.to\\n    /*eslint no-unneeded-ternary:\\\"off\\\"*/\\n    options.dontRenameInTags = paramObject.renameInTags === 'false' || paramObject.renameInTags === 'no' ? true : false\\n    options.dontRenameInLists = paramObject.renameInLists === 'false' || paramObject.renameInLists === 'no' ? true : false\\n    this.wiki.renameTiddler(from, to, options)\\n  }\\n\\n  exports.navigator = NavigatorWidget\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/ipfs/ipfs-wiki.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-wiki.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-wiki.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: wikimethod\\n\\nwikimethod\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*\\n   * Parse a block of text of a specified MIME type\\n   *  type: content type of text to be parsed\\n   *  text: text\\n   *  options: see below\\n   * Options include:\\n   *  parseAsInline: if true, the text of the tiddler will be parsed as an inline run\\n   *  _canonical_uri: optional string of the canonical URI of this content\\n   */\\n  exports.parseText = function (type, text, options) {\\n    text = text || ''\\n    options = options || {}\\n    // Select a parser\\n    var Parser = $tw.Wiki.parsers[type]\\n    if (!Parser && $tw.utils.getFileExtensionInfo(type)) {\\n      Parser = $tw.Wiki.parsers[$tw.utils.getFileExtensionInfo(type).type]\\n    }\\n    if (!Parser) {\\n      Parser = $tw.Wiki.parsers[options.defaultType || 'text/vnd.tiddlywiki']\\n    }\\n    if (!Parser) {\\n      return null\\n    }\\n    // Return the parser instance\\n    return new Parser(type, text, {\\n      parseAsInline: options.parseAsInline,\\n      wiki: this,\\n      tiddler: options.tiddler,\\n    })\\n  }\\n\\n  /*\\n   * Parse a tiddler according to its MIME type\\n   */\\n  exports.parseTiddler = function (title, options) {\\n    options = $tw.utils.extend({}, options)\\n    var cacheType = options.parseAsInline ? 'inlineParseTree' : 'blockParseTree'\\n    var tiddler = this.getTiddler(title)\\n    var self = this\\n    return tiddler\\n      ? this.getCacheForTiddler(title, cacheType, function () {\\n          options.tiddler = tiddler\\n          return self.parseText(tiddler.fields.type, tiddler.fields.text, options)\\n        })\\n      : null\\n  }\\n\\n  /**\\n   * Parse text from a tiddler and render it into another format\\n   * outputType: content type for the output\\n   * title: title of the tiddler to be rendered\\n   * options: see below\\n   * Options include:\\n   * variables: hashmap of variables to set\\n   * parentWidget: optional parent widget for the root node\\n   */\\n  exports.renderTiddlerAndSign = async function (outputType, title, options) {\\n    options = options || {}\\n    var parser = this.parseTiddler(title, options)\\n    var widgetNode = this.makeWidget(parser, options)\\n    var container = $tw.fakeDocument.createElement('div')\\n    widgetNode.render(container, null)\\n    var sign = $tw.wiki.locateTWElement(container, 'sign')\\n    if (sign) {\\n      var content = JSON.parse($tw.utils.htmlDecode(sign.textContent))\\n      content.signature = await $tw.ipfs.personalSign(content.keccak256)\\n      content.signature = $tw.crypto.encrypt(content.signature)\\n      content = JSON.stringify(content)\\n      sign.textContent = $tw.utils.htmlEncode(content)\\n    }\\n    return outputType === 'text/html' ? container.innerHTML : outputType === 'text/plain-formatted' ? container.formattedTextContent : container.textContent\\n  }\\n\\n  exports.locateTWElement = function (element, type) {\\n    if (element.children) {\\n      for (var i = 0; i < element.children.length; i++) {\\n        const current = element.children[i]\\n        if (current[type]) {\\n          return current\\n        }\\n        if (current.children) {\\n          const found = $tw.wiki.locateTWElement(current, type)\\n          if (found) {\\n            return found\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Read an array of browser File objects, invoking callback(tiddlerFieldsArray) once they're all read\\n   */\\n  exports.readFiles = async function (files, options) {\\n    var callback\\n    if (typeof options === 'function') {\\n      callback = options\\n      options = {}\\n    } else {\\n      callback = options.callback\\n    }\\n    var result = []\\n    var outstanding = files.length\\n    var readFileCallback = function (content) {\\n      if ($tw.utils.isArray(content)) {\\n        result.push.apply(result, content)\\n      } else {\\n        result = content\\n      }\\n      if (--outstanding === 0) {\\n        callback(result)\\n      }\\n    }\\n    for (var f = 0; f < files.length; f++) {\\n      await this.readFile(files[f], $tw.utils.extend({}, options, { callback: readFileCallback }))\\n    }\\n    return files.length\\n  }\\n\\n  /**\\n   * Read a browser File object, invoking callback(tiddlerFieldsArray) with an array of tiddler fields objects\\n   */\\n  exports.readFile = async function (file, options) {\\n    var callback\\n    if (typeof options === 'function') {\\n      callback = options\\n      options = {}\\n    } else {\\n      callback = options.callback\\n    }\\n    // Get the type, falling back to the filename extension\\n    var type = file.type\\n    if (type === '' || !type) {\\n      var dotPos = file.name.lastIndexOf('.')\\n      if (dotPos !== -1) {\\n        var fileExtensionInfo = $tw.utils.getFileExtensionInfo(file.name.substr(dotPos))\\n        if (fileExtensionInfo) {\\n          type = fileExtensionInfo.type\\n        }\\n      }\\n    }\\n    // Figure out if we're reading a binary file\\n    var contentTypeInfo = $tw.config.contentTypeInfo[type]\\n    var isBinary = contentTypeInfo ? contentTypeInfo.encoding === 'base64' : false\\n    // Log some debugging information\\n    if ($tw.log.IMPORT) {\\n      console.log(\\\"Importing file '\\\" + file.name + \\\"', type: '\\\" + type + \\\"', isBinary: \\\" + isBinary)\\n    }\\n    // Give the hook a chance to process the drag\\n    if (\\n      (await $tw.hooks.invokeHook('th-importing-file', {\\n        file: file,\\n        type: type,\\n        isBinary: isBinary,\\n        callback: callback,\\n      })) !== true\\n    ) {\\n      this.readFileContent(file, type, isBinary, options.deserializer, callback)\\n    }\\n  }\\n\\n  /**\\n   * Lower level utility to read the content of a browser File object,\\n   * invoking callback(tiddlerFieldsArray) with an array of tiddler fields objects\\n   */\\n  exports.readFileContent = function (file, type, isBinary, deserializer, callback) {\\n    var self = this\\n    // Create the FileReader\\n    var reader = new FileReader()\\n    // Onload\\n    reader.onload = function (event) {\\n      var text = event.target.result\\n      var tiddlerFields = { title: file.name || 'Untitled', type: type }\\n      if (isBinary) {\\n        var commaPos = text.indexOf(',')\\n        if (commaPos !== -1) {\\n          text = text.substr(commaPos + 1)\\n        }\\n      }\\n      // Check whether this is a compressed TiddlyWiki file\\n      var compressedStoreArea = $tw.utils.extractCompressedStoreArea(text)\\n      if (compressedStoreArea) {\\n        if (!$tw.utils.inflateCompressedStoreArea(compressedStoreArea, callback)) {\\n          // Otherwise, just try to deserialise any tiddlers in the file\\n          callback(\\n            self.deserializeTiddlers(type, compressedStoreArea, tiddlerFields, {\\n              deserializer: deserializer,\\n            })\\n          )\\n        }\\n      } else {\\n        // Check whether this is an encrypted TiddlyWiki file\\n        var encryptedStoreArea = $tw.utils.extractEncryptedStoreArea(text)\\n        if (encryptedStoreArea) {\\n          if (!$tw.utils.decrypt(encryptedStoreArea, callback)) {\\n            callback(\\n              self.deserializeTiddlers(type, encryptedStoreArea, tiddlerFields, {\\n                deserializer: deserializer,\\n              })\\n            )\\n          }\\n        } else {\\n          // Otherwise, just try to deserialise any tiddlers in the file\\n          callback(\\n            self.deserializeTiddlers(type, text, tiddlerFields, {\\n              deserializer: deserializer,\\n            })\\n          )\\n        }\\n      }\\n    }\\n    // Kick off the read\\n    if (isBinary) {\\n      reader.readAsDataURL(file)\\n    } else {\\n      reader.readAsText(file)\\n    }\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"wikimethod\"\n        },\n        \"$:/plugins/ipfs/changelog\": {\n            \"title\": \"$:/plugins/ipfs/changelog\",\n            \"tags\": \"$:/ipfs/core\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"!! v0.4.0\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.3.0...v0.4.0]]\\n\\n!! v0.3.0\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.2.9...v0.3.0]]\\n\\n!! v0.2.9\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.2.8...v0.2.9]]\\n\\n!! v0.2.8\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.2.7...v0.2.8]]\\n\\n...\\n\\n!! 0.2.2\\n\\n* First public release\"\n        },\n        \"$:/plugins/ipfs/readme\": {\n            \"title\": \"$:/plugins/ipfs/readme\",\n            \"tags\": \"$:/ipfs/core\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"!! IPFS with ~TiddlyWiki\\n\\nFeatures:\\n\\n* Store `TiddlyWiki`'s and attachments on [ext[IPFS|https://ipfs.io/]]\\n* Access `TiddlyWiki`'s and attachments from [ext[IPFS|https://ipfs.io/]]\\n* Compress `TiddlyWiki`'s and attachments\\n* Encrypt, Decrypt and Sign `TiddlyWiki`'s and attachments\\n  * Standford\\n  * Ethereum\\n  * [ext[SHA-3|https://en.wikipedia.org/wiki/SHA-3]]\\n* Import and Export\\n* Publish and Manage IPNS Names and Keys\\n* Interact with [ext[Metamask|https://metamask.io]] Ethereum wallets\\n* Publish to [ext[ENS|https://ens.domains]]\\n* Share over [ext[IPFS|https://ipfs.io/]] `TiddlyWiki`'s [ext[Tiddlers|https://tiddlywiki.com/#Tiddlers]] and attachments\\n\\nSupported Browsers:\\n\\n* [ext[Firefox|https://www.mozilla.org]]\\n* [ext[Chrome|https://www.google.com/chrome/]]\\n* [ext[Chromium|https://www.chromium.org]]\\n\\nSupported Ethereum browser extension:\\n\\n* [ext[Metamask|https://metamask.io]]\\n\\nSupported Mobile ÄApp browser:\\n\\n* [ext[Metamask|https://metamask.io]]\\n\\nSupported ENS Ethereum Networks\\n\\n* `Mainnet`: Ethereum Main Network\\n* `Ropsten`: Ethereum Test Network (~PoW)\\n* `Rinkeby`: Ethereum Test Network (~PoA)\\n* `Goerli`: Ethereum Test Network (~PoA)\\n\\nResources:\\n\\n* https://github.com/xmaysonnave/tiddlywiki-ipfs/\\n* https://github.com/xmaysonnave/tiddlywiki-ipfs/blob/main/README.md\\n\\nRequirement:\\n\\n* [[IPFS with TiddlyWiki Boot|$:/boot/boot.js]] <$ipfslink field=\\\"_source_uri\\\" text=\\\"_owner\\\" tiddler=\\\"$:/boot/boot.js_build\\\">[img[Available from IPFS|$:/ipfs/icons/ipfs]]</$ipfslink>\\n* [[IPFS with TiddlyWiki Library|$:/library/ipfs-library-modules.js]] <$ipfslink field=\\\"_source_uri\\\" text=\\\"_owner\\\" tiddler=\\\"$:/library/ipfs-library-modules.js_build\\\">[img[Available from IPFS|$:/ipfs/icons/ipfs]]</$ipfslink>\\n* [[IPFS with TiddlyWiki Plugin|$:/plugins/ipfs]]\"\n        },\n        \"$:/ipfs/saver/api/http/10.45.0.1/5001\": {\n            \"title\": \"$:/ipfs/saver/api/http/10.45.0.1/5001\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"http://10.45.0.1:5001\"\n        },\n        \"$:/ipfs/saver/api/http/127.0.0.1/5001\": {\n            \"title\": \"$:/ipfs/saver/api/http/127.0.0.1/5001\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"http://127.0.0.1:5001\"\n        },\n        \"$:/ipfs/saver/api/http/localhost/5001\": {\n            \"title\": \"$:/ipfs/saver/api/http/localhost/5001\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"http://localhost:5001\"\n        },\n        \"$:/ipfs/saver/api/https/ipfs.infura.io/5001\": {\n            \"title\": \"$:/ipfs/saver/api/https/ipfs.infura.io/5001\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"https://ipfs.infura.io:5001\"\n        },\n        \"$:/ipfs/saver/gateway/https/cf-ipfs.com\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/cf-ipfs.com\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://cf-ipfs.com\"\n        },\n        \"$:/ipfs/saver/gateway/https/cloudflare-ipfs.com\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/cloudflare-ipfs.com\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://cloudflare-ipfs.com\"\n        },\n        \"$:/ipfs/saver/gateway/https/dweb.link\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/dweb.link\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://dweb.link\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.eternum.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.eternum.io\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.eternum.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.bluelightav.org\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.bluelightav.org\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.bluelightav.org\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.ipfs.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.ipfs.io\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.ipfs.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.greyh.at\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.greyh.at\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.greyh.at\"\n        },\n        \"$:/ipfs/saver/gateway/https/hardbin.com\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/hardbin.com\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://hardbin.com\"\n        },\n        \"$:/ipfs/saver/gateway/http/10.45.0.1/8080\": {\n            \"title\": \"$:/ipfs/saver/gateway/http/10.45.0.1/8080\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"http://10.45.0.1:8080\"\n        },\n        \"$:/ipfs/saver/gateway/http/127.0.0.1\": {\n            \"title\": \"$:/ipfs/saver/gateway/http/127.0.0.1\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"http://127.0.0.1:8080\"\n        },\n        \"$:/ipfs/saver/gateway/http/localhost\": {\n            \"title\": \"$:/ipfs/saver/gateway/http/localhost\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"http://localhost:8080\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.infura.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.infura.io\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.infura.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.io\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.jes.xxx\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.jes.xxx\",\n            \"tags\": \"$:/ipfs/core $:/ipfs $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.jes.xxx\"\n        },\n        \"$:/ipfs/saver/gateway/https/ninetailed.ninja\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ninetailed.ninja\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ninetailed.ninja\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.pinata.cloud\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.pinata.cloud\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.pinata.cloud\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.sloppyta.co\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.sloppyta.co\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.sloppyta.co\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.temporal.cloud\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.temporal.cloud\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.temporal.cloud\"\n        },\n        \"$:/core/templates/static.area\": {\n            \"title\": \"$:/core/templates/static.area\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<$reveal type=\\\"nomatch\\\" state=\\\"$:/isCompressed\\\" text=\\\"yes\\\">\\n<$reveal type=\\\"nomatch\\\" state=\\\"$:/isEncrypted\\\" text=\\\"yes\\\">\\n{{{ [all[shadows+tiddlers]tag[$:/tags/RawStaticContent]!has[draft.of]] ||$:/core/templates/raw-static-tiddler}}}\\n{{$:/core/templates/static.content||$:/core/templates/html-tiddler}}\\n</$reveal>\\n<!-- ensure splash screen isn't shown when JS is disabled -->\\n`<style>\\n.tc-remove-when-wiki-loaded {display: none;}\\n</style>`\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=\\\"$:/isCompressed\\\" text=\\\"yes\\\">\\n<!-- ensure splash screen isn't shown when JS is disabled -->\\n`<style>\\n.tc-remove-when-wiki-loaded {display: none;}\\n</style>`\\n</$reveal>\"\n        },\n        \"$:/core/templates/store.area.template.html\": {\n            \"title\": \"$:/core/templates/store.area.template.html\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<$reveal type=\\\"nomatch\\\" state=\\\"$:/isCompressed\\\" text=\\\"yes\\\">\\n<$reveal type=\\\"nomatch\\\" state=\\\"$:/isEncrypted\\\" text=\\\"yes\\\">\\n`<div id=\\\"storeArea\\\" type=\\\"text/plain\\\" style=\\\"display:none;\\\">`\\n<$list filter=<<saveTiddlerFilter>> template=\\\"$:/core/templates/html-div-tiddler\\\"/>\\n<$list filter={{{ [<skinnySaveTiddlerFilter>] }}} template=\\\"$:/core/templates/html-div-skinny-tiddler\\\"/>\\n`</div>`\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=\\\"$:/isEncrypted\\\" text=\\\"yes\\\">\\n`<!--~~ Encrypted tiddlers ~~-->`\\n`<pre id=\\\"encryptedStoreArea\\\" type=\\\"text/plain\\\" style=\\\"display:none;\\\">`\\n<$encrypt filter=<<saveTiddlerFilter>>/>\\n`</pre>`\\n</$reveal>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=\\\"$:/isCompressed\\\" text=\\\"yes\\\">\\n`<!--~~ Compressed tiddlers ~~-->`\\n`<pre id=\\\"compressedStoreArea\\\" type=\\\"text/plain\\\" style=\\\"display:none;\\\">`\\n<$compress filter=<<saveTiddlerFilter>>/>\\n`</pre>`\\n</$reveal>\"\n        },\n        \"$:/core/ui/ControlPanel/Saving/General\": {\n            \"title\": \"$:/core/ui/ControlPanel/Saving/General\",\n            \"tags\": \"$:/ipfs/core $:/tags/ControlPanel/Saving\",\n            \"caption\": \"{{$:/language/ControlPanel/Saving/General/Caption}}\",\n            \"list-before\": \"\",\n            \"text\": \"\\\\define lingo-base() $:/language/ControlPanel/Settings/\\n\\n\\\\define preferred-saver()\\n<$text text=<<infosaver \\\"$(currentTiddler)$\\\">>/>\\n\\\\end\\n\\n{{$:/language/ControlPanel/Saving/General/Hint}}\\n\\n!! <$link to=\\\"$:/config/AutoSave\\\"><<lingo AutoSave/Caption>></$link>\\n\\n<<lingo AutoSave/Hint>>\\n\\n<$radio tiddler=\\\"$:/config/AutoSave\\\" value=\\\"yes\\\"> <<lingo AutoSave/Enabled/Description>> </$radio>\\n\\n<$radio tiddler=\\\"$:/config/AutoSave\\\" value=\\\"no\\\"> <<lingo AutoSave/Disabled/Description>> </$radio>\\n\\n!! <$link to=\\\"$:/isCompressed\\\"><<lingo Compression/Caption>></$link>\\n\\n<$checkbox tiddler=\\\"$:/isCompressed\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"> <<lingo Compression/Description>> </$checkbox>\\n\\n!! <$link to=\\\"$:/config/encryption\\\"><<lingo Encryption/Caption>></$link>\\n\\n<$radio tiddler=\\\"$:/config/encryption\\\" value=\\\"standford\\\"> <<lingo Encryption/Standford/Description>> </$radio>\\n\\n<$radio tiddler=\\\"$:/config/encryption\\\" value=\\\"ethereum\\\"> <<lingo Encryption/Ethereum/Description>> </$radio>\\n\\n<$checkbox tiddler=\\\"$:/isSigned\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"> <<lingo Encryption/Signature/Description>> </$checkbox>\\n\\n!! <$link to=\\\"$:/config/PreferredSaver\\\"><<lingo PreferredSaver/Caption>></$link>\\n\\n<$select tiddler=\\\"$:/config/PreferredSaver\\\">\\n<$list filter=\\\"[savers[]sort[]]\\\">\\n<option value=<<currentTiddler>>><<preferred-saver>></option>\\n</$list>\\n</$select>\"\n        },\n        \"$:/core/ui/ControlPanel/Saving/Ipfs\": {\n            \"title\": \"$:/core/ui/ControlPanel/Saving/Ipfs\",\n            \"tags\": \"$:/ipfs/core $:/tags/ControlPanel/Saving\",\n            \"caption\": \"{{$:/language/ControlPanel/Saving/IpfsService/Caption}}\",\n            \"text\": \"\\\\define lingo-base() $:/language/ControlPanel/Saving/IpfsService/\\n\\\\define service-name() Ipfs\\n\\n<<lingo Description>>\\n\\n''<<lingo Global>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"90%\\\">''<$link to=\\\"$:/ipfs/saver/verbose\\\"><<lingo Verbose/Description>></$link>''</td>\\n<td width=\\\"10%\\\"><$checkbox tiddler=\\\"$:/ipfs/saver/verbose\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"yes\\\"/></td>\\n</tr>\\n<tr>\\n<td width=\\\"90%\\\">''<$link to=\\\"$:/ipfs/saver/pin\\\"><<lingo Pin/Description>></$link>''</td>\\n<td width=\\\"10%\\\"><$checkbox tiddler=\\\"$:/ipfs/saver/pin\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"yes\\\"/></td>\\n</tr>\\n<tr>\\n<td width=\\\"90%\\\">''<$link to=\\\"$:/ipfs/saver/unpin\\\"><<lingo Unpin/Description>></$link>''</td>\\n<td width=\\\"10%\\\"><$checkbox tiddler=\\\"$:/ipfs/saver/unpin\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"/></td>\\n</tr>\\n</tbody>\\n</table>\\n\\n''<$link to=\\\"$:/ipfs/saver/export\\\"><<lingo Export>></$link>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/export\\\" value=\\\"json\\\"><<lingo Export/Json/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/export\\\" value=\\\"static\\\"><<lingo Export/Static/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/export\\\" value=\\\"tid\\\"><<lingo Export/Tid/Description>></$radio>\\n\\n''<$link to=\\\"$:/ipfs/saver/protocol\\\"><<lingo Protocol>></$link>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/protocol\\\" value=\\\"ens\\\"><<lingo Protocol/Ens/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/protocol\\\" value=\\\"ipfs\\\"><<lingo Protocol/Ipfs/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/protocol\\\" value=\\\"ipns\\\"><<lingo Protocol/Ipns/Description>></$radio>\\n\\n''<$link to=\\\"$:/ipfs/saver/policy\\\"><<lingo Policy>></$link>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/policy\\\" value=\\\"origin\\\"><<lingo Policy/Origin/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/policy\\\" value=\\\"gateway\\\"><<lingo Policy/Gateway/Description>></$radio>\\n\\n''<<lingo Url>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"20%\\\">''<$link to=\\\"$:/ipfs/saver/api\\\"><<lingo ApiUrl>></$link>''</td>\\n<td width=\\\"80%\\\">\\n<$select tiddler=\\\"$:/ipfs/saver/api\\\" class=\\\"tc-edit-texteditor\\\">\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/ipfs/saver/api]!has[draft.of]sort[]]\\\">\\n<option value=<<currentTiddler>>><$transclude><$text text=<<currentTiddler>>/></$transclude></option>\\n</$list>\\n</$select>\\n</td>\\n</tr>\\n<tr>\\n<td width=\\\"20%\\\">''<$link to=\\\"$:/ipfs/saver/gateway\\\"><<lingo GatewayUrl>></$link>''</td>\\n<td width=\\\"80%\\\">\\n<$select tiddler=\\\"$:/ipfs/saver/gateway\\\" class=\\\"tc-edit-texteditor\\\">\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/ipfs/saver/gateway]!has[draft.of]sort[]]\\\">\\n<option value=<<currentTiddler>>><$transclude><$text text=<<currentTiddler>>/></$transclude></option>\\n</$list>\\n</$select>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n\\n''<<lingo Ens>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"20%\\\">''<$link to=\\\"$:/ipfs/saver/ens/domain\\\"><<lingo EnsDomain>></$link>''</td>\\n<td width=\\\"80%\\\"><$edit-text tiddler=\\\"$:/ipfs/saver/ens/domain\\\" class=\\\"tc-edit-texteditor\\\" default=\\\"\\\" tag=\\\"input\\\"/></td>\\n</tr>\\n</tbody>\\n</table>\\n\\n<table style=\\\"width:20%;margin-left:40%;margin-right:40%;text-align:center;\\\">\\n<tbody>\\n<tr>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ens-manager-open\\\" tooltip={{$:/language/Buttons/Ens/Manager/Open/Hint}} aria-label={{$:/language/Buttons/Ens/Manager/Open/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/ipfs/image/ens}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ens/Manager/Open/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ens-resolve-and-open\\\" tooltip={{$:/language/Buttons/Ens/Resolve/And/Open/Hint}} aria-label={{$:/language/Buttons/Ens/Resolve/And/Open/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/globe}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ens/Resolve/And/Open/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n\\n''<<lingo Ipns>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"20%\\\">''<$link to=\\\"$:/ipfs/saver/ipns/name\\\"><<lingo IpnsName>></$link>''</td>\\n<td width=\\\"80%\\\"><$edit-text tiddler=\\\"$:/ipfs/saver/ipns/name\\\" class=\\\"tc-edit-texteditor\\\" default=\\\"\\\" tag=\\\"input\\\"/></td>\\n</tr>\\n<tr>\\n<td width=\\\"20%\\\">''<$link to=\\\"$:/ipfs/saver/ipns/key\\\"><<lingo IpnsKey>></$link>''</td>\\n<td width=\\\"80%\\\"><$text text={{$:/ipfs/saver/ipns/key}} class=\\\"tc-edit-texteditor\\\"/></td>\\n</tr>\\n</tbody>\\n</table>\\n\\n<table style=\\\"width:50%;margin-left:25%;margin-right:25%;text-align:center;\\\">\\n<tbody>\\n<tr>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-rename\\\" tooltip={{$:/language/Buttons/Ipns/Rename/Hint}} aria-label={{$:/language/Buttons/Ipns/Rename/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/mono-line}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Rename/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-generate\\\" tooltip={{$:/language/Buttons/Ipns/Generate/Hint}} aria-label={{$:/language/Buttons/Ipns/Generate/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/new-here-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Generate/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-remove\\\" tooltip={{$:/language/Buttons/Ipns/Remove/Hint}} aria-label={{$:/language/Buttons/Ipns/Remove/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/delete-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Remove/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-fetch\\\" tooltip={{$:/language/Buttons/Ipns/Fetch/Hint}} aria-label={{$:/language/Buttons/Ipns/Fetch/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/refresh-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Fetch/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-resolve-and-open\\\" tooltip={{$:/language/Buttons/Ipns/Resolve/And/Open/Hint}} aria-label={{$:/language/Buttons/Ipns/Resolve/And/Open/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/globe}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Resolve/And/Open/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-publish-to-ens\\\" tooltip={{$:/language/Buttons/Ipns/Publish/To/Ens/Hint}} aria-label={{$:/language/Buttons/Ipns/Publish/To/Ens/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/ipfs/image/ens}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Publish/To/Ens/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n</tr>\\n</tbody>\\n</table>\"\n        },\n        \"$:/core/ui/ControlPanel/Toolbars/ItemTemplate\": {\n            \"title\": \"$:/core/ui/ControlPanel/Toolbars/ItemTemplate\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\\\\define config-title()\\n$(config-base)$$(currentTiddler)$\\n\\\\end\\n\\n<$draggable tiddler=<<currentTiddler>>>\\n<$checkbox tiddler=<<config-title>> field=\\\"text\\\" checked=\\\"show\\\" unchecked=\\\"hide\\\" default=\\\"show\\\"/> <span class=\\\"tc-icon-wrapper tc-icon-ipfs-wrapper\\\"> <$transclude field=\\\"caption\\\"/> <i class=\\\"tc-muted\\\">-- <$transclude field=\\\"description\\\"/></i></span>\\n</$draggable>\\n\"\n        },\n        \"$:/core/ui/EditTemplate/body\": {\n            \"title\": \"$:/core/ui/EditTemplate/body\",\n            \"tags\": \"$:/ipfs/core $:/tags/EditTemplate\",\n            \"text\": \"\\\\define lingo-base() $:/language/EditTemplate/Body/\\n\\\\define config-visibility-title()\\n$:/config/EditorToolbarButtons/Visibility/$(currentTiddler)$\\n\\\\end\\n<$list filter=\\\"[all[current]has[_canonical_uri]]\\\">\\n\\n<div class=\\\"tc-message-box\\\">\\n\\n<<lingo External/Hint>>\\n\\n<$ipfslink field=\\\"_canonical_uri\\\" tiddler=<<currentTiddler>>/>\\n\\n</div>\\n\\n</$list>\\n\\n<$list filter=\\\"[all[current]!has[_canonical_uri]]\\\">\\n\\n<$reveal state=\\\"$:/state/showeditpreview\\\" type=\\\"match\\\" text=\\\"yes\\\">\\n\\n<div class=\\\"tc-tiddler-preview\\\">\\n\\n<$transclude tiddler=\\\"$:/core/ui/EditTemplate/body/editor\\\" mode=\\\"inline\\\"/>\\n\\n<div class=\\\"tc-tiddler-preview-preview\\\">\\n\\n<$transclude tiddler={{$:/state/editpreviewtype}} mode=\\\"inline\\\">\\n\\n<$transclude tiddler=\\\"$:/core/ui/EditTemplate/body/preview/output\\\" mode=\\\"inline\\\"/>\\n\\n</$transclude>\\n\\n</div>\\n\\n</div>\\n\\n</$reveal>\\n\\n<$reveal state=\\\"$:/state/showeditpreview\\\" type=\\\"nomatch\\\" text=\\\"yes\\\">\\n\\n<$transclude tiddler=\\\"$:/core/ui/EditTemplate/body/editor\\\" mode=\\\"inline\\\"/>\\n\\n</$reveal>\\n\\n</$list>\"\n        },\n        \"$:/core/ui/EditTemplate/fields\": {\n            \"title\": \"$:/core/ui/EditTemplate/fields\",\n            \"tags\": \"$:/ipfs/core $:/tags/EditTemplate\",\n            \"text\": \"\\\\define lingo-base() $:/language/EditTemplate/\\n\\\\define config-title()\\n$:/config/EditTemplateFields/Visibility/$(currentField)$\\n\\\\end\\n\\n\\\\define config-filter()\\n[[hide]] -[title{$(config-title)$}]\\n\\\\end\\n\\n\\\\define current-tiddler-new-field-selector()\\n[data-tiddler-title=\\\"$(currentTiddlerCSSescaped)$\\\"] .tc-edit-field-add-name-wrapper input\\n\\\\end\\n\\n\\\\define new-field-actions()\\n<$action-sendmessage $message=\\\"tm-add-field\\\" $name={{{ [<newFieldNameTiddler>get[text]] }}} $value={{{ [<newFieldValueTiddler>get[text]] }}}/>\\n<$action-deletetiddler $filter=\\\"[<newFieldNameTiddler>] [<newFieldValueTiddler>] [<storeTitle>] [<searchListState>]\\\"/>\\n<$action-sendmessage $message=\\\"tm-focus-selector\\\" $param=<<current-tiddler-new-field-selector>>/>\\n\\\\end\\n\\n\\\\define delete-state-tiddlers() <$action-deletetiddler $filter=\\\"[<newFieldNameTiddler>] [<storeTitle>] [<searchListState>]\\\"/>\\n\\n\\\\define cancel-search-actions-inner()\\n<$list filter=\\\"[<storeTitle>has[text]] [<newFieldNameTiddler>has[text]]\\\" variable=\\\"ignore\\\" emptyMessage=\\\"\\\"\\\"<<cancel-delete-tiddler-actions \\\"cancel\\\">>\\\"\\\"\\\">\\n<<delete-state-tiddlers>>\\n</$list>\\n\\\\end\\n\\n\\\\define cancel-search-actions()\\n<$set name=\\\"userInput\\\" value={{{ [<storeTitle>get[text]] }}}>\\n<$list filter=\\\"[<newFieldNameTiddler>get[text]!match<userInput>]\\\" emptyMessage=\\\"\\\"\\\"<<cancel-search-actions-inner>>\\\"\\\"\\\">\\n<$action-setfield $tiddler=<<newFieldNameTiddler>> text=<<userInput>>/><$action-setfield $tiddler=<<refreshTitle>> text=\\\"yes\\\"/>\\n</$list>\\n</$set>\\n\\\\end\\n\\n\\\\define new-field()\\n<$vars name={{{ [<newFieldNameTiddler>get[text]] }}}>\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" default=<<name>>>\\n<$button tooltip=<<lingo Fields/Add/Button/Hint>>>\\n<$action-sendmessage $message=\\\"tm-add-field\\\"\\n$name=<<name>>\\n$value={{{ [<newFieldValueTiddler>get[text]] }}}/>\\n<$action-deletetiddler $filter=\\\"[<newFieldNameTiddler>] [<newFieldValueTiddler>] [<storeTitle>] [<searchListState>]\\\"/>\\n<<lingo Fields/Add/Button>>\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" default=<<name>>>\\n<$button>\\n<<lingo Fields/Add/Button>>\\n</$button>\\n</$reveal>\\n</$vars>\\n\\\\end\\n\\\\whitespace trim\\n\\n<div class=\\\"tc-edit-fields\\\">\\n<table class={{{ [all[current]fields[]] :filter[lookup[$:/config/EditTemplateFields/Visibility/]!match[hide]] +[count[]!match[0]] +[then[tc-edit-fields]] ~[[tc-edit-fields tc-edit-fields-small]] }}}>\\n<tbody>\\n<$list filter=\\\"[all[current]fields[]] +[sort[title]]\\\" variable=\\\"currentField\\\" storyview=\\\"pop\\\">\\n<$list filter=<<config-filter>> variable=\\\"temp\\\">\\n<tr class=\\\"tc-edit-field\\\">\\n<td class=\\\"tc-edit-field-name\\\">\\n<$ipfslink value=<<currentField>> field=<<currentField>> tiddler=<<currentTiddler>>/>:</td>\\n<td class=\\\"tc-edit-field-value\\\">\\n<$keyboard key=\\\"((delete-field))\\\" actions=\\\"\\\"\\\"<$action-deletefield $field=<<currentField>>/><$set name=\\\"currentTiddlerCSSescaped\\\" value={{{ [<currentTiddler>escapecss[]] }}}><$action-sendmessage $message=\\\"tm-focus-selector\\\" $param=<<current-tiddler-new-field-selector>>/></$set>\\\"\\\"\\\">\\n<$edit-text tiddler=<<currentTiddler>> field=<<currentField>> placeholder={{$:/language/EditTemplate/Fields/Add/Value/Placeholder}} tabindex={{$:/config/EditTabIndex}} cancelPopups=\\\"yes\\\"/>\\n</$keyboard>\\n</td>\\n<td class=\\\"tc-edit-field-remove\\\">\\n<$button class=\\\"tc-btn-invisible\\\" tooltip={{$:/language/EditTemplate/Field/Remove/Hint}} aria-label={{$:/language/EditTemplate/Field/Remove/Caption}}>\\n<$action-deletefield $field=<<currentField>>/><$set name=\\\"currentTiddlerCSSescaped\\\" value={{{ [<currentTiddler>escapecss[]] }}}><$action-sendmessage $message=\\\"tm-focus-selector\\\" $param=<<current-tiddler-new-field-selector>>/></$set>\\n{{$:/core/images/delete-button}}\\n</$button>\\n</td>\\n</tr>\\n</$list>\\n</$list>\\n</tbody>\\n</table>\\n</div>\\n\\n<$fieldmangler>\\n<div class=\\\"tc-edit-field-add\\\">\\n<em class=\\\"tc-edit tc-big-gap-right\\\">\\n<<lingo Fields/Add/Prompt>>\\n</em>\\n<$vars refreshTitle=<<qualify \\\"$:/temp/fieldname/refresh\\\">> storeTitle=<<newFieldNameInputTiddler>> searchListState=<<newFieldNameSelectionTiddler>>>\\n<div class=\\\"tc-edit-field-add-name-wrapper\\\">\\n<$macrocall $name=\\\"keyboard-driven-input\\\" tiddler=<<newFieldNameTiddler>> storeTitle=<<storeTitle>> refreshTitle=<<refreshTitle>>\\n\\t\\tselectionStateTitle=<<searchListState>> tag=\\\"input\\\" default=\\\"\\\" placeholder={{$:/language/EditTemplate/Fields/Add/Name/Placeholder}}\\n\\t\\tfocusPopup=<<qualify \\\"$:/state/popup/field-dropdown\\\">> class=\\\"tc-edit-texteditor tc-popup-handle\\\" tabindex={{$:/config/EditTabIndex}}\\n\\t\\tfocus={{{ [{$:/config/AutoFocus}match[fields]then[true]] ~[[false]] }}} cancelPopups=\\\"yes\\\"\\n\\t\\tconfigTiddlerFilter=\\\"[[$:/config/EditMode/fieldname-filter]]\\\" inputCancelActions=<<cancel-search-actions>> />\\n<$button popup=<<qualify \\\"$:/state/popup/field-dropdown\\\">> class=\\\"tc-btn-invisible tc-btn-dropdown tc-small-gap\\\" tooltip={{$:/language/EditTemplate/Field/Dropdown/Hint}} aria-label={{$:/language/EditTemplate/Field/Dropdown/Caption}}>{{$:/core/images/down-arrow}}</$button>\\n<$reveal state=<<qualify \\\"$:/state/popup/field-dropdown\\\">> type=\\\"nomatch\\\" text=\\\"\\\" default=\\\"\\\">\\n<div class=\\\"tc-block-dropdown tc-edit-type-dropdown\\\">\\n<$set name=\\\"tv-show-missing-links\\\" value=\\\"yes\\\">\\n<$linkcatcher to=<<newFieldNameTiddler>>>\\n<div class=\\\"tc-dropdown-item\\\">\\n<<lingo Fields/Add/Dropdown/User>>\\n</div>\\n<$set name=\\\"newFieldName\\\" value={{{ [<storeTitle>get[text]] }}}>\\n<$list filter=\\\"[!is[shadow]!is[system]fields[]search:title<newFieldName>sort[]] -created -creator -draft.of -draft.title -modified -modifier -tags -text -title -type\\\"  variable=\\\"currentField\\\">\\n<$list filter=\\\"[<currentField>addsuffix[-primaryList]] -[<searchListState>get[text]]\\\" emptyMessage=\\\"\\\"\\\"<$link to=<<currentField>> class=\\\"tc-list-item-selected\\\"><$text text=<<currentField>>/></$link>\\\"\\\"\\\">\\n<$link to=<<currentField>>>\\n<$text text=<<currentField>>/>\\n</$link>\\n</$list>\\n</$list>\\n<div class=\\\"tc-dropdown-item\\\">\\n<<lingo Fields/Add/Dropdown/System>>\\n</div>\\n<$list filter=\\\"[fields[]search:title<newFieldName>sort[]] -[!is[shadow]!is[system]fields[]]\\\" variable=\\\"currentField\\\">\\n<$list filter=\\\"[<currentField>addsuffix[-secondaryList]] -[<searchListState>get[text]]\\\" emptyMessage=\\\"\\\"\\\"<$link to=<<currentField>> class=\\\"tc-list-item-selected\\\"><$text text=<<currentField>>/></$link>\\\"\\\"\\\">\\n<$link to=<<currentField>>>\\n<$text text=<<currentField>>/>\\n</$link>\\n</$list>\\n</$list>\\n</$set>\\n</$linkcatcher>\\n</$set>\\n</div>\\n</$reveal>\\n</div>\\n<span class=\\\"tc-edit-field-add-value tc-small-gap-right\\\">\\n<$set name=\\\"currentTiddlerCSSescaped\\\" value={{{ [<currentTiddler>escapecss[]] }}}>\\n<$keyboard key=\\\"((add-field))\\\" actions=<<new-field-actions>>>\\n<$edit-text tiddler=<<newFieldValueTiddler>> tag=\\\"input\\\" default=\\\"\\\" placeholder={{$:/language/EditTemplate/Fields/Add/Value/Placeholder}} class=\\\"tc-edit-texteditor\\\" tabindex={{$:/config/EditTabIndex}} cancelPopups=\\\"yes\\\"/>\\n</$keyboard>\\n</$set>\\n</span>\\n<span class=\\\"tc-edit-field-add-button\\\">\\n<$macrocall $name=\\\"new-field\\\"/>\\n</span>\\n</$vars>\\n</div>\\n</$fieldmangler>\"\n        },\n        \"$:/core/ui/EditTemplate\": {\n            \"title\": \"$:/core/ui/EditTemplate\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\\\\define delete-edittemplate-state-tiddlers() <$action-deletetiddler $filter=\\\"[<newFieldNameTiddler>] [<newFieldValueTiddler>] [<newFieldNameInputTiddler>] [<newFieldNameSelectionTiddler>] [<newTagNameTiddler>] [<newTagNameInputTiddler>] [<newTagNameSelectionTiddler>] [<typeInputTiddler>] [<typeSelectionTiddler>]\\\"/>\\n\\\\define save-tiddler-actions()\\n<$action-sendmessage $message=\\\"tm-add-tag\\\" $param={{{ [<newTagNameTiddler>get[text]] }}}/>\\n<$action-sendmessage $message=\\\"tm-add-field\\\" $name={{{ [<newFieldNameTiddler>get[text]] }}} $value={{{ [<newFieldValueTiddler>get[text]] }}}/>\\n<<delete-edittemplate-state-tiddlers>>\\n<$action-sendmessage $message=\\\"tm-save-tiddler\\\"/>\\n\\\\end\\n\\\\define cancel-delete-tiddler-actions(message)\\n<<delete-edittemplate-state-tiddlers>>\\n<$action-sendmessage $message=\\\"tm-$message$-tiddler\\\"/>\\n\\\\end\\n<div data-tiddler-title=<<currentTiddler>> data-tags={{!!tags}} class={{{ tc-tiddler-frame tc-tiddler-edit-frame [<currentTiddler>is[tiddler]then[tc-tiddler-exists]] [<currentTiddler>is[missing]!is[shadow]then[tc-tiddler-missing]] [<currentTiddler>is[shadow]then[tc-tiddler-exists tc-tiddler-shadow]] [<currentTiddler>is[system]then[tc-tiddler-system]] [{!!class}] [<currentTiddler>tags[]encodeuricomponent[]addprefix[tc-tagged-]] +[join[ ]] }}}>\\n<$fieldmangler>\\n<$vars storyTiddler=<<currentTiddler>> newTagNameTiddler=<<qualify \\\"$:/temp/NewTagName\\\">> newFieldNameTiddler=<<qualify \\\"$:/temp/NewFieldName\\\">> newFieldValueTiddler=<<qualify \\\"$:/temp/NewFieldValue\\\">> newFieldNameInputTiddler=<<qualify \\\"$:/temp/NewFieldName/input\\\">> newFieldNameSelectionTiddler=<<qualify \\\"$:/temp/NewFieldName/selected-item\\\">> newTagNameInputTiddler=<<qualify \\\"$:/temp/NewTagName/input\\\">> newTagNameSelectionTiddler=<<qualify \\\"$:/temp/NewTagName/selected-item\\\">> typeInputTiddler=<<qualify \\\"$:/temp/Type/input\\\">> typeSelectionTiddler=<<qualify \\\"$:/temp/Type/selected-item\\\">>>\\n<$keyboard key=\\\"((cancel-edit-tiddler))\\\" actions=<<cancel-delete-tiddler-actions \\\"cancel\\\">>>\\n<$keyboard key=\\\"((save-tiddler))\\\" actions=<<save-tiddler-actions>>>\\n<$list filter=\\\"[all[shadows+tiddlers]list[$:/tags/EditTemplate]!has[draft.of]]\\\" variable=\\\"listItem\\\">\\n<$set name=\\\"tv-config-toolbar-class\\\" filter=\\\"[<tv-config-toolbar-class>] [<listItem>encodeuricomponent[]addprefix[tc-btn-]]\\\">\\n<$transclude tiddler=<<listItem>>/>\\n</$set>\\n</$list>\\n</$keyboard>\\n</$keyboard>\\n</$vars>\\n</$fieldmangler>\\n</div>\"\n        },\n        \"$:/core/ui/IpfsExportListing\": {\n            \"title\": \"$:/core/ui/IpfsExportListing\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\\\\define lingo-base() $:/language/Export/\\n\\n\\\\define selectionField()\\nselection-$(payloadTiddler)$\\n\\\\end\\n\\n\\\\define previewPopupState()\\n$(currentTiddler)$!!popup-$(payloadTiddler)$\\n\\\\end\\n\\n\\\\define select-all-actions()\\n<$list filter=\\\"[all[current]plugintiddlers[]sort[title]]\\\" variable=\\\"payloadTiddler\\\">\\n<$action-setfield $field={{{ [<payloadTiddler>addprefix[selection-]] }}} $value={{$:/state/export/select-all}}/>\\n</$list>\\n\\\\end\\n\\n<table>\\n<tbody>\\n<tr>\\n<th>\\n<$checkbox title={{$:/language/Export/Listing/Export/Caption}} tiddler=\\\"$:/state/export/select-all\\\" field=\\\"text\\\" checked=\\\"checked\\\" unchecked=\\\"unchecked\\\" default=\\\"checked\\\" actions=<<select-all-actions>>/>\\n</th>\\n<th>\\n<<lingo Listing/Title/Caption>>\\n</th>\\n</tr>\\n<$list filter=\\\"[all[current]plugintiddlers[]sort[title]]\\\" variable=\\\"payloadTiddler\\\">\\n<tr>\\n<td>\\n<$checkbox field=<<selectionField>> checked=\\\"checked\\\" unchecked=\\\"unchecked\\\" default=\\\"checked\\\"/>\\n</td>\\n<td>\\n<$reveal type=\\\"nomatch\\\" state=<<previewPopupState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$button class=\\\"tc-btn-invisible tc-btn-dropdown\\\" set=<<previewPopupState>> setTo=\\\"yes\\\">\\n{{$:/core/images/right-arrow}}&nbsp;<$link to=<<payloadTiddler>>/>\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=<<previewPopupState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$button class=\\\"tc-btn-invisible tc-btn-dropdown\\\" set=<<previewPopupState>> setTo=\\\"no\\\">\\n{{$:/core/images/down-arrow}}&nbsp;<$link to=<<payloadTiddler>>/>\\n</$button>\\n</$reveal>\\n</td>\\n</tr>\\n<tr>\\n<td colspan=\\\"2\\\">\\n<$reveal type=\\\"match\\\" text=\\\"yes\\\" state=<<previewPopupState>> tag=\\\"div\\\">\\n<$list filter=\\\"[{$:/state/ipfsexportpreviewtype}has[text]]\\\" variable=\\\"listItem\\\" emptyMessage={{$:/core/ui/IpfsExportPreviews/Text}}>\\n<$transclude tiddler={{$:/state/ipfsexportpreviewtype}} mode=\\\"inline\\\"/>\\n</$list>\\n</$reveal>\\n</td>\\n</tr>\\n</$list>\\n</tbody>\\n</table>\\n\"\n        },\n        \"$:/core/ui/IpfsExportPreviews/Fields\": {\n            \"title\": \"$:/core/ui/IpfsExportPreviews/Fields\",\n            \"tags\": \"$:/tags/IpfsExportPreview $:/ipfs/core\",\n            \"caption\": \"{{$:/language/Import/Listing/Preview/Fields}}\",\n            \"text\": \"<table class=\\\"tc-view-field-table\\\">\\n<tbody>\\n<$list filter=\\\"[<payloadTiddler>subtiddlerfields<currentTiddler>sort[]] -text\\\" variable=\\\"fieldName\\\">\\n<tr class=\\\"tc-view-field\\\">\\n<td class=\\\"tc-view-field-name\\\">\\n<$text text=<<fieldName>>/>\\n</td>\\n<td class=\\\"tc-view-field-value\\\">\\n<$view field=<<fieldName>> tiddler=<<currentTiddler>> subtiddler=<<payloadTiddler>>/>\\n</td>\\n</tr>\\n</$list>\\n</tbody>\\n</table>\\n\"\n        },\n        \"$:/core/ui/IpfsExportPreviews/Text\": {\n            \"title\": \"$:/core/ui/IpfsExportPreviews/Text\",\n            \"tags\": \"$:/tags/IpfsExportPreview $:/ipfs/core\",\n            \"caption\": \"{{$:/language/Import/Listing/Preview/Text}}\",\n            \"text\": \"<$transclude tiddler=<<currentTiddler>> subtiddler=<<payloadTiddler>> mode=\\\"block\\\"/>\\n\"\n        },\n        \"$:/core/ui/IpfsExportPreviews/TextRaw\": {\n            \"title\": \"$:/core/ui/IpfsExportPreviews/TextRaw\",\n            \"tags\": \"$:/tags/IpfsExportPreview $:/plugin/ipfs\",\n            \"caption\": \"{{$:/language/Import/Listing/Preview/TextRaw}}\",\n            \"text\": \"<pre><code><$view tiddler=<<currentTiddler>> subtiddler=<<payloadTiddler>> /></code></pre>\"\n        },\n        \"$:/core/ui/IpfsImportListing\": {\n            \"title\": \"$:/core/ui/IpfsImportListing\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\\\\define lingo-base() $:/language/Import/\\n\\n\\\\define messageField() message-$(payloadTiddler)$\\n\\n\\\\define payloadTitleFilter() [<currentTiddler>get<renameField>minlength[1]else<payloadTiddler>]\\n\\n\\\\define overWriteWarning()\\n<$list filter=\\\"[<currentTiddler>!has<suppressedField>]\\\">\\n<$text text={{{[subfilter<payloadTitleFilter>!is[tiddler]then[]] ~[<lingo-base>addsuffix[Listing/Rename/OverwriteWarning]get[text]]}}}/>\\n</$list>\\n\\\\end\\n\\n\\\\define importSelectionField() importSelection-$(payloadTiddler)$\\n\\n\\\\define renameField() rename-$(payloadTiddler)$\\n\\n\\\\define suppressedField() suppressed-$(payloadTiddler)$\\n\\n\\\\define newImportTitleTiddler() $:/temp/NewImportTitle-$(payloadTiddler)$\\n\\n\\\\define deleteSelectionField() deleteSelection-$(payloadTiddler)$\\n\\n\\\\define previewPopupState() $(currentTiddler)$!!popup-$(payloadTiddler)$\\n\\n\\\\define renameFieldState() $(currentTiddler)$!!state-rename-$(payloadTiddler)$\\n\\n\\\\define importState() $(currentTiddler)$!!import-$(payloadTiddler)$\\n\\n\\\\define deleteState() $(currentTiddler)$!!delete-$(payloadTiddler)$\\n\\n\\\\define select-all-actions()\\n<$list filter=\\\"[all[current]plugintiddlers[]sort[title]]\\\" variable=\\\"payloadTiddler\\\">\\n<$action-setfield $field={{{ [<payloadTiddler>addprefix[importSelection-]] }}} $value={{$:/state/import/select-all}}/>\\n</$list>\\n\\\\end\\n\\n\\\\define delete-all-actions()\\n<$list filter=\\\"[all[current]plugintiddlers[]sort[title]]\\\" variable=\\\"payloadTiddler\\\">\\n<$action-setfield $field={{{ [<payloadTiddler>addprefix[deleteSelection-]] }}} $value={{$:/state/import/delete-all}}/>\\n</$list>\\n\\\\end\\n\\n<table class=\\\"tc-import-table\\\">\\n<tbody>\\n<tr>\\n<th align=\\\"left\\\">\\n<$checkbox tiddler=\\\"$:/state/import/select-all\\\" field=\\\"text\\\" checked=\\\"checked\\\" unchecked=\\\"unchecked\\\" default=\\\"checked\\\" actions=<<select-all-actions>>>\\n<<lingo Listing/ImportAll/Caption>>\\n</$checkbox>\\n</th>\\n<th>\\n<$checkbox tiddler=\\\"$:/state/import/delete-all\\\" field=\\\"text\\\" checked=\\\"checked\\\" unchecked=\\\"unchecked\\\" default=\\\"checked\\\" actions=<<delete-all-actions>>>\\n<<lingo Listing/DeleteAll/Caption>>\\n</$checkbox>\\n</th>\\n<th>\\n<<lingo Listing/Title/Caption>>\\n</th>\\n<th>\\n<<lingo Listing/Status/Caption>>\\n</th>\\n</tr>\\n<$list filter=\\\"[all[current]plugintiddlers[]sort[title]]\\\" variable=\\\"payloadTiddler\\\">\\n<tr class={{{[<currentTiddler>has<suppressedField>then[tc-row-disabled]] ~[subfilter<payloadTitleFilter>is[tiddler]then[tc-row-warning]] }}}>\\n<td>\\n<$reveal type=\\\"match\\\" state=<<importState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$checkbox field=<<importSelectionField>> checked=\\\"checked\\\" unchecked=\\\"unchecked\\\" default=\\\"checked\\\"/>\\n</$reveal>\\n</td>\\n<td>\\n<$reveal type=\\\"match\\\" state=<<deleteState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$checkbox field=<<deleteSelectionField>> checked=\\\"checked\\\" unchecked=\\\"unchecked\\\" default=\\\"checked\\\"/>\\n</$reveal>\\n</td>\\n<td>\\n<$reveal type=\\\"nomatch\\\" state=<<renameFieldState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$reveal type=\\\"nomatch\\\" state=<<previewPopupState>> text=\\\"yes\\\" tag=\\\"div\\\" class=\\\"tc-flex\\\">\\n<$button class=\\\"tc-btn-invisible tc-btn-dropdown tc-flex-grow-1 tc-word-break\\\" set=<<previewPopupState>> setTo=\\\"yes\\\" disabled={{{[<currentTiddler>has<suppressedField>then[yes]else[no]]}}}>\\n<span class=\\\"tc-small-gap-right\\\">{{$:/core/images/right-arrow}}</span><$link to={{{[subfilter<payloadTitleFilter>]}}}/>\\n</$button>\\n<$list filter=\\\"[<currentTiddler>!has<suppressedField>]\\\"><$button class=\\\"tc-btn-invisible\\\" set=<<renameFieldState>> setTo=\\\"yes\\\" tooltip={{{[<lingo-base>addsuffix[Listing/Rename/Tooltip]get[text]]}}}>{{$:/core/images/edit-button}}</$button></$list>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=<<previewPopupState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$button class=\\\"tc-btn-invisible tc-btn-dropdown\\\" set=<<previewPopupState>> setTo=\\\"no\\\">\\n<span class=\\\"tc-small-gap-right\\\">{{$:/core/images/down-arrow}}</span><$link to={{{[subfilter<payloadTitleFilter>]}}}/>\\n</$button>\\n</$reveal>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=<<renameFieldState>> text=\\\"yes\\\" tag=\\\"div\\\">\\n<$text text={{{[<lingo-base>addsuffix[Listing/Rename/Prompt]get[text]]}}}/>\\n</$reveal>\\n</td>\\n<td>\\n<$view field=<<messageField>>/>\\n<<overWriteWarning>>\\n</td>\\n</tr>\\n<$reveal type=\\\"match\\\" state=<<renameFieldState>> text=\\\"yes\\\" tag=\\\"tr\\\">\\n<td colspan=\\\"4\\\">\\n<div class=\\\"tc-flex\\\">\\n<$edit-text tiddler=<<newImportTitleTiddler>>  default={{{[subfilter<payloadTitleFilter>]}}} tag=\\\"input\\\" class=\\\"tc-import-rename tc-flex-grow-1\\\"/><span class=\\\"tc-small-gap-left\\\"><$button  class=\\\"tc-btn-invisible\\\" set=<<renameFieldState>> setTo=\\\"no\\\" tooltip={{{[<lingo-base>addsuffix[Listing/Rename/CancelRename]get[text]]}}}>{{$:/core/images/close-button}}<$action-deletetiddler $tiddler=<<newImportTitleTiddler>>/></$button><span class=\\\"tc-small-gap-right\\\"/></span><$button  class=\\\"tc-btn-invisible\\\" set=<<renameFieldState>> setTo=\\\"no\\\" tooltip={{{[<lingo-base>addsuffix[Listing/Rename/ConfirmRename]get[text]]}}}>{{$:/core/images/done-button}}<$action-setfield $field=<<renameField>> $value={{{[<newImportTitleTiddler>get[text]minlength[1]else<payloadTiddler>]}}} /><$action-deletetiddler $tiddler=<<newImportTitleTiddler>>/></$button>\\n</div>\\n</td>\\n</$reveal>\\n<tr>\\n<td colspan=\\\"4\\\">\\n<$reveal type=\\\"match\\\" text=\\\"yes\\\" state=<<previewPopupState>> tag=\\\"div\\\">\\n<$list filter=\\\"[{$:/state/ipfsimportpreviewtype}has[text]]\\\" variable=\\\"listItem\\\" emptyMessage={{$:/core/ui/ImportPreviews/Text}}>\\n<$transclude tiddler={{$:/state/ipfsimportpreviewtype}}/>\\n</$list>\\n</$reveal>\\n</td>\\n</tr>\\n</$list>\\n</tbody>\\n</table>\\n\"\n        },\n        \"$:/core/ui/Buttons/encryption\": {\n            \"title\": \"$:/core/ui/Buttons/encryption\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/locked-padlock}} {{$:/language/Buttons/Encryption/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Encryption/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$reveal type=\\\"match\\\" state=\\\"$:/isEncrypted\\\" text=\\\"yes\\\">\\n<$button message=\\\"tm-clear-password\\\" tooltip=<<ipfs-encryption-tooltip>> aria-label={{$:/language/Buttons/Encryption/ClearPassword/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/locked-padlock}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Encryption/ClearPassword/Caption}}/></span>\\n</$list>\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"nomatch\\\" state=\\\"$:/isEncrypted\\\" text=\\\"yes\\\">\\n<$button message=\\\"tm-set-password\\\" tooltip=<<ipfs-encryption-tooltip>> aria-label={{$:/language/Buttons/Encryption/SetPassword/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/unlocked-padlock}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Encryption/SetPassword/Caption}}/></span>\\n</$list>\\n</$button>\\n</$reveal>\\n\"\n        },\n        \"$:/core/ui/Buttons/ens/publish\": {\n            \"title\": \"$:/core/ui/Buttons/ens/publish\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/language/Buttons/Ens/Publish/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ens/Publish/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ens-publish\\\" tooltip={{$:/language/Buttons/Ens/Publish/Hint}} aria-label={{$:/language/Buttons/Ens/Publish/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/ipfs/image/ens}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ens/Publish/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/console/mobile\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/console/mobile\",\n            \"tags\": \"$:/ipfs/core  $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/preview-open}} {{$:/language/Buttons/Console/Mobile/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Console/Mobile/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-console-mobile\\\" tooltip=<<ipfs-console-tooltip>> aria-label={{$:/language/Buttons/Console/Mobile/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/preview-open}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Console/Mobile/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/pin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/pin\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/chevron-up}} {{$:/language/Buttons/Ipfs/Pin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Pin/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ipfs-pin\\\" tooltip={{$:/language/Buttons/Ipfs/Pin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Pin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-up}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipfs/Pin/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/unpin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/unpin\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/chevron-down}} {{$:/language/Buttons/Ipfs/Unpin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Unpin/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ipfs-unpin\\\" tooltip={{$:/language/Buttons/Ipfs/Unpin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Unpin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-down}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipfs/Unpin/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipns/publish\": {\n            \"title\": \"$:/core/ui/Buttons/ipns/publish\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/excise}} {{$:/language/Buttons/Ipns/Publish/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipns/Publish/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ipns-publish\\\" tooltip={{$:/language/Buttons/Ipns/Publish/Hint}} aria-label={{$:/language/Buttons/Ipns/Publish/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/excise}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Publish/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/SideBar/Tools\": {\n            \"title\": \"$:/core/ui/SideBar/Tools\",\n            \"tags\": \"$:/ipfs/core $:/tags/SideBar\",\n            \"caption\": \"{{$:/language/SideBar/Tools/Caption}}\",\n            \"text\": \"\\\\define lingo-base() $:/language/ControlPanel/\\n\\\\define config-title()\\n$:/config/PageControlButtons/Visibility/$(listItem)$\\n\\\\end\\n\\n<<lingo Basics/Version/Prompt>> <b><<version>></b>, <<lingo Ipfs/Version/Prompt>> <b><<ipfs-plugin-version>></b>\\n\\n<$set name=\\\"tv-config-toolbar-icons\\\" value=\\\"yes\\\">\\n\\n<$set name=\\\"tv-config-toolbar-text\\\" value=\\\"yes\\\">\\n\\n<$set name=\\\"tv-config-toolbar-class\\\" value=\\\"\\\">\\n\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/PageControls]!has[draft.of]]\\\" variable=\\\"listItem\\\">\\n\\n<div style=\\\"position:relative;\\\" class={{{ [<listItem>encodeuricomponent[]addprefix[tc-btn-]] }}}>\\n\\n<$checkbox tiddler=<<config-title>> field=\\\"text\\\" checked=\\\"show\\\" unchecked=\\\"hide\\\" default=\\\"show\\\"/> <$transclude tiddler=<<listItem>>/> <i class=\\\"tc-muted\\\"><$transclude tiddler=<<listItem>> field=\\\"description\\\"/></i>\\n\\n</div>\\n\\n</$list>\\n\\n</$set>\\n\\n</$set>\\n\\n</$set>\"\n        },\n        \"$:/core/ui/ViewTemplate/ipfsexport\": {\n            \"title\": \"$:/core/ui/ViewTemplate/ipfsexport\",\n            \"tags\": \"$:/tags/ViewTemplate $:/ipfs/core\",\n            \"text\": \"\\\\define lingo-base() $:/language/Export/\\n\\n\\\\define buttons()\\n<$button message=\\\"tm-delete-tiddler\\\" param=<<currentTiddler>>><<lingo Listing/Cancel/Caption>></$button>\\n<$button message=\\\"tm-perform-ipfs-export\\\" param=<<currentTiddler>>><<lingo Listing/Export/Caption>></$button>\\n<<lingo Listing/Preview>> <$select tiddler=\\\"$:/state/ipfsexportpreviewtype\\\" default=\\\"$:/core/ui/IpfsExportPreviews/Text\\\">\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/IpfsExportPreview]!has[draft.of]]\\\">\\n<option value=<<currentTiddler>>>{{!!caption}}</option>\\n</$list>\\n</$select>\\n\\\\end\\n\\n<$list filter=\\\"[all[current]field:plugin-type[ipfs-export]]\\\">\\n\\n<div class=\\\"tc-import\\\">\\n\\n<<lingo Listing/Hint>>\\n\\n<<buttons>>\\n\\n{{||$:/core/ui/IpfsExportListing}}\\n\\n<<buttons>>\\n\\n</div>\\n\\n</$list>\\n\"\n        },\n        \"$:/core/ui/ViewTemplate/ipfsimport\": {\n            \"title\": \"$:/core/ui/ViewTemplate/ipfsimport\",\n            \"tags\": \"$:/tags/ViewTemplate $:/ipfs/core\",\n            \"text\": \"\\\\define lingo-base() $:/language/Import/\\n\\n\\\\define buttons()\\n<$button message=\\\"tm-delete-tiddler\\\" param=<<currentTiddler>>><<lingo Listing/Cancel/Caption>></$button>\\n<$button message=\\\"tm-perform-ipfs-import\\\" param=<<currentTiddler>>><<lingo Listing/Import/Caption>></$button>\\n<<lingo Listing/Preview>> <$select tiddler=\\\"$:/state/ipfsimportpreviewtype\\\" default=\\\"$:/core/ui/ImportPreviews/Text\\\">\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/ImportPreview]!has[draft.of]]\\\">\\n<option value=<<currentTiddler>>>{{!!caption}}</option>\\n</$list>\\n</$select>\\n\\\\end\\n\\n<$list filter=\\\"[all[current]field:plugin-type[ipfs-import]]\\\">\\n\\n<div class=\\\"tc-import\\\">\\n\\n<<lingo Listing/Hint>>\\n\\n<<buttons>>\\n\\n{{||$:/core/ui/IpfsImportListing}}\\n\\n<<buttons>>\\n\\n</div>\\n\\n</$list>\\n\"\n        },\n        \"$:/core/ui/ViewTemplate/plugin\": {\n            \"title\": \"$:/core/ui/ViewTemplate/plugin\",\n            \"tags\": \"$:/tags/ViewTemplate $:/ipfs/core\",\n            \"text\": \"<$reveal tag=\\\"div\\\" class=\\\"tc-tiddler-plugin-info\\\" type=\\\"nomatch\\\" stateTitle=<<folded-state>> text=\\\"hide\\\" retain=\\\"yes\\\" animate=\\\"yes\\\">\\n\\n<$list filter=\\\"[all[current]has[plugin-type]] -[all[current]field:plugin-type[import]] -[all[current]field:plugin-type[ipfs-export]] -[all[current]field:plugin-type[ipfs-import]]\\\">\\n<$set name=\\\"plugin-type\\\" value={{!!plugin-type}}>\\n<$set name=\\\"default-popup-state\\\" value=\\\"yes\\\">\\n<$set name=\\\"qualified-state\\\" value=<<qualify \\\"$:/state/plugin-info\\\">>>\\n{{||$:/core/ui/Components/plugin-info}}\\n</$set>\\n</$set>\\n</$set>\\n</$list>\\n</$reveal>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/export/attachment\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/export/attachment\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/language/Buttons/Ipfs/Export/Attachment/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Export/Attachment/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-export-attachment\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Export/Attachment/Hint}} aria-label={{$:/language/Buttons/Ipfs/Export/Attachment/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/ipfs/image/ipfs}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Export/Attachment/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/export/content\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/export/content\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/excise}} {{$:/language/Buttons/Ipfs/Export/Content/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Export/Content/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-export-content\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Export/Content/Hint}} aria-label={{$:/language/Buttons/Ipfs/Export/Content/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/excise}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Export/Content/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/export\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/export\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/excise}} {{$:/language/Buttons/Ipfs/Export/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Export/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-export\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Export/Hint}} aria-label={{$:/language/Buttons/Ipfs/Export/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/excise}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Export/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/refresh\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/refresh\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/refresh-button}} {{$:/language/Buttons/Ipfs/Refresh/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Refresh/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-refresh-tiddler\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Refresh/Hint}} aria-label={{$:/language/Buttons/Ipfs/Refresh/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/refresh-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipfs/Refresh/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/tiddler/pin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/tiddler/pin\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/chevron-up}} {{$:/language/Buttons/Ipfs/Tiddler/Pin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Tiddler/Pin/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-pin\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Tiddler/Pin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Tiddler/Pin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-up}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Tiddler/Pin/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/tiddler/unpin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/tiddler/unpin\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/chevron-down}} {{$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-unpin\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-down}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/plugins/ipfs/styles\": {\n            \"title\": \"$:/plugins/ipfs/styles\",\n            \"tags\": \"$:/ipfs/core $:/tags/Stylesheet\",\n            \"type\": \"text/css\",\n            \"text\": \".tc-ipfs-action {\\n  display: block;\\n  margin: auto;\\n  width: 18px;\\n  height: 18px;\\n}\\n\\n.tc-icon-ipfs-wrapper {\\n  display: inline-block;\\n  width: 1em;\\n  height: 1em;\\n}\\n\\na.tc-ipfs-link-external {\\n\\ttext-decoration: underline;\\n\\tcolor: <<colour external-link-foreground>>;\\n\\tbackground-color: <<colour external-link-background>>;\\n}\\n\\na.tc-ipfs-link-external:visited {\\n\\tcolor: <<colour external-link-foreground-visited>>;\\n\\tbackground-color: <<colour external-link-background-visited>>;\\n}\\n\\na.tc-ipfs-link-external:hover {\\n\\tcolor: <<colour external-link-foreground-hover>>;\\n\\tbackground-color: <<colour external-link-background-hover>>;\\n  cursor: pointer;\\n}\\n\\n.ethAddress {\\n  padding: 20px 0px 0px 40px;\\n  height: 80px;\\n}\"\n        },\n        \"$:/config/AutoSave\": {\n            \"title\": \"$:/config/AutoSave\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"no\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/encryption\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/encryption\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/home\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/home\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/pin\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/pin\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/unpin\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/unpin\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/console/mobile\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/console/mobile\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/more-page-actions\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/more-page-actions\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ens/publish\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ens/publish\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipns/publish\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipns/publish\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/Standford\": {\n            \"title\": \"$:/config/Standford\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"yes\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/content\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/content\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/attachment\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/attachment\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/refresh\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/refresh\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/pin\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/pin\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/unpin\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/unpin\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        }\n    }\n}"
}Éø