
Š€€€m-url-password\\n    password: accessorDescriptor(getPassword, function (password) {\\n      var url = getInternalURLState(this);\\n      var codePoints = arrayFrom(String(password));\\n      if (cannotHaveUsernamePasswordPort(url)) return;\\n      url.password = '';\\n      for (var i = 0; i < codePoints.length; i++) {\\n        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\\n      }\\n    }),\\n    // `URL.prototype.host` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-host\\n    host: accessorDescriptor(getHost, function (host) {\\n      var url = getInternalURLState(this);\\n      if (url.cannotBeABaseURL) return;\\n      parseURL(url, String(host), HOST);\\n    }),\\n    // `URL.prototype.hostname` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-hostname\\n    hostname: accessorDescriptor(getHostname, function (hostname) {\\n      var url = getInternalURLState(this);\\n      if (url.cannotBeABaseURL) return;\\n      parseURL(url, String(hostname), HOSTNAME);\\n    }),\\n    // `URL.prototype.port` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-port\\n    port: accessorDescriptor(getPort, function (port) {\\n      var url = getInternalURLState(this);\\n      if (cannotHaveUsernamePasswordPort(url)) return;\\n      port = String(port);\\n      if (port == '') url.port = null;\\n      else parseURL(url, port, PORT);\\n    }),\\n    // `URL.prototype.pathname` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-pathname\\n    pathname: accessorDescriptor(getPathname, function (pathname) {\\n      var url = getInternalURLState(this);\\n      if (url.cannotBeABaseURL) return;\\n      url.path = [];\\n      parseURL(url, pathname + '', PATH_START);\\n    }),\\n    // `URL.prototype.search` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-search\\n    search: accessorDescriptor(getSearch, function (search) {\\n      var url = getInternalURLState(this);\\n      search = String(search);\\n      if (search == '') {\\n        url.query = null;\\n      } else {\\n        if ('?' == search.charAt(0)) search = search.slice(1);\\n        url.query = '';\\n        parseURL(url, search, QUERY);\\n      }\\n      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\\n    }),\\n    // `URL.prototype.searchParams` getter\\n    // https://url.spec.whatwg.org/#dom-url-searchparams\\n    searchParams: accessorDescriptor(getSearchParams),\\n    // `URL.prototype.hash` accessors pair\\n    // https://url.spec.whatwg.org/#dom-url-hash\\n    hash: accessorDescriptor(getHash, function (hash) {\\n      var url = getInternalURLState(this);\\n      hash = String(hash);\\n      if (hash == '') {\\n        url.fragment = null;\\n        return;\\n      }\\n      if ('#' == hash.charAt(0)) hash = hash.slice(1);\\n      url.fragment = '';\\n      parseURL(url, hash, FRAGMENT);\\n    })\\n  });\\n}\\n\\n// `URL.prototype.toJSON` method\\n// https://url.spec.whatwg.org/#dom-url-tojson\\nredefine(URLPrototype, 'toJSON', function toJSON() {\\n  return serializeURL.call(this);\\n}, { enumerable: true });\\n\\n// `URL.prototype.toString` method\\n// https://url.spec.whatwg.org/#URL-stringification-behavior\\nredefine(URLPrototype, 'toString', function toString() {\\n  return serializeURL.call(this);\\n}, { enumerable: true });\\n\\nif (NativeURL) {\\n  var nativeCreateObjectURL = NativeURL.createObjectURL;\\n  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\\n  // `URL.createObjectURL` method\\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\\n  // eslint-disable-next-line no-unused-vars\\n  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {\\n    return nativeCreateObjectURL.apply(NativeURL, arguments);\\n  });\\n  // `URL.revokeObjectURL` method\\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\\n  // eslint-disable-next-line no-unused-vars\\n  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {\\n    return nativeRevokeObjectURL.apply(NativeURL, arguments);\\n  });\\n}\\n\\nsetToStringTag(URLConstructor, 'URL');\\n\\n$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {\\n  URL: URLConstructor\\n});\\n\\n},{\\\"../internals/an-instance\\\":17,\\\"../internals/array-from\\\":23,\\\"../internals/descriptors\\\":39,\\\"../internals/export\\\":43,\\\"../internals/global\\\":52,\\\"../internals/has\\\":53,\\\"../internals/internal-state\\\":61,\\\"../internals/native-url\\\":72,\\\"../internals/object-assign\\\":74,\\\"../internals/object-define-properties\\\":76,\\\"../internals/redefine\\\":89,\\\"../internals/set-to-string-tag\\\":98,\\\"../internals/string-multibyte\\\":103,\\\"../internals/string-punycode-to-ascii\\\":104,\\\"../modules/es.string.iterator\\\":123,\\\"../modules/web.url-search-params\\\":141}],143:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\n\\n// `URL.prototype.toJSON` method\\n// https://url.spec.whatwg.org/#dom-url-tojson\\n$({ target: 'URL', proto: true, enumerable: true }, {\\n  toJSON: function toJSON() {\\n    return URL.prototype.toString.call(this);\\n  }\\n});\\n\\n},{\\\"../internals/export\\\":43}],144:[function(require,module,exports){\\n'use strict';\\n\\nvar matchOperatorsRe = /[|\\\\\\\\{}()[\\\\]^$+*?.]/g;\\n\\nmodule.exports = function (str) {\\n\\tif (typeof str !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\treturn str.replace(matchOperatorsRe, '\\\\\\\\$&');\\n};\\n\\n},{}],145:[function(require,module,exports){\\n'use strict';\\n/* eslint-disable no-control-regex */\\n// TODO: remove parens when Node.js 6 is targeted. Node.js 4 barfs at it.\\nmodule.exports = () => (/[<>:\\\"\\\\/\\\\\\\\|?*\\\\x00-\\\\x1F]/g);\\nmodule.exports.windowsNames = () => (/^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i);\\n\\n},{}],146:[function(require,module,exports){\\n'use strict';\\nconst path = require('path');\\nconst filenamify = require('./filenamify');\\n\\nconst filenamifyPath = (filePath, options) => {\\n\\tfilePath = path.resolve(filePath);\\n\\treturn path.join(path.dirname(filePath), filenamify(path.basename(filePath), options));\\n};\\n\\nmodule.exports = filenamifyPath;\\n\\n},{\\\"./filenamify\\\":147,\\\"path\\\":190}],147:[function(require,module,exports){\\n'use strict';\\nconst trimRepeated = require('trim-repeated');\\nconst filenameReservedRegex = require('filename-reserved-regex');\\nconst stripOuter = require('strip-outer');\\n\\n// Doesn't make sense to have longer filenames\\nconst MAX_FILENAME_LENGTH = 100;\\n\\nconst reControlChars = /[\\\\u0000-\\\\u001f\\\\u0080-\\\\u009f]/g; // eslint-disable-line no-control-regex\\nconst reRelativePath = /^\\\\.+/;\\n\\nconst filenamify = (string, options = {}) => {\\n\\tif (typeof string !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\tconst replacement = options.replacement === undefined ? '!' : options.replacement;\\n\\n\\tif (filenameReservedRegex().test(replacement) && reControlChars.test(replacement)) {\\n\\t\\tthrow new Error('Replacement string cannot contain reserved filename characters');\\n\\t}\\n\\n\\tstring = string.replace(filenameReservedRegex(), replacement);\\n\\tstring = string.replace(reControlChars, replacement);\\n\\tstring = string.replace(reRelativePath, replacement);\\n\\n\\tif (replacement.length > 0) {\\n\\t\\tstring = trimRepeated(string, replacement);\\n\\t\\tstring = string.length > 1 ? stripOuter(string, replacement) : string;\\n\\t}\\n\\n\\tstring = filenameReservedRegex.windowsNames().test(string) ? string + replacement : string;\\n\\tstring = string.slice(0, typeof options.maxLength === 'number' ? options.maxLength : MAX_FILENAME_LENGTH);\\n\\n\\treturn string;\\n};\\n\\nmodule.exports = filenamify;\\n\\n},{\\\"filename-reserved-regex\\\":145,\\\"strip-outer\\\":192,\\\"trim-repeated\\\":193}],148:[function(require,module,exports){\\n'use strict';\\nconst filenamify = require('./filenamify');\\nconst filenamifyPath = require('./filenamify-path');\\n\\nconst filenamifyCombined = filenamify;\\nfilenamifyCombined.path = filenamifyPath;\\n\\nmodule.exports = filenamify;\\n\\n},{\\\"./filenamify\\\":147,\\\"./filenamify-path\\\":146}],149:[function(require,module,exports){\\n'use strict';\\n\\nconst {\\n    URLWithLegacySupport,\\n    format,\\n    URLSearchParams,\\n    defaultBase\\n} = require('./src/url');\\nconst relative = require('./src/relative');\\n\\nmodule.exports = {\\n    URL: URLWithLegacySupport,\\n    URLSearchParams,\\n    format,\\n    relative,\\n    defaultBase\\n};\\n\\n},{\\\"./src/relative\\\":150,\\\"./src/url\\\":151}],150:[function(require,module,exports){\\n'use strict';\\n\\nconst { URLWithLegacySupport, format } = require('./url');\\n\\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\\n    let protocol = location.protocol ?\\n        location.protocol.replace(':', '') :\\n        'http';\\n\\n    // Check protocol map\\n    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';\\n    let urlParsed;\\n\\n    try {\\n        urlParsed = new URLWithLegacySupport(url);\\n    } catch (err) {\\n        urlParsed = {};\\n    }\\n\\n    const base = Object.assign({}, location, {\\n        protocol: protocol || urlParsed.protocol,\\n        host: location.host || urlParsed.host\\n    });\\n\\n    return new URLWithLegacySupport(url, format(base)).toString();\\n};\\n\\n},{\\\"./url\\\":151}],151:[function(require,module,exports){\\n'use strict';\\n\\nconst defaultBase = self.location ?\\n    self.location.protocol + '//' + self.location.host :\\n    '';\\nconst URL = self.URL;\\n\\nclass URLWithLegacySupport {\\n    constructor(url = '', base = defaultBase) {\\n        this.super = new URL(url, base);\\n        this.path = this.pathname + this.search;\\n        this.auth =\\n            this.username && this.password ?\\n                this.username + ':' + this.password :\\n                null;\\n\\n        this.query =\\n            this.search && this.search.startsWith('?') ?\\n                this.search.slice(1) :\\n                null;\\n    }\\n\\n    get hash() {\\n        return this.super.hash;\\n    }\\n    get host() {\\n        return this.super.host;\\n    }\\n    get hostname() {\\n        return this.super.hostname;\\n    }\\n    get href() {\\n        return this.super.href;\\n    }\\n    get origin() {\\n        return this.super.origin;\\n    }\\n    get password() {\\n        return this.super.password;\\n    }\\n    get pathname() {\\n        return this.super.pathname;\\n    }\\n    get port() {\\n        return this.super.port;\\n    }\\n    get protocol() {\\n        return this.super.protocol;\\n    }\\n    get search() {\\n        return this.super.search;\\n    }\\n    get searchParams() {\\n        return this.super.searchParams;\\n    }\\n    get username() {\\n        return this.super.username;\\n    }\\n\\n    set hash(hash) {\\n        this.super.hash = hash;\\n    }\\n    set host(host) {\\n        this.super.host = host;\\n    }\\n    set hostname(hostname) {\\n        this.super.hostname = hostname;\\n    }\\n    set href(href) {\\n        this.super.href = href;\\n    }\\n    set origin(origin) {\\n        this.super.origin = origin;\\n    }\\n    set password(password) {\\n        this.super.password = password;\\n    }\\n    set pathname(pathname) {\\n        this.super.pathname = pathname;\\n    }\\n    set port(port) {\\n        this.super.port = port;\\n    }\\n    set protocol(protocol) {\\n        this.super.protocol = protocol;\\n    }\\n    set search(search) {\\n        this.super.search = search;\\n    }\\n    set searchParams(searchParams) {\\n        this.super.searchParams = searchParams;\\n    }\\n    set username(username) {\\n        this.super.username = username;\\n    }\\n\\n    createObjectURL(o) {\\n        return this.super.createObjectURL(o);\\n    }\\n    revokeObjectURL(o) {\\n        this.super.revokeObjectURL(o);\\n    }\\n    toJSON() {\\n        return this.super.toJSON();\\n    }\\n    toString() {\\n        return this.super.toString();\\n    }\\n    format() {\\n        return this.toString();\\n    }\\n}\\n\\nfunction format(obj) {\\n    if (typeof obj === 'string') {\\n        const url = new URL(obj);\\n\\n        return url.toString();\\n    }\\n\\n    if (!(obj instanceof URL)) {\\n        const userPass =\\n            obj.username && obj.password ?\\n                `${obj.username}:${obj.password}@` :\\n                '';\\n        const auth = obj.auth ? obj.auth + '@' : '';\\n        const port = obj.port ? ':' + obj.port : '';\\n        const protocol = obj.protocol ? obj.protocol + '//' : '';\\n        const host = obj.host || '';\\n        const hostname = obj.hostname || '';\\n        const search = obj.search || (obj.query ? '?' + obj.query : '');\\n        const hash = obj.hash || '';\\n        const pathname = obj.pathname || '';\\n        const path = obj.path || pathname + search;\\n\\n        return `${protocol}${userPass || auth}${host ||\\n            hostname + port}${path}${hash}`;\\n    }\\n}\\n\\nmodule.exports = {\\n    URLWithLegacySupport,\\n    URLSearchParams: self.URLSearchParams,\\n    defaultBase,\\n    format\\n};\\n\\n},{}],152:[function(require,module,exports){\\n'use strict'\\n\\nmodule.exports = {\\n  DEFAULT_HTTP_API: '/ip4/127.0.0.1/tcp/5001'\\n}\\n\\n},{}],153:[function(require,module,exports){\\n'use strict'\\n\\nmodule.exports = {\\n  httpClient: 'httpClient',\\n  windowIpfs: 'windowIpfs',\\n  jsIpfs: 'jsIpfs',\\n  webExt: 'webExt'\\n}\\n\\n},{}],154:[function(require,module,exports){\\n(function (global){(function (){\\n'use strict'\\n/* global self */\\n\\n// Establish the root object, `window` in the browser, `self` in Service Worker. or `global` on the server.\\n// Credit: https://github.com/megawac/underscore/commit/365311c9a440438531ca1c6bfd49e3c7c5f46079\\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\\n  (typeof global === 'object' && global.global === global && global) ||\\n  this\\n\\n}).call(this)}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],155:[function(require,module,exports){\\n'use strict'\\n\\nconst root = require('./constants/root')\\nconst mergeOptions = require('merge-options')\\nconst tryWebExt = require('./providers/webext')\\nconst tryWindow = require('./providers/window-ipfs')\\nconst tryHttpClient = require('./providers/http-client')\\nconst tryJsIpfs = require('./providers/js-ipfs')\\n\\nconst defaultGlobalOpts = {\\n  connectionTest: async (ipfs) => {\\n    // ipfs connection is working if we can fetch data via async iterator API\\n    const cid = 'QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn'\\n    for await (const file of ipfs.get(cid)) {\\n      return file.type === 'dir' && file.name === cid\\n    }\\n  }\\n}\\n\\nconst makeProvider = (fn, defaults = {}) => {\\n  return (options = {}) => {\\n    return (globalOpts) => {\\n      options = mergeOptions(defaultGlobalOpts, defaults, globalOpts, options)\\n      return fn(options)\\n    }\\n  }\\n}\\n\\nconst providers = {\\n  httpClient: makeProvider((options) => {\\n    return tryHttpClient({ root, ...options })\\n  }),\\n  windowIpfs: makeProvider(options => {\\n    return tryWindow({ root, ...options })\\n  }),\\n  jsIpfs: makeProvider(options => {\\n    return tryJsIpfs(options)\\n  }),\\n  webExt: makeProvider(options => {\\n    return tryWebExt({ root, ...options })\\n  })\\n}\\n\\nconst defaultProviders = [\\n  providers.windowIpfs(),\\n  providers.httpClient()\\n]\\n\\nasync function getIpfs ({ providers = defaultProviders, ...options } = {}) {\\n  for (const provider of providers) {\\n    try {\\n      const res = await provider(options)\\n      if (res) return res\\n    } catch (err) {\\n      // provider failed unexpectedly, log error and move to the next one\\n      console.error('[ipfs-provider]', err) // eslint-disable-line no-console\\n    }\\n  }\\n}\\n\\nmodule.exports = {\\n  getIpfs,\\n  providers,\\n  makeProvider\\n}\\n\\n},{\\\"./constants/root\\\":154,\\\"./providers/http-client\\\":156,\\\"./providers/js-ipfs\\\":157,\\\"./providers/webext\\\":158,\\\"./providers/window-ipfs\\\":159,\\\"merge-options\\\":161}],156:[function(require,module,exports){\\n'use strict'\\n\\nconst { URL } = require('iso-url')\\nconst PROVIDERS = require('../constants/providers')\\nconst { DEFAULT_HTTP_API } = require('../constants/defaults')\\n\\n/*\\n * This provider lazy-loads https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-http-client\\n * so it is not included as a dependency if not used.\\n *\\n * HTTP Client init fallback:\\n * 1. Use constructor returned by loadHttpClientModule function\\n * 2. Fallback to window.IpfsHttpClient\\n *\\n * API URL fallback order:\\n * 1. Try user specified API address\\n * 2. Try current origin\\n * 3. Try DEFAULT_HTTP_API\\n*/\\nasync function tryHttpClient ({ loadHttpClientModule, apiAddress, root, connectionTest }) {\\n  // Find HTTP client\\n  let httpClient\\n  if (loadHttpClientModule) httpClient = await loadHttpClientModule()\\n\\n  // Final fallback to window.IpfsHttpClient or error\\n  if (!httpClient) {\\n    if (root.IpfsHttpClient) {\\n      httpClient = root.IpfsHttpClient\\n    } else {\\n      throw new Error('ipfs-provider could not initialize js-ipfs-http-client: make sure its constructor is returned by loadHttpClientModule function or exposed at window.IpfsHttpClient')\\n    }\\n  }\\n\\n  // Allow the use of `import` or `require` on `loadHttpClientModule` fn\\n  httpClient = httpClient.default || httpClient // TODO: create 'import' demo in examples/\\n\\n  // If explicit custom apiAddress provided, only try that.\\n  if (apiAddress) {\\n    return maybeApi({ apiAddress, connectionTest, httpClient })\\n  }\\n\\n  // Current origin is not localhost:5001 so try with current origin info\\n  const { location } = root\\n  if (location && !(location.port === '5001' && location.hostname.match(/^127.0.0.1$|^localhost$/))) {\\n    const origin = new URL(location.origin)\\n    origin.pathname = '/'\\n    const res = await maybeApi({\\n      apiAddress: origin.toString(),\\n      connectionTest,\\n      httpClient\\n    })\\n    if (res) return res\\n  }\\n\\n  // ...otherwise try /ip4/127.0.0.1/tcp/5001\\n  return maybeApi({ apiAddress: DEFAULT_HTTP_API, connectionTest, httpClient })\\n}\\n\\n// Init and test an api client against provided API address.\\n// Returns js-ipfs-http-client instance or null\\nasync function maybeApi ({ apiAddress, connectionTest, httpClient }) {\\n  try {\\n    const ipfs = httpClient(copyIfObject(apiAddress))\\n    await connectionTest(ipfs)\\n    return { ipfs, provider: PROVIDERS.httpClient, apiAddress }\\n  } catch (error) {\\n    // Failed to connect to ipfs-api in `apiAddress`\\n    // console.error('[ipfs-provider:httpClient]', error)\\n    return null\\n  }\\n}\\n\\n// Some versions of js-ipfs-http-client mutate the object passed instead of\\n// URL/multiaddr string. This wrapper preserves the original config to ensure one can\\n// compare objects returned apiAddress to tell which provider was successful\\nconst copyIfObject = (apiAddress) => {\\n  return (typeof apiAddress === 'object')\\n    ? JSON.parse(JSON.stringify(apiAddress))\\n    : apiAddress\\n}\\n\\nmodule.exports = tryHttpClient\\n\\n},{\\\"../constants/defaults\\\":152,\\\"../constants/providers\\\":153,\\\"iso-url\\\":149}],157:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nfunction createIpfs (ipfsModule, opts) {\\n  // Allow the use of `import` or `require` on `getJsIpfs` fn\\n  ipfsModule = ipfsModule.default || ipfsModule\\n  return ipfsModule.create(opts)\\n}\\n\\nasync function tryJsIpfs ({ connectionTest, loadJsIpfsModule, options, init = createIpfs }) {\\n  const ipfsModule = await loadJsIpfsModule()\\n  const ipfs = await init(ipfsModule, options)\\n  await connectionTest(ipfs)\\n  return { ipfs, provider: PROVIDERS.jsIpfs }\\n}\\n\\nmodule.exports = tryJsIpfs\\n\\n},{\\\"../constants/providers\\\":153}],158:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function tryWebExt ({ root, connectionTest }) {\\n  // Opportunistic optimizations when running inside of web extension (eg. ipfs-companion)\\n  if (typeof root.chrome === 'object' && root.chrome.extension && root.chrome.extension.getBackgroundPage) {\\n    // Note: under some vendors getBackgroundPage() will return null if window is in incognito mode\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1329304\\n    let bg = null\\n    try {\\n      bg = root.chrome.extension.getBackgroundPage()\\n    } catch (err) {\\n      // not in browser extension\\n      return null\\n    }\\n    // If extension is exposing IPFS API as `ipfs` on the background page\\n    // it can be used directly for the best performance\\n    if (bg && bg.ipfs) {\\n      const { ipfs } = bg\\n      await connectionTest(ipfs)\\n      return { ipfs, provider: PROVIDERS.webExt }\\n    }\\n    /*  Other endpoints can be added here in the future.\\n        For example, Companion could provide API for other browser extensions:\\n        https://github.com/ipfs-shipyard/ipfs-companion/issues/307 */\\n  }\\n}\\n\\nmodule.exports = tryWebExt\\n\\n},{\\\"../constants/providers\\\":153}],159:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function tryWindow ({ root, permissions, connectionTest }) {\\n  if (root.ipfs) {\\n    // files.get is required for testing if API works, ensure we request it\\n    if (!(permissions && permissions.commands && permissions.commands.includes('files.get'))) {\\n      permissions = permissions || {}\\n      permissions = JSON.parse(JSON.stringify(permissions)) // deep copy to work with freezed objects\\n      permissions.commands = permissions.commands || []\\n      permissions.commands.push('files.get')\\n    }\\n    // try window.ipfs.enable first: https://github.com/ipfs-shipyard/ipfs-companion/issues/589\\n    const ipfs = typeof root.ipfs.enable === 'function'\\n      ? await root.ipfs.enable(permissions)\\n      : root.ipfs\\n    await connectionTest(ipfs)\\n    return { ipfs, provider: PROVIDERS.windowIpfs }\\n  }\\n}\\n\\nmodule.exports = tryWindow\\n\\n},{\\\"../constants/providers\\\":153}],160:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = value => {\\n\\tif (Object.prototype.toString.call(value) !== '[object Object]') {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tconst prototype = Object.getPrototypeOf(value);\\n\\treturn prototype === null || prototype === Object.prototype;\\n};\\n\\n},{}],161:[function(require,module,exports){\\n'use strict';\\nconst isOptionObject = require('is-plain-obj');\\n\\nconst {hasOwnProperty} = Object.prototype;\\nconst {propertyIsEnumerable} = Object;\\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\\n\\tvalue,\\n\\twritable: true,\\n\\tenumerable: true,\\n\\tconfigurable: true\\n});\\n\\nconst globalThis = this;\\nconst defaultMergeOptions = {\\n\\tconcatArrays: false,\\n\\tignoreUndefined: false\\n};\\n\\nconst getEnumerableOwnPropertyKeys = value => {\\n\\tconst keys = [];\\n\\n\\tfor (const key in value) {\\n\\t\\tif (hasOwnProperty.call(value, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\n\\t/* istanbul ignore else  */\\n\\tif (Object.getOwnPropertySymbols) {\\n\\t\\tconst symbols = Object.getOwnPropertySymbols(value);\\n\\n\\t\\tfor (const symbol of symbols) {\\n\\t\\t\\tif (propertyIsEnumerable.call(value, symbol)) {\\n\\t\\t\\t\\tkeys.push(symbol);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn keys;\\n};\\n\\nfunction clone(value) {\\n\\tif (Array.isArray(value)) {\\n\\t\\treturn cloneArray(value);\\n\\t}\\n\\n\\tif (isOptionObject(value)) {\\n\\t\\treturn cloneOptionObject(value);\\n\\t}\\n\\n\\treturn value;\\n}\\n\\nfunction cloneArray(array) {\\n\\tconst result = array.slice(0, 0);\\n\\n\\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\\n\\t\\tdefineProperty(result, key, clone(array[key]));\\n\\t});\\n\\n\\treturn result;\\n}\\n\\nfunction cloneOptionObject(object) {\\n\\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\\n\\n\\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\\n\\t\\tdefineProperty(result, key, clone(object[key]));\\n\\t});\\n\\n\\treturn result;\\n}\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {string[]} keys keys to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n */\\nconst mergeKeys = (merged, source, keys, config) => {\\n\\tkeys.forEach(key => {\\n\\t\\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Do not recurse into prototype chain of merged\\n\\t\\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\\n\\t\\t\\tdefineProperty(merged, key, merge(merged[key], source[key], config));\\n\\t\\t} else {\\n\\t\\t\\tdefineProperty(merged, key, clone(source[key]));\\n\\t\\t}\\n\\t});\\n\\n\\treturn merged;\\n};\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n *\\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\\n */\\nconst concatArrays = (merged, source, config) => {\\n\\tlet result = merged.slice(0, 0);\\n\\tlet resultIndex = 0;\\n\\n\\t[merged, source].forEach(array => {\\n\\t\\tconst indices = [];\\n\\n\\t\\t// `result.concat(array)` with cloning\\n\\t\\tfor (let k = 0; k < array.length; k++) {\\n\\t\\t\\tif (!hasOwnProperty.call(array, k)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tindices.push(String(k));\\n\\n\\t\\t\\tif (array === merged) {\\n\\t\\t\\t\\t// Already cloned\\n\\t\\t\\t\\tdefineProperty(result, resultIndex++, array[k]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdefineProperty(result, resultIndex++, clone(array[k]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Merge non-index keys\\n\\t\\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\\n\\t});\\n\\n\\treturn result;\\n};\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n */\\nfunction merge(merged, source, config) {\\n\\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\\n\\t\\treturn concatArrays(merged, source, config);\\n\\t}\\n\\n\\tif (!isOptionObject(source) || !isOptionObject(merged)) {\\n\\t\\treturn clone(source);\\n\\t}\\n\\n\\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\\n}\\n\\nmodule.exports = function (...options) {\\n\\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\\n\\tlet merged = {_: {}};\\n\\n\\tfor (const option of options) {\\n\\t\\tif (option === undefined) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!isOptionObject(option)) {\\n\\t\\t\\tthrow new TypeError('`' + option + '` is not an Option Object');\\n\\t\\t}\\n\\n\\t\\tmerged = merge(merged, {_: option}, config);\\n\\t}\\n\\n\\treturn merged._;\\n};\\n\\n},{\\\"is-plain-obj\\\":160}],162:[function(require,module,exports){\\n'use strict'\\n\\nconst { encodeText } = require('./util')\\n\\n/** @typedef {import('./types').CodecFactory} CodecFactory */\\n/** @typedef {import(\\\"./types\\\").BaseName} BaseName */\\n/** @typedef {import(\\\"./types\\\").BaseCode} BaseCode */\\n\\n/**\\n * Class to encode/decode in the supported Bases\\n *\\n */\\nclass Base {\\n  /**\\n   * @param {BaseName} name\\n   * @param {BaseCode} code\\n   * @param {CodecFactory} factory\\n   * @param {string} alphabet\\n   */\\n  constructor (name, code, factory, alphabet) {\\n    this.name = name\\n    this.code = code\\n    this.codeBuf = encodeText(this.code)\\n    this.alphabet = alphabet\\n    this.codec = factory(alphabet)\\n  }\\n\\n  /**\\n   * @param {Uint8Array} buf\\n   * @returns {string}\\n   */\\n  encode (buf) {\\n    return this.codec.encode(buf)\\n  }\\n\\n  /**\\n   * @param {string} string\\n   * @returns {Uint8Array}\\n   */\\n  decode (string) {\\n    for (const char of string) {\\n      if (this.alphabet && this.alphabet.indexOf(char) < 0) {\\n        throw new Error(`invalid character '${char}' in '${string}'`)\\n      }\\n    }\\n    return this.codec.decode(string)\\n  }\\n}\\n\\nmodule.exports = Base\\n\\n},{\\\"./util\\\":166}],163:[function(require,module,exports){\\n'use strict'\\n\\nconst baseX = require('@multiformats/base-x')\\nconst Base = require('./base.js')\\nconst { rfc4648 } = require('./rfc4648')\\nconst { decodeText, encodeText } = require('./util')\\n\\n/** @typedef {import('./types').CodecFactory} CodecFactory */\\n/** @typedef {import('./types').Codec} Codec */\\n/** @typedef {import('./types').BaseName} BaseName */\\n/** @typedef {import('./types').BaseCode} BaseCode */\\n\\n/** @type {CodecFactory} */\\nconst identity = () => {\\n  return {\\n    encode: decodeText,\\n    decode: encodeText\\n  }\\n}\\n\\n/**\\n *\\n * name, code, implementation, alphabet\\n *\\n * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}\\n */\\nconst constants = [\\n  ['identity', '\\\\x00', identity, ''],\\n  ['base2', '0', rfc4648(1), '01'],\\n  ['base8', '7', rfc4648(3), '01234567'],\\n  ['base10', '9', baseX, '0123456789'],\\n  ['base16', 'f', rfc4648(4), '0123456789abcdef'],\\n  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],\\n  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],\\n  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],\\n  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],\\n  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],\\n  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],\\n  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],\\n  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],\\n  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],\\n  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],\\n  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],\\n  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],\\n  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],\\n  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],\\n  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],\\n  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],\\n  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],\\n  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']\\n]\\n\\n/** @type {Record<BaseName,Base>} */\\nconst names = constants.reduce((prev, tupple) => {\\n  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])\\n  return prev\\n}, /** @type {Record<BaseName,Base>} */({}))\\n\\n/** @type {Record<BaseCode,Base>} */\\nconst codes = constants.reduce((prev, tupple) => {\\n  prev[tupple[1]] = names[tupple[0]]\\n  return prev\\n}, /** @type {Record<BaseCode,Base>} */({}))\\n\\nmodule.exports = {\\n  names,\\n  codes\\n}\\n\\n},{\\\"./base.js\\\":162,\\\"./rfc4648\\\":165,\\\"./util\\\":166,\\\"@multiformats/base-x\\\":7}],164:[function(require,module,exports){\\n/**\\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\\n *\\n */\\n'use strict'\\n\\nconst constants = require('./constants')\\nconst { encodeText, decodeText, concat } = require('./util')\\n\\n/** @typedef {import('./base')} Base */\\n/** @typedef {import(\\\"./types\\\").BaseNameOrCode} BaseNameOrCode */\\n/** @typedef {import(\\\"./types\\\").BaseCode} BaseCode */\\n/** @typedef {import(\\\"./types\\\").BaseName} BaseName */\\n\\n/**\\n * Create a new Uint8Array with the multibase varint+code.\\n *\\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\\n * @param {Uint8Array} buf - The data to be prefixed with multibase.\\n * @returns {Uint8Array}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction multibase (nameOrCode, buf) {\\n  if (!buf) {\\n    throw new Error('requires an encoded Uint8Array')\\n  }\\n  const { name, codeBuf } = encoding(nameOrCode)\\n  validEncode(name, buf)\\n\\n  return concat([codeBuf, buf], codeBuf.length + buf.length)\\n}\\n\\n/**\\n * Encode data with the specified base and add the multibase prefix.\\n *\\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\\n * @param {Uint8Array} buf - The data to be encoded.\\n * @returns {Uint8Array}\\n * @throws {Error} Will throw if the encoding is not supported\\n *\\n */\\nfunction encode (nameOrCode, buf) {\\n  const enc = encoding(nameOrCode)\\n  const data = encodeText(enc.encode(buf))\\n\\n  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)\\n}\\n\\n/**\\n * Takes a Uint8Array or string encoded with multibase header, decodes it and\\n * returns the decoded buffer\\n *\\n * @param {Uint8Array|string} data\\n * @returns {Uint8Array}\\n * @throws {Error} Will throw if the encoding is not supported\\n *\\n */\\nfunction decode (data) {\\n  if (data instanceof Uint8Array) {\\n    data = decodeText(data)\\n  }\\n  const prefix = data[0]\\n\\n  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet\\n  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {\\n    data = data.toLowerCase()\\n  }\\n  const enc = encoding(/** @type {BaseCode} */(data[0]))\\n  return enc.decode(data.substring(1))\\n}\\n\\n/**\\n * Is the given data multibase encoded?\\n *\\n * @param {Uint8Array|string} data\\n * @returns {false | string}\\n */\\nfunction isEncoded (data) {\\n  if (data instanceof Uint8Array) {\\n    data = decodeText(data)\\n  }\\n\\n  // Ensure bufOrString is a string\\n  if (Object.prototype.toString.call(data) !== '[object String]') {\\n    return false\\n  }\\n\\n  try {\\n    const enc = encoding(/** @type {BaseCode} */(data[0]))\\n    return enc.name\\n  } catch (err) {\\n    return false\\n  }\\n}\\n\\n/**\\n * Validate encoded data\\n *\\n * @param {BaseNameOrCode} name\\n * @param {Uint8Array} buf\\n * @returns {void}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction validEncode (name, buf) {\\n  const enc = encoding(name)\\n  enc.decode(decodeText(buf))\\n}\\n\\n/**\\n * Get the encoding by name or code\\n *\\n * @param {BaseNameOrCode} nameOrCode\\n * @returns {Base}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction encoding (nameOrCode) {\\n  if (constants.names[/** @type {BaseName} */(nameOrCode)]) {\\n    return constants.names[/** @type {BaseName} */(nameOrCode)]\\n  } else if (constants.codes[/** @type {BaseCode} */(nameOrCode)]) {\\n    return constants.codes[/** @type {BaseCode} */(nameOrCode)]\\n  } else {\\n    throw new Error(`Unsupported encoding: ${nameOrCode}`)\\n  }\\n}\\n\\n/**\\n * Get encoding from data\\n *\\n * @param {string|Uint8Array} data\\n * @returns {Base}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction encodingFromData (data) {\\n  if (data instanceof Uint8Array) {\\n    data = decodeText(data)\\n  }\\n\\n  return encoding(/** @type {BaseCode} */(data[0]))\\n}\\n\\nexports = module.exports = multibase\\nexports.encode = encode\\nexports.decode = decode\\nexports.isEncoded = isEncoded\\nexports.encoding = encoding\\nexports.encodingFromData = encodingFromData\\nexports.names = Object.freeze(constants.names)\\nexports.codes = Object.freeze(constants.codes)\\n\\n},{\\\"./constants\\\":163,\\\"./util\\\":166}],165:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./types').CodecFactory} CodecFactory */\\n\\n/**\\n * @param {string} string\\n * @param {string} alphabet\\n * @param {number} bitsPerChar\\n * @returns {Uint8Array}\\n */\\nconst decode = (string, alphabet, bitsPerChar) => {\\n  // Build the character lookup table:\\n  /** @type {Record<string, number>} */\\n  const codes = {}\\n  for (let i = 0; i < alphabet.length; ++i) {\\n    codes[alphabet[i]] = i\\n  }\\n\\n  // Count the padding bytes:\\n  let end = string.length\\n  while (string[end - 1] === '=') {\\n    --end\\n  }\\n\\n  // Allocate the output:\\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\\n\\n  // Parse the data:\\n  let bits = 0 // Number of bits currently in the buffer\\n  let buffer = 0 // Bits waiting to be written out, MSB first\\n  let written = 0 // Next byte to write\\n  for (let i = 0; i < end; ++i) {\\n    // Read one character from the string:\\n    const value = codes[string[i]]\\n    if (value === undefined) {\\n      throw new SyntaxError('Invalid character ' + string[i])\\n    }\\n\\n    // Append the bits to the buffer:\\n    buffer = (buffer << bitsPerChar) | value\\n    bits += bitsPerChar\\n\\n    // Write out some bits if the buffer has a byte's worth:\\n    if (bits >= 8) {\\n      bits -= 8\\n      out[written++] = 0xff & (buffer >> bits)\\n    }\\n  }\\n\\n  // Verify that we have received just enough bits:\\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\\n    throw new SyntaxError('Unexpected end of data')\\n  }\\n\\n  return out\\n}\\n\\n/**\\n * @param {Uint8Array} data\\n * @param {string} alphabet\\n * @param {number} bitsPerChar\\n * @returns {string}\\n */\\nconst encode = (data, alphabet, bitsPerChar) => {\\n  const pad = alphabet[alphabet.length - 1] === '='\\n  const mask = (1 << bitsPerChar) - 1\\n  let out = ''\\n\\n  let bits = 0 // Number of bits currently in the buffer\\n  let buffer = 0 // Bits waiting to be written out, MSB first\\n  for (let i = 0; i < data.length; ++i) {\\n    // Slurp data into the buffer:\\n    buffer = (buffer << 8) | data[i]\\n    bits += 8\\n\\n    // Write out as much as we can:\\n    while (bits > bitsPerChar) {\\n      bits -= bitsPerChar\\n      out += alphabet[mask & (buffer >> bits)]\\n    }\\n  }\\n\\n  // Partial character:\\n  if (bits) {\\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\\n  }\\n\\n  // Add padding characters until we hit a byte boundary:\\n  if (pad) {\\n    while ((out.length * bitsPerChar) & 7) {\\n      out += '='\\n    }\\n  }\\n\\n  return out\\n}\\n\\n/**\\n * RFC4648 Factory\\n *\\n * @param {number} bitsPerChar\\n * @returns {CodecFactory}\\n */\\nconst rfc4648 = (bitsPerChar) => (alphabet) => {\\n  return {\\n    /**\\n     * @param {Uint8Array} input\\n     * @returns {string}\\n     */\\n    encode (input) {\\n      return encode(input, alphabet, bitsPerChar)\\n    },\\n    /**\\n     * @param {string} input\\n     * @returns {Uint8Array}\\n     */\\n    decode (input) {\\n      return decode(input, alphabet, bitsPerChar)\\n    }\\n  }\\n}\\n\\nmodule.exports = { rfc4648 }\\n\\n},{}],166:[function(require,module,exports){\\n'use strict'\\n\\n// @ts-ignore\\nconst { TextEncoder, TextDecoder } = require('web-encoding')\\n\\nconst textDecoder = new TextDecoder()\\n/**\\n * @param {ArrayBufferView|ArrayBuffer} bytes\\n * @returns {string}\\n */\\nconst decodeText = (bytes) => textDecoder.decode(bytes)\\n\\nconst textEncoder = new TextEncoder()\\n/**\\n * @param {string} text\\n * @returns {Uint8Array}\\n */\\nconst encodeText = (text) => textEncoder.encode(text)\\n\\n/**\\n * Returns a new Uint8Array created by concatenating the passed Arrays\\n *\\n * @param {Array<ArrayLike<number>>} arrs\\n * @param {number} length\\n * @returns {Uint8Array}\\n */\\nfunction concat (arrs, length) {\\n  const output = new Uint8Array(length)\\n  let offset = 0\\n\\n  for (const arr of arrs) {\\n    output.set(arr, offset)\\n    offset += arr.length\\n  }\\n\\n  return output\\n}\\n\\nmodule.exports = { decodeText, encodeText, concat }\\n\\n},{\\\"web-encoding\\\":201}],167:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\\n *\\n * @param {Array<ArrayLike<number>>} arrays\\n * @param {Number} length\\n * @returns {Uint8Array}\\n */\\nfunction concat (arrays, length) {\\n  if (!length) {\\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\\n  }\\n\\n  const output = new Uint8Array(length)\\n  let offset = 0\\n\\n  for (const arr of arrays) {\\n    output.set(arr, offset)\\n    offset += arr.length\\n  }\\n\\n  return output\\n}\\n\\nmodule.exports = concat\\n\\n},{}],168:[function(require,module,exports){\\n'use strict'\\n\\nconst { names } = require('multibase/src/constants')\\nconst { TextEncoder } = require('web-encoding')\\nconst utf8Encoder = new TextEncoder()\\n\\n/**\\n * Interperets each character in a string as a byte and\\n * returns a Uint8Array of those bytes.\\n *\\n * @param {String} string The string to turn into an array\\n * @returns {Uint8Array}\\n */\\nfunction asciiStringToUint8Array (string) {\\n  const array = new Uint8Array(string.length)\\n\\n  for (let i = 0; i < string.length; i++) {\\n    array[i] = string.charCodeAt(i)\\n  }\\n\\n  return array\\n}\\n\\n/**\\n * Create a `Uint8Array` from the passed string\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {String} string\\n * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc\\n * @returns {Uint8Array}\\n * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`\\n */\\nfunction fromString (string, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Encoder.encode(string)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return asciiStringToUint8Array(string)\\n  }\\n\\n  const codec = names[encoding]\\n\\n  if (!codec) {\\n    throw new Error('Unknown base')\\n  }\\n\\n  return codec.decode(string)\\n}\\n\\nmodule.exports = fromString\\n\\n},{\\\"multibase/src/constants\\\":163,\\\"web-encoding\\\":201}],169:[function(require,module,exports){\\n'use strict'\\n\\nconst { names } = require('multibase/src/constants')\\nconst { TextDecoder } = require('web-encoding')\\nconst utf8Decoder = new TextDecoder('utf8')\\n\\n/**\\n * Turns a Uint8Array of bytes into a string with each\\n * character being the char code of the corresponding byte\\n *\\n * @param {Uint8Array} array The array to turn into a string\\n * @returns {String}\\n */\\nfunction uint8ArrayToAsciiString (array) {\\n  let string = ''\\n\\n  for (let i = 0; i < array.length; i++) {\\n    string += String.fromCharCode(array[i])\\n  }\\n  return string\\n}\\n\\n/**\\n * Turns a `Uint8Array` into a string.\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {Uint8Array} array The array to turn into a string\\n * @param {String} [encoding=utf8] The encoding to use\\n * @returns {String}\\n * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`\\n */\\nfunction toString (array, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Decoder.decode(array)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return uint8ArrayToAsciiString(array)\\n  }\\n\\n  const codec = names[encoding]\\n\\n  if (!codec) {\\n    throw new Error('Unknown base')\\n  }\\n\\n  return codec.encode(array)\\n}\\n\\nmodule.exports = toString\\n\\n},{\\\"multibase/src/constants\\\":163,\\\"web-encoding\\\":201}],170:[function(require,module,exports){\\nmodule.exports = read\\n\\nvar MSB = 0x80\\n  , REST = 0x7F\\n\\nfunction read(buf, offset) {\\n  var res    = 0\\n    , offset = offset || 0\\n    , shift  = 0\\n    , counter = offset\\n    , b\\n    , l = buf.length\\n\\n  do {\\n    if (counter >= l || shift > 49) {\\n      read.bytes = 0\\n      throw new RangeError('Could not decode varint')\\n    }\\n    b = buf[counter++]\\n    res += shift < 28\\n      ? (b & REST) << shift\\n      : (b & REST) * Math.pow(2, shift)\\n    shift += 7\\n  } while (b >= MSB)\\n\\n  read.bytes = counter - offset\\n\\n  return res\\n}\\n\\n},{}],171:[function(require,module,exports){\\nmodule.exports = encode\\n\\nvar MSB = 0x80\\n  , REST = 0x7F\\n  , MSBALL = ~REST\\n  , INT = Math.pow(2, 31)\\n\\nfunction encode(num, out, offset) {\\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\\n    encode.bytes = 0\\n    throw new RangeError('Could not encode varint')\\n  }\\n  out = out || []\\n  offset = offset || 0\\n  var oldOffset = offset\\n\\n  while(num >= INT) {\\n    out[offset++] = (num & 0xFF) | MSB\\n    num /= 128\\n  }\\n  while(num & MSBALL) {\\n    out[offset++] = (num & 0xFF) | MSB\\n    num >>>= 7\\n  }\\n  out[offset] = num | 0\\n  \\n  encode.bytes = offset - oldOffset + 1\\n  \\n  return out\\n}\\n\\n},{}],172:[function(require,module,exports){\\nmodule.exports = {\\n    encode: require('./encode.js')\\n  , decode: require('./decode.js')\\n  , encodingLength: require('./length.js')\\n}\\n\\n},{\\\"./decode.js\\\":170,\\\"./encode.js\\\":171,\\\"./length.js\\\":173}],173:[function(require,module,exports){\\n\\nvar N1 = Math.pow(2,  7)\\nvar N2 = Math.pow(2, 14)\\nvar N3 = Math.pow(2, 21)\\nvar N4 = Math.pow(2, 28)\\nvar N5 = Math.pow(2, 35)\\nvar N6 = Math.pow(2, 42)\\nvar N7 = Math.pow(2, 49)\\nvar N8 = Math.pow(2, 56)\\nvar N9 = Math.pow(2, 63)\\n\\nmodule.exports = function (value) {\\n  return (\\n    value < N1 ? 1\\n  : value < N2 ? 2\\n  : value < N3 ? 3\\n  : value < N4 ? 4\\n  : value < N5 ? 5\\n  : value < N6 ? 6\\n  : value < N7 ? 7\\n  : value < N8 ? 8\\n  : value < N9 ? 9\\n  :              10\\n  )\\n}\\n\\n},{}],174:[function(require,module,exports){\\n// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js\\n/* eslint quote-props: off */\\n'use strict'\\n\\n/**\\n * @type {import('./generated-types').NameNumberMap}\\n */\\nconst baseTable = Object.freeze({\\n  'identity': 0x00,\\n  'cidv1': 0x01,\\n  'cidv2': 0x02,\\n  'cidv3': 0x03,\\n  'ip4': 0x04,\\n  'tcp': 0x06,\\n  'sha1': 0x11,\\n  'sha2-256': 0x12,\\n  'sha2-512': 0x13,\\n  'sha3-512': 0x14,\\n  'sha3-384': 0x15,\\n  'sha3-256': 0x16,\\n  'sha3-224': 0x17,\\n  'shake-128': 0x18,\\n  'shake-256': 0x19,\\n  'keccak-224': 0x1a,\\n  'keccak-256': 0x1b,\\n  'keccak-384': 0x1c,\\n  'keccak-512': 0x1d,\\n  'blake3': 0x1e,\\n  'dccp': 0x21,\\n  'murmur3-128': 0x22,\\n  'murmur3-32': 0x23,\\n  'ip6': 0x29,\\n  'ip6zone': 0x2a,\\n  'path': 0x2f,\\n  'multicodec': 0x30,\\n  'multihash': 0x31,\\n  'multiaddr': 0x32,\\n  'multibase': 0x33,\\n  'dns': 0x35,\\n  'dns4': 0x36,\\n  'dns6': 0x37,\\n  'dnsaddr': 0x38,\\n  'protobuf': 0x50,\\n  'cbor': 0x51,\\n  'raw': 0x55,\\n  'dbl-sha2-256': 0x56,\\n  'rlp': 0x60,\\n  'bencode': 0x63,\\n  'dag-pb': 0x70,\\n  'dag-cbor': 0x71,\\n  'libp2p-key': 0x72,\\n  'git-raw': 0x78,\\n  'torrent-info': 0x7b,\\n  'torrent-file': 0x7c,\\n  'leofcoin-block': 0x81,\\n  'leofcoin-tx': 0x82,\\n  'leofcoin-pr': 0x83,\\n  'sctp': 0x84,\\n  'dag-jose': 0x85,\\n  'dag-cose': 0x86,\\n  'eth-block': 0x90,\\n  'eth-block-list': 0x91,\\n  'eth-tx-trie': 0x92,\\n  'eth-tx': 0x93,\\n  'eth-tx-receipt-trie': 0x94,\\n  'eth-tx-receipt': 0x95,\\n  'eth-state-trie': 0x96,\\n  'eth-account-snapshot': 0x97,\\n  'eth-storage-trie': 0x98,\\n  'bitcoin-block': 0xb0,\\n  'bitcoin-tx': 0xb1,\\n  'bitcoin-witness-commitment': 0xb2,\\n  'zcash-block': 0xc0,\\n  'zcash-tx': 0xc1,\\n  'docid': 0xce,\\n  'stellar-block': 0xd0,\\n  'stellar-tx': 0xd1,\\n  'md4': 0xd4,\\n  'md5': 0xd5,\\n  'bmt': 0xd6,\\n  'decred-block': 0xe0,\\n  'decred-tx': 0xe1,\\n  'ipld-ns': 0xe2,\\n  'ipfs-ns': 0xe3,\\n  'swarm-ns': 0xe4,\\n  'ipns-ns': 0xe5,\\n  'zeronet': 0xe6,\\n  'secp256k1-pub': 0xe7,\\n  'bls12_381-g1-pub': 0xea,\\n  'bls12_381-g2-pub': 0xeb,\\n  'x25519-pub': 0xec,\\n  'ed25519-pub': 0xed,\\n  'bls12_381-g1g2-pub': 0xee,\\n  'dash-block': 0xf0,\\n  'dash-tx': 0xf1,\\n  'swarm-manifest': 0xfa,\\n  'swarm-feed': 0xfb,\\n  'udp': 0x0111,\\n  'p2p-webrtc-star': 0x0113,\\n  'p2p-webrtc-direct': 0x0114,\\n  'p2p-stardust': 0x0115,\\n  'p2p-circuit': 0x0122,\\n  'dag-json': 0x0129,\\n  'udt': 0x012d,\\n  'utp': 0x012e,\\n  'unix': 0x0190,\\n  'p2p': 0x01a5,\\n  'ipfs': 0x01a5,\\n  'https': 0x01bb,\\n  'onion': 0x01bc,\\n  'onion3': 0x01bd,\\n  'garlic64': 0x01be,\\n  'garlic32': 0x01bf,\\n  'tls': 0x01c0,\\n  'quic': 0x01cc,\\n  'ws': 0x01dd,\\n  'wss': 0x01de,\\n  'p2p-websocket-star': 0x01df,\\n  'http': 0x01e0,\\n  'json': 0x0200,\\n  'messagepack': 0x0201,\\n  'libp2p-peer-record': 0x0301,\\n  'sha2-256-trunc254-padded': 0x1012,\\n  'ripemd-128': 0x1052,\\n  'ripemd-160': 0x1053,\\n  'ripemd-256': 0x1054,\\n  'ripemd-320': 0x1055,\\n  'x11': 0x1100,\\n  'p256-pub': 0x1200,\\n  'p384-pub': 0x1201,\\n  'p521-pub': 0x1202,\\n  'ed448-pub': 0x1203,\\n  'x448-pub': 0x1204,\\n  'ed25519-priv': 0x1300,\\n  'kangarootwelve': 0x1d01,\\n  'sm3-256': 0x534d,\\n  'blake2b-8': 0xb201,\\n  'blake2b-16': 0xb202,\\n  'blake2b-24': 0xb203,\\n  'blake2b-32': 0xb204,\\n  'blake2b-40': 0xb205,\\n  'blake2b-48': 0xb206,\\n  'blake2b-56': 0xb207,\\n  'blake2b-64': 0xb208,\\n  'blake2b-72': 0xb209,\\n  'blake2b-80': 0xb20a,\\n  'blake2b-88': 0xb20b,\\n  'blake2b-96': 0xb20c,\\n  'blake2b-104': 0xb20d,\\n  'blake2b-112': 0xb20e,\\n  'blake2b-120': 0xb20f,\\n  'blake2b-128': 0xb210,\\n  'blake2b-136': 0xb211,\\n  'blake2b-144': 0xb212,\\n  'blake2b-152': 0xb213,\\n  'blake2b-160': 0xb214,\\n  'blake2b-168': 0xb215,\\n  'blake2b-176': 0xb216,\\n  'blake2b-184': 0xb217,\\n  'blake2b-192': 0xb218,\\n  'blake2b-200': 0xb219,\\n  'blake2b-208': 0xb21a,\\n  'blake2b-216': 0xb21b,\\n  'blake2b-224': 0xb21c,\\n  'blake2b-232': 0xb21d,\\n  'blake2b-240': 0xb21e,\\n  'blake2b-248': 0xb21f,\\n  'blake2b-256': 0xb220,\\n  'blake2b-264': 0xb221,\\n  'blake2b-272': 0xb222,\\n  'blake2b-280': 0xb223,\\n  'blake2b-288': 0xb224,\\n  'blake2b-296': 0xb225,\\n  'blake2b-304': 0xb226,\\n  'blake2b-312': 0xb227,\\n  'blake2b-320': 0xb228,\\n  'blake2b-328': 0xb229,\\n  'blake2b-336': 0xb22a,\\n  'blake2b-344': 0xb22b,\\n  'blake2b-352': 0xb22c,\\n  'blake2b-360': 0xb22d,\\n  'blake2b-368': 0xb22e,\\n  'blake2b-376': 0xb22f,\\n  'blake2b-384': 0xb230,\\n  'blake2b-392': 0xb231,\\n  'blake2b-400': 0xb232,\\n  'blake2b-408': 0xb233,\\n  'blake2b-416': 0xb234,\\n  'blake2b-424': 0xb235,\\n  'blake2b-432': 0xb236,\\n  'blake2b-440': 0xb237,\\n  'blake2b-448': 0xb238,\\n  'blake2b-456': 0xb239,\\n  'blake2b-464': 0xb23a,\\n  'blake2b-472': 0xb23b,\\n  'blake2b-480': 0xb23c,\\n  'blake2b-488': 0xb23d,\\n  'blake2b-496': 0xb23e,\\n  'blake2b-504': 0xb23f,\\n  'blake2b-512': 0xb240,\\n  'blake2s-8': 0xb241,\\n  'blake2s-16': 0xb242,\\n  'blake2s-24': 0xb243,\\n  'blake2s-32': 0xb244,\\n  'blake2s-40': 0xb245,\\n  'blake2s-48': 0xb246,\\n  'blake2s-56': 0xb247,\\n  'blake2s-64': 0xb248,\\n  'blake2s-72': 0xb249,\\n  'blake2s-80': 0xb24a,\\n  'blake2s-88': 0xb24b,\\n  'blake2s-96': 0xb24c,\\n  'blake2s-104': 0xb24d,\\n  'blake2s-112': 0xb24e,\\n  'blake2s-120': 0xb24f,\\n  'blake2s-128': 0xb250,\\n  'blake2s-136': 0xb251,\\n  'blake2s-144': 0xb252,\\n  'blake2s-152': 0xb253,\\n  'blake2s-160': 0xb254,\\n  'blake2s-168': 0xb255,\\n  'blake2s-176': 0xb256,\\n  'blake2s-184': 0xb257,\\n  'blake2s-192': 0xb258,\\n  'blake2s-200': 0xb259,\\n  'blake2s-208': 0xb25a,\\n  'blake2s-216': 0xb25b,\\n  'blake2s-224': 0xb25c,\\n  'blake2s-232': 0xb25d,\\n  'blake2s-240': 0xb25e,\\n  'blake2s-248': 0xb25f,\\n  'blake2s-256': 0xb260,\\n  'skein256-8': 0xb301,\\n  'skein256-16': 0xb302,\\n  'skein256-24': 0xb303,\\n  'skein256-32': 0xb304,\\n  'skein256-40': 0xb305,\\n  'skein256-48': 0xb306,\\n  'skein256-56': 0xb307,\\n  'skein256-64': 0xb308,\\n  'skein256-72': 0xb309,\\n  'skein256-80': 0xb30a,\\n  'skein256-88': 0xb30b,\\n  'skein256-96': 0xb30c,\\n  'skein256-104': 0xb30d,\\n  'skein256-112': 0xb30e,\\n  'skein256-120': 0xb30f,\\n  'skein256-128': 0xb310,\\n  'skein256-136': 0xb311,\\n  'skein256-144': 0xb312,\\n  'skein256-152': 0xb313,\\n  'skein256-160': 0xb314,\\n  'skein256-168': 0xb315,\\n  'skein256-176': 0xb316,\\n  'skein256-184': 0xb317,\\n  'skein256-192': 0xb318,\\n  'skein256-200': 0xb319,\\n  'skein256-208': 0xb31a,\\n  'skein256-216': 0xb31b,\\n  'skein256-224': 0xb31c,\\n  'skein256-232': 0xb31d,\\n  'skein256-240': 0xb31e,\\n  'skein256-248': 0xb31f,\\n  'skein256-256': 0xb320,\\n  'skein512-8': 0xb321,\\n  'skein512-16': 0xb322,\\n  'skein512-24': 0xb323,\\n  'skein512-32': 0xb324,\\n  'skein512-40': 0xb325,\\n  'skein512-48': 0xb326,\\n  'skein512-56': 0xb327,\\n  'skein512-64': 0xb328,\\n  'skein512-72': 0xb329,\\n  'skein512-80': 0xb32a,\\n  'skein512-88': 0xb32b,\\n  'skein512-96': 0xb32c,\\n  'skein512-104': 0xb32d,\\n  'skein512-112': 0xb32e,\\n  'skein512-120': 0xb32f,\\n  'skein512-128': 0xb330,\\n  'skein512-136': 0xb331,\\n  'skein512-144': 0xb332,\\n  'skein512-152': 0xb333,\\n  'skein512-160': 0xb334,\\n  'skein512-168': 0xb335,\\n  'skein512-176': 0xb336,\\n  'skein512-184': 0xb337,\\n  'skein512-192': 0xb338,\\n  'skein512-200': 0xb339,\\n  'skein512-208': 0xb33a,\\n  'skein512-216': 0xb33b,\\n  'skein512-224': 0xb33c,\\n  'skein512-232': 0xb33d,\\n  'skein512-240': 0xb33e,\\n  'skein512-248': 0xb33f,\\n  'skein512-256': 0xb340,\\n  'skein512-264': 0xb341,\\n  'skein512-272': 0xb342,\\n  'skein512-280': 0xb343,\\n  'skein512-288': 0xb344,\\n  'skein512-296': 0xb345,\\n  'skein512-304': 0xb346,\\n  'skein512-312': 0xb347,\\n  'skein512-320': 0xb348,\\n  'skein512-328': 0xb349,\\n  'skein512-336': 0xb34a,\\n  'skein512-344': 0xb34b,\\n  'skein512-352': 0xb34c,\\n  'skein512-360': 0xb34d,\\n  'skein512-368': 0xb34e,\\n  'skein512-376': 0xb34f,\\n  'skein512-384': 0xb350,\\n  'skein512-392': 0xb351,\\n  'skein512-400': 0xb352,\\n  'skein512-408': 0xb353,\\n  'skein512-416': 0xb354,\\n  'skein512-424': 0xb355,\\n  'skein512-432': 0xb356,\\n  'skein512-440': 0xb357,\\n  'skein512-448': 0xb358,\\n  'skein512-456': 0xb359,\\n  'skein512-464': 0xb35a,\\n  'skein512-472': 0xb35b,\\n  'skein512-480': 0xb35c,\\n  'skein512-488': 0xb35d,\\n  'skein512-496': 0xb35e,\\n  'skein512-504': 0xb35f,\\n  'skein512-512': 0xb360,\\n  'skein1024-8': 0xb361,\\n  'skein1024-16': 0xb362,\\n  'skein1024-24': 0xb363,\\n  'skein1024-32': 0xb364,\\n  'skein1024-40': 0xb365,\\n  'skein1024-48': 0xb366,\\n  'skein1024-56': 0xb367,\\n  'skein1024-64': 0xb368,\\n  'skein1024-72': 0xb369,\\n  'skein1024-80': 0xb36a,\\n  'skein1024-88': 0xb36b,\\n  'skein1024-96': 0xb36c,\\n  'skein1024-104': 0xb36d,\\n  'skein1024-112': 0xb36e,\\n  'skein1024-120': 0xb36f,\\n  'skein1024-128': 0xb370,\\n  'skein1024-136': 0xb371,\\n  'skein1024-144': 0xb372,\\n  'skein1024-152': 0xb373,\\n  'skein1024-160': 0xb374,\\n  'skein1024-168': 0xb375,\\n  'skein1024-176': 0xb376,\\n  'skein1024-184': 0xb377,\\n  'skein1024-192': 0xb378,\\n  'skein1024-200': 0xb379,\\n  'skein1024-208': 0xb37a,\\n  'skein1024-216': 0xb37b,\\n  'skein1024-224': 0xb37c,\\n  'skein1024-232': 0xb37d,\\n  'skein1024-240': 0xb37e,\\n  'skein1024-248': 0xb37f,\\n  'skein1024-256': 0xb380,\\n  'skein1024-264': 0xb381,\\n  'skein1024-272': 0xb382,\\n  'skein1024-280': 0xb383,\\n  'skein1024-288': 0xb384,\\n  'skein1024-296': 0xb385,\\n  'skein1024-304': 0xb386,\\n  'skein1024-312': 0xb387,\\n  'skein1024-320': 0xb388,\\n  'skein1024-328': 0xb389,\\n  'skein1024-336': 0xb38a,\\n  'skein1024-344': 0xb38b,\\n  'skein1024-352': 0xb38c,\\n  'skein1024-360': 0xb38d,\\n  'skein1024-368': 0xb38e,\\n  'skein1024-376': 0xb38f,\\n  'skein1024-384': 0xb390,\\n  'skein1024-392': 0xb391,\\n  'skein1024-400': 0xb392,\\n  'skein1024-408': 0xb393,\\n  'skein1024-416': 0xb394,\\n  'skein1024-424': 0xb395,\\n  'skein1024-432': 0xb396,\\n  'skein1024-440': 0xb397,\\n  'skein1024-448': 0xb398,\\n  'skein1024-456': 0xb399,\\n  'skein1024-464': 0xb39a,\\n  'skein1024-472': 0xb39b,\\n  'skein1024-480': 0xb39c,\\n  'skein1024-488': 0xb39d,\\n  'skein1024-496': 0xb39e,\\n  'skein1024-504': 0xb39f,\\n  'skein1024-512': 0xb3a0,\\n  'skein1024-520': 0xb3a1,\\n  'skein1024-528': 0xb3a2,\\n  'skein1024-536': 0xb3a3,\\n  'skein1024-544': 0xb3a4,\\n  'skein1024-552': 0xb3a5,\\n  'skein1024-560': 0xb3a6,\\n  'skein1024-568': 0xb3a7,\\n  'skein1024-576': 0xb3a8,\\n  'skein1024-584': 0xb3a9,\\n  'skein1024-592': 0xb3aa,\\n  'skein1024-600': 0xb3ab,\\n  'skein1024-608': 0xb3ac,\\n  'skein1024-616': 0xb3ad,\\n  'skein1024-624': 0xb3ae,\\n  'skein1024-632': 0xb3af,\\n  'skein1024-640': 0xb3b0,\\n  'skein1024-648': 0xb3b1,\\n  'skein1024-656': 0xb3b2,\\n  'skein1024-664': 0xb3b3,\\n  'skein1024-672': 0xb3b4,\\n  'skein1024-680': 0xb3b5,\\n  'skein1024-688': 0xb3b6,\\n  'skein1024-696': 0xb3b7,\\n  'skein1024-704': 0xb3b8,\\n  'skein1024-712': 0xb3b9,\\n  'skein1024-720': 0xb3ba,\\n  'skein1024-728': 0xb3bb,\\n  'skein1024-736': 0xb3bc,\\n  'skein1024-744': 0xb3bd,\\n  'skein1024-752': 0xb3be,\\n  'skein1024-760': 0xb3bf,\\n  'skein1024-768': 0xb3c0,\\n  'skein1024-776': 0xb3c1,\\n  'skein1024-784': 0xb3c2,\\n  'skein1024-792': 0xb3c3,\\n  'skein1024-800': 0xb3c4,\\n  'skein1024-808': 0xb3c5,\\n  'skein1024-816': 0xb3c6,\\n  'skein1024-824': 0xb3c7,\\n  'skein1024-832': 0xb3c8,\\n  'skein1024-840': 0xb3c9,\\n  'skein1024-848': 0xb3ca,\\n  'skein1024-856': 0xb3cb,\\n  'skein1024-864': 0xb3cc,\\n  'skein1024-872': 0xb3cd,\\n  'skein1024-880': 0xb3ce,\\n  'skein1024-888': 0xb3cf,\\n  'skein1024-896': 0xb3d0,\\n  'skein1024-904': 0xb3d1,\\n  'skein1024-912': 0xb3d2,\\n  'skein1024-920': 0xb3d3,\\n  'skein1024-928': 0xb3d4,\\n  'skein1024-936': 0xb3d5,\\n  'skein1024-944': 0xb3d6,\\n  'skein1024-952': 0xb3d7,\\n  'skein1024-960': 0xb3d8,\\n  'skein1024-968': 0xb3d9,\\n  'skein1024-976': 0xb3da,\\n  'skein1024-984': 0xb3db,\\n  'skein1024-992': 0xb3dc,\\n  'skein1024-1000': 0xb3dd,\\n  'skein1024-1008': 0xb3de,\\n  'skein1024-1016': 0xb3df,\\n  'skein1024-1024': 0xb3e0,\\n  'poseidon-bls12_381-a2-fc1': 0xb401,\\n  'poseidon-bls12_381-a2-fc1-sc': 0xb402,\\n  'zeroxcert-imprint-256': 0xce11,\\n  'fil-commitment-unsealed': 0xf101,\\n  'fil-commitment-sealed': 0xf102,\\n  'holochain-adr-v0': 0x807124,\\n  'holochain-adr-v1': 0x817124,\\n  'holochain-key-v0': 0x947124,\\n  'holochain-key-v1': 0x957124,\\n  'holochain-sig-v0': 0xa27124,\\n  'holochain-sig-v1': 0xa37124,\\n  'skynet-ns': 0xb19910\\n})\\n\\nmodule.exports = { baseTable }\\n\\n},{}],175:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./generated-types').ConstantNumberMap} ConstantNumberMap */\\n\\nconst { baseTable } = require('./base-table')\\n\\nconst constants = /** @type {ConstantNumberMap} */({})\\n\\nfor (const [name, code] of Object.entries(baseTable)) {\\n  const constant = name.toUpperCase().replace(/-/g, '_')\\n  constants[constant] = code\\n}\\n\\nmodule.exports = Object.freeze(constants)\\n\\n},{\\\"./base-table\\\":174}],176:[function(require,module,exports){\\n/**\\n * Implementation of the multicodec specification.\\n *\\n * @module multicodec\\n * @example\\n * const multicodec = require('multicodec')\\n *\\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\\n * // prefixedProtobuf 0x50...\\n *\\n */\\n'use strict'\\n\\n/** @typedef {import('./generated-types').CodecName} CodecName */\\n/** @typedef {import('./generated-types').CodecNumber} CodecNumber */\\n\\nconst varint = require('varint')\\nconst intTable = require('./int-table')\\nconst codecNameToCodeVarint = require('./varint-table')\\nconst util = require('./util')\\nconst uint8ArrayConcat = require('uint8arrays/concat')\\n\\n/**\\n * Prefix a buffer with a multicodec-packed.\\n *\\n * @param {CodecName|Uint8Array} multicodecStrOrCode\\n * @param {Uint8Array} data\\n * @returns {Uint8Array}\\n */\\nfunction addPrefix (multicodecStrOrCode, data) {\\n  let prefix\\n\\n  if (multicodecStrOrCode instanceof Uint8Array) {\\n    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)\\n  } else {\\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\\n      prefix = codecNameToCodeVarint[multicodecStrOrCode]\\n    } else {\\n      throw new Error('multicodec not recognized')\\n    }\\n  }\\n  return uint8ArrayConcat([prefix, data], prefix.length + data.length)\\n}\\n\\n/**\\n * Decapsulate the multicodec-packed prefix from the data.\\n *\\n * @param {Uint8Array} data\\n * @returns {Uint8Array}\\n */\\nfunction rmPrefix (data) {\\n  varint.decode(data)\\n  return data.slice(varint.decode.bytes)\\n}\\n\\n/**\\n * Get the codec of the prefixed data.\\n *\\n * @param {Uint8Array} prefixedData\\n * @returns {CodecName}\\n */\\nfunction getCodec (prefixedData) {\\n  const code = varint.decode(prefixedData)\\n  const codecName = intTable.get(code)\\n  if (codecName === undefined) {\\n    throw new Error(`Code ${code} not found`)\\n  }\\n  return codecName\\n}\\n\\n/**\\n * Get the name of the codec.\\n *\\n * @param {CodecNumber} codec\\n * @returns {CodecName|undefined}\\n */\\nfunction getName (codec) {\\n  return intTable.get(codec)\\n}\\n\\n/**\\n * Get the code of the codec\\n *\\n * @param {CodecName} name\\n * @returns {CodecNumber}\\n */\\nfunction getNumber (name) {\\n  const code = codecNameToCodeVarint[name]\\n  if (code === undefined) {\\n    throw new Error('Codec `' + name + '` not found')\\n  }\\n  return varint.decode(code)\\n}\\n\\n/**\\n * Get the code of the prefixed data.\\n *\\n * @param {Uint8Array} prefixedData\\n * @returns {CodecNumber}\\n */\\nfunction getCode (prefixedData) {\\n  return varint.decode(prefixedData)\\n}\\n\\n/**\\n * Get the code as varint of a codec name.\\n *\\n * @param {CodecName} codecName\\n * @returns {Uint8Array}\\n */\\nfunction getCodeVarint (codecName) {\\n  const code = codecNameToCodeVarint[codecName]\\n  if (code === undefined) {\\n    throw new Error('Codec `' + codecName + '` not found')\\n  }\\n  return code\\n}\\n\\n/**\\n * Get the varint of a code.\\n *\\n * @param {CodecNumber} code\\n * @returns {Array.<number>}\\n */\\nfunction getVarint (code) {\\n  return varint.encode(code)\\n}\\n\\n// Make the constants top-level constants\\nconst constants = require('./constants')\\n\\n// Human friendly names for printing, e.g. in error messages\\nconst print = require('./print')\\n\\nmodule.exports = {\\n  addPrefix,\\n  rmPrefix,\\n  getCodec,\\n  getName,\\n  getNumber,\\n  getCode,\\n  getCodeVarint,\\n  getVarint,\\n  print,\\n  ...constants\\n}\\n\\n},{\\\"./constants\\\":175,\\\"./int-table\\\":177,\\\"./print\\\":178,\\\"./util\\\":179,\\\"./varint-table\\\":180,\\\"uint8arrays/concat\\\":167,\\\"varint\\\":172}],177:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./generated-types').CodecName} CodecName */\\n/** @typedef {import('./generated-types').CodecNumber} CodecNumber */\\n\\nconst { baseTable } = require('./base-table')\\n\\n/**\\n * @type {Map<CodecNumber,CodecName>}\\n */\\nconst nameTable = new Map()\\n\\nfor (const encodingName in baseTable) {\\n  const code = baseTable[encodingName]\\n  nameTable.set(code, /** @type {CodecName} */(encodingName))\\n}\\n\\nmodule.exports = Object.freeze(nameTable)\\n\\n},{\\\"./base-table\\\":174}],178:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./generated-types').CodecName} CodecName */\\n/** @typedef {import('./generated-types').NumberNameMap} NumberNameMap */\\n\\nconst { baseTable } = require('./base-table')\\n\\nconst tableByCode = /** @type {NumberNameMap} */({})\\n\\nfor (const [name, code] of Object.entries(baseTable)) {\\n  if (tableByCode[code] === undefined) {\\n    tableByCode[code] = /** @type {CodecName} **/(name)\\n  }\\n}\\n\\nmodule.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))\\n\\n},{\\\"./base-table\\\":174}],179:[function(require,module,exports){\\n'use strict'\\n\\nconst varint = require('varint')\\nconst uint8ArrayToString = require('uint8arrays/to-string')\\nconst uint8ArrayFromString = require('uint8arrays/from-string')\\n\\nmodule.exports = {\\n  numberToUint8Array,\\n  uint8ArrayToNumber,\\n  varintUint8ArrayEncode,\\n  varintEncode\\n}\\n\\nfunction uint8ArrayToNumber (buf) {\\n  return parseInt(uint8ArrayToString(buf, 'base16'), 16)\\n}\\n\\nfunction numberToUint8Array (num) {\\n  let hexString = num.toString(16)\\n  if (hexString.length % 2 === 1) {\\n    hexString = '0' + hexString\\n  }\\n  return uint8ArrayFromString(hexString, 'base16')\\n}\\n\\nfunction varintUint8ArrayEncode (input) {\\n  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))\\n}\\n\\nfunction varintEncode (num) {\\n  return Uint8Array.from(varint.encode(num))\\n}\\n\\n},{\\\"uint8arrays/from-string\\\":168,\\\"uint8arrays/to-string\\\":169,\\\"varint\\\":172}],180:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */\\n\\nconst { baseTable } = require('./base-table')\\nconst varintEncode = require('./util').varintEncode\\n\\nconst varintTable = /** @type {NameUint8ArrayMap} */ ({})\\n\\nfor (const encodingName in baseTable) {\\n  const code = baseTable[encodingName]\\n  varintTable[encodingName] = varintEncode(code)\\n}\\n\\nmodule.exports = Object.freeze(varintTable)\\n\\n},{\\\"./base-table\\\":174,\\\"./util\\\":179}],181:[function(require,module,exports){\\narguments[4][8][0].apply(exports,arguments)\\n},{\\\"dup\\\":8}],182:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst { TextEncoder } = require('web-encoding')\\nconst utf8Encoder = new TextEncoder()\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName} BaseName\\n */\\n\\n/**\\n * Interprets each character in a string as a byte and\\n * returns a Uint8Array of those bytes.\\n *\\n * @param {string} string - The string to turn into an array\\n * @returns {Uint8Array}\\n */\\nfunction asciiStringToUint8Array (string) {\\n  const array = new Uint8Array(string.length)\\n\\n  for (let i = 0; i < string.length; i++) {\\n    array[i] = string.charCodeAt(i)\\n  }\\n\\n  return array\\n}\\n\\n/**\\n * Create a `Uint8Array` from the passed string\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {string} string\\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc\\n * @returns {Uint8Array}\\n */\\nfunction fromString (string, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Encoder.encode(string)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return asciiStringToUint8Array(string)\\n  }\\n\\n  return getCodec(encoding).decode(string)\\n}\\n\\nmodule.exports = fromString\\n\\n},{\\\"multibase\\\":164,\\\"web-encoding\\\":201}],183:[function(require,module,exports){\\narguments[4][10][0].apply(exports,arguments)\\n},{\\\"dup\\\":10,\\\"multibase\\\":164,\\\"web-encoding\\\":201}],184:[function(require,module,exports){\\narguments[4][170][0].apply(exports,arguments)\\n},{\\\"dup\\\":170}],185:[function(require,module,exports){\\narguments[4][171][0].apply(exports,arguments)\\n},{\\\"dup\\\":171}],186:[function(require,module,exports){\\narguments[4][172][0].apply(exports,arguments)\\n},{\\\"./decode.js\\\":184,\\\"./encode.js\\\":185,\\\"./length.js\\\":187,\\\"dup\\\":172}],187:[function(require,module,exports){\\narguments[4][173][0].apply(exports,arguments)\\n},{\\\"dup\\\":173}],188:[function(require,module,exports){\\n/* eslint quote-props: off */\\n'use strict'\\n\\n/**\\n * Names for all available hashes\\n *\\n * @typedef { \\\"identity\\\" | \\\"sha1\\\" | \\\"sha2-256\\\" | \\\"sha2-512\\\" | \\\"sha3-512\\\" | \\\"sha3-384\\\" | \\\"sha3-256\\\" | \\\"sha3-224\\\" | \\\"shake-128\\\" | \\\"shake-256\\\" | \\\"keccak-224\\\" | \\\"keccak-256\\\" | \\\"keccak-384\\\" | \\\"keccak-512\\\" | \\\"blake3\\\" | \\\"murmur3-128\\\" | \\\"murmur3-32\\\" | \\\"dbl-sha2-256\\\" | \\\"md4\\\" | \\\"md5\\\" | \\\"bmt\\\" | \\\"sha2-256-trunc254-padded\\\" | \\\"ripemd-128\\\" | \\\"ripemd-160\\\" | \\\"ripemd-256\\\" | \\\"ripemd-320\\\" | \\\"x11\\\" | \\\"kangarootwelve\\\" | \\\"sm3-256\\\" | \\\"blake2b-8\\\" | \\\"blake2b-16\\\" | \\\"blake2b-24\\\" | \\\"blake2b-32\\\" | \\\"blake2b-40\\\" | \\\"blake2b-48\\\" | \\\"blake2b-56\\\" | \\\"blake2b-64\\\" | \\\"blake2b-72\\\" | \\\"blake2b-80\\\" | \\\"blake2b-88\\\" | \\\"blake2b-96\\\" | \\\"blake2b-104\\\" | \\\"blake2b-112\\\" | \\\"blake2b-120\\\" | \\\"blake2b-128\\\" | \\\"blake2b-136\\\" | \\\"blake2b-144\\\" | \\\"blake2b-152\\\" | \\\"blake2b-160\\\" | \\\"blake2b-168\\\" | \\\"blake2b-176\\\" | \\\"blake2b-184\\\" | \\\"blake2b-192\\\" | \\\"blake2b-200\\\" | \\\"blake2b-208\\\" | \\\"blake2b-216\\\" | \\\"blake2b-224\\\" | \\\"blake2b-232\\\" | \\\"blake2b-240\\\" | \\\"blake2b-248\\\" | \\\"blake2b-256\\\" | \\\"blake2b-264\\\" | \\\"blake2b-272\\\" | \\\"blake2b-280\\\" | \\\"blake2b-288\\\" | \\\"blake2b-296\\\" | \\\"blake2b-304\\\" | \\\"blake2b-312\\\" | \\\"blake2b-320\\\" | \\\"blake2b-328\\\" | \\\"blake2b-336\\\" | \\\"blake2b-344\\\" | \\\"blake2b-352\\\" | \\\"blake2b-360\\\" | \\\"blake2b-368\\\" | \\\"blake2b-376\\\" | \\\"blake2b-384\\\" | \\\"blake2b-392\\\" | \\\"blake2b-400\\\" | \\\"blake2b-408\\\" | \\\"blake2b-416\\\" | \\\"blake2b-424\\\" | \\\"blake2b-432\\\" | \\\"blake2b-440\\\" | \\\"blake2b-448\\\" | \\\"blake2b-456\\\" | \\\"blake2b-464\\\" | \\\"blake2b-472\\\" | \\\"blake2b-480\\\" | \\\"blake2b-488\\\" | \\\"blake2b-496\\\" | \\\"blake2b-504\\\" | \\\"blake2b-512\\\" | \\\"blake2s-8\\\" | \\\"blake2s-16\\\" | \\\"blake2s-24\\\" | \\\"blake2s-32\\\" | \\\"blake2s-40\\\" | \\\"blake2s-48\\\" | \\\"blake2s-56\\\" | \\\"blake2s-64\\\" | \\\"blake2s-72\\\" | \\\"blake2s-80\\\" | \\\"blake2s-88\\\" | \\\"blake2s-96\\\" | \\\"blake2s-104\\\" | \\\"blake2s-112\\\" | \\\"blake2s-120\\\" | \\\"blake2s-128\\\" | \\\"blake2s-136\\\" | \\\"blake2s-144\\\" | \\\"blake2s-152\\\" | \\\"blake2s-160\\\" | \\\"blake2s-168\\\" | \\\"blake2s-176\\\" | \\\"blake2s-184\\\" | \\\"blake2s-192\\\" | \\\"blake2s-200\\\" | \\\"blake2s-208\\\" | \\\"blake2s-216\\\" | \\\"blake2s-224\\\" | \\\"blake2s-232\\\" | \\\"blake2s-240\\\" | \\\"blake2s-248\\\" | \\\"blake2s-256\\\" | \\\"skein256-8\\\" | \\\"skein256-16\\\" | \\\"skein256-24\\\" | \\\"skein256-32\\\" | \\\"skein256-40\\\" | \\\"skein256-48\\\" | \\\"skein256-56\\\" | \\\"skein256-64\\\" | \\\"skein256-72\\\" | \\\"skein256-80\\\" | \\\"skein256-88\\\" | \\\"skein256-96\\\" | \\\"skein256-104\\\" | \\\"skein256-112\\\" | \\\"skein256-120\\\" | \\\"skein256-128\\\" | \\\"skein256-136\\\" | \\\"skein256-144\\\" | \\\"skein256-152\\\" | \\\"skein256-160\\\" | \\\"skein256-168\\\" | \\\"skein256-176\\\" | \\\"skein256-184\\\" | \\\"skein256-192\\\" | \\\"skein256-200\\\" | \\\"skein256-208\\\" | \\\"skein256-216\\\" | \\\"skein256-224\\\" | \\\"skein256-232\\\" | \\\"skein256-240\\\" | \\\"skein256-248\\\" | \\\"skein256-256\\\" | \\\"skein512-8\\\" | \\\"skein512-16\\\" | \\\"skein512-24\\\" | \\\"skein512-32\\\" | \\\"skein512-40\\\" | \\\"skein512-48\\\" | \\\"skein512-56\\\" | \\\"skein512-64\\\" | \\\"skein512-72\\\" | \\\"skein512-80\\\" | \\\"skein512-88\\\" | \\\"skein512-96\\\" | \\\"skein512-104\\\" | \\\"skein512-112\\\" | \\\"skein512-120\\\" | \\\"skein512-128\\\" | \\\"skein512-136\\\" | \\\"skein512-144\\\" | \\\"skein512-152\\\" | \\\"skein512-160\\\" | \\\"skein512-168\\\" | \\\"skein512-176\\\" | \\\"skein512-184\\\" | \\\"skein512-192\\\" | \\\"skein512-200\\\" | \\\"skein512-208\\\" | \\\"skein512-216\\\" | \\\"skein512-224\\\" | \\\"skein512-232\\\" | \\\"skein512-240\\\" | \\\"skein512-248\\\" | \\\"skein512-256\\\" | \\\"skein512-264\\\" | \\\"skein512-272\\\" | \\\"skein512-280\\\" | \\\"skein512-288\\\" | \\\"skein512-296\\\" | \\\"skein512-304\\\" | \\\"skein512-312\\\" | \\\"skein512-320\\\" | \\\"skein512-328\\\" | \\\"skein512-336\\\" | \\\"skein512-344\\\" | \\\"skein512-352\\\" | \\\"skein512-360\\\" | \\\"skein512-368\\\" | \\\"skein512-376\\\" | \\\"skein512-384\\\" | \\\"skein512-392\\\" | \\\"skein512-400\\\" | \\\"skein512-408\\\" | \\\"skein512-416\\\" | \\\"skein512-424\\\" | \\\"skein512-432\\\" | \\\"skein512-440\\\" | \\\"skein512-448\\\" | \\\"skein512-456\\\" | \\\"skein512-464\\\" | \\\"skein512-472\\\" | \\\"skein512-480\\\" | \\\"skein512-488\\\" | \\\"skein512-496\\\" | \\\"skein512-504\\\" | \\\"skein512-512\\\" | \\\"skein1024-8\\\" | \\\"skein1024-16\\\" | \\\"skein1024-24\\\" | \\\"skein1024-32\\\" | \\\"skein1024-40\\\" | \\\"skein1024-48\\\" | \\\"skein1024-56\\\" | \\\"skein1024-64\\\" | \\\"skein1024-72\\\" | \\\"skein1024-80\\\" | \\\"skein1024-88\\\" | \\\"skein1024-96\\\" | \\\"skein1024-104\\\" | \\\"skein1024-112\\\" | \\\"skein1024-120\\\" | \\\"skein1024-128\\\" | \\\"skein1024-136\\\" | \\\"skein1024-144\\\" | \\\"skein1024-152\\\" | \\\"skein1024-160\\\" | \\\"skein1024-168\\\" | \\\"skein1024-176\\\" | \\\"skein1024-184\\\" | \\\"skein1024-192\\\" | \\\"skein1024-200\\\" | \\\"skein1024-208\\\" | \\\"skein1024-216\\\" | \\\"skein1024-224\\\" | \\\"skein1024-232\\\" | \\\"skein1024-240\\\" | \\\"skein1024-248\\\" | \\\"skein1024-256\\\" | \\\"skein1024-264\\\" | \\\"skein1024-272\\\" | \\\"skein1024-280\\\" | \\\"skein1024-288\\\" | \\\"skein1024-296\\\" | \\\"skein1024-304\\\" | \\\"skein1024-312\\\" | \\\"skein1024-320\\\" | \\\"skein1024-328\\\" | \\\"skein1024-336\\\" | \\\"skein1024-344\\\" | \\\"skein1024-352\\\" | \\\"skein1024-360\\\" | \\\"skein1024-368\\\" | \\\"skein1024-376\\\" | \\\"skein1024-384\\\" | \\\"skein1024-392\\\" | \\\"skein1024-400\\\" | \\\"skein1024-408\\\" | \\\"skein1024-416\\\" | \\\"skein1024-424\\\" | \\\"skein1024-432\\\" | \\\"skein1024-440\\\" | \\\"skein1024-448\\\" | \\\"skein1024-456\\\" | \\\"skein1024-464\\\" | \\\"skein1024-472\\\" | \\\"skein1024-480\\\" | \\\"skein1024-488\\\" | \\\"skein1024-496\\\" | \\\"skein1024-504\\\" | \\\"skein1024-512\\\" | \\\"skein1024-520\\\" | \\\"skein1024-528\\\" | \\\"skein1024-536\\\" | \\\"skein1024-544\\\" | \\\"skein1024-552\\\" | \\\"skein1024-560\\\" | \\\"skein1024-568\\\" | \\\"skein1024-576\\\" | \\\"skein1024-584\\\" | \\\"skein1024-592\\\" | \\\"skein1024-600\\\" | \\\"skein1024-608\\\" | \\\"skein1024-616\\\" | \\\"skein1024-624\\\" | \\\"skein1024-632\\\" | \\\"skein1024-640\\\" | \\\"skein1024-648\\\" | \\\"skein1024-656\\\" | \\\"skein1024-664\\\" | \\\"skein1024-672\\\" | \\\"skein1024-680\\\" | \\\"skein1024-688\\\" | \\\"skein1024-696\\\" | \\\"skein1024-704\\\" | \\\"skein1024-712\\\" | \\\"skein1024-720\\\" | \\\"skein1024-728\\\" | \\\"skein1024-736\\\" | \\\"skein1024-744\\\" | \\\"skein1024-752\\\" | \\\"skein1024-760\\\" | \\\"skein1024-768\\\" | \\\"skein1024-776\\\" | \\\"skein1024-784\\\" | \\\"skein1024-792\\\" | \\\"skein1024-800\\\" | \\\"skein1024-808\\\" | \\\"skein1024-816\\\" | \\\"skein1024-824\\\" | \\\"skein1024-832\\\" | \\\"skein1024-840\\\" | \\\"skein1024-848\\\" | \\\"skein1024-856\\\" | \\\"skein1024-864\\\" | \\\"skein1024-872\\\" | \\\"skein1024-880\\\" | \\\"skein1024-888\\\" | \\\"skein1024-896\\\" | \\\"skein1024-904\\\" | \\\"skein1024-912\\\" | \\\"skein1024-920\\\" | \\\"skein1024-928\\\" | \\\"skein1024-936\\\" | \\\"skein1024-944\\\" | \\\"skein1024-952\\\" | \\\"skein1024-960\\\" | \\\"skein1024-968\\\" | \\\"skein1024-976\\\" | \\\"skein1024-984\\\" | \\\"skein1024-992\\\" | \\\"skein1024-1000\\\" | \\\"skein1024-1008\\\" | \\\"skein1024-1016\\\" | \\\"skein1024-1024\\\" | \\\"poseidon-bls12_381-a2-fc1\\\" | \\\"poseidon-bls12_381-a2-fc1-sc\\\" } HashName\\n */\\n/**\\n * Codes for all available hashes\\n *\\n * @typedef { 0x00 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x1a | 0x1b | 0x1c | 0x1d | 0x1e | 0x22 | 0x23 | 0x56 | 0xd4 | 0xd5 | 0xd6 | 0x1012 | 0x1052 | 0x1053 | 0x1054 | 0x1055 | 0x1100 | 0x1d01 | 0x534d | 0xb201 | 0xb202 | 0xb203 | 0xb204 | 0xb205 | 0xb206 | 0xb207 | 0xb208 | 0xb209 | 0xb20a | 0xb20b | 0xb20c | 0xb20d | 0xb20e | 0xb20f | 0xb210 | 0xb211 | 0xb212 | 0xb213 | 0xb214 | 0xb215 | 0xb216 | 0xb217 | 0xb218 | 0xb219 | 0xb21a | 0xb21b | 0xb21c | 0xb21d | 0xb21e | 0xb21f | 0xb220 | 0xb221 | 0xb222 | 0xb223 | 0xb224 | 0xb225 | 0xb226 | 0xb227 | 0xb228 | 0xb229 | 0xb22a | 0xb22b | 0xb22c | 0xb22d | 0xb22e | 0xb22f | 0xb230 | 0xb231 | 0xb232 | 0xb233 | 0xb234 | 0xb235 | 0xb236 | 0xb237 | 0xb238 | 0xb239 | 0xb23a | 0xb23b | 0xb23c | 0xb23d | 0xb23e | 0xb23f | 0xb240 | 0xb241 | 0xb242 | 0xb243 | 0xb244 | 0xb245 | 0xb246 | 0xb247 | 0xb248 | 0xb249 | 0xb24a | 0xb24b | 0xb24c | 0xb24d | 0xb24e | 0xb24f | 0xb250 | 0xb251 | 0xb252 | 0xb253 | 0xb254 | 0xb255 | 0xb256 | 0xb257 | 0xb258 | 0xb259 | 0xb25a | 0xb25b | 0xb25c | 0xb25d | 0xb25e | 0xb25f | 0xb260 | 0xb301 | 0xb302 | 0xb303 | 0xb304 | 0xb305 | 0xb306 | 0xb307 | 0xb308 | 0xb309 | 0xb30a | 0xb30b | 0xb30c | 0xb30d | 0xb30e | 0xb30f | 0xb310 | 0xb311 | 0xb312 | 0xb313 | 0xb314 | 0xb315 | 0xb316 | 0xb317 | 0xb318 | 0xb319 | 0xb31a | 0xb31b | 0xb31c | 0xb31d | 0xb31e | 0xb31f | 0xb320 | 0xb321 | 0xb322 | 0xb323 | 0xb324 | 0xb325 | 0xb326 | 0xb327 | 0xb328 | 0xb329 | 0xb32a | 0xb32b | 0xb32c | 0xb32d | 0xb32e | 0xb32f | 0xb330 | 0xb331 | 0xb332 | 0xb333 | 0xb334 | 0xb335 | 0xb336 | 0xb337 | 0xb338 | 0xb339 | 0xb33a | 0xb33b | 0xb33c | 0xb33d | 0xb33e | 0xb33f | 0xb340 | 0xb341 | 0xb342 | 0xb343 | 0xb344 | 0xb345 | 0xb346 | 0xb347 | 0xb348 | 0xb349 | 0xb34a | 0xb34b | 0xb34c | 0xb34d | 0xb34e | 0xb34f | 0xb350 | 0xb351 | 0xb352 | 0xb353 | 0xb354 | 0xb355 | 0xb356 | 0xb357 | 0xb358 | 0xb359 | 0xb35a | 0xb35b | 0xb35c | 0xb35d | 0xb35e | 0xb35f | 0xb360 | 0xb361 | 0xb362 | 0xb363 | 0xb364 | 0xb365 | 0xb366 | 0xb367 | 0xb368 | 0xb369 | 0xb36a | 0xb36b | 0xb36c | 0xb36d | 0xb36e | 0xb36f | 0xb370 | 0xb371 | 0xb372 | 0xb373 | 0xb374 | 0xb375 | 0xb376 | 0xb377 | 0xb378 | 0xb379 | 0xb37a | 0xb37b | 0xb37c | 0xb37d | 0xb37e | 0xb37f | 0xb380 | 0xb381 | 0xb382 | 0xb383 | 0xb384 | 0xb385 | 0xb386 | 0xb387 | 0xb388 | 0xb389 | 0xb38a | 0xb38b | 0xb38c | 0xb38d | 0xb38e | 0xb38f | 0xb390 | 0xb391 | 0xb392 | 0xb393 | 0xb394 | 0xb395 | 0xb396 | 0xb397 | 0xb398 | 0xb399 | 0xb39a | 0xb39b | 0xb39c | 0xb39d | 0xb39e | 0xb39f | 0xb3a0 | 0xb3a1 | 0xb3a2 | 0xb3a3 | 0xb3a4 | 0xb3a5 | 0xb3a6 | 0xb3a7 | 0xb3a8 | 0xb3a9 | 0xb3aa | 0xb3ab | 0xb3ac | 0xb3ad | 0xb3ae | 0xb3af | 0xb3b0 | 0xb3b1 | 0xb3b2 | 0xb3b3 | 0xb3b4 | 0xb3b5 | 0xb3b6 | 0xb3b7 | 0xb3b8 | 0xb3b9 | 0xb3ba | 0xb3bb | 0xb3bc | 0xb3bd | 0xb3be | 0xb3bf | 0xb3c0 | 0xb3c1 | 0xb3c2 | 0xb3c3 | 0xb3c4 | 0xb3c5 | 0xb3c6 | 0xb3c7 | 0xb3c8 | 0xb3c9 | 0xb3ca | 0xb3cb | 0xb3cc | 0xb3cd | 0xb3ce | 0xb3cf | 0xb3d0 | 0xb3d1 | 0xb3d2 | 0xb3d3 | 0xb3d4 | 0xb3d5 | 0xb3d6 | 0xb3d7 | 0xb3d8 | 0xb3d9 | 0xb3da | 0xb3db | 0xb3dc | 0xb3dd | 0xb3de | 0xb3df | 0xb3e0 | 0xb401 | 0xb402 } HashCode\\n */\\n\\n/**\\n * @type { Record<HashName,HashCode> }\\n */\\nconst names = Object.freeze({\\n  'identity': 0x00,\\n  'sha1': 0x11,\\n  'sha2-256': 0x12,\\n  'sha2-512': 0x13,\\n  'sha3-512': 0x14,\\n  'sha3-384': 0x15,\\n  'sha3-256': 0x16,\\n  'sha3-224': 0x17,\\n  'shake-128': 0x18,\\n  'shake-256': 0x19,\\n  'keccak-224': 0x1a,\\n  'keccak-256': 0x1b,\\n  'keccak-384': 0x1c,\\n  'keccak-512': 0x1d,\\n  'blake3': 0x1e,\\n  'murmur3-128': 0x22,\\n  'murmur3-32': 0x23,\\n  'dbl-sha2-256': 0x56,\\n  'md4': 0xd4,\\n  'md5': 0xd5,\\n  'bmt': 0xd6,\\n  'sha2-256-trunc254-padded': 0x1012,\\n  'ripemd-128': 0x1052,\\n  'ripemd-160': 0x1053,\\n  'ripemd-256': 0x1054,\\n  'ripemd-320': 0x1055,\\n  'x11': 0x1100,\\n  'kangarootwelve': 0x1d01,\\n  'sm3-256': 0x534d,\\n  'blake2b-8': 0xb201,\\n  'blake2b-16': 0xb202,\\n  'blake2b-24': 0xb203,\\n  'blake2b-32': 0xb204,\\n  'blake2b-40': 0xb205,\\n  'blake2b-48': 0xb206,\\n  'blake2b-56': 0xb207,\\n  'blake2b-64': 0xb208,\\n  'blake2b-72': 0xb209,\\n  'blake2b-80': 0xb20a,\\n  'blake2b-88': 0xb20b,\\n  'blake2b-96': 0xb20c,\\n  'blake2b-104': 0xb20d,\\n  'blake2b-112': 0xb20e,\\n  'blake2b-120': 0xb20f,\\n  'blake2b-128': 0xb210,\\n  'blake2b-136': 0xb211,\\n  'blake2b-144': 0xb212,\\n  'blake2b-152': 0xb213,\\n  'blake2b-160': 0xb214,\\n  'blake2b-168': 0xb215,\\n  'blake2b-176': 0xb216,\\n  'blake2b-184': 0xb217,\\n  'blake2b-192': 0xb218,\\n  'blake2b-200': 0xb219,\\n  'blake2b-208': 0xb21a,\\n  'blake2b-216': 0xb21b,\\n  'blake2b-224': 0xb21c,\\n  'blake2b-232': 0xb21d,\\n  'blake2b-240': 0xb21e,\\n  'blake2b-248': 0xb21f,\\n  'blake2b-256': 0xb220,\\n  'blake2b-264': 0xb221,\\n  'blake2b-272': 0xb222,\\n  'blake2b-280': 0xb223,\\n  'blake2b-288': 0xb224,\\n  'blake2b-296': 0xb225,\\n  'blake2b-304': 0xb226,\\n  'blake2b-312': 0xb227,\\n  'blake2b-320': 0xb228,\\n  'blake2b-328': 0xb229,\\n  'blake2b-336': 0xb22a,\\n  'blake2b-344': 0xb22b,\\n  'blake2b-352': 0xb22c,\\n  'blake2b-360': 0xb22d,\\n  'blake2b-368': 0xb22e,\\n  'blake2b-376': 0xb22f,\\n  'blake2b-384': 0xb230,\\n  'blake2b-392': 0xb231,\\n  'blake2b-400': 0xb232,\\n  'blake2b-408': 0xb233,\\n  'blake2b-416': 0xb234,\\n  'blake2b-424': 0xb235,\\n  'blake2b-432': 0xb236,\\n  'blake2b-440': 0xb237,\\n  'blake2b-448': 0xb238,\\n  'blake2b-456': 0xb239,\\n  'blake2b-464': 0xb23a,\\n  'blake2b-472': 0xb23b,\\n  'blake2b-480': 0xb23c,\\n  'blake2b-488': 0xb23d,\\n  'blake2b-496': 0xb23e,\\n  'blake2b-504': 0xb23f,\\n  'blake2b-512': 0xb240,\\n  'blake2s-8': 0xb241,\\n  'blake2s-16': 0xb242,\\n  'blake2s-24': 0xb243,\\n  'blake2s-32': 0xb244,\\n  'blake2s-40': 0xb245,\\n  'blake2s-48': 0xb246,\\n  'blake2s-56': 0xb247,\\n  'blake2s-64': 0xb248,\\n  'blake2s-72': 0xb249,\\n  'blake2s-80': 0xb24a,\\n  'blake2s-88': 0xb24b,\\n  'blake2s-96': 0xb24c,\\n  'blake2s-104': 0xb24d,\\n  'blake2s-112': 0xb24e,\\n  'blake2s-120': 0xb24f,\\n  'blake2s-128': 0xb250,\\n  'blake2s-136': 0xb251,\\n  'blake2s-144': 0xb252,\\n  'blake2s-152': 0xb253,\\n  'blake2s-160': 0xb254,\\n  'blake2s-168': 0xb255,\\n  'blake2s-176': 0xb256,\\n  'blake2s-184': 0xb257,\\n  'blake2s-192': 0xb258,\\n  'blake2s-200': 0xb259,\\n  'blake2s-208': 0xb25a,\\n  'blake2s-216': 0xb25b,\\n  'blake2s-224': 0xb25c,\\n  'blake2s-232': 0xb25d,\\n  'blake2s-240': 0xb25e,\\n  'blake2s-248': 0xb25f,\\n  'blake2s-256': 0xb260,\\n  'skein256-8': 0xb301,\\n  'skein256-16': 0xb302,\\n  'skein256-24': 0xb303,\\n  'skein256-32': 0xb304,\\n  'skein256-40': 0xb305,\\n  'skein256-48': 0xb306,\\n  'skein256-56': 0xb307,\\n  'skein256-64': 0xb308,\\n  'skein256-72': 0xb309,\\n  'skein256-80': 0xb30a,\\n  'skein256-88': 0xb30b,\\n  'skein256-96': 0xb30c,\\n  'skein256-104': 0xb30d,\\n  'skein256-112': 0xb30e,\\n  'skein256-120': 0xb30f,\\n  'skein256-128': 0xb310,\\n  'skein256-136': 0xb311,\\n  'skein256-144': 0xb312,\\n  'skein256-152': 0xb313,\\n  'skein256-160': 0xb314,\\n  'skein256-168': 0xb315,\\n  'skein256-176': 0xb316,\\n  'skein256-184': 0xb317,\\n  'skein256-192': 0xb318,\\n  'skein256-200': 0xb319,\\n  'skein256-208': 0xb31a,\\n  'skein256-216': 0xb31b,\\n  'skein256-224': 0xb31c,\\n  'skein256-232': 0xb31d,\\n  'skein256-240': 0xb31e,\\n  'skein256-248': 0xb31f,\\n  'skein256-256': 0xb320,\\n  'skein512-8': 0xb321,\\n  'skein512-16': 0xb322,\\n  'skein512-24': 0xb323,\\n  'skein512-32': 0xb324,\\n  'skein512-40': 0xb325,\\n  'skein512-48': 0xb326,\\n  'skein512-56': 0xb327,\\n  'skein512-64': 0xb328,\\n  'skein512-72': 0xb329,\\n  'skein512-80': 0xb32a,\\n  'skein512-88': 0xb32b,\\n  'skein512-96': 0xb32c,\\n  'skein512-104': 0xb32d,\\n  'skein512-112': 0xb32e,\\n  'skein512-120': 0xb32f,\\n  'skein512-128': 0xb330,\\n  'skein512-136': 0xb331,\\n  'skein512-144': 0xb332,\\n  'skein512-152': 0xb333,\\n  'skein512-160': 0xb334,\\n  'skein512-168': 0xb335,\\n  'skein512-176': 0xb336,\\n  'skein512-184': 0xb337,\\n  'skein512-192': 0xb338,\\n  'skein512-200': 0xb339,\\n  'skein512-208': 0xb33a,\\n  'skein512-216': 0xb33b,\\n  'skein512-224': 0xb33c,\\n  'skein512-232': 0xb33d,\\n  'skein512-240': 0xb33e,\\n  'skein512-248': 0xb33f,\\n  'skein512-256': 0xb340,\\n  'skein512-264': 0xb341,\\n  'skein512-272': 0xb342,\\n  'skein512-280': 0xb343,\\n  'skein512-288': 0xb344,\\n  'skein512-296': 0xb345,\\n  'skein512-304': 0xb346,\\n  'skein512-312': 0xb347,\\n  'skein512-320': 0xb348,\\n  'skein512-328': 0xb349,\\n  'skein512-336': 0xb34a,\\n  'skein512-344': 0xb34b,\\n  'skein512-352': 0xb34c,\\n  'skein512-360': 0xb34d,\\n  'skein512-368': 0xb34e,\\n  'skein512-376': 0xb34f,\\n  'skein512-384': 0xb350,\\n  'skein512-392': 0xb351,\\n  'skein512-400': 0xb352,\\n  'skein512-408': 0xb353,\\n  'skein512-416': 0xb354,\\n  'skein512-424': 0xb355,\\n  'skein512-432': 0xb356,\\n  'skein512-440': 0xb357,\\n  'skein512-448': 0xb358,\\n  'skein512-456': 0xb359,\\n  'skein512-464': 0xb35a,\\n  'skein512-472': 0xb35b,\\n  'skein512-480': 0xb35c,\\n  'skein512-488': 0xb35d,\\n  'skein512-496': 0xb35e,\\n  'skein512-504': 0xb35f,\\n  'skein512-512': 0xb360,\\n  'skein1024-8': 0xb361,\\n  'skein1024-16': 0xb362,\\n  'skein1024-24': 0xb363,\\n  'skein1024-32': 0xb364,\\n  'skein1024-40': 0xb365,\\n  'skein1024-48': 0xb366,\\n  'skein1024-56': 0xb367,\\n  'skein1024-64': 0xb368,\\n  'skein1024-72': 0xb369,\\n  'skein1024-80': 0xb36a,\\n  'skein1024-88': 0xb36b,\\n  'skein1024-96': 0xb36c,\\n  'skein1024-104': 0xb36d,\\n  'skein1024-112': 0xb36e,\\n  'skein1024-120': 0xb36f,\\n  'skein1024-128': 0xb370,\\n  'skein1024-136': 0xb371,\\n  'skein1024-144': 0xb372,\\n  'skein1024-152': 0xb373,\\n  'skein1024-160': 0xb374,\\n  'skein1024-168': 0xb375,\\n  'skein1024-176': 0xb376,\\n  'skein1024-184': 0xb377,\\n  'skein1024-192': 0xb378,\\n  'skein1024-200': 0xb379,\\n  'skein1024-208': 0xb37a,\\n  'skein1024-216': 0xb37b,\\n  'skein1024-224': 0xb37c,\\n  'skein1024-232': 0xb37d,\\n  'skein1024-240': 0xb37e,\\n  'skein1024-248': 0xb37f,\\n  'skein1024-256': 0xb380,\\n  'skein1024-264': 0xb381,\\n  'skein1024-272': 0xb382,\\n  'skein1024-280': 0xb383,\\n  'skein1024-288': 0xb384,\\n  'skein1024-296': 0xb385,\\n  'skein1024-304': 0xb386,\\n  'skein1024-312': 0xb387,\\n  'skein1024-320': 0xb388,\\n  'skein1024-328': 0xb389,\\n  'skein1024-336': 0xb38a,\\n  'skein1024-344': 0xb38b,\\n  'skein1024-352': 0xb38c,\\n  'skein1024-360': 0xb38d,\\n  'skein1024-368': 0xb38e,\\n  'skein1024-376': 0xb38f,\\n  'skein1024-384': 0xb390,\\n  'skein1024-392': 0xb391,\\n  'skein1024-400': 0xb392,\\n  'skein1024-408': 0xb393,\\n  'skein1024-416': 0xb394,\\n  'skein1024-424': 0xb395,\\n  'skein1024-432': 0xb396,\\n  'skein1024-440': 0xb397,\\n  'skein1024-448': 0xb398,\\n  'skein1024-456': 0xb399,\\n  'skein1024-464': 0xb39a,\\n  'skein1024-472': 0xb39b,\\n  'skein1024-480': 0xb39c,\\n  'skein1024-488': 0xb39d,\\n  'skein1024-496': 0xb39e,\\n  'skein1024-504': 0xb39f,\\n  'skein1024-512': 0xb3a0,\\n  'skein1024-520': 0xb3a1,\\n  'skein1024-528': 0xb3a2,\\n  'skein1024-536': 0xb3a3,\\n  'skein1024-544': 0xb3a4,\\n  'skein1024-552': 0xb3a5,\\n  'skein1024-560': 0xb3a6,\\n  'skein1024-568': 0xb3a7,\\n  'skein1024-576': 0xb3a8,\\n  'skein1024-584': 0xb3a9,\\n  'skein1024-592': 0xb3aa,\\n  'skein1024-600': 0xb3ab,\\n  'skein1024-608': 0xb3ac,\\n  'skein1024-616': 0xb3ad,\\n  'skein1024-624': 0xb3ae,\\n  'skein1024-632': 0xb3af,\\n  'skein1024-640': 0xb3b0,\\n  'skein1024-648': 0xb3b1,\\n  'skein1024-656': 0xb3b2,\\n  'skein1024-664': 0xb3b3,\\n  'skein1024-672': 0xb3b4,\\n  'skein1024-680': 0xb3b5,\\n  'skein1024-688': 0xb3b6,\\n  'skein1024-696': 0xb3b7,\\n  'skein1024-704': 0xb3b8,\\n  'skein1024-712': 0xb3b9,\\n  'skein1024-720': 0xb3ba,\\n  'skein1024-728': 0xb3bb,\\n  'skein1024-736': 0xb3bc,\\n  'skein1024-744': 0xb3bd,\\n  'skein1024-752': 0xb3be,\\n  'skein1024-760': 0xb3bf,\\n  'skein1024-768': 0xb3c0,\\n  'skein1024-776': 0xb3c1,\\n  'skein1024-784': 0xb3c2,\\n  'skein1024-792': 0xb3c3,\\n  'skein1024-800': 0xb3c4,\\n  'skein1024-808': 0xb3c5,\\n  'skein1024-816': 0xb3c6,\\n  'skein1024-824': 0xb3c7,\\n  'skein1024-832': 0xb3c8,\\n  'skein1024-840': 0xb3c9,\\n  'skein1024-848': 0xb3ca,\\n  'skein1024-856': 0xb3cb,\\n  'skein1024-864': 0xb3cc,\\n  'skein1024-872': 0xb3cd,\\n  'skein1024-880': 0xb3ce,\\n  'skein1024-888': 0xb3cf,\\n  'skein1024-896': 0xb3d0,\\n  'skein1024-904': 0xb3d1,\\n  'skein1024-912': 0xb3d2,\\n  'skein1024-920': 0xb3d3,\\n  'skein1024-928': 0xb3d4,\\n  'skein1024-936': 0xb3d5,\\n  'skein1024-944': 0xb3d6,\\n  'skein1024-952': 0xb3d7,\\n  'skein1024-960': 0xb3d8,\\n  'skein1024-968': 0xb3d9,\\n  'skein1024-976': 0xb3da,\\n  'skein1024-984': 0xb3db,\\n  'skein1024-992': 0xb3dc,\\n  'skein1024-1000': 0xb3dd,\\n  'skein1024-1008': 0xb3de,\\n  'skein1024-1016': 0xb3df,\\n  'skein1024-1024': 0xb3e0,\\n  'poseidon-bls12_381-a2-fc1': 0xb401,\\n  'poseidon-bls12_381-a2-fc1-sc': 0xb402\\n})\\n\\nmodule.exports = { names }\\n\\n},{}],189:[function(require,module,exports){\\n/**\\n * Multihash implementation in JavaScript.\\n *\\n * @module multihash\\n */\\n'use strict'\\n\\nconst multibase = require('multibase')\\nconst varint = require('varint')\\nconst { names } = require('./constants')\\nconst uint8ArrayToString = require('uint8arrays/to-string')\\nconst uint8ArrayFromString = require('uint8arrays/from-string')\\nconst uint8ArrayConcat = require('uint8arrays/concat')\\n\\nconst codes = /** @type {import('./types').CodeNameMap} */({})\\n\\n// eslint-disable-next-line guard-for-in\\nfor (const key in names) {\\n  const name = /** @type {HashName} */(key)\\n  codes[names[name]] = name\\n}\\n\\n/**\\n * Convert the given multihash to a hex encoded string.\\n *\\n * @param {Uint8Array} hash\\n * @returns {string}\\n */\\nfunction toHexString (hash) {\\n  if (!(hash instanceof Uint8Array)) {\\n    throw new Error('must be passed a Uint8Array')\\n  }\\n\\n  return uint8ArrayToString(hash, 'base16')\\n}\\n\\n/**\\n * Convert the given hex encoded string to a multihash.\\n *\\n * @param {string} hash\\n * @returns {Uint8Array}\\n */\\nfunction fromHexString (hash) {\\n  return uint8ArrayFromString(hash, 'base16')\\n}\\n\\n/**\\n * Convert the given multihash to a base58 encoded string.\\n *\\n * @param {Uint8Array} hash\\n * @returns {string}\\n */\\nfunction toB58String (hash) {\\n  if (!(hash instanceof Uint8Array)) {\\n    throw new Error('must be passed a Uint8Array')\\n  }\\n\\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\\n}\\n\\n/**\\n * Convert the given base58 encoded string to a multihash.\\n *\\n * @param {string|Uint8Array} hash\\n * @returns {Uint8Array}\\n */\\nfunction fromB58String (hash) {\\n  const encoded = hash instanceof Uint8Array\\n    ? uint8ArrayToString(hash)\\n    : hash\\n\\n  return multibase.decode('z' + encoded)\\n}\\n\\n/**\\n * Decode a hash from the given multihash.\\n *\\n * @param {Uint8Array} bytes\\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\\n */\\nfunction decode (bytes) {\\n  if (!(bytes instanceof Uint8Array)) {\\n    throw new Error('multihash must be a Uint8Array')\\n  }\\n\\n  if (bytes.length < 2) {\\n    throw new Error('multihash too short. must be > 2 bytes.')\\n  }\\n\\n  const code = /** @type {HashCode} */(varint.decode(bytes))\\n  if (!isValidCode(code)) {\\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\\n  }\\n  bytes = bytes.slice(varint.decode.bytes)\\n\\n  const len = varint.decode(bytes)\\n  if (len < 0) {\\n    throw new Error(`multihash invalid length: ${len}`)\\n  }\\n  bytes = bytes.slice(varint.decode.bytes)\\n\\n  if (bytes.length !== len) {\\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\\n  }\\n\\n  return {\\n    code,\\n    name: codes[code],\\n    length: len,\\n    digest: bytes\\n  }\\n}\\n\\n/**\\n * Encode a hash digest along with the specified function code.\\n *\\n * > **Note:** the length is derived from the length of the digest itself.\\n *\\n * @param {Uint8Array} digest\\n * @param {HashName | HashCode} code\\n * @param {number} [length]\\n * @returns {Uint8Array}\\n */\\nfunction encode (digest, code, length) {\\n  if (!digest || code === undefined) {\\n    throw new Error('multihash encode requires at least two args: digest, code')\\n  }\\n\\n  // ensure it's a hashfunction code.\\n  const hashfn = coerceCode(code)\\n\\n  if (!(digest instanceof Uint8Array)) {\\n    throw new Error('digest should be a Uint8Array')\\n  }\\n\\n  if (length == null) {\\n    length = digest.length\\n  }\\n\\n  if (length && digest.length !== length) {\\n    throw new Error('digest length should be equal to specified length.')\\n  }\\n\\n  const hash = varint.encode(hashfn)\\n  const len = varint.encode(length)\\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\\n}\\n\\n/**\\n * Converts a hash function name into the matching code.\\n * If passed a number it will return the number if it's a valid code.\\n *\\n * @param {HashName | number} name\\n * @returns {number}\\n */\\nfunction coerceCode (name) {\\n  let code = name\\n\\n  if (typeof name === 'string') {\\n    if (names[name] === undefined) {\\n      throw new Error(`Unrecognized hash function named: ${name}`)\\n    }\\n    code = names[name]\\n  }\\n\\n  if (typeof code !== 'number') {\\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\\n  }\\n\\n  // @ts-ignore\\n  if (codes[code] === undefined && !isAppCode(code)) {\\n    throw new Error(`Unrecognized function code: ${code}`)\\n  }\\n\\n  return code\\n}\\n\\n/**\\n * Checks if a code is part of the app range\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\nfunction isAppCode (code) {\\n  return code > 0 && code < 0x10\\n}\\n\\n/**\\n * Checks whether a multihash code is valid.\\n *\\n * @param {HashCode} code\\n * @returns {boolean}\\n */\\nfunction isValidCode (code) {\\n  if (isAppCode(code)) {\\n    return true\\n  }\\n\\n  if (codes[code]) {\\n    return true\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Uint8Array} multihash\\n * @returns {void}\\n * @throws {Error}\\n */\\nfunction validate (multihash) {\\n  decode(multihash) // throws if bad.\\n}\\n\\n/**\\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Uint8Array} multihash\\n * @returns {Uint8Array}\\n * @throws {Error}\\n */\\nfunction prefix (multihash) {\\n  validate(multihash)\\n\\n  return multihash.subarray(0, 2)\\n}\\n\\nmodule.exports = {\\n  names,\\n  codes: Object.freeze(codes),\\n  toHexString,\\n  fromHexString,\\n  toB58String,\\n  fromB58String,\\n  decode,\\n  encode,\\n  coerceCode,\\n  isAppCode,\\n  validate,\\n  prefix,\\n  isValidCode\\n}\\n\\n/**\\n * @typedef { import(\\\"./constants\\\").HashCode } HashCode\\n * @typedef { import(\\\"./constants\\\").HashName } HashName\\n */\\n\\n},{\\\"./constants\\\":188,\\\"multibase\\\":164,\\\"uint8arrays/concat\\\":181,\\\"uint8arrays/from-string\\\":182,\\\"uint8arrays/to-string\\\":183,\\\"varint\\\":186}],190:[function(require,module,exports){\\n(function (process){(function (){\\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\\n// transplited with Babel\\n\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\nfunction assertPath(path) {\\n  if (typeof path !== 'string') {\\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\\n  }\\n}\\n\\n// Resolves . and .. elements in a path with directory names\\nfunction normalizeStringPosix(path, allowAboveRoot) {\\n  var res = '';\\n  var lastSegmentLength = 0;\\n  var lastSlash = -1;\\n  var dots = 0;\\n  var code;\\n  for (var i = 0; i <= path.length; ++i) {\\n    if (i < path.length)\\n      code = path.charCodeAt(i);\\n    else if (code === 47 /*/*/)\\n      break;\\n    else\\n      code = 47 /*/*/;\\n    if (code === 47 /*/*/) {\\n      if (lastSlash === i - 1 || dots === 1) {\\n        // NOOP\\n      } else if (lastSlash !== i - 1 && dots === 2) {\\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\\n          if (res.length > 2) {\\n            var lastSlashIndex = res.lastIndexOf('/');\\n            if (lastSlashIndex !== res.length - 1) {\\n              if (lastSlashIndex === -1) {\\n                res = '';\\n                lastSegmentLength = 0;\\n              } else {\\n                res = res.slice(0, lastSlashIndex);\\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\\n              }\\n              lastSlash = i;\\n              dots = 0;\\n              continue;\\n            }\\n          } else if (res.length === 2 || res.length === 1) {\\n            res = '';\\n            lastSegmentLength = 0;\\n            lastSlash = i;\\n            dots = 0;\\n            continue;\\n          }\\n        }\\n        if (allowAboveRoot) {\\n          if (res.length > 0)\\n            res += '/..';\\n          else\\n            res = '..';\\n          lastSegmentLength = 2;\\n        }\\n      } else {\\n        if (res.length > 0)\\n          res += '/' + path.slice(lastSlash + 1, i);\\n        else\\n          res = path.slice(lastSlash + 1, i);\\n        lastSegmentLength = i - lastSlash - 1;\\n      }\\n      lastSlash = i;\\n      dots = 0;\\n    } else if (code === 46 /*.*/ && dots !== -1) {\\n      ++dots;\\n    } else {\\n      dots = -1;\\n    }\\n  }\\n  return res;\\n}\\n\\nfunction _format(sep, pathObject) {\\n  var dir = pathObject.dir || pathObject.root;\\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\\n  if (!dir) {\\n    return base;\\n  }\\n  if (dir === pathObject.root) {\\n    return dir + base;\\n  }\\n  return dir + sep + base;\\n}\\n\\nvar posix = {\\n  // path.resolve([from ...], to)\\n  resolve: function resolve() {\\n    var resolvedPath = '';\\n    var resolvedAbsolute = false;\\n    var cwd;\\n\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path;\\n      if (i >= 0)\\n        path = arguments[i];\\n      else {\\n        if (cwd === undefined)\\n          cwd = process.cwd();\\n        path = cwd;\\n      }\\n\\n      assertPath(path);\\n\\n      // Skip empty entries\\n      if (path.length === 0) {\\n        continue;\\n      }\\n\\n      resolvedPath = path + '/' + resolvedPath;\\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path, but\\n    // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n    // Normalize the path\\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\\n\\n    if (resolvedAbsolute) {\\n      if (resolvedPath.length > 0)\\n        return '/' + resolvedPath;\\n      else\\n        return '/';\\n    } else if (resolvedPath.length > 0) {\\n      return resolvedPath;\\n    } else {\\n      return '.';\\n    }\\n  },\\n\\n  normalize: function normalize(path) {\\n    assertPath(path);\\n\\n    if (path.length === 0) return '.';\\n\\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\\n\\n    // Normalize the path\\n    path = normalizeStringPosix(path, !isAbsolute);\\n\\n    if (path.length === 0 && !isAbsolute) path = '.';\\n    if (path.length > 0 && trailingSeparator) path += '/';\\n\\n    if (isAbsolute) return '/' + path;\\n    return path;\\n  },\\n\\n  isAbsolute: function isAbsolute(path) {\\n    assertPath(path);\\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\\n  },\\n\\n  join: function join() {\\n    if (arguments.length === 0)\\n      return '.';\\n    var joined;\\n    for (var i = 0; i < arguments.length; ++i) {\\n      var arg = arguments[i];\\n      assertPath(arg);\\n      if (arg.length > 0) {\\n        if (joined === undefined)\\n          joined = arg;\\n        else\\n          joined += '/' + arg;\\n      }\\n    }\\n    if (joined === undefined)\\n      return '.';\\n    return posix.normalize(joined);\\n  },\\n\\n  relative: function relative(from, to) {\\n    assertPath(from);\\n    assertPath(to);\\n\\n    if (from === to) return '';\\n\\n    from = posix.resolve(from);\\n    to = posix.resolve(to);\\n\\n    if (from === to) return '';\\n\\n    // Trim any leading backslashes\\n    var fromStart = 1;\\n    for (; fromStart < from.length; ++fromStart) {\\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\\n        break;\\n    }\\n    var fromEnd = from.length;\\n    var fromLen = fromEnd - fromStart;\\n\\n    // Trim any leading backslashes\\n    var toStart = 1;\\n    for (; toStart < to.length; ++toStart) {\\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\\n        break;\\n    }\\n    var toEnd = to.length;\\n    var toLen = toEnd - toStart;\\n\\n    // Compare paths to find the longest common path from root\\n    var length = fromLen < toLen ? fromLen : toLen;\\n    var lastCommonSep = -1;\\n    var i = 0;\\n    for (; i <= length; ++i) {\\n      if (i === length) {\\n        if (toLen > length) {\\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\\n            // We get here if `from` is the exact base path for `to`.\\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\\n            return to.slice(toStart + i + 1);\\n          } else if (i === 0) {\\n            // We get here if `from` is the root\\n            // For example: from='/'; to='/foo'\\n            return to.slice(toStart + i);\\n          }\\n        } else if (fromLen > length) {\\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\\n            // We get here if `to` is the exact base path for `from`.\\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\\n            lastCommonSep = i;\\n          } else if (i === 0) {\\n            // We get here if `to` is the root.\\n            // For example: from='/foo'; to='/'\\n            lastCommonSep = 0;\\n          }\\n        }\\n        break;\\n      }\\n      var fromCode = from.charCodeAt(fromStart + i);\\n      var toCode = to.charCodeAt(toStart + i);\\n      if (fromCode !== toCode)\\n        break;\\n      else if (fromCode === 47 /*/*/)\\n        lastCommonSep = i;\\n    }\\n\\n    var out = '';\\n    // Generate the relative path based on the path difference between `to`\\n    // and `from`\\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\\n        if (out.length === 0)\\n          out += '..';\\n        else\\n          out += '/..';\\n      }\\n    }\\n\\n    // Lastly, append the rest of the destination (`to`) path that comes after\\n    // the common path parts\\n    if (out.length > 0)\\n      return out + to.slice(toStart + lastCommonSep);\\n    else {\\n      toStart += lastCommonSep;\\n      if (to.charCodeAt(toStart) === 47 /*/*/)\\n        ++toStart;\\n      return to.slice(toStart);\\n    }\\n  },\\n\\n  _makeLong: function _makeLong(path) {\\n    return path;\\n  },\\n\\n  dirname: function dirname(path) {\\n    assertPath(path);\\n    if (path.length === 0) return '.';\\n    var code = path.charCodeAt(0);\\n    var hasRoot = code === 47 /*/*/;\\n    var end = -1;\\n    var matchedSlash = true;\\n    for (var i = path.length - 1; i >= 1; --i) {\\n      code = path.charCodeAt(i);\\n      if (code === 47 /*/*/) {\\n          if (!matchedSlash) {\\n            end = i;\\n            break;\\n          }\\n        } else {\\n        // We saw the first non-path separator\\n        matchedSlash = false;\\n      }\\n    }\\n\\n    if (end === -1) return hasRoot ? '/' : '.';\\n    if (hasRoot && end === 1) return '//';\\n    return path.slice(0, end);\\n  },\\n\\n  basename: function basename(path, ext) {\\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\\\"ext\\\" argument must be a string');\\n    assertPath(path);\\n\\n    var start = 0;\\n    var end = -1;\\n    var matchedSlash = true;\\n    var i;\\n\\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\\n      if (ext.length === path.length && ext === path) return '';\\n      var extIdx = ext.length - 1;\\n      var firstNonSlashEnd = -1;\\n      for (i = path.length - 1; i >= 0; --i) {\\n        var code = path.charCodeAt(i);\\n        if (code === 47 /*/*/) {\\n            // If we reached a path separator that was not part of a set of path\\n            // separators at the end of the string, stop now\\n            if (!matchedSlash) {\\n              start = i + 1;\\n              break;\\n            }\\n          } else {\\n          if (firstNonSlashEnd === -1) {\\n            // We saw the first non-path separator, remember this index in case\\n            // we need it if the extension ends up not matching\\n            matchedSlash = false;\\n            firstNonSlashEnd = i + 1;\\n          }\\n          if (extIdx >= 0) {\\n            // Try to match the explicit extension\\n            if (code === ext.charCodeAt(extIdx)) {\\n              if (--extIdx === -1) {\\n                // We matched the extension, so mark this as the end of our path\\n                // component\\n                end = i;\\n              }\\n            } else {\\n              // Extension does not match, so our result is the entire path\\n              // component\\n              extIdx = -1;\\n              end = firstNonSlashEnd;\\n            }\\n          }\\n        }\\n      }\\n\\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\\n      return path.slice(start, end);\\n    } else {\\n      for (i = path.length - 1; i >= 0; --i) {\\n        if (path.charCodeAt(i) === 47 /*/*/) {\\n            // If we reached a path separator that was not part of a set of path\\n            // separators at the end of the string, stop now\\n            if (!matchedSlash) {\\n              start = i + 1;\\n              break;\\n            }\\n          } else if (end === -1) {\\n          // We saw the first non-path separator, mark this as the end of our\\n          // path component\\n          matchedSlash = false;\\n          end = i + 1;\\n        }\\n      }\\n\\n      if (end === -1) return '';\\n      return path.slice(start, end);\\n    }\\n  },\\n\\n  extname: function extname(path) {\\n    assertPath(path);\\n    var startDot = -1;\\n    var startPart = 0;\\n    var end = -1;\\n    var matchedSlash = true;\\n    // Track the state of characters (if any) we see before our first dot and\\n    // after any path separator we find\\n    var preDotState = 0;\\n    for (var i = path.length - 1; i >= 0; --i) {\\n      var code = path.charCodeAt(i);\\n      if (code === 47 /*/*/) {\\n          // If we reached a path separator that was not part of a set of path\\n          // separators at the end of the string, stop now\\n          if (!matchedSlash) {\\n            startPart = i + 1;\\n            break;\\n          }\\n          continue;\\n        }\\n      if (end === -1) {\\n        // We saw the first non-path separator, mark this as the end of our\\n        // extension\\n        matchedSlash = false;\\n        end = i + 1;\\n      }\\n      if (code === 46 /*.*/) {\\n          // If this is our first dot, mark it as the start of our extension\\n          if (startDot === -1)\\n            startDot = i;\\n          else if (preDotState !== 1)\\n            preDotState = 1;\\n      } else if (startDot !== -1) {\\n        // We saw a non-dot and non-path separator before our dot, so we should\\n        // have a good chance at having a non-empty extension\\n        preDotState = -1;\\n      }\\n    }\\n\\n    if (startDot === -1 || end === -1 ||\\n        // We saw a non-dot character immediately before the dot\\n        preDotState === 0 ||\\n        // The (right-most) trimmed path component is exactly '..'\\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\\n      return '';\\n    }\\n    return path.slice(startDot, end);\\n  },\\n\\n  format: function format(pathObject) {\\n    if (pathObject === null || typeof pathObject !== 'object') {\\n      throw new TypeError('The \\\"pathObject\\\" argument must be of type Object. Received type ' + typeof pathObject);\\n    }\\n    return _format('/', pathObject);\\n  },\\n\\n  parse: function parse(path) {\\n    assertPath(path);\\n\\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\\n    if (path.length === 0) return ret;\\n    var code = path.charCodeAt(0);\\n    var isAbsolute = code === 47 /*/*/;\\n    var start;\\n    if (isAbsolute) {\\n      ret.root = '/';\\n      start = 1;\\n    } else {\\n      start = 0;\\n    }\\n    var startDot = -1;\\n    var startPart = 0;\\n    var end = -1;\\n    var matchedSlash = true;\\n    var i = path.length - 1;\\n\\n    // Track the state of characters (if any) we see before our first dot and\\n    // after any path separator we find\\n    var preDotState = 0;\\n\\n    // Get non-dir info\\n    for (; i >= start; --i) {\\n      code = path.charCodeAt(i);\\n      if (code === 47 /*/*/) {\\n          // If we reached a path separator that was not part of a set of path\\n          // separators at the end of the string, stop now\\n          if (!matchedSlash) {\\n            startPart = i + 1;\\n            break;\\n          }\\n          continue;\\n        }\\n      if (end === -1) {\\n        // We saw the first non-path separator, mark this as the end of our\\n        // extension\\n        matchedSlash = false;\\n        end = i + 1;\\n      }\\n      if (code === 46 /*.*/) {\\n          // If this is our first dot, mark it as the start of our extension\\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\\n        } else if (startDot !== -1) {\\n        // We saw a non-dot and non-path separator before our dot, so we should\\n        // have a good chance at having a non-empty extension\\n        preDotState = -1;\\n      }\\n    }\\n\\n    if (startDot === -1 || end === -1 ||\\n    // We saw a non-dot character immediately before the dot\\n    preDotState === 0 ||\\n    // The (right-most) trimmed path component is exactly '..'\\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\\n      if (end !== -1) {\\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\\n      }\\n    } else {\\n      if (startPart === 0 && isAbsolute) {\\n        ret.name = path.slice(1, startDot);\\n        ret.base = path.slice(1, end);\\n      } else {\\n        ret.name = path.slice(startPart, startDot);\\n        ret.base = path.slice(startPart, end);\\n      }\\n      ret.ext = path.slice(startDot, end);\\n    }\\n\\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\\n\\n    return ret;\\n  },\\n\\n  sep: '/',\\n  delimiter: ':',\\n  win32: null,\\n  posix: null\\n};\\n\\nposix.posix = posix;\\n\\nmodule.exports = posix;\\n\\n}).call(this)}).call(this,require('_process'))\\n},{\\\"_process\\\":191}],191:[function(require,module,exports){\\n// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n},{}],192:[function(require,module,exports){\\n'use strict';\\nvar escapeStringRegexp = require('escape-string-regexp');\\n\\nmodule.exports = function (str, sub) {\\n\\tif (typeof str !== 'string' || typeof sub !== 'string') {\\n\\t\\tthrow new TypeError();\\n\\t}\\n\\n\\tsub = escapeStringRegexp(sub);\\n\\treturn str.replace(new RegExp('^' + sub + '|' + sub + '$', 'g'), '');\\n};\\n\\n},{\\\"escape-string-regexp\\\":144}],193:[function(require,module,exports){\\n'use strict';\\nvar escapeStringRegexp = require('escape-string-regexp');\\n\\nmodule.exports = function (str, target) {\\n\\tif (typeof str !== 'string' || typeof target !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\treturn str.replace(new RegExp('(?:' + escapeStringRegexp(target) + '){2,}', 'g'), target);\\n};\\n\\n},{\\\"escape-string-regexp\\\":144}],194:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Can be used with Array.sort to sort and array with Uint8Array entries\\n *\\n * @param {Uint8Array} a\\n * @param {Uint8Array} b\\n */\\nfunction compare (a, b) {\\n  for (let i = 0; i < a.byteLength; i++) {\\n    if (a[i] < b[i]) {\\n      return -1\\n    }\\n\\n    if (a[i] > b[i]) {\\n      return 1\\n    }\\n  }\\n\\n  if (a.byteLength > b.byteLength) {\\n    return 1\\n  }\\n\\n  if (a.byteLength < b.byteLength) {\\n    return -1\\n  }\\n\\n  return 0\\n}\\n\\nmodule.exports = compare\\n\\n},{}],195:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\\n *\\n * @param {Array<ArrayLike<number>>} arrays\\n * @param {number} [length]\\n */\\nfunction concat (arrays, length) {\\n  if (!length) {\\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\\n  }\\n\\n  const output = new Uint8Array(length)\\n  let offset = 0\\n\\n  for (const arr of arrays) {\\n    output.set(arr, offset)\\n    offset += arr.length\\n  }\\n\\n  return output\\n}\\n\\nmodule.exports = concat\\n\\n},{}],196:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns true if the two passed Uint8Arrays have the same content\\n *\\n * @param {Uint8Array} a\\n * @param {Uint8Array} b\\n */\\nfunction equals (a, b) {\\n  if (a === b) {\\n    return true\\n  }\\n\\n  if (a.byteLength !== b.byteLength) {\\n    return false\\n  }\\n\\n  for (let i = 0; i < a.byteLength; i++) {\\n    if (a[i] !== b[i]) {\\n      return false\\n    }\\n  }\\n\\n  return true\\n}\\n\\nmodule.exports = equals\\n\\n},{}],197:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst { TextEncoder } = require('web-encoding')\\nconst utf8Encoder = new TextEncoder()\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName} BaseName\\n */\\n\\n/**\\n * Interprets each character in a string as a byte and\\n * returns a Uint8Array of those bytes.\\n *\\n * @param {string} string - The string to turn into an array\\n */\\nfunction asciiStringToUint8Array (string) {\\n  const array = new Uint8Array(string.length)\\n\\n  for (let i = 0; i < string.length; i++) {\\n    array[i] = string.charCodeAt(i)\\n  }\\n\\n  return array\\n}\\n\\n/**\\n * Create a `Uint8Array` from the passed string\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {string} string\\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc\\n * @returns {Uint8Array}\\n */\\nfunction fromString (string, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Encoder.encode(string)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return asciiStringToUint8Array(string)\\n  }\\n\\n  return getCodec(encoding).decode(string)\\n}\\n\\nmodule.exports = fromString\\n\\n},{\\\"multibase\\\":164,\\\"web-encoding\\\":201}],198:[function(require,module,exports){\\n'use strict'\\n\\nmodule.exports = {\\n  compare: require('./compare'),\\n  concat: require('./concat'),\\n  equals: require('./equals'),\\n  fromString: require('./from-string'),\\n  toString: require('./to-string'),\\n  xor: require('./xor')\\n}\\n\\n},{\\\"./compare\\\":194,\\\"./concat\\\":195,\\\"./equals\\\":196,\\\"./from-string\\\":197,\\\"./to-string\\\":199,\\\"./xor\\\":200}],199:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst { TextDecoder } = require('web-encoding')\\nconst utf8Decoder = new TextDecoder('utf8')\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName} BaseName\\n */\\n\\n/**\\n * Turns a Uint8Array of bytes into a string with each\\n * character being the char code of the corresponding byte\\n *\\n * @param {Uint8Array} array - The array to turn into a string\\n */\\nfunction uint8ArrayToAsciiString (array) {\\n  let string = ''\\n\\n  for (let i = 0; i < array.length; i++) {\\n    string += String.fromCharCode(array[i])\\n  }\\n  return string\\n}\\n\\n/**\\n * Turns a `Uint8Array` into a string.\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {Uint8Array} array - The array to turn into a string\\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - The encoding to use\\n * @returns {string}\\n */\\nfunction toString (array, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Decoder.decode(array)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return uint8ArrayToAsciiString(array)\\n  }\\n\\n  return getCodec(encoding).encode(array)\\n}\\n\\nmodule.exports = toString\\n\\n},{\\\"multibase\\\":164,\\\"web-encoding\\\":201}],200:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns the xor distance between two arrays\\n *\\n * @param {Uint8Array} a\\n * @param {Uint8Array} b\\n */\\nfunction xor (a, b) {\\n  if (a.length !== b.length) {\\n    throw new Error('Inputs should have the same length')\\n  }\\n\\n  const result = new Uint8Array(a.length)\\n\\n  for (let i = 0; i < a.length; i++) {\\n    result[i] = a[i] ^ b[i]\\n  }\\n\\n  return result\\n}\\n\\nmodule.exports = xor\\n\\n},{}],201:[function(require,module,exports){\\n\\\"use strict\\\"\\n\\nexports.TextEncoder = TextEncoder\\nexports.TextDecoder = TextDecoder\\n\\n},{}]},{},[1])(1)\\n});\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-controller.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-controller.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-controller.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Controller\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const EnsAction = require('$:/plugins/ipfs/ens-action.js').EnsAction\\n  const EnsWrapper = require('$:/plugins/ipfs/ens-wrapper.js').EnsWrapper\\n\\n  const IpfsAction = require('$:/plugins/ipfs/ipfs-action.js').IpfsAction\\n  const IpfsBundle = require('$:/plugins/ipfs/ipfs-bundle.js').IpfsBundle\\n  const IpfsTiddler = require('$:/plugins/ipfs/ipfs-tiddler.js').IpfsTiddler\\n  const IpfsWrapper = require('$:/plugins/ipfs/ipfs-wrapper.js').IpfsWrapper\\n\\n  const ipfsKeyword = 'ipfs'\\n  const ipnsKeyword = 'ipns'\\n\\n  const name = 'ipfs-controller'\\n\\n  var IpfsController = function () {\\n    this.ipfsClients = new Map()\\n    this.pin = []\\n    this.unpin = []\\n  }\\n\\n  IpfsController.prototype.init = function () {\\n    // Init once\\n    if (this.once) {\\n      return\\n    }\\n    this.ipfsBundle = new IpfsBundle()\\n    this.ipfsBundle.init()\\n    this.ensWrapper = new EnsWrapper(this.ipfsBundle.ensLibrary)\\n    this.ipfsWrapper = new IpfsWrapper(this.ipfsBundle)\\n    // Listener\\n    this.ensAction = new EnsAction()\\n    this.ipfsAction = new IpfsAction()\\n    this.ipfsTiddler = new IpfsTiddler()\\n    // Init\\n    this.ensAction.init()\\n    this.ipfsAction.init()\\n    this.ipfsTiddler.init()\\n    // Load sigUtil early if needed\\n    if ($tw.crypto.hasEncryptionPublicKey()) {\\n      this.loadEthSigUtilLibrary()\\n    }\\n    // Init once\\n    this.once = true\\n  }\\n\\n  IpfsController.prototype.getLogger = function () {\\n    if (window.log !== undefined && window.log !== null) {\\n      const loggers = window.log.getLoggers()\\n      var log = loggers.eruda\\n      if (log !== undefined && log !== null) {\\n        return log\\n      }\\n      log = loggers.default\\n      if (log !== undefined && log !== null) {\\n        return log\\n      }\\n    }\\n    return console\\n  }\\n\\n  IpfsController.prototype.loadToBase64 = async function (url, password) {\\n    return await this.ipfsBundle.loadToBase64(url, password)\\n  }\\n\\n  IpfsController.prototype.loadToUtf8 = async function (url, password) {\\n    return await this.ipfsBundle.loadToUtf8(url, password)\\n  }\\n\\n  IpfsController.prototype.Base64ToUint8Array = function (b64) {\\n    return this.ipfsBundle.Base64ToUint8Array(b64)\\n  }\\n\\n  IpfsController.prototype.Uint8ArrayToBase64 = function (ua) {\\n    return this.ipfsBundle.Uint8ArrayToBase64(ua)\\n  }\\n\\n  IpfsController.prototype.StringToUint8Array = function (string) {\\n    return this.ipfsBundle.StringToUint8Array(string)\\n  }\\n\\n  IpfsController.prototype.Utf8ArrayToStr = function (array) {\\n    return this.ipfsBundle.Utf8ArrayToStr(array)\\n  }\\n\\n  IpfsController.prototype.processContent = async function (tiddler, content, encoding) {\\n    if (content === undefined || content == null) {\\n      throw new Error('Unable to process undefined content...')\\n    }\\n    if (encoding === undefined || encoding == null) {\\n      encoding = 'utf8'\\n    }\\n    var compress = $tw.wiki.getTiddler('$:/isCompressed')\\n    compress = compress !== undefined ? compress.fields.text === 'yes' : false\\n    compress = tiddler !== undefined && tiddler.fields._compress !== undefined && tiddler.fields._compress.trim() !== '' ? tiddler.fields._compress.trim() === 'yes' : compress\\n    var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypted = encrypted !== undefined ? encrypted.fields.text === 'yes' : false\\n    var password = tiddler !== undefined && tiddler.fields._password !== undefined && tiddler.fields._password.trim() !== '' ? tiddler.fields._password.trim() : null\\n    var publicKey =\\n      tiddler !== undefined && tiddler.fields._encryption_public_key !== undefined && tiddler.fields._encryption_public_key.trim() !== ''\\n        ? tiddler.fields._encryption_public_key.trim()\\n        : null\\n    var sign = $tw.wiki.getTiddler('$:/isSigned')\\n    sign = sign !== undefined ? sign.fields.text === 'yes' : false\\n    sign = tiddler !== undefined && tiddler.fields._sign !== undefined && tiddler.fields._sign.trim() !== '' ? tiddler.fields._sign.trim() === 'yes' : sign\\n    var hasPublicKey = publicKey || $tw.crypto.hasEncryptionPublicKey()\\n    if (encrypted || password || hasPublicKey) {\\n      try {\\n        if (hasPublicKey) {\\n          await this.loadEthSigUtilLibrary()\\n        }\\n        if (compress) {\\n          content = { compressed: this.deflate(content) }\\n          content.compressed = $tw.crypto.encrypt(content.compressed, password, publicKey)\\n          if (hasPublicKey && sign) {\\n            content.keccak256 = $tw.crypto.keccak256(content.compressed)\\n            content.signature = await this.personalSign(content.keccak256)\\n            content.signature = $tw.crypto.encrypt(content.signature, null, publicKey)\\n          }\\n          content = JSON.stringify(content)\\n        } else {\\n          // https://github.com/xmaysonnave/tiddlywiki-ipfs/issues/9\\n          if (encoding === 'base64') {\\n            content = atob(content)\\n          }\\n          if (hasPublicKey) {\\n            content = { encrypted: content }\\n            content.encrypted = $tw.crypto.encrypt(content.encrypted, null, publicKey)\\n            if (sign) {\\n              content.keccak256 = $tw.crypto.keccak256(content.encrypted)\\n              content.signature = await this.personalSign(content.keccak256)\\n              content.signature = $tw.crypto.encrypt(content.signature, null, publicKey)\\n            }\\n            content = JSON.stringify(content)\\n          } else {\\n            content = $tw.crypto.encrypt(content, password)\\n          }\\n        }\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, 'Failed to process encrypted content...')\\n        return null\\n      }\\n    } else {\\n      try {\\n        if (compress) {\\n          content = { compressed: this.deflate(content) }\\n          content = JSON.stringify(content)\\n        }\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, 'Failed to process content...')\\n        return null\\n      }\\n    }\\n    return content\\n  }\\n\\n  IpfsController.prototype.requestToPin = function (cid, ipnsKey, value) {\\n    const self = this\\n    return new Promise((resolve, reject) => {\\n      if ($tw.utils.getIpfsPin() === false) {\\n        resolve(false)\\n      }\\n      cid = cid !== undefined && cid !== null && cid.toString().trim() !== '' ? cid.toString().trim() : null\\n      ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.trim() !== '' ? ipnsKey.trim() : null\\n      value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n      if (ipnsKey !== null) {\\n        self\\n          .resolveUrl(true, true, value)\\n          .then(data => {\\n            const { cid, resolvedUrl } = data\\n            if (resolvedUrl !== null && cid !== null) {\\n              resolve(self.addToPin(cid, resolvedUrl))\\n            } else {\\n              resolve(false)\\n            }\\n          })\\n          .catch(error => {\\n            reject(error)\\n          })\\n      } else if (cid !== null) {\\n        const normalizedUrl = self.normalizeUrl(`/${ipfsKeyword}/${cid}`)\\n        resolve(self.addToPin(cid, normalizedUrl))\\n      } else {\\n        resolve(false)\\n      }\\n    })\\n  }\\n\\n  IpfsController.prototype.addToPin = function (cid, normalizedUrl) {\\n    if (cid !== undefined && cid !== null) {\\n      var index = this.unpin.indexOf(cid)\\n      if (index !== -1) {\\n        this.unpin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Unpin:\\n ${normalizedUrl}`\\n        )\\n        return false\\n      }\\n      if (this.pin.indexOf(cid) === -1) {\\n        this.pin.push(cid)\\n        $tw.ipfs.getLogger().info(\\n          `Request to Pin:\\n ${normalizedUrl}`\\n        )\\n        return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  IpfsController.prototype.requestToUnpin = function (cid, ipnsKey, value) {\\n    const self = this\\n    return new Promise((resolve, reject) => {\\n      if ($tw.utils.getIpfsUnpin() === false) {\\n        resolve(false)\\n      }\\n      cid = cid !== undefined && cid !== null && cid.toString().trim() !== '' ? cid.toString().trim() : null\\n      ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.trim() !== '' ? ipnsKey.trim() : null\\n      value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n      if (ipnsKey !== undefined && ipnsKey !== null) {\\n        self\\n          .resolveUrl(true, true, value)\\n          .then(data => {\\n            const { cid, resolvedUrl } = data\\n            if (resolvedUrl !== null && cid !== null) {\\n              resolve(self.addToUnpin(cid, resolvedUrl))\\n            } else {\\n              resolve(false)\\n            }\\n          })\\n          .catch(error => {\\n            reject(error)\\n          })\\n      } else if (cid !== null) {\\n        const normalizedUrl = self.normalizeUrl(`/${ipfsKeyword}/${cid}`)\\n        resolve(self.addToUnpin(cid, normalizedUrl))\\n      } else {\\n        resolve(false)\\n      }\\n    })\\n  }\\n\\n  IpfsController.prototype.addToUnpin = function (cid, normalizedUrl) {\\n    if (cid !== undefined && cid !== null) {\\n      // Discard\\n      var index = this.pin.indexOf(cid)\\n      if (index !== -1) {\\n        this.pin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Pin:\\n ${normalizedUrl}`\\n        )\\n        return false\\n      }\\n      // Add to unpin\\n      if (this.unpin.indexOf(cid) === -1) {\\n        this.unpin.push(cid)\\n        $tw.ipfs.getLogger().info(\\n          `Request to unpin:\\n ${normalizedUrl}`\\n        )\\n        return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  IpfsController.prototype.removeFromPinUnpin = function (cid, normalizedUrl) {\\n    if (cid !== undefined && cid !== null) {\\n      var index = this.pin.indexOf(cid)\\n      if (index !== -1) {\\n        this.pin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Pin:\\n ${normalizedUrl}`\\n        )\\n      }\\n      index = this.unpin.indexOf(cid)\\n      if (index !== -1) {\\n        this.unpin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Unpin:\\n ${normalizedUrl}`\\n        )\\n      }\\n    }\\n  }\\n\\n  IpfsController.prototype.pinToIpfs = async function (cid, recursive) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.pinToIpfs(ipfs, cid, recursive)\\n  }\\n\\n  IpfsController.prototype.unpinFromIpfs = async function (cid, recursive) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.unpinFromIpfs(ipfs, cid, recursive)\\n  }\\n\\n  IpfsController.prototype.addToIpfs = async function (content) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.addToIpfs(ipfs, content)\\n  }\\n\\n  IpfsController.prototype.generateIpnsKey = async function (ipnsName) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.generateIpnsKey(ipfs, ipnsName)\\n  }\\n\\n  IpfsController.prototype.removeIpnsKey = async function (ipnsName) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.removeIpnsKey(ipfs, ipnsName)\\n  }\\n\\n  IpfsController.prototype.renameIpnsName = async function (oldIpnsName, newIpnsName) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.renameIpnsName(ipfs, oldIpnsName, newIpnsName)\\n  }\\n\\n  IpfsController.prototype.getIpnsIdentifiers = async function (identifier, base, path, ipnsName) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.getIpnsIdentifiers(ipfs, identifier, base, path, ipnsName)\\n  }\\n\\n  IpfsController.prototype.resolveIpnsKey = async function (ipnsKey) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey)\\n  }\\n\\n  IpfsController.prototype.publishIpnsName = async function (cid, ipnsKey, ipnsName) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.publishIpnsName(cid, ipfs, ipnsKey, ipnsName)\\n  }\\n\\n  IpfsController.prototype.isJson = function (content) {\\n    return this.ipfsBundle.isJson(content)\\n  }\\n\\n  IpfsController.prototype.filenamify = function (name, options) {\\n    return this.ipfsBundle.filenamify(name, options)\\n  }\\n\\n  IpfsController.prototype.getIpfsBaseUrl = function () {\\n    return this.ipfsBundle.getIpfsBaseUrl()\\n  }\\n\\n  IpfsController.prototype.normalizeUrl = function (value, base) {\\n    return this.ipfsBundle.normalizeUrl(value, base)\\n  }\\n\\n  IpfsController.prototype.getDocumentUrl = function () {\\n    return this.ipfsBundle.getDocumentUrl()\\n  }\\n\\n  IpfsController.prototype.getIpfsDefaultApi = function () {\\n    return this.ipfsBundle.getIpfsDefaultApi()\\n  }\\n\\n  IpfsController.prototype.getIpfsDefaultGateway = function () {\\n    return this.ipfsBundle.getIpfsDefaultGateway()\\n  }\\n\\n  IpfsController.prototype.getIpfsApiUrl = function () {\\n    return this.ipfsBundle.getIpfsApiUrl()\\n  }\\n\\n  IpfsController.prototype.getIpfsGatewayUrl = function () {\\n    return this.ipfsBundle.getIpfsGatewayUrl()\\n  }\\n\\n  IpfsController.prototype.getUrl = function (url, base) {\\n    return this.ipfsBundle.getUrl(url, base)\\n  }\\n\\n  IpfsController.prototype.resolveUrl = async function (resolveIpns, resolveEns, value, base, web3) {\\n    var cid = null\\n    var ipnsKey = null\\n    var ipnsName = null\\n    var normalizedUrl = null\\n    var resolvedUrl = null\\n    value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n    if (value == null) {\\n      return {\\n        cid: null,\\n        ipnsKey: null,\\n        ipnsName: null,\\n        normalizedUrl: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    try {\\n      normalizedUrl = this.normalizeUrl(value, base)\\n    } catch (error) {\\n      // Ignore\\n    }\\n    if (normalizedUrl == null) {\\n      return {\\n        cid: null,\\n        ipnsKey: null,\\n        ipnsName: null,\\n        normalizedUrl: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    var { cid, ipnsIdentifier, path, protocol } = this.decodeCid(normalizedUrl)\\n    if (protocol === ipnsKeyword && ipnsIdentifier !== null) {\\n      var { cid, ipnsKey, ipnsName, normalizedUrl, resolvedUrl } = await this.resolveIpns(ipnsIdentifier, resolveIpns, base, path)\\n    } else if (resolveEns && normalizedUrl.hostname.endsWith('.eth') && protocol !== ipfsKeyword && protocol !== ipnsKeyword) {\\n      var { cid, protocol, resolvedUrl } = await this.resolveEns(normalizedUrl.hostname, base, path, web3)\\n      if (protocol === ipnsKeyword) {\\n        var { cid, ipnsKey, ipnsName, resolvedUrl } = await this.resolveIpns(cid, resolveIpns, base, path)\\n      }\\n    }\\n    return {\\n      cid: cid,\\n      ipnsKey: ipnsKey,\\n      ipnsName: ipnsName,\\n      normalizedUrl: normalizedUrl,\\n      resolvedUrl: resolvedUrl !== null ? resolvedUrl : normalizedUrl,\\n    }\\n  }\\n\\n  IpfsController.prototype.resolveIpns = async function (ipnsIdentifier, resolveIpns, base, path) {\\n    ipnsIdentifier = ipnsIdentifier !== undefined && ipnsIdentifier !== null && ipnsIdentifier.toString().trim() !== '' ? ipnsIdentifier.toString().trim() : null\\n    path = path !== undefined && path !== null && path.trim() !== '' ? path.trim() : ''\\n    if (ipnsIdentifier == null) {\\n      return {\\n        cid: null,\\n        ipnsKey: null,\\n        ipnsName: null,\\n        normalizedUrl: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    var cid = null\\n    var resolvedUrl = null\\n    var { ipnsKey, ipnsName, normalizedUrl } = await this.getIpnsIdentifiers(ipnsIdentifier, base, path)\\n    if (resolveIpns) {\\n      $tw.ipfs.getLogger().info(\\n        `Resolving IPNS key:\\n${normalizedUrl}`\\n      )\\n      $tw.utils.alert(name, 'Resolving an IPNS key...')\\n      try {\\n        cid = await this.resolveIpnsKey(ipnsKey)\\n        if (cid !== null) {\\n          resolvedUrl = this.normalizeUrl(`/${ipfsKeyword}/${cid}${path}`, base)\\n          $tw.ipfs.getLogger().info(\\n            `Successfully resolved IPNS key:\\n${normalizedUrl}`\\n          )\\n          $tw.utils.alert(name, 'Successfully resolved an IPNS key...')\\n        }\\n      } catch (error) {\\n        // Unable to resolve the key\\n        // It usually happen when the key is not initialized\\n        cid = null\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      }\\n    }\\n    return {\\n      cid: cid,\\n      ipnsKey: ipnsKey,\\n      ipnsName: ipnsName,\\n      normalizedUrl: normalizedUrl,\\n      resolvedUrl: resolvedUrl,\\n    }\\n  }\\n\\n  IpfsController.prototype.resolveEns = async function (ensDomain, base, path, web3) {\\n    ensDomain = ensDomain !== undefined && ensDomain !== null && ensDomain.toString().trim() !== '' ? ensDomain.toString().trim() : null\\n    if (ensDomain == null) {\\n      return {\\n        cid: null,\\n        protocol: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    path = path !== undefined && path !== null && path.trim() !== '' ? path.trim() : ''\\n    if (web3 === undefined || web3 == null) {\\n      var { web3 } = await this.getWeb3Provider()\\n    }\\n    const { content, protocol } = await this.ensWrapper.getContentHash(ensDomain, web3)\\n    if (content == null || protocol == null) {\\n      return {\\n        cid: null,\\n        protocol: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    const url = this.normalizeUrl(`/${protocol}/${content}${path}`, base)\\n    $tw.ipfs.getLogger().info(\\n      `Successfully fetched ENS domain content: \\\"${ensDomain}\\\"\\n${url}`\\n    )\\n    return {\\n      cid: content,\\n      protocol: protocol,\\n      resolvedUrl: url,\\n    }\\n  }\\n\\n  IpfsController.prototype.getIpfsClient = async function () {\\n    // Provider\\n    const ipfsProvider = $tw.utils.getIpfsProvider()\\n    // IPFS companion\\n    if (ipfsProvider === 'window') {\\n      const client = await this.ipfsWrapper.getWindowIpfsClient()\\n      return {\\n        ipfs: client.ipfs,\\n        provider: client.provider,\\n      }\\n    }\\n    // Default, try IPFS companion\\n    if (ipfsProvider === 'default') {\\n      try {\\n        const client = await this.ipfsWrapper.getWindowIpfsClient()\\n        return {\\n          ipfs: client.ipfs,\\n          provider: client.provider,\\n        }\\n      } catch (error) {\\n        // Ignore, fallback to HTTP\\n      }\\n    }\\n    // Current API URL\\n    const url = this.getIpfsApiUrl()\\n    // Check\\n    if (url === undefined || url == null || url.toString().trim() === '') {\\n      throw new Error('Undefined IPFS API URL...')\\n    }\\n    // HTTP Client\\n    const client = this.ipfsClients.get(url.toString())\\n    if (client !== undefined) {\\n      // Log\\n      $tw.ipfs.getLogger().info(`Reuse IPFS provider: \\\"${client.provider}\\\"`)\\n      // Done\\n      return {\\n        ipfs: client.ipfs,\\n        provider: client.provider,\\n      }\\n    }\\n    // Build a new HTTP client\\n    const policy = await this.ipfsWrapper.getHttpIpfsClient(url)\\n    const ipfs = policy.ipfs\\n    const provider = policy.provider\\n    // Store\\n    this.ipfsClients.set(url.toString(), { ipfs, provider })\\n    // Log\\n    $tw.ipfs.getLogger().info(`New IPFS provider: \\\"${policy.provider}\\\"`)\\n    // Done\\n    return {\\n      ipfs: ipfs,\\n      provider: provider,\\n    }\\n  }\\n\\n  IpfsController.prototype.setContentHash = async function (ensDomain, cid, web3, account) {\\n    if (account === undefined || account == null || web3 === undefined || web3 == null) {\\n      var { account, web3 } = await this.getEnabledWeb3Provider()\\n    }\\n    await this.ensWrapper.setContentHash(ensDomain, cid, web3, account)\\n    const url = this.normalizeUrl(cid)\\n    $tw.ipfs.getLogger().info(\\n      `Successfully set ENS domain content:\\n ${url}\\n to: \\\"${ensDomain}\\\"`\\n    )\\n    return true\\n  }\\n\\n  IpfsController.prototype.decodeCid = function (pathname) {\\n    return this.ipfsBundle.decodeCid(pathname)\\n  }\\n\\n  IpfsController.prototype.getCid = function (cid) {\\n    return this.ipfsBundle.getCid(cid)\\n  }\\n\\n  IpfsController.prototype.cidToBase58CidV0 = function (cid, log) {\\n    return this.ipfsBundle.cidToBase58CidV0(cid, log)\\n  }\\n\\n  IpfsController.prototype.cidToCidV1 = function (cid, protocol, log) {\\n    return this.ipfsBundle.cidToCidV1(cid, protocol, log)\\n  }\\n\\n  IpfsController.prototype.cidToLibp2pKeyCidV1 = function (cid, multibaseName, log) {\\n    return this.ipfsBundle.cidToLibp2pKeyCidV1(cid, multibaseName, log)\\n  }\\n\\n  IpfsController.prototype.isOwner = async function (domain, web3, account) {\\n    return await this.ipfsBundle.isOwner(domain, web3, account)\\n  }\\n\\n  IpfsController.prototype.personalRecover = async function (message, signature) {\\n    return await this.ipfsBundle.personalRecover(message, signature)\\n  }\\n\\n  IpfsController.prototype.personalSign = async function (message, provider) {\\n    return await this.ipfsBundle.personalSign(message, provider)\\n  }\\n\\n  IpfsController.prototype.decrypt = async function (text, provider) {\\n    return await this.ipfsBundle.decrypt(text, provider)\\n  }\\n\\n  IpfsController.prototype.getPublicEncryptionKey = async function (provider) {\\n    return await this.ipfsBundle.getPublicEncryptionKey(provider)\\n  }\\n\\n  IpfsController.prototype.getEthereumProvider = async function () {\\n    return await this.ipfsBundle.getEthereumProvider()\\n  }\\n\\n  IpfsController.prototype.getEnabledWeb3Provider = async function () {\\n    return await this.ipfsBundle.getEnabledWeb3Provider()\\n  }\\n\\n  IpfsController.prototype.getWeb3Provider = async function () {\\n    return await this.ipfsBundle.getWeb3Provider()\\n  }\\n\\n  IpfsController.prototype.getEtherscanRegistry = function () {\\n    return this.ipfsBundle.getEtherscanRegistry()\\n  }\\n\\n  IpfsController.prototype.getNetworkRegistry = function () {\\n    return this.ipfsBundle.getNetworkRegistry()\\n  }\\n\\n  IpfsController.prototype.getENSRegistry = function () {\\n    return this.ipfsBundle.getENSRegistry()\\n  }\\n\\n  IpfsController.prototype.loadErudaLibrary = async function () {\\n    return await this.ipfsBundle.loadErudaLibrary()\\n  }\\n\\n  IpfsController.prototype.loadEthSigUtilLibrary = async function () {\\n    return await this.ipfsBundle.loadEthSigUtilLibrary()\\n  }\\n\\n  IpfsController.prototype.deflate = function (str) {\\n    return this.ipfsBundle.deflate(str)\\n  }\\n\\n  IpfsController.prototype.inflate = function (b64) {\\n    return this.ipfsBundle.inflate(b64)\\n  }\\n\\n  exports.IpfsController = IpfsController\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-import.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-import.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-import.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Import\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const name = 'ipfs-import'\\n\\n  const tiddlyWikiType = 'text/vnd.tiddlywiki'\\n\\n  const local = '<a href=\\\"'\\n  const remote = '<a class=\\\"tc-tiddlylink-external\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\" href=\\\"'\\n\\n  const alertFailed = function (strings, msg, key, field, parentField, parentUrl, parentTitle) {\\n    var space = strings[1]\\n    var endH1 = strings[2]\\n    var endL1 = strings[3]\\n    var from = strings[4]\\n    var endH2 = strings[5]\\n    var endL2 = strings[6]\\n    if (parentUrl.hostname === $tw.ipfs.getIpfsBaseUrl().hostname && parentUrl.pathname === $tw.ipfs.getIpfsBaseUrl().pathname) {\\n      return `${msg}${space}${remote}${key}${endH1}${field}${endL1}${parentField}${from}${local}${parentUrl}${endH2}${parentTitle}${endL2}`\\n    } else {\\n      return `${msg}${space}${remote}${key}${endH1}${field}${endL1}${parentField}${from}${remote}${parentUrl}${endH2}${parentTitle}${endL2}`\\n    }\\n  }\\n\\n  const alertFieldFailed = function (strings, msg, field, url, title) {\\n    var failed = strings[1]\\n    var from = strings[2]\\n    var endH = strings[3]\\n    var endL = strings[4]\\n    if (url.hostname === $tw.ipfs.getIpfsBaseUrl().hostname && url.pathname === $tw.ipfs.getIpfsBaseUrl().pathname) {\\n      return `${msg}${failed}${field}${from}${local}${url}${endH}${title}${endL}`\\n    } else {\\n      return `${msg}${failed}${field}${from}${remote}${url}${endH}${title}${endL}`\\n    }\\n  }\\n\\n  const alertConditionFailed = function (strings, msg, condition, key, title, parentUrl) {\\n    var space = strings[1]\\n    var from = strings[2]\\n    var endH1 = strings[3]\\n    var endL1 = strings[4]\\n    var endH2 = strings[5]\\n    var endL2 = strings[6]\\n    if (parentUrl.hostname === $tw.ipfs.getIpfsBaseUrl().hostname && parentUrl.pathname === $tw.ipfs.getIpfsBaseUrl().pathname) {\\n      return `${msg}${space}${condition}${from}${remote}${key}${endH1}${title}${endL1}${local}${parentUrl}${endH2}${title}${endL2}`\\n    } else {\\n      return `${msg}${space}${condition}${from}${remote}${key}${endH1}${title}${endL1}${remote}${parentUrl}${endH2}${title}${endL2}`\\n    }\\n  }\\n\\n  var IpfsImport = function () {}\\n\\n  IpfsImport.prototype.removeTiddlers = function (keys, title) {\\n    var removed = 0\\n    for (var key of this.loaded.keys()) {\\n      if (keys.indexOf(key) !== -1) {\\n        continue\\n      }\\n      const { imported, resolvedKey } = this.loaded.get(key)\\n      if (imported.delete(title)) {\\n        const msg = 'Remove:'\\n        const field = ''\\n        $tw.ipfs.getLogger().info(\\n          `${msg} ${field}\\\"${title}\\\"\\n ${resolvedKey}`\\n        )\\n        $tw.utils.alert(name, alertFieldFailed`${msg} ${field}${resolvedKey}\\\">${title}</a>`)\\n        removed += 1\\n      }\\n    }\\n    return removed\\n  }\\n\\n  IpfsImport.prototype.getKey = async function (value, base) {\\n    var cid = null\\n    var ipnsKey = null\\n    var key = null\\n    var normalizedUrl = null\\n    var resolvedUrl = null\\n    value = value === undefined || value == null || value.toString().trim() === '' ? null : value.toString().trim()\\n    if (value == null) {\\n      return {\\n        key: null,\\n        isIpfs: false,\\n        resolvedUrl: null,\\n      }\\n    }\\n    var { cid, ipnsKey, normalizedUrl, resolvedUrl } = await $tw.ipfs.resolveUrl(false, true, value, base)\\n    if (normalizedUrl == null && resolvedUrl == null) {\\n      throw new Error(`Failed to resolve value: ${value}`)\\n    }\\n    if (normalizedUrl.hostname.endsWith('.eth') || normalizedUrl.hostname.endsWith('.eth.link')) {\\n      key = normalizedUrl.hostname\\n    } else if (cid !== null) {\\n      key = `ipfs://${cid}`\\n    } else if (ipnsKey !== null) {\\n      key = `ipns://${ipnsKey}`\\n    } else {\\n      key = normalizedUrl.toString()\\n    }\\n    return {\\n      key: key,\\n      resolvedUrl: resolvedUrl,\\n    }\\n  }\\n\\n  IpfsImport.prototype.isIpfs = async function (key) {\\n    key = key === undefined || key == null || key.trim() === '' ? null : key.trim()\\n    if (key == null) {\\n      return false\\n    }\\n    const { cid, ipnsIdentifier, protocol } = $tw.ipfs.decodeCid(key)\\n    if (key.endsWith('.eth') || key.endsWith('.eth.link') || (protocol !== null && (cid !== null || ipnsIdentifier !== null))) {\\n      return true\\n    }\\n    return false\\n  }\\n\\n  IpfsImport.prototype.import = async function (canonicalUri, importUri, tiddler) {\\n    canonicalUri = canonicalUri === undefined || canonicalUri == null || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n    importUri = importUri === undefined || importUri == null || importUri.trim() === '' ? null : importUri.trim()\\n    var password = tiddler.fields._password\\n    password = password === undefined || password == null || password.trim() === '' ? null : password.trim()\\n    const { type } = $tw.utils.getContentType(tiddler.fields.title, tiddler.fields.type)\\n    this.loaded = new Map()\\n    this.notLoaded = []\\n    this.isEmpty = []\\n    this.resolved = new Map()\\n    this.notResolved = []\\n    this.merged = new Map()\\n    try {\\n      // Load and prepare imported tiddlers to be processed\\n      const host = $tw.ipfs.getUrl(`#${tiddler.fields.title}`, $tw.ipfs.getIpfsBaseUrl())\\n      if (canonicalUri !== null || importUri !== null) {\\n        if (importUri !== null) {\\n          await this.load(host, tiddler.fields.title, '_import_uri', importUri, password, true)\\n        }\\n        if (canonicalUri !== null) {\\n          await this.load(host, tiddler.fields.title, '_canonical_uri', canonicalUri, password, tiddlyWikiType === type)\\n        }\\n        // Process\\n        this.processImported()\\n        // Import\\n        var rootUri = importUri !== null ? importUri : canonicalUri\\n        this.importTiddlers(rootUri)\\n        // Deleted\\n        var deleted = new Map()\\n        var titles = $tw.wiki.getTiddlers({ includeSystem: true })\\n        for (var i = 0; i < titles.length; i++) {\\n          const title = titles[i]\\n          const current = $tw.wiki.getTiddler(title)\\n          canonicalUri = current.fields._canonical_uri\\n          canonicalUri = canonicalUri === undefined || canonicalUri == null || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n          if (canonicalUri !== null) {\\n            var key = this.resolved.get(canonicalUri)\\n            if (key === undefined) {\\n              var { key } = await this.getKey(canonicalUri, rootUri)\\n            }\\n            if (key === rootUri && this.merged.get(title) === undefined && deleted.get(title) === undefined) {\\n              deleted.set(title, JSON.parse($tw.wiki.getTiddlerAsJson(title)))\\n            }\\n          }\\n          importUri = current.fields._import_uri\\n          importUri = importUri === undefined || importUri == null || importUri.trim() === '' ? null : importUri.trim()\\n          if (importUri !== null) {\\n            var key = this.resolved.get(importUri)\\n            if (key === undefined) {\\n              var { key } = await this.getKey(importUri, rootUri)\\n            }\\n            if (key === rootUri && this.merged.get(title) === undefined && deleted.get(title) === undefined) {\\n              deleted.set(title, JSON.parse($tw.wiki.getTiddlerAsJson(title)))\\n            }\\n          }\\n        }\\n        return {\\n          merged: this.merged,\\n          deleted: deleted,\\n          loaded: this.loaded,\\n          isEmpty: this.isEmpty,\\n          notLoaded: this.notLoaded,\\n          notResolved: this.notResolved,\\n        }\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n    }\\n    this.loaded = null\\n    this.isEmpty = null\\n    this.notLoaded = null\\n    this.resolved = null\\n    this.notResolved = null\\n    this.merged = null\\n  }\\n\\n  IpfsImport.prototype.load = async function (parentUrl, parentTitle, field, url, password, load) {\\n    var loaded = 0\\n    var removed = 0\\n    var key = null\\n    var resolvedUrl = null\\n    if (url !== null && this.notResolved.indexOf(url) === -1 && this.resolved.get(url) === undefined) {\\n      try {\\n        var { key, resolvedUrl } = await this.getKey(url, parentUrl)\\n        this.resolved.set(url, key)\\n      } catch (error) {\\n        const msg = 'Failed to Resolve:'\\n        this.notResolved.push(url)\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${parentUrl}\\\">${parentTitle}</a>`)\\n      }\\n    }\\n    if (load && key !== null && resolvedUrl !== null && this.notLoaded.indexOf(key) === -1 && this.loaded.get(key) === undefined) {\\n      const { loaded: loadedAdded, removed: loadedRemoved } = await this.loadResource(parentUrl, parentTitle, field, url, key, resolvedUrl, password)\\n      loaded = loadedAdded\\n      removed = loadedRemoved\\n    }\\n    return {\\n      loaded: loaded,\\n      removed: removed,\\n    }\\n  }\\n\\n  /**\\n   * https://stackoverflow.com/questions/15458876/check-if-a-string-is-html-or-not/15458987\\n   */\\n  IpfsImport.prototype.isHTML = function (text) {\\n    /*eslint max-len:\\\"off\\\"*/\\n    return /<(br|basefont|hr|input|source|frame|param|area|meta|!--|col|link|option|base|img|wbr|!DOCTYPE).*?>|<(a|abbr|acronym|address|applet|article|aside|audio|b|bdi|bdo|big|blockquote|body|button|canvas|caption|center|cite|code|colgroup|command|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|em|embed|fieldset|figcaption|figure|font|footer|form|frameset|head|header|hgroup|h1|h2|h3|h4|h5|h6|html|i|iframe|ins|kbd|keygen|label|legend|li|map|mark|menu|meter|nav|noframes|noscript|object|ol|optgroup|output|p|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|span|strike|strong|style|sub|summary|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video).*?<\\\\/\\\\2>/i.test(\\n      text\\n    )\\n  }\\n\\n  IpfsImport.prototype.loadResource = async function (parentUrl, parentTitle, parentField, url, key, resolvedKey, password) {\\n    var loaded = 0\\n    var removed = 0\\n    var content = null\\n    var imported = new Map()\\n    var tiddlers = null\\n    const creationFields = $tw.wiki.getCreationFields()\\n    try {\\n      // Load\\n      content = await $tw.ipfs.loadToUtf8(resolvedKey, password)\\n      // HTML\\n      if (this.isHTML(content)) {\\n        content = $tw.wiki.deserializeTiddlers('.html', content, creationFields)\\n        if ($tw.utils.isArray(content) && content.length === 1 && content[0].text && $tw.ipfs.isJson(content[0].text)) {\\n          tiddlers = Object.values(JSON.parse(content[0].text))\\n        } else {\\n          tiddlers = content\\n        }\\n      } else {\\n        if ($tw.ipfs.isJson(content)) {\\n          tiddlers = $tw.wiki.deserializeTiddlers('.json', content, creationFields)\\n        } else {\\n          tiddlers = $tw.wiki.deserializeTiddlers('.tid', content, creationFields)\\n        }\\n      }\\n      // Loaded\\n      if (tiddlers !== undefined && tiddlers !== null) {\\n        this.loaded.set(key, {\\n          imported: imported,\\n          resolvedKey: resolvedKey,\\n          url: url,\\n        })\\n        for (var i in tiddlers) {\\n          const tiddler = tiddlers[i]\\n          var title = tiddler.title\\n          if (title === undefined || title == null || title.trim() === '') {\\n            const msg = 'Ignore Unknown:'\\n            const field = 'Title'\\n            $tw.ipfs.getLogger().info(\\n              `${msg} \\\"${field}\\\"\\n ${resolvedKey}\\n from \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n            )\\n            $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${field}</a>, from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n            removed += 1\\n            continue\\n          }\\n          if (imported.get(title) !== undefined) {\\n            const msg = 'Ignore Duplicate:'\\n            $tw.ipfs.getLogger().info(\\n              `${msg} \\\"${title}\\\"\\n ${resolvedKey}\\n from \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n            )\\n            $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${title}</a>, from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n            removed += 1\\n            continue\\n          }\\n          var type = tiddler.type\\n          if (type === undefined || type == null) {\\n            type = tiddlyWikiType\\n          }\\n          var info = $tw.config.contentTypeInfo[type]\\n          if (info === undefined || info == null) {\\n            const msg = 'Unknown:'\\n            const field = 'Content-Type'\\n            $tw.ipfs.getLogger().info(\\n              `${msg} \\\"${field}\\\": \\\"${title}\\\"\\n ${resolvedKey}`\\n            )\\n            $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\": ${resolvedKey}\\\">${title}</a>`)\\n            // Default\\n            type = tiddlyWikiType\\n            info = $tw.config.contentTypeInfo[type]\\n          }\\n          tiddler.type = type\\n          // Next\\n          var canonicalUri = tiddler._canonical_uri\\n          canonicalUri = canonicalUri === undefined || canonicalUri == null || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n          tiddler._canonical_uri = canonicalUri\\n          var importUri = tiddler._import_uri\\n          importUri = importUri === undefined || importUri == null || importUri.trim() === '' ? null : importUri.trim()\\n          tiddler._import_uri = importUri\\n          if (canonicalUri !== null || importUri !== null) {\\n            password = tiddler._password\\n            password = password === undefined || password == null || password.trim() === '' ? null : password.trim()\\n            if (importUri !== null) {\\n              const { loaded: loadedAdded, removed: loadedRemoved } = await this.load(resolvedKey, title, '_import_uri', importUri, password, true)\\n              loaded += loadedAdded\\n              removed += loadedRemoved\\n            }\\n            if (canonicalUri !== null) {\\n              const { loaded: loadedAdded, removed: loadedRemoved } = await this.load(resolvedKey, title, 'canonical_uri', canonicalUri, password, tiddlyWikiType === tiddler.type)\\n              loaded += loadedAdded\\n              removed += loadedRemoved\\n            }\\n          }\\n          imported.set(title, tiddler)\\n          loaded += 1\\n        }\\n      }\\n      if (imported.size === 0) {\\n        this.isEmpty.push(key)\\n        const msg = 'Empty:'\\n        const field = 'Resource'\\n        $tw.ipfs.getLogger().info(\\n          `${msg} \\\"${field}\\\"\\n ${resolvedKey}\\n from \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n        )\\n        $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${field}</a> from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n      }\\n    } catch (error) {\\n      this.notLoaded.push(key)\\n      const msg = 'Failed to Load:'\\n      const field = 'Resource'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\"\\n ${resolvedKey}\\n from \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n      )\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${field}</a> from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n    }\\n    return {\\n      loaded: loaded,\\n      removed: removed,\\n    }\\n  }\\n\\n  IpfsImport.prototype.performImport = function (toBeAdded, toBeUpdated, toBeDeleted) {\\n    // New and Updated\\n    for (var [title, merged] of this.merged.entries()) {\\n      if (toBeAdded.indexOf(title) || toBeUpdated.indexOf(title) !== -1) {\\n        $tw.wiki.addTiddler(merged)\\n      }\\n    }\\n    // Deleted\\n    for (var i = 0; i < toBeDeleted.length; i++) {\\n      $tw.wiki.deleteTiddler(toBeDeleted[i])\\n    }\\n  }\\n\\n  IpfsImport.prototype.processImported = function () {\\n    var processed = 0\\n    var removed = 0\\n    var processedTitles = []\\n    for (var key of this.loaded.keys()) {\\n      const { imported, resolvedKey } = this.loaded.get(key)\\n      for (var title of imported.keys()) {\\n        if (processedTitles.indexOf(title) !== -1) {\\n          continue\\n        }\\n        const keys = []\\n        const tiddler = imported.get(title)\\n        var type = tiddler.type\\n        var canonicalUri = tiddler._canonical_uri\\n        canonicalUri = canonicalUri === undefined || canonicalUri == null || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n        var importUri = tiddler._import_uri\\n        importUri = importUri === undefined || importUri == null || importUri.trim() === '' ? null : importUri.trim()\\n        if (canonicalUri == null && importUri == null) {\\n          keys.push(key)\\n        } else if (canonicalUri == null && importUri !== null) {\\n          const msg = 'Missing:'\\n          const field = '_canonical_uri'\\n          $tw.ipfs.getLogger().info(\\n            `${msg} \\\"${field}\\\" from ${title}\\\"\\n ${resolvedKey}`\\n          )\\n          $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a>`)\\n        } else {\\n          var canonicalKey = null\\n          if (canonicalUri !== null && this.notResolved.indexOf(canonicalUri) === -1) {\\n            canonicalKey = this.resolved.get(canonicalUri)\\n          }\\n          if (canonicalKey !== undefined && canonicalKey !== null) {\\n            if (key === canonicalKey) {\\n              const msg = 'Cycle:'\\n              const field = '_canonical_uri'\\n              $tw.ipfs.getLogger().info(\\n                `${msg} \\\"${field}\\\" from ${title}\\\"\\n ${resolvedKey}`\\n              )\\n              $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a>`)\\n            } else if (this.processCanonicalKey(keys, resolvedKey, title, canonicalKey, type)) {\\n              var importKey = null\\n              if (importUri !== null && this.notResolved.indexOf(importUri) === -1) {\\n                importKey = this.resolved.get(importUri)\\n              }\\n              if (importKey === undefined || importKey == null) {\\n                keys.push(key)\\n              } else {\\n                if (canonicalKey === importKey) {\\n                  const msg = 'Matching:'\\n                  const field = '\\\"_canonical_uri\\\" and \\\"_import_uri\\\"'\\n                  $tw.ipfs.getLogger().info(\\n                    `${msg} ${field} from \\\"${title}\\\"\\n ${resolvedKey}`\\n                  )\\n                  $tw.utils.alert(name, alertFieldFailed`${msg} ${field} from ${resolvedKey}\\\">${title}</a>`)\\n                } else if (key === importKey) {\\n                  const msg = 'Cycle:'\\n                  const field = '_import_uri'\\n                  $tw.ipfs.getLogger().info(\\n                    `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${resolvedKey}`\\n                  )\\n                  $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a>`)\\n                } else {\\n                  keys.push(key)\\n                  this.processImportKey(keys, resolvedKey, title, canonicalKey, importKey)\\n                }\\n              }\\n            }\\n          }\\n        }\\n        processed += keys.length\\n        removed += this.removeTiddlers(keys, title)\\n        processedTitles.push(title)\\n      }\\n    }\\n    return {\\n      processed: processed,\\n      removed: removed,\\n    }\\n  }\\n\\n  IpfsImport.prototype.processCanonicalKey = function (keys, parentResolvedKey, title, canonicalKey, type) {\\n    if (tiddlyWikiType !== type) {\\n      keys.push(canonicalKey)\\n      return true\\n    }\\n    if (this.notLoaded.indexOf(canonicalKey) !== -1) {\\n      return false\\n    }\\n    if (this.loaded.get(canonicalKey) === undefined) {\\n      return false\\n    }\\n    const { imported, resolvedKey } = this.loaded.get(canonicalKey)\\n    if (imported === undefined) {\\n      return false\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    var canonicalUri = tiddler._canonical_uri\\n    canonicalUri = canonicalUri == null || canonicalUri === undefined || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n    if (canonicalUri !== null) {\\n      const msg = 'Inconsistency:'\\n      const field = '_canonical_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${resolvedKey}\\n and ${parentResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertConditionFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a> and ${parentResolvedKey}\\\">${title}</a>`)\\n      return false\\n    }\\n    var importUri = tiddler._import_uri\\n    importUri = importUri == null || importUri === undefined || importUri.trim() === '' ? null : importUri.trim()\\n    if (importUri !== null) {\\n      const msg = 'Inconsistency:'\\n      const field = '_import_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${resolvedKey}\\n and ${parentResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertConditionFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a> and ${parentResolvedKey}\\\">${title}</a>`)\\n      return false\\n    }\\n    keys.push(canonicalKey)\\n    return true\\n  }\\n\\n  IpfsImport.prototype.processImportKey = function (keys, parentResolvedKey, title, canonicalKey, importKey) {\\n    if (this.notLoaded.indexOf(importKey) !== -1) {\\n      return\\n    }\\n    if (this.loaded.get(importKey) === undefined) {\\n      return\\n    }\\n    const { imported, resolvedKey: importResolvedKey } = this.loaded.get(importKey)\\n    if (imported === undefined) {\\n      return\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return\\n    }\\n    var targetCanonicalUri = tiddler._canonical_uri\\n    targetCanonicalUri = targetCanonicalUri == null || targetCanonicalUri === undefined || targetCanonicalUri.trim() === '' ? null : targetCanonicalUri.trim()\\n    var targetCanonicalKey = null\\n    if (targetCanonicalUri !== null && this.notResolved.indexOf(targetCanonicalUri) === -1) {\\n      targetCanonicalKey = this.resolved.get(targetCanonicalUri)\\n    }\\n    if (targetCanonicalKey !== undefined && targetCanonicalKey !== null && canonicalKey !== targetCanonicalKey) {\\n      const msg = 'Inconsistency:'\\n      const field = '_canonical_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${importResolvedKey}\\n and ${parentResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertConditionFailed`${msg} \\\"${field}\\\" from ${importResolvedKey}\\\">${title}</a> and ${parentResolvedKey}\\\">${title}</a>`)\\n      return\\n    }\\n    var nextImportUri = tiddler._import_uri\\n    nextImportUri = nextImportUri == null || nextImportUri === undefined || nextImportUri.trim() === '' ? null : nextImportUri.trim()\\n    if (targetCanonicalUri == null && nextImportUri !== null) {\\n      const msg = 'Missing:'\\n      const field = '_canonical_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${importResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${importResolvedKey}\\\">${title}</a>`)\\n      return\\n    }\\n    if (nextImportUri == null) {\\n      keys.push(importKey)\\n    } else {\\n      var nextImportKey = null\\n      if (nextImportUri !== null && this.notResolved.indexOf(nextImportUri) === -1) {\\n        nextImportKey = this.resolved.get(nextImportUri)\\n      }\\n      if (nextImportKey !== undefined && nextImportKey !== null) {\\n        if (canonicalKey === nextImportKey) {\\n          const msg = 'Matching:'\\n          const field = '\\\"_canonical_uri\\\" and \\\"_import_uri\\\"'\\n          $tw.ipfs.getLogger().info(\\n            `${msg} ${field} from \\\"${title}\\\"\\n ${importResolvedKey}`\\n          )\\n          $tw.utils.alert(name, alertFieldFailed`${msg} ${field} from ${importResolvedKey}\\\">${title}</a>`)\\n        } else if (keys.indexOf(nextImportKey) !== -1) {\\n          const msg = 'Cycle:'\\n          const field = '_import_uri'\\n          $tw.ipfs.getLogger().info(\\n            `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${importResolvedKey}`\\n          )\\n          $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${importResolvedKey}\\\">${title}</a>`)\\n        } else {\\n          keys.push(importKey)\\n          this.processImportKey(keys, importResolvedKey, title, canonicalKey, nextImportKey)\\n        }\\n      }\\n    }\\n  }\\n\\n  IpfsImport.prototype.importTiddlers = function (rootUri) {\\n    var processedTitles = []\\n    for (var key of this.loaded.keys()) {\\n      const { imported, url } = this.loaded.get(key)\\n      for (var title of imported.keys()) {\\n        if (processedTitles.indexOf(title) !== -1) {\\n          continue\\n        }\\n        const tiddler = imported.get(title)\\n        var type = tiddler.type\\n        var canonicalUri = tiddler._canonical_uri\\n        canonicalUri = canonicalUri === undefined || canonicalUri == null || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n        var importUri = tiddler._import_uri\\n        importUri = importUri === undefined || importUri == null || importUri.trim() === '' ? null : importUri.trim()\\n        var processed\\n        if (importUri !== null) {\\n          processed = this.importTiddler(title, importUri)\\n        }\\n        if (!processed && canonicalUri !== null && tiddlyWikiType === type) {\\n          this.importTiddler(title, canonicalUri)\\n        }\\n        if (this.mergeTiddler(title, url)) {\\n          const merged = this.merged.get(title)\\n          var type = merged.type\\n          if (tiddlyWikiType !== type) {\\n            if (rootUri.startsWith('blob:') === false) {\\n              merged._import_uri = rootUri\\n            }\\n          } else {\\n            var canonicalUri = merged._canonical_uri\\n            if (canonicalUri === undefined || canonicalUri == null) {\\n              if (url !== rootUri) {\\n                merged._canonical_uri = this.resolved.get(url)\\n                if (rootUri.startsWith('blob:') === false) {\\n                  merged._import_uri = rootUri\\n                }\\n              } else {\\n                if (rootUri.startsWith('blob:') === false) {\\n                  merged._canonical_uri = rootUri\\n                }\\n              }\\n            } else {\\n              merged._canonical_uri = this.resolved.get(canonicalUri)\\n              if (canonicalUri !== rootUri && rootUri.startsWith('blob:') === false) {\\n                merged._import_uri = rootUri\\n              }\\n            }\\n          }\\n        }\\n        processedTitles.push(title)\\n      }\\n    }\\n  }\\n\\n  IpfsImport.prototype.importTiddler = function (title, uri) {\\n    const key = this.resolved.get(uri)\\n    if (key === undefined) {\\n      return false\\n    }\\n    if (this.loaded.get(key) === undefined) {\\n      return false\\n    }\\n    const { imported } = this.loaded.get(key)\\n    if (imported === undefined) {\\n      return false\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    var type = tiddler.type\\n    var importUri = tiddler._import_uri\\n    importUri = importUri == null || importUri === undefined || importUri.trim() === '' ? null : importUri.trim()\\n    var canonicalUri = tiddler._canonical_uri\\n    canonicalUri = canonicalUri == null || canonicalUri === undefined || canonicalUri.trim() === '' ? null : canonicalUri.trim()\\n    var processed\\n    if (importUri !== null) {\\n      processed = this.importTiddler(title, importUri)\\n    }\\n    if (!processed && canonicalUri !== null && tiddlyWikiType === type) {\\n      this.importTiddler(title, canonicalUri)\\n    }\\n    return this.mergeTiddler(title, uri)\\n  }\\n\\n  IpfsImport.prototype.mergeTiddler = function (title, uri) {\\n    const key = this.resolved.get(uri)\\n    if (key === undefined) {\\n      return false\\n    }\\n    if (this.loaded.get(key) === undefined) {\\n      return false\\n    }\\n    const { imported } = this.loaded.get(key)\\n    if (imported === undefined) {\\n      return false\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    // Retrieve target host Tiddler\\n    var currentTiddler = $tw.wiki.getTiddler(title)\\n    // Retrieve or prepare merged content\\n    var merged = this.merged.get(title)\\n    if (merged === undefined) {\\n      merged = {}\\n      this.merged.set(title, merged)\\n    }\\n    // Tags\\n    var tags = tiddler.tags !== undefined ? tiddler.tags : ''\\n    // Fields\\n    var hasModified = false\\n    for (var field in tiddler) {\\n      // Discard\\n      if (field === 'tags') {\\n        continue\\n      }\\n      if (field === 'modified') {\\n        hasModified = true\\n      }\\n      // Unknown from leaf to top, we keep the top modified field\\n      if (merged[field] === undefined || merged[field] == null || field === '_canonical_uri' || field === '_import_uri' || field === 'modified') {\\n        merged[field] = tiddler[field]\\n      }\\n    }\\n    if (hasModified === false) {\\n      merged.modified = new Date()\\n    }\\n    // Merge current Tiddler Tags\\n    if (currentTiddler !== undefined && currentTiddler !== null) {\\n      const currentTags = (currentTiddler.fields.tags || []).slice(0)\\n      for (var i = 0; i < currentTags.length; i++) {\\n        const currentTag = currentTags[i]\\n        if (tags.includes(currentTag) === false) {\\n          tags = `${tags} [[${currentTag}]]`\\n        }\\n      }\\n    }\\n    // Merge Tags\\n    if (merged.tags !== undefined && merged.tags !== null) {\\n      const mergedTags = $tw.utils.parseStringArray(merged.tags, false)\\n      for (var i = 0; i < mergedTags.length; i++) {\\n        const mergedTag = mergedTags[i]\\n        if (tags.includes(mergedTag) === false) {\\n          tags = `${tags} [[${mergedTag}]]`\\n        }\\n      }\\n    }\\n    // IPFS tag\\n    if (this.isIpfs(key) && tags.includes('$:/isIpfs') === false) {\\n      tags = `${tags} $:/isIpfs`\\n    }\\n    // Imported tag\\n    if (tags.includes('$:/isImported') === false) {\\n      tags = `${tags} $:/isImported`\\n    }\\n    // Processed tags\\n    merged.tags = tags\\n    // Processed\\n    return true\\n  }\\n\\n  exports.IpfsImport = IpfsImport\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-tiddler.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-tiddler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-tiddler.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Tiddler\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const IpfsImport = require('$:/plugins/ipfs/ipfs-import.js').IpfsImport\\n\\n  const name = 'ipfs-tiddler'\\n\\n  /*\\n   * https://tiddlywiki.com/#TiddlerFields\\n   * $:/core/modules/server/routes/get-tiddler.js\\n   * TODO: expose it as Tiddler ??\\n   */\\n  const reservedFields = [\\n    'bag',\\n    'caption',\\n    'class',\\n    'color',\\n    'description',\\n    'created',\\n    'creator',\\n    'fields',\\n    'footer',\\n    'hide-body',\\n    'icon',\\n    '_is_skinny',\\n    'library',\\n    'list',\\n    'list-after',\\n    'list-before',\\n    'modified',\\n    'modifier',\\n    'name',\\n    'plugin-priority',\\n    'plugin-type',\\n    'permissions',\\n    'recipe',\\n    'revision',\\n    // \\\"source\\\",\\n    'subtitle',\\n    'tags',\\n    'text',\\n    // \\\"url\\\",\\n    'throttle.refresh',\\n    'toc-link',\\n    'title',\\n    'type',\\n  ]\\n\\n  var IpfsTiddler = function () {\\n    this.once = false\\n  }\\n\\n  IpfsTiddler.prototype.init = function () {\\n    // Init once\\n    if (this.once) {\\n      return\\n    }\\n    const self = this\\n    // Events\\n    $tw.wiki.addEventListener('change', function (changes) {\\n      return self.handleChangeEvent(changes)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipfs-pin', function (event) {\\n      return self.handleIpfsPin(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipfs-unpin', function (event) {\\n      return self.handleIpfsUnpin(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-refresh-tiddler', function (event) {\\n      return self.handleRefreshTiddler(event)\\n    })\\n    // Hooks\\n    $tw.hooks.addHook('th-deleting-tiddler', async function (tiddler) {\\n      return await self.handleDeleteTiddler(tiddler)\\n    })\\n    $tw.hooks.addHook('th-importing-file', async function (info) {\\n      return await self.handleImportFile(info)\\n    })\\n    $tw.hooks.addHook('th-saving-tiddler', async function (tiddler) {\\n      return await self.handleSaveTiddler(tiddler)\\n    })\\n    // Init once\\n    this.once = true\\n  }\\n\\n  IpfsTiddler.prototype.handleChangeEvent = function (changes) {\\n    // Gateway preference\\n    const api = changes['$:/ipfs/saver/api']\\n    if (api !== undefined && api.modified) {\\n      $tw.ipfs.getLogger().info(`IPFS API: ${$tw.ipfs.getIpfsApiUrl()}`)\\n    }\\n    // Gateway preference\\n    const gateway = changes['$:/ipfs/saver/gateway']\\n    if (gateway !== undefined && gateway.modified) {\\n      const base = $tw.ipfs.getIpfsBaseUrl()\\n      if ($tw.utils.getIpfsUrlPolicy() === 'gateway') {\\n        $tw.ipfs.getLogger().info(`Gateway Policy: ${base}`)\\n      }\\n    }\\n    // Policy preference\\n    const policy = changes['$:/ipfs/saver/policy']\\n    if (policy !== undefined && policy.modified) {\\n      const base = $tw.ipfs.getIpfsBaseUrl()\\n      if ($tw.utils.getIpfsUrlPolicy() === 'origin') {\\n        $tw.ipfs.getLogger().info(`Origin Policy: ${base}`)\\n      } else {\\n        $tw.ipfs.getLogger().info(`Gateway Policy: ${base}`)\\n      }\\n    }\\n    // Pin preference\\n    const pin = changes['$:/ipfs/saver/pin']\\n    if (pin !== undefined && pin.modified) {\\n      if ($tw.utils.getIpfsPin()) {\\n        $tw.ipfs.getLogger().info('Pin current IPFS content...')\\n      } else {\\n        $tw.ipfs.getLogger().info('Do not pin current IPFS content...')\\n      }\\n    }\\n    // Unpin preference\\n    const unpin = changes['$:/ipfs/saver/unpin']\\n    if (unpin !== undefined && unpin.modified) {\\n      if ($tw.utils.getIpfsUnpin()) {\\n        $tw.ipfs.getLogger().info('Unpin previous IPFS content...')\\n      } else {\\n        $tw.ipfs.getLogger().info('Do not unpin previous IPFS content...')\\n      }\\n    }\\n    // Verbose preference\\n    const verbose = changes['$:/ipfs/saver/verbose']\\n    if (verbose !== undefined && verbose.modified) {\\n      if (window.log !== undefined && window.log !== null) {\\n        if ($tw.utils.getIpfsVerbose()) {\\n          window.log.setLevel('info', false)\\n        } else {\\n          window.log.setLevel('warn', false)\\n        }\\n      }\\n    }\\n  }\\n\\n  IpfsTiddler.prototype.handleIpfsPin = function (event) {\\n    const title = event.tiddlerTitle\\n    const tiddler = $tw.wiki.getTiddler(title)\\n    // Tiddler\\n    if (tiddler) {\\n      if (event.param) {\\n        // Tiddler\\n        for (var field in tiddler.fields) {\\n          if (reservedFields.indexOf(field) !== -1) {\\n            continue\\n          }\\n          var value = tiddler.getFieldString(field)\\n          value = value !== undefined && value !== null && value.trim() !== '' ? value.trim() : null\\n          if (value !== null) {\\n            this.ipfsPin(value, field)\\n          }\\n        }\\n        return true\\n      }\\n      return false\\n    }\\n    // Wiki\\n    this.ipfsPin($tw.ipfs.getDocumentUrl().toString(), 'Wiki')\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.ipfsPin = function (value, field) {\\n    $tw.ipfs\\n      .resolveUrl(true, true, value)\\n      .then(data => {\\n        const { cid, resolvedUrl } = data\\n        if (resolvedUrl !== null && cid !== null) {\\n          if (field !== undefined && field !== null) {\\n            $tw.ipfs.getLogger().info(\\n              `Pinning: \\\"${field}\\\"\\n ${resolvedUrl}`\\n            )\\n          }\\n          $tw.ipfs\\n            .pinToIpfs(cid)\\n            .then(data => {\\n              if (data !== undefined && data !== null) {\\n                $tw.ipfs.removeFromPinUnpin(cid, resolvedUrl)\\n                if (field) {\\n                  $tw.utils.alert(name, `Successfully Pinned : <a class=\\\"tc-tiddlylink-external\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\" href=\\\"${resolvedUrl}\\\">${field}</a>`)\\n                }\\n              }\\n            })\\n            .catch(error => {\\n              $tw.ipfs.getLogger().error(error)\\n              $tw.utils.alert(name, error.message)\\n            })\\n        }\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n  }\\n\\n  IpfsTiddler.prototype.handleIpfsUnpin = async function (event) {\\n    const title = event.tiddlerTitle\\n    const tiddler = $tw.wiki.getTiddler(title)\\n    if (tiddler) {\\n      const { type, info } = $tw.utils.getContentType(title, tiddler.fields.type)\\n      if (event.param) {\\n        // Tiddler\\n        for (var field in tiddler.fields) {\\n          if (reservedFields.indexOf(field) !== -1) {\\n            continue\\n          }\\n          var value = tiddler.getFieldString(field)\\n          value = value !== undefined && value !== null && value.trim() !== '' ? value.trim() : null\\n          if (value !== null) {\\n            if (info.encoding !== 'base64' && type !== 'image/svg+xml') {\\n              if (field === '_canonical_uri' || field === '_import_uri') {\\n                continue\\n              }\\n            }\\n            this.ipfsUnpin(value, field)\\n          }\\n        }\\n        return true\\n      }\\n      return false\\n    }\\n    // Wiki\\n    this.ipfsUnpin($tw.ipfs.getDocumentUrl().toString(), 'Wiki')\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.ipfsUnpin = function (value, field) {\\n    field = field !== undefined && field !== null && field.trim() !== '' ? field.trim() : null\\n    $tw.ipfs\\n      .resolveUrl(true, true, value)\\n      .then(data => {\\n        const { cid, resolvedUrl } = data\\n        if (resolvedUrl !== null && cid !== null) {\\n          if (field !== null) {\\n            $tw.ipfs.getLogger().info(\\n              `Unpinning: \\\"${field}\\n ${resolvedUrl}`\\n            )\\n          }\\n          $tw.ipfs\\n            .unpinFromIpfs(cid)\\n            .then(data => {\\n              if (data !== undefined && data !== null) {\\n                $tw.ipfs.removeFromPinUnpin(cid, resolvedUrl)\\n                if (field !== null) {\\n                  $tw.utils.alert(name, `Successfully Unpinned : <a rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\" href=\\\"${resolvedUrl}\\\">${field}</a>`)\\n                }\\n              }\\n            })\\n            .catch(error => {\\n              $tw.ipfs.getLogger().error(error)\\n              $tw.utils.alert(name, error.message)\\n            })\\n        }\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n  }\\n\\n  IpfsTiddler.prototype.handleDeleteTiddler = async function (tiddler) {\\n    try {\\n      const { type, info } = $tw.utils.getContentType(tiddler.fields.title, tiddler.fields.type)\\n      // Process\\n      var field = null\\n      if (info.encoding === 'base64' || type === 'image/svg+xml') {\\n        field = '_canonical_uri'\\n      } else {\\n        field = '_export_uri'\\n      }\\n      // Value\\n      var url = null\\n      const value = tiddler.getFieldString(field)\\n      if (value !== undefined && value !== null && value.trim() !== '') {\\n        // URL or not\\n        try {\\n          url = $tw.ipfs.normalizeUrl(value)\\n        } catch (error) {\\n          // Ignore\\n        }\\n        // Process\\n        if (url) {\\n          const { cid } = $tw.ipfs.decodeCid(url)\\n          // Request to unpin\\n          if ($tw.utils.getIpfsUnpin()) {\\n            await $tw.ipfs.requestToUnpin(cid)\\n          }\\n        }\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n    }\\n    return tiddler\\n  }\\n\\n  IpfsTiddler.prototype.handleRefreshTiddler = function (event) {\\n    const title = event.tiddlerTitle\\n    const tiddler = $tw.wiki.getTiddler(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    var canonicalUri = tiddler.fields._canonical_uri\\n    canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n    var importUri = tiddler.fields._import_uri\\n    importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n    // Reload\\n    if (canonicalUri !== null && importUri == null) {\\n      const updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: '' }],\\n      })\\n      $tw.wiki.addTiddler(updatedTiddler)\\n      return true\\n    }\\n    // Import\\n    if (canonicalUri !== null || importUri !== null) {\\n      const ipfsImport = new IpfsImport()\\n      ipfsImport\\n        .import(canonicalUri, importUri, tiddler)\\n        .then(data => {\\n          if (data !== undefined && data !== null) {\\n            const navigator = $tw.utils.locateNavigatorWidget($tw.pageWidgetNode)\\n            if (navigator !== undefined && navigator !== null) {\\n              navigator.dispatchEvent({\\n                type: 'tm-ipfs-import-tiddlers',\\n                param: data,\\n              })\\n            }\\n          }\\n        })\\n        .catch(error => {\\n          $tw.ipfs.getLogger().error(error)\\n          $tw.utils.alert(name, error.message)\\n        })\\n      return true\\n    }\\n    // Refresh\\n    $tw.wiki.clearCache(title)\\n    const changedTiddler = $tw.utils.getChangedTiddler(title)\\n    $tw.rootWidget.refresh(changedTiddler)\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.handleImportFile = async function (info) {\\n    const dummy = new $tw.Tiddler({\\n      title: $tw.wiki.generateNewTitle('Untitled'),\\n      type: info.type,\\n    })\\n    try {\\n      const ipfsImport = new IpfsImport()\\n      const url = URL.createObjectURL(info.file)\\n      try {\\n        const data = await ipfsImport.import(null, url, dummy)\\n        if (data.merged.size > 0 || data.deleted.size > 0) {\\n          info.callback(data)\\n        }\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      }\\n      URL.revokeObjectURL(url)\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n    }\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.handleSaveTiddler = async function (tiddler) {\\n    const oldTiddler = $tw.wiki.getTiddler(tiddler.fields.title)\\n    const { info } = $tw.utils.getContentType(tiddler.fields.title, tiddler.fields.type)\\n    var password = tiddler.fields._password\\n    password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n    // Prepare\\n    var updatedTiddler = new $tw.Tiddler(tiddler)\\n    // Process deleted fields\\n    if (oldTiddler) {\\n      for (var field in oldTiddler.fields) {\\n        // Not a reserved keyword\\n        if (reservedFields.indexOf(field) !== -1) {\\n          continue\\n        }\\n        // Updated\\n        const discard = tiddler.fields[field]\\n        if (discard && tiddler.getFieldString(field)) {\\n          continue\\n        }\\n        // Process\\n        var oldCid = null\\n        var oldIpnsKey = null\\n        var oldNormalizedUrl = null\\n        var oldResolvedUrl = null\\n        var oldValue = oldTiddler.getFieldString(field)\\n        try {\\n          var { cid: oldCid, ipnsKey: oldIpnsKey, normalizedUrl: oldNormalizedUrl, resolvedUrl: oldResolvedUrl } = await $tw.ipfs.resolveUrl(false, true, oldValue)\\n        } catch (error) {\\n          $tw.ipfs.getLogger().error(error)\\n          $tw.utils.alert(name, error.message)\\n          return tiddler\\n        }\\n        oldResolvedUrl = oldResolvedUrl !== undefined && oldResolvedUrl !== null && oldResolvedUrl.toString().trim() !== '' ? oldResolvedUrl.toString().trim() : null\\n        if (oldResolvedUrl !== null && field === '_canonical_uri') {\\n          var data = tiddler.fields.text\\n          try {\\n            if (info.encoding === 'base64') {\\n              data = await $tw.ipfs.loadToBase64(oldResolvedUrl, password)\\n            } else {\\n              data = await $tw.ipfs.loadToUtf8(oldResolvedUrl, password)\\n            }\\n            updatedTiddler = $tw.utils.updateTiddler({\\n              tiddler: updatedTiddler,\\n              addTags: ['$:/isAttachment', '$:/isEmbedded'],\\n              fields: [{ key: 'text', value: data }],\\n            })\\n            $tw.ipfs.getLogger().info(\\n              `Embed attachment: ${data.length}\\n ${oldResolvedUrl}`\\n            )\\n          } catch (error) {\\n            $tw.ipfs.getLogger().error(error)\\n            $tw.utils.alert(name, error.message)\\n            return tiddler\\n          }\\n        }\\n        await $tw.ipfs.requestToUnpin(oldCid, oldIpnsKey, oldNormalizedUrl)\\n      }\\n    }\\n    // Process new and updated fields\\n    updatedTiddler = await this.updateIpfsTags(tiddler, oldTiddler, updatedTiddler)\\n    // Update\\n    $tw.wiki.addTiddler(updatedTiddler)\\n    return updatedTiddler\\n  }\\n\\n  IpfsTiddler.prototype.updateIpfsTags = async function (tiddler, oldTiddler, updatedTiddler) {\\n    var canonicalUri = null\\n    var exportUri = null\\n    var importUri = null\\n    var canonicalCid = null\\n    var exportCid = null\\n    var importCid = null\\n    var updatedTiddler = updatedTiddler === undefined || updatedTiddler == null ? new $tw.Tiddler(tiddler) : updatedTiddler\\n    const { type, info } = $tw.utils.getContentType(tiddler.fields.title, tiddler.fields.type)\\n    // Process\\n    for (var field in tiddler.fields) {\\n      // Not a reserved keyword\\n      if (reservedFields.indexOf(field) !== -1) {\\n        continue\\n      }\\n      // Process\\n      var cid = null\\n      var ipnsKey = null\\n      var normalizedUrl = null\\n      var resolvedUrl = null\\n      var value = tiddler.getFieldString(field)\\n      try {\\n        var { cid, ipnsKey, normalizedUrl, resolvedUrl } = await $tw.ipfs.resolveUrl(false, true, value)\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n        return tiddler\\n      }\\n      // Store\\n      resolvedUrl = resolvedUrl !== undefined && resolvedUrl !== null && resolvedUrl.toString().trim() !== '' ? resolvedUrl.toString().trim() : null\\n      if (field === '_canonical_uri') {\\n        canonicalUri = resolvedUrl\\n        canonicalCid = cid\\n      }\\n      if (field === '_import_uri') {\\n        importUri = resolvedUrl\\n        importCid = cid\\n      }\\n      if (field === '_export_uri') {\\n        exportUri = resolvedUrl\\n        exportCid = cid\\n      }\\n      // Previous values if any\\n      var oldValue = null\\n      if (oldTiddler !== undefined && oldTiddler !== null) {\\n        oldValue = oldTiddler.getFieldString(field)\\n      }\\n      // Process new or updated\\n      if (value === oldValue) {\\n        continue\\n      }\\n      var oldCid = null\\n      var oldIpnsKey = null\\n      var oldNormalizedUrl = null\\n      try {\\n        var { cid: oldCid, ipnsKey: oldIpnsKey, normalizedUrl: oldNormalizedUrl } = await $tw.ipfs.resolveUrl(false, true, oldValue)\\n      } catch (error) {\\n        // We cannot resolve the previous value\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      }\\n      await $tw.ipfs.requestToPin(cid, ipnsKey, normalizedUrl)\\n      await $tw.ipfs.requestToUnpin(oldCid, oldIpnsKey, oldNormalizedUrl)\\n    }\\n    // Tag management\\n    var addTags = []\\n    var removeTags = []\\n    if (canonicalUri == null && exportUri == null && importUri == null) {\\n      removeTags.push('$:/isExported', '$:/isImported', '$:/isIpfs')\\n    }\\n    if (canonicalCid == null && exportCid == null && importCid == null) {\\n      if (removeTags.indexOf('$:/isIpfs') === -1) {\\n        removeTags.push('$:/isIpfs')\\n      }\\n    } else {\\n      addTags.push('$:/isIpfs')\\n    }\\n    if (canonicalUri !== null) {\\n      // Attachment\\n      if (info.encoding === 'base64' || type === 'image/svg+xml') {\\n        if (addTags.indexOf('$:/isAttachment') === -1) {\\n          addTags.push('$:/isAttachment')\\n        }\\n        if (removeTags.indexOf('$:/isEmbedded') === -1) {\\n          removeTags.push('$:/isEmbedded')\\n        }\\n        if (importUri !== null) {\\n          if (addTags.indexOf('$:/isImported') === -1) {\\n            addTags.push('$:/isImported')\\n          }\\n        } else {\\n          if (removeTags.indexOf('$:/isImported') === -1) {\\n            removeTags.push('$:/isImported')\\n          }\\n        }\\n        // Others\\n      } else {\\n        if (removeTags.indexOf('$:/isAttachment') === -1) {\\n          removeTags.push('$:/isAttachment')\\n        }\\n        if (removeTags.indexOf('$:/isEmbedded') === -1) {\\n          removeTags.push('$:/isEmbedded')\\n        }\\n        if (addTags.indexOf('$:/isImported') === -1) {\\n          addTags.push('$:/isImported')\\n        }\\n      }\\n    } else {\\n      // Attachment\\n      if (info.encoding === 'base64' || type === 'image/svg+xml') {\\n        if (addTags.indexOf('$:/isAttachment') === -1) {\\n          addTags.push('$:/isAttachment')\\n        }\\n        if (addTags.indexOf('$:/isEmbedded') === -1) {\\n          addTags.push('$:/isEmbedded')\\n        }\\n        // Others\\n      } else {\\n        if (removeTags.indexOf('$:/isAttachment') === -1) {\\n          removeTags.push('$:/isAttachment')\\n        }\\n        if (removeTags.indexOf('$:/isEmbedded') === -1) {\\n          removeTags.push('$:/isEmbedded')\\n        }\\n      }\\n      if (importUri !== null) {\\n        if (addTags.indexOf('$:/isImported') === -1) {\\n          addTags.push('$:/isImported')\\n        }\\n      } else {\\n        if (removeTags.indexOf('$:/isImported') === -1) {\\n          removeTags.push('$:/isImported')\\n        }\\n      }\\n    }\\n    if (exportUri !== null) {\\n      if (addTags.indexOf('$:/isExported') === -1) {\\n        addTags.push('$:/isExported')\\n      }\\n    } else {\\n      if (removeTags.indexOf('$:/isExported') === -1) {\\n        removeTags.push('$:/isExported')\\n      }\\n    }\\n    if (addTags.length > 0 || removeTags.length > 0) {\\n      updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: updatedTiddler,\\n        addTags: addTags,\\n        removeTags: removeTags,\\n      })\\n    }\\n    return updatedTiddler\\n  }\\n\\n  exports.IpfsTiddler = IpfsTiddler\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-wrapper.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-wrapper.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-wrapper.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Wrapper\\n\\n\\\\*/\\n/*jslint node:true,browser:true*/\\n/*global $tw:false*/\\n'use strict'\\n\\nconst cidAnalyser = 'https://cid.ipfs.io/#'\\n\\nconst ipfsKeyword = 'ipfs'\\nconst ipnsKeyword = 'ipns'\\n\\n/*eslint no-unused-vars:\\\"off\\\"*/\\nconst name = 'ipfs-wrapper'\\n\\nvar IpfsWrapper = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle\\n  this.ipfsLibrary = ipfsBundle.ipfsLibrary\\n  this.ipfsUrl = ipfsBundle.ipfsUrl\\n}\\n\\nIpfsWrapper.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger()\\n}\\n\\nIpfsWrapper.prototype.getWindowIpfsClient = async function () {\\n  // IPFS Companion\\n  try {\\n    const policy = await this.ipfsLibrary.getWindowIpfs()\\n    if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n      return policy\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to retrieve IPFS Companion...')\\n}\\n\\nIpfsWrapper.prototype.getHttpIpfsClient = async function (url) {\\n  // HTTP Client\\n  try {\\n    const policy = await this.ipfsLibrary.getHttpIpfs(url)\\n    if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n      return policy\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to retrieve an IPFS HTTP provider...')\\n}\\n\\nIpfsWrapper.prototype.getIpfsClient = async function (url) {\\n  // IPFS client\\n  try {\\n    var policy = null\\n    const ipfsProvider = $tw.utils.getIpfsProvider()\\n    if (ipfsProvider === 'window') {\\n      policy = await this.ipfsLibrary.getWindowIpfs()\\n    } else if (ipfsProvider === 'http') {\\n      policy = await this.ipfsLibrary.getHttpIpfs(url)\\n    } else {\\n      policy = await this.ipfsLibrary.getDefaultIpfs(url)\\n    }\\n    if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n      return policy\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to retrieve an IPFS provider...')\\n}\\n\\nIpfsWrapper.prototype.getIpnsIdentifiers = async function (ipfs, identifier, base, path, ipnsName) {\\n  identifier = identifier === undefined || identifier == null || identifier.trim() === '' ? null : identifier.trim()\\n  ipnsName = ipnsName === undefined || ipnsName == null || ipnsName.trim() === '' ? null : ipnsName.trim()\\n  if (identifier == null && ipnsName == null) {\\n    throw new Error('Undefined IPNS identifiers...')\\n  }\\n  path = path === undefined || path == null || path.trim() === '' ? '' : path.trim()\\n  var found = false\\n  var ipnsKey = null\\n  var keys = null\\n  var normalizedUrl = null\\n  try {\\n    // Only the server who generates the key has the knowledge\\n    keys = await this.getIpnsKeys(ipfs)\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  // Do our best\\n  if (ipnsName !== null && identifier !== null) {\\n    if (keys !== null && keys !== undefined && Array.isArray(keys)) {\\n      for (var index = 0; index < keys.length; index++) {\\n        const cidv1b32 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base32', false).toString()\\n        const cidv1b36 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base36', false).toString()\\n        if ((keys[index].id === identifier || cidv1b32 === identifier || cidv1b36 === identifier) && keys[index].name === ipnsName) {\\n          ipnsKey = keys[index].id\\n          found = true\\n          break\\n        }\\n      }\\n    }\\n  } else if (ipnsName !== null) {\\n    if (keys !== null && keys !== undefined && Array.isArray(keys)) {\\n      for (var index = 0; index < keys.length; index++) {\\n        if (keys[index].name === ipnsName) {\\n          ipnsKey = keys[index].id\\n          found = true\\n          break\\n        }\\n      }\\n    }\\n  } else {\\n    if (keys !== null && keys !== undefined && Array.isArray(keys)) {\\n      for (var index = 0; index < keys.length; index++) {\\n        const cidv1b32 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base32', false).toString()\\n        const cidv1b36 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base36', false).toString()\\n        if (keys[index].id === identifier || cidv1b32 === identifier || cidv1b36 === identifier || keys[index].name === identifier) {\\n          ipnsKey = keys[index].id\\n          ipnsName = keys[index].name\\n          found = true\\n          break\\n        }\\n      }\\n    }\\n  }\\n  if (found === false) {\\n    // Unable to resolve the keys, check if identifier is a an IPFS cid\\n    if (!this.ipfsBundle.getCid(identifier)) {\\n      throw new Error('Unknown IPNS identifier...')\\n    }\\n    ipnsKey = identifier\\n  }\\n  // Lets build an url, the resolver will do the final check, we cannot do more here\\n  if (found) {\\n    const cidv0 = this.ipfsBundle.cidToBase58CidV0(ipnsKey, false).toString()\\n    const cidv1b32 = this.ipfsBundle.cidToLibp2pKeyCidV1(cidv0, 'base32', false).toString()\\n    ipnsKey = this.ipfsBundle.cidToLibp2pKeyCidV1(cidv1b32, 'base36', false)\\n    normalizedUrl = this.ipfsUrl.normalizeUrl(`/${ipnsKeyword}/${ipnsKey}${path}`, base)\\n    this.getLogger().info(\\n      `Successfully Fetched IPNS identifiers: '${ipnsName}':\\n'dag-pb' \\\"cidv0\\\" (base58btc): ${cidAnalyser}${cidv0}\\nto 'libp2p-key' \\\"cidv1\\\" (base32): ${cidAnalyser}${cidv1b32}\\nto 'libp2p-key' \\\"cidv1\\\" (base36): ${cidAnalyser}${ipnsKey}\\n${normalizedUrl}`\\n    )\\n  } else {\\n    normalizedUrl = this.ipfsUrl.normalizeUrl(`/${ipnsKeyword}/${ipnsKey}${path}`, base)\\n    this.getLogger().info(\\n      `Unable to Fetch IPNS identifiers, default to\\n${normalizedUrl}`\\n    )\\n  }\\n  return {\\n    ipnsKey: ipnsKey !== null ? ipnsKey.toString() : null,\\n    ipnsName: ipnsName,\\n    normalizedUrl: normalizedUrl,\\n  }\\n}\\n\\nIpfsWrapper.prototype.generateIpnsKey = async function (ipfs, ipnsName) {\\n  try {\\n    const key = await this.ipfsLibrary.genKey(ipfs, ipnsName)\\n    const cid = this.ipfsBundle.cidToLibp2pKeyCidV1(key, 'base36', true).toString()\\n    const url = this.ipfsUrl.normalizeUrl(`/${ipnsKeyword}/${cid}`)\\n    this.getLogger().info(\\n      `Successfully generated IPNS key with IPNS name: ${ipnsName}\\n${url}`\\n    )\\n    return cid\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to generate and IPNS key...')\\n}\\n\\nIpfsWrapper.prototype.removeIpnsKey = async function (ipfs, ipnsName) {\\n  try {\\n    const hash = await this.ipfsLibrary.rmKey(ipfs, ipnsName)\\n    const msg = `Successfully removed IPNS name: ${ipnsName}`\\n    this.getLogger().info(msg)\\n    $tw.utils.alert(name, msg)\\n    return hash\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to remove an IPNS Key...')\\n}\\n\\nIpfsWrapper.prototype.renameIpnsName = async function (ipfs, oldIpnsName, newIpnsName) {\\n  try {\\n    const { keyId, was, now } = await this.ipfsLibrary.keyRename(ipfs, oldIpnsName, newIpnsName)\\n    const key = this.ipfsBundle.cidToLibp2pKeyCidV1(keyId, 'base36', true).toString()\\n    const msg = `Successfully renamed IPNS name: ${was} with ${now}`\\n    this.getLogger().info(msg)\\n    $tw.utils.alert(name, msg)\\n    return {\\n      ipnsKey: key,\\n      ipnsName: now,\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to rename an IPNS name...')\\n}\\n\\nIpfsWrapper.prototype.getIpnsKeys = async function (ipfs) {\\n  try {\\n    const keyList = await this.ipfsLibrary.keyList(ipfs)\\n    this.getLogger().info('Successfully fetched IPNS keys...')\\n    return keyList\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to fetch IPNS keys...')\\n}\\n\\nIpfsWrapper.prototype.fetchFromIpfs = async function (ipfs, cid) {\\n  cid = cid === undefined || cid == null || cid.toString().trim() === '' ? null : cid.toString().trim()\\n  if (cid == null) {\\n    throw new Error('Undefined IPNS identifier...')\\n  }\\n  const pathname = `/${ipfsKeyword}/${cid}`\\n  try {\\n    const fetched = await this.ipfsLibrary.cat(ipfs, pathname)\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    this.getLogger().info(`Successfully fetched:\\n${url}`)\\n    return fetched\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to fetch from IPFS...')\\n}\\n\\nIpfsWrapper.prototype.addToIpfs = async function (ipfs, content) {\\n  try {\\n    const { cid, size } = await this.ipfsLibrary.add(ipfs, $tw.ipfs.StringToUint8Array(content))\\n    const pathname = '/' + ipfsKeyword + '/' + cid\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    this.getLogger().info(`Successfully added: ${size} bytes,\\n${url}`)\\n    return {\\n      cid: cid,\\n      size: size,\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to add content to IPFS...')\\n}\\n\\nIpfsWrapper.prototype.resolveIpnsKey = async function (ipfs, ipnsKey) {\\n  ipnsKey = ipnsKey === undefined || ipnsKey == null || ipnsKey.trim() === '' ? null : ipnsKey.trim()\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...')\\n  }\\n  const pathname = `/${ipnsKeyword}/${ipnsKey}`\\n  try {\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    const resolved = await this.ipfsLibrary.nameResolve(ipfs, pathname)\\n    const { cid } = this.ipfsBundle.decodeCid(resolved)\\n    if (cid !== null) {\\n      const parsed = this.ipfsUrl.normalizeUrl(resolved)\\n      this.getLogger().info(\\n        `Successfully resolved IPNS key:\\n${url}\\n${parsed}`\\n      )\\n      return cid\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to resolve an IPNS key...')\\n}\\n\\nIpfsWrapper.prototype.publishIpnsName = async function (cid, ipfs, ipnsKey, ipnsName) {\\n  ipnsKey = ipnsKey === undefined || ipnsKey == null || ipnsKey.trim() === '' ? null : ipnsKey.trim()\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...')\\n  }\\n  ipnsName = ipnsName === undefined || ipnsName == null || ipnsName.trim() === '' ? null : ipnsName.trim()\\n  if (ipnsName == null) {\\n    throw new Error('Undefined IPNS name...')\\n  }\\n  cid = cid === undefined || cid == null || cid.toString().trim() === '' ? null : cid.toString().trim()\\n  if (cid == null) {\\n    throw new Error('Undefined IPNS identifier...')\\n  }\\n  // Path\\n  const key = `/${ipnsKeyword}/${ipnsKey}`\\n  const pathname = `/${ipfsKeyword}/${cid}`\\n  try {\\n    // Publish\\n    const result = await this.ipfsLibrary.namePublish(ipfs, ipnsName, pathname)\\n    const keyParsed = this.ipfsUrl.normalizeUrl(key)\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    this.getLogger().info(\\n      `Successfully published IPNS name: ${ipnsName}\\n${keyParsed}\\n${url}`\\n    )\\n    return result\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to publish an IPNS name...')\\n}\\n\\nIpfsWrapper.prototype.pinToIpfs = async function (ipfs, cid, recursive) {\\n  cid = cid !== undefined && cid !== null && cid.toString().trim() !== '' ? cid.toString().trim() : null\\n  if (cid == null) {\\n    throw new Error('Undefined IPNS identifier...')\\n  }\\n  const pathname = `/${ipfsKeyword}/${cid}`\\n  try {\\n    const pinned = await this.ipfsLibrary.pinAdd(ipfs, pathname, recursive)\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    this.getLogger().info(\\n      `Successfully pinned:\\n${url}`\\n    )\\n    return pinned\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to pin...')\\n}\\n\\nIpfsWrapper.prototype.unpinFromIpfs = async function (ipfs, cid, recursive) {\\n  cid = cid !== undefined && cid !== null && cid.toString().trim() !== '' ? cid.toString().trim() : null\\n  if (cid == null) {\\n    throw new Error('Undefined IPNS identifier...')\\n  }\\n  const pathname = `/${ipfsKeyword}/${cid}`\\n  try {\\n    const unpinned = await this.ipfsLibrary.pinRm(ipfs, pathname, recursive)\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    this.getLogger().info(\\n      `Successfully unpinned:\\n${url}`\\n    )\\n    return unpinned\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to unpin...')\\n}\\n\\nexports.IpfsWrapper = IpfsWrapper\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/core/modules/macros/infosaver.js\": {\n            \"title\": \"$:/core/modules/macros/infosaver.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/macros/infosaver.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\nDisplay saver info name\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*\\n   * Information about this macro\\n   */\\n  exports.name = 'infosaver'\\n\\n  exports.params = [{ name: 'tiddler' }]\\n\\n  /*\\n   * Run the macro\\n   */\\n  exports.run = function (tiddler) {\\n    return $tw.saverHandler.getSaver(tiddler).module.info.name\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-console-tooltip.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-console-tooltip.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macros/ipfs-console-tooltip.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\nIPFS plugin version\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*\\n   * Information about this macro\\n   */\\n  exports.name = 'ipfs-console-tooltip'\\n\\n  exports.params = []\\n\\n  /*\\n   * Run the macro\\n   */\\n  exports.run = function () {\\n    var tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Hint')\\n    if (typeof window.eruda === 'undefined') {\\n      tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Load')\\n    } else if ($tw.ipfs.ipfsAction !== undefined) {\\n      if ($tw.ipfs.ipfsAction.console) {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Hide')\\n      } else {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Show')\\n      }\\n    }\\n    return tiddler.fields.text\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-encryption-tooltip.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-encryption-tooltip.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macros/ipfs-encryption-tooltip.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\nIPFS plugin version\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*\\n   * Information about this macro\\n   */\\n  exports.name = 'ipfs-encryption-tooltip'\\n\\n  exports.params = []\\n\\n  /*\\n   * Run the macro\\n   */\\n  exports.run = function () {\\n    var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\\n    if (encrypted !== undefined && encrypted !== null && encrypted.fields.text === 'yes') {\\n      encrypted = true\\n    } else {\\n      encrypted = false\\n    }\\n    var tiddler\\n    var encryption = $tw.wiki.getTiddler('$:/config/encryption')\\n    if (encrypted) {\\n      tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/ClearEncryptionPublicKey/Hint')\\n      if (encryption.fields.text === 'standford') {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/ClearPassword/Hint')\\n      }\\n    } else {\\n      tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/SetEncryptionPublicKey/Hint')\\n      if (encryption.fields.text === 'standford') {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/SetPassword/Hint')\\n      }\\n    }\\n    return tiddler.fields.text\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-plugin-version.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-plugin-version.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macros/ipfs-plugin-version.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\nIPFS plugin version\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*\\n   * Information about this macro\\n   */\\n  exports.name = 'ipfs-plugin-version'\\n\\n  exports.params = []\\n\\n  /*\\n   * Run the macro\\n   */\\n  exports.run = function () {\\n    return $tw.wiki.getTiddler('$:/plugins/ipfs').fields.version\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/core/modules/macros/jsontiddler.js\": {\n            \"title\": \"$:/core/modules/macros/jsontiddler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/macros/jsontiddler.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nMacro to output a single tiddler to JSON\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /*\\nInformation about this macro\\n*/\\n\\n  exports.name = 'jsontiddler'\\n\\n  exports.params = [{ name: 'title' }]\\n\\n  /*\\nRun the macro\\n*/\\n  exports.run = function (title) {\\n    title = title || this.getVariable('currentTiddler')\\n    var tiddler = !!title && this.wiki.getTiddler(title)\\n    var fields = {}\\n    if (tiddler) {\\n      for (var field in tiddler.fields) {\\n        fields[field] = tiddler.getFieldString(field)\\n      }\\n    }\\n    var content = JSON.stringify(fields, null, $tw.config.preferences.jsonSpaces)\\n    var compress = $tw.wiki.getTiddler('$:/isCompressed')\\n    compress = compress !== undefined ? compress.fields.text === 'yes' : false\\n    if (compress) {\\n      content = { compressed: $tw.compress.deflate(content) }\\n    }\\n    var encrypt = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypt = encrypt !== undefined ? encrypt.fields.text === 'yes' : false\\n    if (encrypt) {\\n      content.compressed = $tw.crypto.encrypt(compress ? content.compressed : content)\\n      if ($tw.crypto.hasEncryptionPublicKey()) {\\n        content.keccak256 = $tw.crypto.keccak256(compress ? content.compressed : content)\\n      }\\n    }\\n    if (compress || encrypt) {\\n      content = JSON.stringify(content)\\n    }\\n    return content\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/core/modules/macros/jsontiddlers.js\": {\n            \"title\": \"$:/core/modules/macros/jsontiddlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/macros/jsontiddlers.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nMacro to output tiddlers matching a filter to JSON\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /*\\nInformation about this macro\\n*/\\n\\n  exports.name = 'jsontiddlers'\\n\\n  exports.params = [{ name: 'filter' }, { name: 'spaces' }]\\n\\n  /*\\nRun the macro\\n*/\\n  exports.run = function (filter, spaces) {\\n    var content = this.wiki.getTiddlersAsJson(filter, $tw.utils.parseInt(spaces))\\n    var compress = $tw.wiki.getTiddler('$:/isCompressed')\\n    compress = compress !== undefined ? compress.fields.text === 'yes' : false\\n    if (compress) {\\n      content = { compressed: $tw.compress.deflate(content) }\\n    }\\n    var encrypt = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypt = encrypt !== undefined ? encrypt.fields.text === 'yes' : false\\n    if (encrypt) {\\n      content.compressed = $tw.crypto.encrypt(compress ? content.compressed : content)\\n      if ($tw.crypto.hasEncryptionPublicKey()) {\\n        content.keccak256 = $tw.crypto.keccak256(compress ? content.compressed : content)\\n      }\\n    }\\n    if (compress || encrypt) {\\n      content = JSON.stringify(content)\\n    }\\n    return content\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/core/modules/parsers/audioparser.js\": {\n            \"title\": \"$:/core/modules/parsers/audioparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/audioparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe audio parser parses an audio tiddler into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  var name = 'ipfs-audioparser'\\n\\n  var AudioParser = function (type, text, options) {\\n    var value = `data:${type};base64,`\\n    var element = {\\n      type: 'element',\\n      tag: 'audio',\\n      attributes: {\\n        controls: { type: 'string', value: 'controls' },\\n        style: { type: 'string', value: 'width: 100%; object-fit: contain' },\\n      },\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToBase64(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['audio/ogg'] = AudioParser\\n  exports['audio/mpeg'] = AudioParser\\n  exports['audio/mp3'] = AudioParser\\n  exports['audio/mp4'] = AudioParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/binaryparser.js\": {\n            \"title\": \"$:/core/modules/parsers/binaryparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/binaryparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe binary parser parses a binary tiddler into a warning message and download link\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n  const name = 'ipfs-binaryparser'\\n\\n  var BINARY_WARNING_MESSAGE = '$:/core/ui/BinaryWarning'\\n  var EXPORT_BUTTON_IMAGE = '$:/core/images/export-button'\\n\\n  var BinaryParser = function (type, text, options) {\\n    var self = this\\n    var value = `data:${type};base64,`\\n    // Transclude the binary data tiddler warning message\\n    var warn = {\\n      type: 'element',\\n      tag: 'p',\\n      children: [\\n        {\\n          type: 'transclude',\\n          attributes: {\\n            tiddler: { type: 'string', value: BINARY_WARNING_MESSAGE },\\n          },\\n        },\\n      ],\\n    }\\n    // Create download link based on binary tiddler title\\n    var link = {\\n      type: 'element',\\n      tag: 'a',\\n      attributes: {\\n        title: { type: 'indirect', textReference: '!!title' },\\n        download: { type: 'indirect', textReference: '!!title' },\\n      },\\n      children: [\\n        {\\n          type: 'transclude',\\n          attributes: {\\n            tiddler: { type: 'string', value: EXPORT_BUTTON_IMAGE },\\n          },\\n        },\\n      ],\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToBase64(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    link.attributes.href = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        link.attributes.href = {\\n          type: 'string',\\n          value: `${value}${text}`,\\n        }\\n      }\\n    }\\n    // Combine warning message and download link in a div\\n    var element = {\\n      type: 'element',\\n      tag: 'div',\\n      attributes: {\\n        class: { type: 'string', value: 'tc-binary-warning' },\\n      },\\n      children: [warn, link],\\n    }\\n    this.tree = [element]\\n  }\\n\\n  exports['application/octet-stream'] = BinaryParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/csvparser.js\": {\n            \"title\": \"$:/core/modules/parsers/csvparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/csvparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe CSV text parser processes CSV files into a table wrapped in a scrollable widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var CsvParser = function (type, text, options) {\\n    var self = this\\n    // Table framework\\n    this.tree = [\\n      {\\n        type: 'scrollable',\\n        children: [\\n          {\\n            type: 'element',\\n            tag: 'table',\\n            children: [\\n              {\\n                type: 'element',\\n                tag: 'tbody',\\n                children: [],\\n              },\\n            ],\\n            attributes: {\\n              class: { type: 'string', value: 'tc-csv-table' },\\n            },\\n          },\\n        ],\\n      },\\n    ]\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    self.split(data)\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        this.split(text)\\n      }\\n    }\\n  }\\n\\n  CsvParser.prototype.split = function (text) {\\n    // Split the text into lines\\n    var lines = text.split(/\\\\r?\\\\n/gm)\\n    var tag = 'th'\\n    for (var line = 0; line < lines.length; line++) {\\n      var lineText = lines[line]\\n      if (lineText) {\\n        var row = {\\n          type: 'element',\\n          tag: 'tr',\\n          children: [],\\n        }\\n        var columns = lineText.split(',')\\n        for (var column = 0; column < columns.length; column++) {\\n          row.children.push({\\n            type: 'element',\\n            tag: tag,\\n            children: [\\n              {\\n                type: 'text',\\n                text: columns[column],\\n              },\\n            ],\\n          })\\n        }\\n        tag = 'td'\\n        this.tree[0].children[0].children[0].children.push(row)\\n      }\\n    }\\n  }\\n  exports['text/csv'] = CsvParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/htmlparser.js\": {\n            \"title\": \"$:/core/modules/parsers/htmlparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/htmlparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe HTML parser displays text as raw HTML\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-htmlparser'\\n\\n  var HtmlParser = function (type, text, options) {\\n    var value = 'data:text/html;charset=utf-8,'\\n    var src\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    src = value + encodeURIComponent(data)\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        src = value + encodeURIComponent(text)\\n      }\\n    }\\n    this.tree = [\\n      {\\n        type: 'element',\\n        tag: 'iframe',\\n        attributes: {\\n          src: { type: 'string', value: src },\\n          sandbox: { type: 'string', value: 'allow-scripts' },\\n        },\\n      },\\n    ]\\n  }\\n\\n  exports['text/html'] = HtmlParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/imageparser.js\": {\n            \"title\": \"$:/core/modules/parsers/imageparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/imageparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe image parser parses an image into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  var name = 'ipfs-imageparser'\\n\\n  var ImageParser = function (type, text, options) {\\n    var value = `data:${type};base64,`\\n    var element = {\\n      type: 'element',\\n      tag: 'img',\\n      attributes: {},\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToBase64(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['image/gif'] = ImageParser\\n  exports['image/heic'] = ImageParser\\n  exports['image/heif'] = ImageParser\\n  exports['image/jpeg'] = ImageParser\\n  exports['image/jpg'] = ImageParser\\n  exports['image/png'] = ImageParser\\n  exports['image/vnd.microsoft.icon'] = ImageParser\\n  exports['image/webp'] = ImageParser\\n  exports['image/x-icon'] = ImageParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/pdfparser.js\": {\n            \"title\": \"$:/core/modules/parsers/pdfparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/pdfparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe PDF parser embeds a PDF viewer\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const name = 'ipfs-pdfparser'\\n\\n  var PdfParser = function (type, text, options) {\\n    var value = 'data:application/pdf;base64,'\\n    var element = {\\n      type: 'element',\\n      tag: 'embed',\\n      attributes: {},\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToBase64(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['application/pdf'] = PdfParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/svgparser.js\": {\n            \"title\": \"$:/core/modules/parsers/svgparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/svgparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe image parser parses an image into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const name = 'ipfs-svgparser'\\n\\n  var SvgParser = function (type, text, options) {\\n    var value = 'data:image/svg+xml,'\\n    var element = {\\n      type: 'element',\\n      tag: 'img',\\n      attributes: {},\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: value + encodeURIComponent(data),\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else {\\n        element.attributes.src = {\\n          type: 'string',\\n          value: value + encodeURIComponent(text),\\n        }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['image/svg+xml'] = SvgParser\\n  exports['.svg'] = SvgParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/textparser.js\": {\n            \"title\": \"$:/core/modules/parsers/textparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/textparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe plain text parser processes blocks of source text into a degenerate parse tree consisting of a single text node\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  var TextParser = function (type, text, options) {\\n    var element = {\\n      type: 'codeblock',\\n      attributes: {\\n        code: { type: 'string', value: text },\\n        language: { type: 'string', value: type },\\n      },\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.code.value = data\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['application/javascript'] = TextParser\\n  exports['application/json'] = TextParser\\n  exports['application/x-tiddler-dictionary'] = TextParser\\n  exports['text/css'] = TextParser\\n  exports['text/plain'] = TextParser\\n  exports['text/x-tiddlywiki'] = TextParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/videoparser.js\": {\n            \"title\": \"$:/core/modules/parsers/videoparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/videoparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe video parser parses a video tiddler into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const name = 'ipfs-videoparser'\\n\\n  var VideoParser = function (type, text, options) {\\n    var value = `data:${type};base64,`\\n    var element = {\\n      type: 'element',\\n      tag: 'video',\\n      attributes: {\\n        controls: { type: 'string', value: 'controls' },\\n        style: { type: 'string', value: 'width: 100%; object-fit: contain' },\\n      },\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if (canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(false, true, canonicalUri)\\n          .then(data => {\\n            var { normalizedUrl, resolvedUrl } = data\\n            var url = resolvedUrl !== null ? resolvedUrl.toString() : normalizedUrl !== null ? normalizedUrl.toString() : null\\n            if (url !== null) {\\n              $tw.ipfs\\n                .loadToBase64(url, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['video/mp4'] = VideoParser\\n  exports['video/ogg'] = VideoParser\\n  exports['video/quicktime'] = VideoParser\\n  exports['video/webm'] = VideoParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/wikiparser/wikiparser.js\": {\n            \"title\": \"$:/core/modules/parsers/wikiparser/wikiparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/wikiparser/wikiparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe wiki text parser processes blocks of source text into a parse tree.\\n\\nThe parse tree is made up of nested arrays of these JavaScript objects:\\n\\n\\t{type: \\\"element\\\", tag: <string>, attributes: {}, children: []} - an HTML element\\n\\t{type: \\\"text\\\", text: <string>} - a text node\\n\\t{type: \\\"entity\\\", value: <string>} - an entity\\n\\t{type: \\\"raw\\\", html: <string>} - raw HTML\\n\\nAttributes are stored as hashmaps of the following objects:\\n\\n\\t{type: \\\"string\\\", value: <string>} - literal string\\n\\t{type: \\\"indirect\\\", textReference: <textReference>} - indirect through a text reference\\n\\t{type: \\\"macro\\\", macro: <TBD>} - indirect through a macro invocation\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const IpfsImport = require('$:/plugins/ipfs/ipfs-import.js').IpfsImport\\n\\n  var name = 'ipfs-wikiparser'\\n\\n  var WikiParser = function (type, text, options) {\\n    this.wiki = options.wiki\\n    // Check for an externally linked tiddler\\n    if ($tw.browser && (text || '') === '' && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      var importUri = options.tiddler.fields._import_uri\\n      importUri = importUri !== undefined && importUri !== null && importUri.toString().trim() !== '' ? importUri.toString().trim() : null\\n      if (canonicalUri !== null || importUri !== null) {\\n        var ipfsImport = new IpfsImport()\\n        ipfsImport\\n          .import(canonicalUri, importUri, options.tiddler)\\n          .then(data => {\\n            if (data) {\\n              const navigator = $tw.utils.locateNavigatorWidget($tw.pageWidgetNode)\\n              if (navigator) {\\n                navigator.dispatchEvent({\\n                  type: 'tm-ipfs-import-tiddlers',\\n                  param: data,\\n                })\\n              }\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n            $tw.utils.alert(name, error.message)\\n          })\\n        text = `''${$tw.language.getRawString('LazyLoadingWarning')}''`\\n      }\\n    }\\n    // Initialise the classes if we don't have them already\\n    if (!this.pragmaRuleClasses) {\\n      WikiParser.prototype.pragmaRuleClasses = $tw.modules.createClassesFromModules('wikirule', 'pragma', $tw.WikiRuleBase)\\n      this.setupRules(WikiParser.prototype.pragmaRuleClasses, '$:/config/WikiParserRules/Pragmas/')\\n    }\\n    if (!this.blockRuleClasses) {\\n      WikiParser.prototype.blockRuleClasses = $tw.modules.createClassesFromModules('wikirule', 'block', $tw.WikiRuleBase)\\n      this.setupRules(WikiParser.prototype.blockRuleClasses, '$:/config/WikiParserRules/Block/')\\n    }\\n    if (!this.inlineRuleClasses) {\\n      WikiParser.prototype.inlineRuleClasses = $tw.modules.createClassesFromModules('wikirule', 'inline', $tw.WikiRuleBase)\\n      this.setupRules(WikiParser.prototype.inlineRuleClasses, '$:/config/WikiParserRules/Inline/')\\n    }\\n    // Save the parse text\\n    this.type = type || 'text/vnd.tiddlywiki'\\n    this.source = text || ''\\n    this.sourceLength = this.source.length\\n    // Flag for ignoring whitespace\\n    this.configTrimWhiteSpace = false\\n    // Set current parse position\\n    this.pos = 0\\n    // Instantiate the pragma parse rules\\n    this.pragmaRules = this.instantiateRules(this.pragmaRuleClasses, 'pragma', 0)\\n    // Instantiate the parser block and inline rules\\n    this.blockRules = this.instantiateRules(this.blockRuleClasses, 'block', 0)\\n    this.inlineRules = this.instantiateRules(this.inlineRuleClasses, 'inline', 0)\\n    // Parse any pragmas\\n    this.tree = []\\n    var topBranch = this.parsePragmas()\\n    // Parse the text into inline runs or blocks\\n    if (options.parseAsInline) {\\n      topBranch.push.apply(topBranch, this.parseInlineRun())\\n    } else {\\n      topBranch.push.apply(topBranch, this.parseBlocks())\\n    }\\n    // Return the parsed tree\\n  }\\n\\n  /*\\n   */\\n  WikiParser.prototype.setupRules = function (proto, configPrefix) {\\n    var self = this\\n    if (!$tw.safemode) {\\n      $tw.utils.each(proto, function (object, name) {\\n        if (self.wiki.getTiddlerText(configPrefix + name, 'enable') !== 'enable') {\\n          delete proto[name]\\n        }\\n      })\\n    }\\n  }\\n\\n  /*\\nInstantiate an array of parse rules\\n*/\\n  WikiParser.prototype.instantiateRules = function (classes, type, startPos) {\\n    var rulesInfo = []\\n    var self = this\\n    $tw.utils.each(classes, function (RuleClass) {\\n      // Instantiate the rule\\n      var rule = new RuleClass(self)\\n      rule.is = {}\\n      rule.is[type] = true\\n      rule.init(self)\\n      var matchIndex = rule.findNextMatch(startPos)\\n      if (matchIndex !== undefined) {\\n        rulesInfo.push({\\n          rule: rule,\\n          matchIndex: matchIndex,\\n        })\\n      }\\n    })\\n    return rulesInfo\\n  }\\n\\n  /*\\nSkip any whitespace at the current position. Options are:\\n  treatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace\\n*/\\n  WikiParser.prototype.skipWhitespace = function (options) {\\n    options = options || {}\\n    var whitespaceRegExp = options.treatNewlinesAsNonWhitespace ? /([^\\\\S\\\\n]+)/gm : /(\\\\s+)/gm\\n    whitespaceRegExp.lastIndex = this.pos\\n    var whitespaceMatch = whitespaceRegExp.exec(this.source)\\n    if (whitespaceMatch && whitespaceMatch.index === this.pos) {\\n      this.pos = whitespaceRegExp.lastIndex\\n    }\\n  }\\n\\n  /*\\nGet the next match out of an array of parse rule instances\\n*/\\n  WikiParser.prototype.findNextMatch = function (rules, startPos) {\\n    // Find the best matching rule by finding the closest match position\\n    var matchingRule\\n    var matchingRulePos = this.sourceLength\\n    // Step through each rule\\n    for (var t = 0; t < rules.length; t++) {\\n      var ruleInfo = rules[t]\\n      // Ask the rule to get the next match if we've moved past the current one\\n      if (ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex < startPos) {\\n        ruleInfo.matchIndex = ruleInfo.rule.findNextMatch(startPos)\\n      }\\n      // Adopt this match if it's closer than the current best match\\n      if (ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex <= matchingRulePos) {\\n        matchingRule = ruleInfo\\n        matchingRulePos = ruleInfo.matchIndex\\n      }\\n    }\\n    return matchingRule\\n  }\\n\\n  /*\\nParse any pragmas at the beginning of a block of parse text\\n*/\\n  WikiParser.prototype.parsePragmas = function () {\\n    var currentTreeBranch = this.tree\\n    while (true) {\\n      // Skip whitespace\\n      this.skipWhitespace()\\n      // Check for the end of the text\\n      if (this.pos >= this.sourceLength) {\\n        break\\n      }\\n      // Check if we've arrived at a pragma rule match\\n      var nextMatch = this.findNextMatch(this.pragmaRules, this.pos)\\n      // If not, just exit\\n      if (!nextMatch || nextMatch.matchIndex !== this.pos) {\\n        break\\n      }\\n      // Process the pragma rule\\n      var subTree = nextMatch.rule.parse()\\n      if (subTree.length > 0) {\\n        // Quick hack; we only cope with a single parse tree node being returned, which is true at the moment\\n        currentTreeBranch.push.apply(currentTreeBranch, subTree)\\n        subTree[0].children = []\\n        currentTreeBranch = subTree[0].children\\n      }\\n    }\\n    return currentTreeBranch\\n  }\\n\\n  /*\\nParse a block from the current position\\n  terminatorRegExpString: optional regular expression string that identifies the end of plain paragraphs. Must not include capturing parenthesis\\n*/\\n  WikiParser.prototype.parseBlock = function (terminatorRegExpString) {\\n    var terminatorRegExp = terminatorRegExpString ? new RegExp('(' + terminatorRegExpString + '|\\\\\\\\r?\\\\\\\\n\\\\\\\\r?\\\\\\\\n)', 'mg') : /(\\\\r?\\\\n\\\\r?\\\\n)/gm\\n    this.skipWhitespace()\\n    if (this.pos >= this.sourceLength) {\\n      return []\\n    }\\n    // Look for a block rule that applies at the current position\\n    var nextMatch = this.findNextMatch(this.blockRules, this.pos)\\n    if (nextMatch && nextMatch.matchIndex === this.pos) {\\n      return nextMatch.rule.parse()\\n    }\\n    // Treat it as a paragraph if we didn't find a block rule\\n    return [\\n      {\\n        type: 'element',\\n        tag: 'p',\\n        children: this.parseInlineRun(terminatorRegExp),\\n      },\\n    ]\\n  }\\n\\n  /*\\nParse a series of blocks of text until a terminating regexp is encountered or the end of the text\\n  terminatorRegExpString: terminating regular expression\\n*/\\n  WikiParser.prototype.parseBlocks = function (terminatorRegExpString) {\\n    if (terminatorRegExpString) {\\n      return this.parseBlocksTerminated(terminatorRegExpString)\\n    } else {\\n      return this.parseBlocksUnterminated()\\n    }\\n  }\\n\\n  /*\\nParse a block from the current position to the end of the text\\n*/\\n  WikiParser.prototype.parseBlocksUnterminated = function () {\\n    var tree = []\\n    while (this.pos < this.sourceLength) {\\n      tree.push.apply(tree, this.parseBlock())\\n    }\\n    return tree\\n  }\\n\\n  /*\\nParse blocks of text until a terminating regexp is encountered\\n*/\\n  WikiParser.prototype.parseBlocksTerminated = function (terminatorRegExpString) {\\n    var terminatorRegExp = new RegExp('(' + terminatorRegExpString + ')', 'mg')\\n    var tree = []\\n    // Skip any whitespace\\n    this.skipWhitespace()\\n    //  Check if we've got the end marker\\n    terminatorRegExp.lastIndex = this.pos\\n    var match = terminatorRegExp.exec(this.source)\\n    // Parse the text into blocks\\n    while (this.pos < this.sourceLength && !(match && match.index === this.pos)) {\\n      var blocks = this.parseBlock(terminatorRegExpString)\\n      tree.push.apply(tree, blocks)\\n      // Skip any whitespace\\n      this.skipWhitespace()\\n      //  Check if we've got the end marker\\n      terminatorRegExp.lastIndex = this.pos\\n      match = terminatorRegExp.exec(this.source)\\n    }\\n    if (match && match.index === this.pos) {\\n      this.pos = match.index + match[0].length\\n    }\\n    return tree\\n  }\\n\\n  /*\\nParse a run of text at the current position\\n  terminatorRegExp: a regexp at which to stop the run\\n  options: see below\\nOptions available:\\n  eatTerminator: move the parse position past any encountered terminator (default false)\\n*/\\n  WikiParser.prototype.parseIn€€