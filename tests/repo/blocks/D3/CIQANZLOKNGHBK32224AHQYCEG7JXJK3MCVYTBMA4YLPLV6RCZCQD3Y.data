
Š€€€ernals/has\\\":62,\\\"../internals/internal-state\\\":70,\\\"../internals/native-url\\\":81,\\\"../internals/object-assign\\\":83,\\\"../internals/object-define-properties\\\":85,\\\"../internals/redefine\\\":98,\\\"../internals/set-to-string-tag\\\":107,\\\"../internals/string-multibyte\\\":112,\\\"../internals/string-punycode-to-ascii\\\":113,\\\"../modules/es.string.iterator\\\":132,\\\"../modules/web.url-search-params\\\":150}],152:[function(require,module,exports){\\n'use strict';\\nvar $ = require('../internals/export');\\n\\n// `URL.prototype.toJSON` method\\n// https://url.spec.whatwg.org/#dom-url-tojson\\n$({ target: 'URL', proto: true, enumerable: true }, {\\n  toJSON: function toJSON() {\\n    return URL.prototype.toString.call(this);\\n  }\\n});\\n\\n},{\\\"../internals/export\\\":52}],153:[function(require,module,exports){\\n'use strict';\\n\\nvar matchOperatorsRe = /[|\\\\\\\\{}()[\\\\]^$+*?.]/g;\\n\\nmodule.exports = function (str) {\\n\\tif (typeof str !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\treturn str.replace(matchOperatorsRe, '\\\\\\\\$&');\\n};\\n\\n},{}],154:[function(require,module,exports){\\n'use strict';\\n/* eslint-disable no-control-regex */\\n// TODO: remove parens when Node.js 6 is targeted. Node.js 4 barfs at it.\\nmodule.exports = () => (/[<>:\\\"\\\\/\\\\\\\\|?*\\\\x00-\\\\x1F]/g);\\nmodule.exports.windowsNames = () => (/^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i);\\n\\n},{}],155:[function(require,module,exports){\\n'use strict';\\nconst path = require('path');\\nconst filenamify = require('./filenamify');\\n\\nconst filenamifyPath = (filePath, options) => {\\n\\tfilePath = path.resolve(filePath);\\n\\treturn path.join(path.dirname(filePath), filenamify(path.basename(filePath), options));\\n};\\n\\nmodule.exports = filenamifyPath;\\n\\n},{\\\"./filenamify\\\":156,\\\"path\\\":196}],156:[function(require,module,exports){\\n'use strict';\\nconst trimRepeated = require('trim-repeated');\\nconst filenameReservedRegex = require('filename-reserved-regex');\\nconst stripOuter = require('strip-outer');\\n\\n// Doesn't make sense to have longer filenames\\nconst MAX_FILENAME_LENGTH = 100;\\n\\nconst reControlChars = /[\\\\u0000-\\\\u001f\\\\u0080-\\\\u009f]/g; // eslint-disable-line no-control-regex\\nconst reRelativePath = /^\\\\.+/;\\nconst reTrailingPeriods = /\\\\.+$/;\\n\\nconst filenamify = (string, options = {}) => {\\n\\tif (typeof string !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\tconst replacement = options.replacement === undefined ? '!' : options.replacement;\\n\\n\\tif (filenameReservedRegex().test(replacement) && reControlChars.test(replacement)) {\\n\\t\\tthrow new Error('Replacement string cannot contain reserved filename characters');\\n\\t}\\n\\n\\tstring = string.replace(filenameReservedRegex(), replacement);\\n\\tstring = string.replace(reControlChars, replacement);\\n\\tstring = string.replace(reRelativePath, replacement);\\n\\tstring = string.replace(reTrailingPeriods, '');\\n\\n\\tif (replacement.length > 0) {\\n\\t\\tstring = trimRepeated(string, replacement);\\n\\t\\tstring = string.length > 1 ? stripOuter(string, replacement) : string;\\n\\t}\\n\\n\\tstring = filenameReservedRegex.windowsNames().test(string) ? string + replacement : string;\\n\\tstring = string.slice(0, typeof options.maxLength === 'number' ? options.maxLength : MAX_FILENAME_LENGTH);\\n\\n\\treturn string;\\n};\\n\\nmodule.exports = filenamify;\\n\\n},{\\\"filename-reserved-regex\\\":154,\\\"strip-outer\\\":198,\\\"trim-repeated\\\":199}],157:[function(require,module,exports){\\n'use strict';\\nconst filenamify = require('./filenamify');\\nconst filenamifyPath = require('./filenamify-path');\\n\\nconst filenamifyCombined = filenamify;\\nfilenamifyCombined.path = filenamifyPath;\\n\\nmodule.exports = filenamify;\\n\\n},{\\\"./filenamify\\\":156,\\\"./filenamify-path\\\":155}],158:[function(require,module,exports){\\n'use strict'\\n\\nmodule.exports = {\\n  DEFAULT_HTTP_API: '/ip4/127.0.0.1/tcp/5001'\\n}\\n\\n},{}],159:[function(require,module,exports){\\n'use strict'\\n\\nmodule.exports = {\\n  httpClient: 'httpClient',\\n  windowIpfs: 'windowIpfs',\\n  jsIpfs: 'jsIpfs',\\n  webExt: 'webExt'\\n}\\n\\n},{}],160:[function(require,module,exports){\\n(function (global){(function (){\\n'use strict'\\n/* global self */\\n\\n// Establish the root object, `window` in the browser, `self` in Service Worker. or `global` on the server.\\n// Credit: https://github.com/megawac/underscore/commit/365311c9a440438531ca1c6bfd49e3c7c5f46079\\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\\n  (typeof global === 'object' && global.global === global && global) ||\\n  this\\n\\n}).call(this)}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],161:[function(require,module,exports){\\n'use strict'\\n\\nconst root = require('./constants/root')\\nconst mergeOptions = require('merge-options')\\nconst tryWebExt = require('./providers/webext')\\nconst tryWindow = require('./providers/window-ipfs')\\nconst tryHttpClient = require('./providers/http-client')\\nconst tryJsIpfs = require('./providers/js-ipfs')\\n\\nconst defaultGlobalOpts = {\\n  connectionTest: async (ipfs) => {\\n    // ipfs connection is working if we can fetch data via async iterator API\\n    const cid = 'QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn' // TODO: switch to identity hash when js-ipfs is fixed: https://github.com/ipfs/js-ipfs/issues/3289\\n    for await (const file of ipfs.get(cid)) {\\n      if (file.type === 'dir' && file.name === cid) return true\\n    }\\n    return false\\n  }\\n}\\n\\nconst makeProvider = (fn, defaults = {}) => {\\n  return (options = {}) => {\\n    return (globalOpts) => {\\n      options = mergeOptions(defaultGlobalOpts, defaults, globalOpts, options)\\n      return fn(options)\\n    }\\n  }\\n}\\n\\nconst providers = {\\n  httpClient: makeProvider((options) => {\\n    return tryHttpClient({ root, ...options })\\n  }),\\n  windowIpfs: makeProvider(options => {\\n    return tryWindow({ root, ...options })\\n  }),\\n  jsIpfs: makeProvider(options => {\\n    return tryJsIpfs(options)\\n  }),\\n  webExt: makeProvider(options => {\\n    return tryWebExt({ root, ...options })\\n  })\\n}\\n\\nconst defaultProviders = [\\n  providers.windowIpfs(),\\n  providers.httpClient()\\n]\\n\\nasync function getIpfs ({ providers = defaultProviders, ...options } = {}) {\\n  for (const provider of providers) {\\n    try {\\n      const res = await provider(options)\\n      if (res) return res\\n    } catch (err) {\\n      // provider failed unexpectedly, log error and move to the next one\\n      console.error('[ipfs-provider]', err) // eslint-disable-line no-console\\n    }\\n  }\\n}\\n\\nmodule.exports = {\\n  getIpfs,\\n  providers,\\n  makeProvider\\n}\\n\\n},{\\\"./constants/root\\\":160,\\\"./providers/http-client\\\":162,\\\"./providers/js-ipfs\\\":163,\\\"./providers/webext\\\":164,\\\"./providers/window-ipfs\\\":165,\\\"merge-options\\\":170}],162:[function(require,module,exports){\\n'use strict'\\n\\nconst { URL } = require('iso-url')\\nconst PROVIDERS = require('../constants/providers')\\nconst { DEFAULT_HTTP_API } = require('../constants/defaults')\\n\\n/*\\n * This provider lazy-loads https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-http-client\\n * so it is not included as a dependency if not used.\\n *\\n * HTTP Client init fallback:\\n * 1. Use constructor returned by loadHttpClientModule function\\n * 2. Fallback to window.IpfsHttpClient\\n *\\n * API URL fallback order:\\n * 1. Try user specified API address\\n * 2. Try current origin\\n * 3. Try DEFAULT_HTTP_API\\n*/\\nasync function tryHttpClient ({ loadHttpClientModule, apiAddress, root, connectionTest, ...options }) {\\n  // Find HTTP client\\n  let httpClient\\n  if (loadHttpClientModule) httpClient = await loadHttpClientModule()\\n\\n  // Final fallback to window.IpfsHttpClient or error\\n  if (!httpClient) {\\n    if (root.IpfsHttpClient) {\\n      httpClient = root.IpfsHttpClient\\n    } else {\\n      throw new Error('ipfs-provider could not initialize js-ipfs-http-client: make sure its constructor is returned by loadHttpClientModule function or exposed at window.IpfsHttpClient')\\n    }\\n  }\\n\\n  // Allow the use of `import` or `require` on `loadHttpClientModule` fn\\n  httpClient = httpClient.default || httpClient // TODO: create 'import' demo in examples/\\n\\n  // If explicit custom apiAddress provided, only try that.\\n  if (apiAddress || options.url || options.host) {\\n    return maybeApi({ apiAddress, connectionTest, httpClient, ...options })\\n  }\\n\\n  // Current origin is not localhost:5001 so try with current origin info\\n  const { location } = root\\n  if (location && !(location.port === '5001' && location.hostname.match(/^127.0.0.1$|^localhost$/))) {\\n    const origin = new URL(location.origin)\\n    origin.pathname = '/'\\n    const res = await maybeApi({\\n      apiAddress: origin.toString(),\\n      connectionTest,\\n      httpClient,\\n      ...options\\n    })\\n    if (res) return res\\n  }\\n\\n  // ...otherwise try /ip4/127.0.0.1/tcp/5001\\n  return maybeApi({ apiAddress: DEFAULT_HTTP_API, connectionTest, httpClient, ...options })\\n}\\n\\n// Init and test an api client against provided API address.\\n// Returns js-ipfs-http-client instance or null\\nasync function maybeApi ({ apiAddress, connectionTest, httpClient, ...options }) {\\n  try {\\n    const ipfs = httpClient({ ...options, ...clientOptions(apiAddress) })\\n    await connectionTest(ipfs)\\n    return { ipfs, provider: PROVIDERS.httpClient, apiAddress }\\n  } catch (error) {\\n    // Failed to connect to ipfs-api in `apiAddress`\\n    // console.error('[ipfs-provider:httpClient]', error)\\n    return null\\n  }\\n}\\n\\n// Convert string with URL or Multiaddr to explicit configuration object\\n// https://www.npmjs.com/package/ipfs-http-client#usage\\nconst clientOptions = (apiAddress) => {\\n  switch (typeof apiAddress) {\\n    case 'string':\\n      return { url: apiAddress }\\n    case 'object':\\n      return JSON.parse(JSON.stringify(apiAddress)) // ensure deep copy\\n    case 'undefined':\\n      return {}\\n    default:\\n      throw new Error('invalid apiAddress passed to httpClient')\\n  }\\n}\\n\\nmodule.exports = tryHttpClient\\n\\n},{\\\"../constants/defaults\\\":158,\\\"../constants/providers\\\":159,\\\"iso-url\\\":167}],163:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function createIpfs (ipfsModule, opts) {\\n  // Allow the use of `import` or `require` on `getJsIpfs` fn\\n  ipfsModule = ipfsModule.default || ipfsModule\\n  return ipfsModule.create(opts)\\n}\\n\\nasync function tryJsIpfs ({ connectionTest, loadJsIpfsModule, options, init = createIpfs }) {\\n  const ipfsModule = await loadJsIpfsModule()\\n  const ipfs = await init(ipfsModule, options)\\n  await connectionTest(ipfs)\\n  return { ipfs, provider: PROVIDERS.jsIpfs }\\n}\\n\\nmodule.exports = tryJsIpfs\\n\\n},{\\\"../constants/providers\\\":159}],164:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function tryWebExt ({ root, connectionTest }) {\\n  // Opportunistic optimizations when running inside of web extension (eg. ipfs-companion)\\n  if (typeof root.chrome === 'object' && root.chrome.extension && root.chrome.extension.getBackgroundPage) {\\n    // Note: under some vendors getBackgroundPage() will return null if window is in incognito mode\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1329304\\n    let bg = null\\n    try {\\n      bg = root.chrome.extension.getBackgroundPage()\\n    } catch (err) {\\n      // not in browser extension\\n      return null\\n    }\\n    // If extension is exposing IPFS API as `ipfs` on the background page\\n    // it can be used directly for the best performance\\n    if (bg && bg.ipfs) {\\n      const { ipfs } = bg\\n      await connectionTest(ipfs)\\n      return { ipfs, provider: PROVIDERS.webExt }\\n    }\\n    /*  Other endpoints can be added here in the future.\\n        For example, Companion could provide API for other browser extensions:\\n        https://github.com/ipfs-shipyard/ipfs-companion/issues/307 */\\n  }\\n}\\n\\nmodule.exports = tryWebExt\\n\\n},{\\\"../constants/providers\\\":159}],165:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function tryWindow ({ root, permissions, connectionTest }) {\\n  if (root.ipfs) {\\n    // files.get is required for testing if API works, ensure we request it\\n    if (!(permissions && permissions.commands && permissions.commands.includes('files.get'))) {\\n      permissions = permissions || {}\\n      permissions = JSON.parse(JSON.stringify(permissions)) // deep copy to work with freezed objects\\n      permissions.commands = permissions.commands || []\\n      permissions.commands.push('files.get')\\n    }\\n    // try window.ipfs.enable first: https://github.com/ipfs-shipyard/ipfs-companion/issues/589\\n    const ipfs = typeof root.ipfs.enable === 'function'\\n      ? await root.ipfs.enable(permissions)\\n      : root.ipfs\\n    await connectionTest(ipfs)\\n    return { ipfs, provider: PROVIDERS.windowIpfs }\\n  }\\n}\\n\\nmodule.exports = tryWindow\\n\\n},{\\\"../constants/providers\\\":159}],166:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = value => {\\n\\tif (Object.prototype.toString.call(value) !== '[object Object]') {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tconst prototype = Object.getPrototypeOf(value);\\n\\treturn prototype === null || prototype === Object.prototype;\\n};\\n\\n},{}],167:[function(require,module,exports){\\n'use strict'\\n\\nconst {\\n  URLWithLegacySupport,\\n  format,\\n  URLSearchParams,\\n  defaultBase\\n} = require('./src/url')\\nconst relative = require('./src/relative')\\n\\nmodule.exports = {\\n  URL: URLWithLegacySupport,\\n  URLSearchParams,\\n  format,\\n  relative,\\n  defaultBase\\n}\\n\\n},{\\\"./src/relative\\\":168,\\\"./src/url\\\":169}],168:[function(require,module,exports){\\n'use strict'\\n\\nconst { URLWithLegacySupport, format } = require('./url')\\n\\n/**\\n * @param {string | undefined} url\\n * @param {any} [location]\\n * @param {any} [protocolMap]\\n * @param {any} [defaultProtocol]\\n */\\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\\n  let protocol = location.protocol\\n    ? location.protocol.replace(':', '')\\n    : 'http'\\n\\n  // Check protocol map\\n  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'\\n  let urlParsed\\n\\n  try {\\n    urlParsed = new URLWithLegacySupport(url)\\n  } catch (err) {\\n    urlParsed = {}\\n  }\\n\\n  const base = Object.assign({}, location, {\\n    protocol: protocol || urlParsed.protocol,\\n    host: location.host || urlParsed.host\\n  })\\n\\n  return new URLWithLegacySupport(url, format(base)).toString()\\n}\\n\\n},{\\\"./url\\\":169}],169:[function(require,module,exports){\\n'use strict'\\n\\nconst isReactNative =\\n    typeof navigator !== 'undefined' &&\\n    navigator.product === 'ReactNative'\\n\\nfunction getDefaultBase () {\\n  if (isReactNative) {\\n    return 'http://localhost'\\n  }\\n\\n  return self.location.protocol + '//' + self.location.host\\n}\\n\\nconst URL = self.URL\\nconst defaultBase = getDefaultBase()\\n\\nclass URLWithLegacySupport {\\n  constructor (url = '', base = defaultBase) {\\n    this.super = new URL(url, base)\\n    this.path = this.pathname + this.search\\n    this.auth =\\n            this.username && this.password\\n              ? this.username + ':' + this.password\\n              : null\\n\\n    this.query =\\n            this.search && this.search.startsWith('?')\\n              ? this.search.slice(1)\\n              : null\\n  }\\n\\n  get hash () {\\n    return this.super.hash\\n  }\\n\\n  get host () {\\n    return this.super.host\\n  }\\n\\n  get hostname () {\\n    return this.super.hostname\\n  }\\n\\n  get href () {\\n    return this.super.href\\n  }\\n\\n  get origin () {\\n    return this.super.origin\\n  }\\n\\n  get password () {\\n    return this.super.password\\n  }\\n\\n  get pathname () {\\n    return this.super.pathname\\n  }\\n\\n  get port () {\\n    return this.super.port\\n  }\\n\\n  get protocol () {\\n    return this.super.protocol\\n  }\\n\\n  get search () {\\n    return this.super.search\\n  }\\n\\n  get searchParams () {\\n    return this.super.searchParams\\n  }\\n\\n  get username () {\\n    return this.super.username\\n  }\\n\\n  set hash (hash) {\\n    this.super.hash = hash\\n  }\\n\\n  set host (host) {\\n    this.super.host = host\\n  }\\n\\n  set hostname (hostname) {\\n    this.super.hostname = hostname\\n  }\\n\\n  set href (href) {\\n    this.super.href = href\\n  }\\n\\n  set password (password) {\\n    this.super.password = password\\n  }\\n\\n  set pathname (pathname) {\\n    this.super.pathname = pathname\\n  }\\n\\n  set port (port) {\\n    this.super.port = port\\n  }\\n\\n  set protocol (protocol) {\\n    this.super.protocol = protocol\\n  }\\n\\n  set search (search) {\\n    this.super.search = search\\n  }\\n\\n  set username (username) {\\n    this.super.username = username\\n  }\\n\\n  /**\\n   * @param {any} o\\n   */\\n  static createObjectURL (o) {\\n    return URL.createObjectURL(o)\\n  }\\n\\n  /**\\n   * @param {string} o\\n   */\\n  static revokeObjectURL (o) {\\n    URL.revokeObjectURL(o)\\n  }\\n\\n  toJSON () {\\n    return this.super.toJSON()\\n  }\\n\\n  toString () {\\n    return this.super.toString()\\n  }\\n\\n  format () {\\n    return this.toString()\\n  }\\n}\\n\\n/**\\n * @param {string | import('url').UrlObject} obj\\n */\\nfunction format (obj) {\\n  if (typeof obj === 'string') {\\n    const url = new URL(obj)\\n\\n    return url.toString()\\n  }\\n\\n  if (!(obj instanceof URL)) {\\n    const userPass =\\n            // @ts-ignore its not supported in node but we normalise\\n            obj.username && obj.password\\n              // @ts-ignore its not supported in node but we normalise\\n              ? `${obj.username}:${obj.password}@`\\n              : ''\\n    const auth = obj.auth ? obj.auth + '@' : ''\\n    const port = obj.port ? ':' + obj.port : ''\\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\\n    const host = obj.host || ''\\n    const hostname = obj.hostname || ''\\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\\n    const hash = obj.hash || ''\\n    const pathname = obj.pathname || ''\\n    // @ts-ignore - path is not supported in node but we normalise\\n    const path = obj.path || pathname + search\\n\\n    return `${protocol}${userPass || auth}${\\n            host || hostname + port\\n        }${path}${hash}`\\n  }\\n}\\n\\nmodule.exports = {\\n  URLWithLegacySupport,\\n  URLSearchParams: self.URLSearchParams,\\n  defaultBase,\\n  format\\n}\\n\\n},{}],170:[function(require,module,exports){\\n'use strict';\\nconst isOptionObject = require('is-plain-obj');\\n\\nconst {hasOwnProperty} = Object.prototype;\\nconst {propertyIsEnumerable} = Object;\\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\\n\\tvalue,\\n\\twritable: true,\\n\\tenumerable: true,\\n\\tconfigurable: true\\n});\\n\\nconst globalThis = this;\\nconst defaultMergeOptions = {\\n\\tconcatArrays: false,\\n\\tignoreUndefined: false\\n};\\n\\nconst getEnumerableOwnPropertyKeys = value => {\\n\\tconst keys = [];\\n\\n\\tfor (const key in value) {\\n\\t\\tif (hasOwnProperty.call(value, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\n\\t/* istanbul ignore else  */\\n\\tif (Object.getOwnPropertySymbols) {\\n\\t\\tconst symbols = Object.getOwnPropertySymbols(value);\\n\\n\\t\\tfor (const symbol of symbols) {\\n\\t\\t\\tif (propertyIsEnumerable.call(value, symbol)) {\\n\\t\\t\\t\\tkeys.push(symbol);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn keys;\\n};\\n\\nfunction clone(value) {\\n\\tif (Array.isArray(value)) {\\n\\t\\treturn cloneArray(value);\\n\\t}\\n\\n\\tif (isOptionObject(value)) {\\n\\t\\treturn cloneOptionObject(value);\\n\\t}\\n\\n\\treturn value;\\n}\\n\\nfunction cloneArray(array) {\\n\\tconst result = array.slice(0, 0);\\n\\n\\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\\n\\t\\tdefineProperty(result, key, clone(array[key]));\\n\\t});\\n\\n\\treturn result;\\n}\\n\\nfunction cloneOptionObject(object) {\\n\\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\\n\\n\\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\\n\\t\\tdefineProperty(result, key, clone(object[key]));\\n\\t});\\n\\n\\treturn result;\\n}\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {string[]} keys keys to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n */\\nconst mergeKeys = (merged, source, keys, config) => {\\n\\tkeys.forEach(key => {\\n\\t\\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Do not recurse into prototype chain of merged\\n\\t\\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\\n\\t\\t\\tdefineProperty(merged, key, merge(merged[key], source[key], config));\\n\\t\\t} else {\\n\\t\\t\\tdefineProperty(merged, key, clone(source[key]));\\n\\t\\t}\\n\\t});\\n\\n\\treturn merged;\\n};\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n *\\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\\n */\\nconst concatArrays = (merged, source, config) => {\\n\\tlet result = merged.slice(0, 0);\\n\\tlet resultIndex = 0;\\n\\n\\t[merged, source].forEach(array => {\\n\\t\\tconst indices = [];\\n\\n\\t\\t// `result.concat(array)` with cloning\\n\\t\\tfor (let k = 0; k < array.length; k++) {\\n\\t\\t\\tif (!hasOwnProperty.call(array, k)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tindices.push(String(k));\\n\\n\\t\\t\\tif (array === merged) {\\n\\t\\t\\t\\t// Already cloned\\n\\t\\t\\t\\tdefineProperty(result, resultIndex++, array[k]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdefineProperty(result, resultIndex++, clone(array[k]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Merge non-index keys\\n\\t\\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\\n\\t});\\n\\n\\treturn result;\\n};\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n */\\nfunction merge(merged, source, config) {\\n\\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\\n\\t\\treturn concatArrays(merged, source, config);\\n\\t}\\n\\n\\tif (!isOptionObject(source) || !isOptionObject(merged)) {\\n\\t\\treturn clone(source);\\n\\t}\\n\\n\\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\\n}\\n\\nmodule.exports = function (...options) {\\n\\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\\n\\tlet merged = {_: {}};\\n\\n\\tfor (const option of options) {\\n\\t\\tif (option === undefined) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!isOptionObject(option)) {\\n\\t\\t\\tthrow new TypeError('`' + option + '` is not an Option Object');\\n\\t\\t}\\n\\n\\t\\tmerged = merge(merged, {_: option}, config);\\n\\t}\\n\\n\\treturn merged._;\\n};\\n\\n},{\\\"is-plain-obj\\\":166}],171:[function(require,module,exports){\\n'use strict'\\n\\nconst { encodeText } = require('./util')\\n\\n/** @typedef {import('./types').CodecFactory} CodecFactory */\\n/** @typedef {import(\\\"./types\\\").BaseName} BaseName */\\n/** @typedef {import(\\\"./types\\\").BaseCode} BaseCode */\\n\\n/**\\n * Class to encode/decode in the supported Bases\\n *\\n */\\nclass Base {\\n  /**\\n   * @param {BaseName} name\\n   * @param {BaseCode} code\\n   * @param {CodecFactory} factory\\n   * @param {string} alphabet\\n   */\\n  constructor (name, code, factory, alphabet) {\\n    this.name = name\\n    this.code = code\\n    this.codeBuf = encodeText(this.code)\\n    this.alphabet = alphabet\\n    this.codec = factory(alphabet)\\n  }\\n\\n  /**\\n   * @param {Uint8Array} buf\\n   * @returns {string}\\n   */\\n  encode (buf) {\\n    return this.codec.encode(buf)\\n  }\\n\\n  /**\\n   * @param {string} string\\n   * @returns {Uint8Array}\\n   */\\n  decode (string) {\\n    for (const char of string) {\\n      if (this.alphabet && this.alphabet.indexOf(char) < 0) {\\n        throw new Error(`invalid character '${char}' in '${string}'`)\\n      }\\n    }\\n    return this.codec.decode(string)\\n  }\\n}\\n\\nmodule.exports = Base\\n\\n},{\\\"./util\\\":175}],172:[function(require,module,exports){\\n'use strict'\\n\\nconst baseX = require('@multiformats/base-x')\\nconst Base = require('./base.js')\\nconst { rfc4648 } = require('./rfc4648')\\nconst { decodeText, encodeText } = require('./util')\\n\\n/** @typedef {import('./types').CodecFactory} CodecFactory */\\n/** @typedef {import('./types').Codec} Codec */\\n/** @typedef {import('./types').BaseName} BaseName */\\n/** @typedef {import('./types').BaseCode} BaseCode */\\n\\n/** @type {CodecFactory} */\\nconst identity = () => {\\n  return {\\n    encode: decodeText,\\n    decode: encodeText\\n  }\\n}\\n\\n/**\\n *\\n * name, code, implementation, alphabet\\n *\\n * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}\\n */\\nconst constants = [\\n  ['identity', '\\\\x00', identity, ''],\\n  ['base2', '0', rfc4648(1), '01'],\\n  ['base8', '7', rfc4648(3), '01234567'],\\n  ['base10', '9', baseX, '0123456789'],\\n  ['base16', 'f', rfc4648(4), '0123456789abcdef'],\\n  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],\\n  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],\\n  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],\\n  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],\\n  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],\\n  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],\\n  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],\\n  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],\\n  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],\\n  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],\\n  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],\\n  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],\\n  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],\\n  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],\\n  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],\\n  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],\\n  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],\\n  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']\\n]\\n\\n/** @type {Record<BaseName,Base>} */\\nconst names = constants.reduce((prev, tupple) => {\\n  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])\\n  return prev\\n}, /** @type {Record<BaseName,Base>} */({}))\\n\\n/** @type {Record<BaseCode,Base>} */\\nconst codes = constants.reduce((prev, tupple) => {\\n  prev[tupple[1]] = names[tupple[0]]\\n  return prev\\n}, /** @type {Record<BaseCode,Base>} */({}))\\n\\nmodule.exports = {\\n  names,\\n  codes\\n}\\n\\n},{\\\"./base.js\\\":171,\\\"./rfc4648\\\":174,\\\"./util\\\":175,\\\"@multiformats/base-x\\\":7}],173:[function(require,module,exports){\\n/**\\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\\n *\\n */\\n'use strict'\\n\\nconst constants = require('./constants')\\nconst { encodeText, decodeText, concat } = require('./util')\\n\\n/** @typedef {import('./base')} Base */\\n/** @typedef {import(\\\"./types\\\").BaseNameOrCode} BaseNameOrCode */\\n/** @typedef {import(\\\"./types\\\").BaseCode} BaseCode */\\n/** @typedef {import(\\\"./types\\\").BaseName} BaseName */\\n\\n/**\\n * Create a new Uint8Array with the multibase varint+code.\\n *\\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\\n * @param {Uint8Array} buf - The data to be prefixed with multibase.\\n * @returns {Uint8Array}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction multibase (nameOrCode, buf) {\\n  if (!buf) {\\n    throw new Error('requires an encoded Uint8Array')\\n  }\\n  const { name, codeBuf } = encoding(nameOrCode)\\n  validEncode(name, buf)\\n\\n  return concat([codeBuf, buf], codeBuf.length + buf.length)\\n}\\n\\n/**\\n * Encode data with the specified base and add the multibase prefix.\\n *\\n * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.\\n * @param {Uint8Array} buf - The data to be encoded.\\n * @returns {Uint8Array}\\n * @throws {Error} Will throw if the encoding is not supported\\n *\\n */\\nfunction encode (nameOrCode, buf) {\\n  const enc = encoding(nameOrCode)\\n  const data = encodeText(enc.encode(buf))\\n\\n  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)\\n}\\n\\n/**\\n * Takes a Uint8Array or string encoded with multibase header, decodes it and\\n * returns the decoded buffer\\n *\\n * @param {Uint8Array|string} data\\n * @returns {Uint8Array}\\n * @throws {Error} Will throw if the encoding is not supported\\n *\\n */\\nfunction decode (data) {\\n  if (data instanceof Uint8Array) {\\n    data = decodeText(data)\\n  }\\n  const prefix = data[0]\\n\\n  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet\\n  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {\\n    data = data.toLowerCase()\\n  }\\n  const enc = encoding(/** @type {BaseCode} */(data[0]))\\n  return enc.decode(data.substring(1))\\n}\\n\\n/**\\n * Is the given data multibase encoded?\\n *\\n * @param {Uint8Array|string} data\\n * @returns {false | string}\\n */\\nfunction isEncoded (data) {\\n  if (data instanceof Uint8Array) {\\n    data = decodeText(data)\\n  }\\n\\n  // Ensure bufOrString is a string\\n  if (Object.prototype.toString.call(data) !== '[object String]') {\\n    return false\\n  }\\n\\n  try {\\n    const enc = encoding(/** @type {BaseCode} */(data[0]))\\n    return enc.name\\n  } catch (err) {\\n    return false\\n  }\\n}\\n\\n/**\\n * Validate encoded data\\n *\\n * @param {BaseNameOrCode} name\\n * @param {Uint8Array} buf\\n * @returns {void}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction validEncode (name, buf) {\\n  const enc = encoding(name)\\n  enc.decode(decodeText(buf))\\n}\\n\\n/**\\n * Get the encoding by name or code\\n *\\n * @param {BaseNameOrCode} nameOrCode\\n * @returns {Base}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction encoding (nameOrCode) {\\n  if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {\\n    return constants.names[/** @type {BaseName} */(nameOrCode)]\\n  } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {\\n    return constants.codes[/** @type {BaseCode} */(nameOrCode)]\\n  } else {\\n    throw new Error(`Unsupported encoding: ${nameOrCode}`)\\n  }\\n}\\n\\n/**\\n * Get encoding from data\\n *\\n * @param {string|Uint8Array} data\\n * @returns {Base}\\n * @throws {Error} Will throw if the encoding is not supported\\n */\\nfunction encodingFromData (data) {\\n  if (data instanceof Uint8Array) {\\n    data = decodeText(data)\\n  }\\n\\n  return encoding(/** @type {BaseCode} */(data[0]))\\n}\\n\\nexports = module.exports = multibase\\nexports.encode = encode\\nexports.decode = decode\\nexports.isEncoded = isEncoded\\nexports.encoding = encoding\\nexports.encodingFromData = encodingFromData\\nconst names = Object.freeze(constants.names)\\nconst codes = Object.freeze(constants.codes)\\nexports.names = names\\nexports.codes = codes\\n\\n},{\\\"./constants\\\":172,\\\"./util\\\":175}],174:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./types').CodecFactory} CodecFactory */\\n\\n/**\\n * @param {string} string\\n * @param {string} alphabet\\n * @param {number} bitsPerChar\\n * @returns {Uint8Array}\\n */\\nconst decode = (string, alphabet, bitsPerChar) => {\\n  // Build the character lookup table:\\n  /** @type {Record<string, number>} */\\n  const codes = {}\\n  for (let i = 0; i < alphabet.length; ++i) {\\n    codes[alphabet[i]] = i\\n  }\\n\\n  // Count the padding bytes:\\n  let end = string.length\\n  while (string[end - 1] === '=') {\\n    --end\\n  }\\n\\n  // Allocate the output:\\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\\n\\n  // Parse the data:\\n  let bits = 0 // Number of bits currently in the buffer\\n  let buffer = 0 // Bits waiting to be written out, MSB first\\n  let written = 0 // Next byte to write\\n  for (let i = 0; i < end; ++i) {\\n    // Read one character from the string:\\n    const value = codes[string[i]]\\n    if (value === undefined) {\\n      throw new SyntaxError('Invalid character ' + string[i])\\n    }\\n\\n    // Append the bits to the buffer:\\n    buffer = (buffer << bitsPerChar) | value\\n    bits += bitsPerChar\\n\\n    // Write out some bits if the buffer has a byte's worth:\\n    if (bits >= 8) {\\n      bits -= 8\\n      out[written++] = 0xff & (buffer >> bits)\\n    }\\n  }\\n\\n  // Verify that we have received just enough bits:\\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\\n    throw new SyntaxError('Unexpected end of data')\\n  }\\n\\n  return out\\n}\\n\\n/**\\n * @param {Uint8Array} data\\n * @param {string} alphabet\\n * @param {number} bitsPerChar\\n * @returns {string}\\n */\\nconst encode = (data, alphabet, bitsPerChar) => {\\n  const pad = alphabet[alphabet.length - 1] === '='\\n  const mask = (1 << bitsPerChar) - 1\\n  let out = ''\\n\\n  let bits = 0 // Number of bits currently in the buffer\\n  let buffer = 0 // Bits waiting to be written out, MSB first\\n  for (let i = 0; i < data.length; ++i) {\\n    // Slurp data into the buffer:\\n    buffer = (buffer << 8) | data[i]\\n    bits += 8\\n\\n    // Write out as much as we can:\\n    while (bits > bitsPerChar) {\\n      bits -= bitsPerChar\\n      out += alphabet[mask & (buffer >> bits)]\\n    }\\n  }\\n\\n  // Partial character:\\n  if (bits) {\\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\\n  }\\n\\n  // Add padding characters until we hit a byte boundary:\\n  if (pad) {\\n    while ((out.length * bitsPerChar) & 7) {\\n      out += '='\\n    }\\n  }\\n\\n  return out\\n}\\n\\n/**\\n * RFC4648 Factory\\n *\\n * @param {number} bitsPerChar\\n * @returns {CodecFactory}\\n */\\nconst rfc4648 = (bitsPerChar) => (alphabet) => {\\n  return {\\n    /**\\n     * @param {Uint8Array} input\\n     * @returns {string}\\n     */\\n    encode (input) {\\n      return encode(input, alphabet, bitsPerChar)\\n    },\\n    /**\\n     * @param {string} input\\n     * @returns {Uint8Array}\\n     */\\n    decode (input) {\\n      return decode(input, alphabet, bitsPerChar)\\n    }\\n  }\\n}\\n\\nmodule.exports = { rfc4648 }\\n\\n},{}],175:[function(require,module,exports){\\n'use strict'\\n\\nconst textDecoder = new TextDecoder()\\n/**\\n * @param {ArrayBufferView|ArrayBuffer} bytes\\n * @returns {string}\\n */\\nconst decodeText = (bytes) => textDecoder.decode(bytes)\\n\\nconst textEncoder = new TextEncoder()\\n/**\\n * @param {string} text\\n * @returns {Uint8Array}\\n */\\nconst encodeText = (text) => textEncoder.encode(text)\\n\\n/**\\n * Returns a new Uint8Array created by concatenating the passed Arrays\\n *\\n * @param {Array<ArrayLike<number>>} arrs\\n * @param {number} length\\n * @returns {Uint8Array}\\n */\\nfunction concat (arrs, length) {\\n  const output = new Uint8Array(length)\\n  let offset = 0\\n\\n  for (const arr of arrs) {\\n    output.set(arr, offset)\\n    offset += arr.length\\n  }\\n\\n  return output\\n}\\n\\nmodule.exports = { decodeText, encodeText, concat }\\n\\n},{}],176:[function(require,module,exports){\\narguments[4][15][0].apply(exports,arguments)\\n},{\\\"dup\\\":15}],177:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst utf8Encoder = new TextEncoder()\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName} BaseName\\n */\\n\\n/**\\n * Interprets each character in a string as a byte and\\n * returns a Uint8Array of those bytes.\\n *\\n * @param {string} string - The string to turn into an array\\n */\\nfunction asciiStringToUint8Array (string) {\\n  const array = new Uint8Array(string.length)\\n\\n  for (let i = 0; i < string.length; i++) {\\n    array[i] = string.charCodeAt(i)\\n  }\\n\\n  return array\\n}\\n\\n/**\\n * Create a `Uint8Array` from the passed string\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {string} string\\n * @param {BaseName | 'utf8' | 'utf-8' | 'ascii'} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc\\n * @returns {Uint8Array}\\n */\\nfunction fromString (string, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Encoder.encode(string)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return asciiStringToUint8Array(string)\\n  }\\n\\n  return getCodec(encoding).decode(string)\\n}\\n\\nmodule.exports = fromString\\n\\n},{\\\"multibase\\\":173}],178:[function(require,module,exports){\\narguments[4][17][0].apply(exports,arguments)\\n},{\\\"dup\\\":17,\\\"multibase\\\":173}],179:[function(require,module,exports){\\nmodule.exports = read\\n\\nvar MSB = 0x80\\n  , REST = 0x7F\\n\\nfunction read(buf, offset) {\\n  var res    = 0\\n    , offset = offset || 0\\n    , shift  = 0\\n    , counter = offset\\n    , b\\n    , l = buf.length\\n\\n  do {\\n    if (counter >= l) {\\n      read.bytes = 0\\n      throw new RangeError('Could not decode varint')\\n    }\\n    b = buf[counter++]\\n    res += shift < 28\\n      ? (b & REST) << shift\\n      : (b & REST) * Math.pow(2, shift)\\n    shift += 7\\n  } while (b >= MSB)\\n\\n  read.bytes = counter - offset\\n\\n  return res\\n}\\n\\n},{}],180:[function(require,module,exports){\\nmodule.exports = encode\\n\\nvar MSB = 0x80\\n  , REST = 0x7F\\n  , MSBALL = ~REST\\n  , INT = Math.pow(2, 31)\\n\\nfunction encode(num, out, offset) {\\n  out = out || []\\n  offset = offset || 0\\n  var oldOffset = offset\\n\\n  while(num >= INT) {\\n    out[offset++] = (num & 0xFF) | MSB\\n    num /= 128\\n  }\\n  while(num & MSBALL) {\\n    out[offset++] = (num & 0xFF) | MSB\\n    num >>>= 7\\n  }\\n  out[offset] = num | 0\\n  \\n  encode.bytes = offset - oldOffset + 1\\n  \\n  return out\\n}\\n\\n},{}],181:[function(require,module,exports){\\nmodule.exports = {\\n    encode: require('./encode.js')\\n  , decode: require('./decode.js')\\n  , encodingLength: require('./length.js')\\n}\\n\\n},{\\\"./decode.js\\\":179,\\\"./encode.js\\\":180,\\\"./length.js\\\":182}],182:[function(require,module,exports){\\n\\nvar N1 = Math.pow(2,  7)\\nvar N2 = Math.pow(2, 14)\\nvar N3 = Math.pow(2, 21)\\nvar N4 = Math.pow(2, 28)\\nvar N5 = Math.pow(2, 35)\\nvar N6 = Math.pow(2, 42)\\nvar N7 = Math.pow(2, 49)\\nvar N8 = Math.pow(2, 56)\\nvar N9 = Math.pow(2, 63)\\n\\nmodule.exports = function (value) {\\n  return (\\n    value < N1 ? 1\\n  : value < N2 ? 2\\n  : value < N3 ? 3\\n  : value < N4 ? 4\\n  : value < N5 ? 5\\n  : value < N6 ? 6\\n  : value < N7 ? 7\\n  : value < N8 ? 8\\n  : value < N9 ? 9\\n  :              10\\n  )\\n}\\n\\n},{}],183:[function(require,module,exports){\\n// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js\\n/* eslint quote-props: off */\\n'use strict'\\n\\n/**\\n * @type {import('./generated-types').NameCodeMap}\\n */\\nconst baseTable = Object.freeze({\\n  'identity': 0x00,\\n  'cidv1': 0x01,\\n  'cidv2': 0x02,\\n  'cidv3': 0x03,\\n  'ip4': 0x04,\\n  'tcp': 0x06,\\n  'sha1': 0x11,\\n  'sha2-256': 0x12,\\n  'sha2-512': 0x13,\\n  'sha3-512': 0x14,\\n  'sha3-384': 0x15,\\n  'sha3-256': 0x16,\\n  'sha3-224': 0x17,\\n  'shake-128': 0x18,\\n  'shake-256': 0x19,\\n  'keccak-224': 0x1a,\\n  'keccak-256': 0x1b,\\n  'keccak-384': 0x1c,\\n  'keccak-512': 0x1d,\\n  'blake3': 0x1e,\\n  'dccp': 0x21,\\n  'murmur3-128': 0x22,\\n  'murmur3-32': 0x23,\\n  'ip6': 0x29,\\n  'ip6zone': 0x2a,\\n  'path': 0x2f,\\n  'multicodec': 0x30,\\n  'multihash': 0x31,\\n  'multiaddr': 0x32,\\n  'multibase': 0x33,\\n  'dns': 0x35,\\n  'dns4': 0x36,\\n  'dns6': 0x37,\\n  'dnsaddr': 0x38,\\n  'protobuf': 0x50,\\n  'cbor': 0x51,\\n  'raw': 0x55,\\n  'dbl-sha2-256': 0x56,\\n  'rlp': 0x60,\\n  'bencode': 0x63,\\n  'dag-pb': 0x70,\\n  'dag-cbor': 0x71,\\n  'libp2p-key': 0x72,\\n  'git-raw': 0x78,\\n  'torrent-info': 0x7b,\\n  'torrent-file': 0x7c,\\n  'leofcoin-block': 0x81,\\n  'leofcoin-tx': 0x82,\\n  'leofcoin-pr': 0x83,\\n  'sctp': 0x84,\\n  'dag-jose': 0x85,\\n  'dag-cose': 0x86,\\n  'eth-block': 0x90,\\n  'eth-block-list': 0x91,\\n  'eth-tx-trie': 0x92,\\n  'eth-tx': 0x93,\\n  'eth-tx-receipt-trie': 0x94,\\n  'eth-tx-receipt': 0x95,\\n  'eth-state-trie': 0x96,\\n  'eth-account-snapshot': 0x97,\\n  'eth-storage-trie': 0x98,\\n  'bitcoin-block': 0xb0,\\n  'bitcoin-tx': 0xb1,\\n  'bitcoin-witness-commitment': 0xb2,\\n  'zcash-block': 0xc0,\\n  'zcash-tx': 0xc1,\\n  'docid': 0xce,\\n  'stellar-block': 0xd0,\\n  'stellar-tx': 0xd1,\\n  'md4': 0xd4,\\n  'md5': 0xd5,\\n  'bmt': 0xd6,\\n  'decred-block': 0xe0,\\n  'decred-tx': 0xe1,\\n  'ipld-ns': 0xe2,\\n  'ipfs-ns': 0xe3,\\n  'swarm-ns': 0xe4,\\n  'ipns-ns': 0xe5,\\n  'zeronet': 0xe6,\\n  'secp256k1-pub': 0xe7,\\n  'bls12_381-g1-pub': 0xea,\\n  'bls12_381-g2-pub': 0xeb,\\n  'x25519-pub': 0xec,\\n  'ed25519-pub': 0xed,\\n  'bls12_381-g1g2-pub': 0xee,\\n  'dash-block': 0xf0,\\n  'dash-tx': 0xf1,\\n  'swarm-manifest': 0xfa,\\n  'swarm-feed': 0xfb,\\n  'udp': 0x0111,\\n  'p2p-webrtc-star': 0x0113,\\n  'p2p-webrtc-direct': 0x0114,\\n  'p2p-stardust': 0x0115,\\n  'p2p-circuit': 0x0122,\\n  'dag-json': 0x0129,\\n  'udt': 0x012d,\\n  'utp': 0x012e,\\n  'unix': 0x0190,\\n  'thread': 0x0196,\\n  'p2p': 0x01a5,\\n  'ipfs': 0x01a5,\\n  'https': 0x01bb,\\n  'onion': 0x01bc,\\n  'onion3': 0x01bd,\\n  'garlic64': 0x01be,\\n  'garlic32': 0x01bf,\\n  'tls': 0x01c0,\\n  'quic': 0x01cc,\\n  'ws': 0x01dd,\\n  'wss': 0x01de,\\n  'p2p-websocket-star': 0x01df,\\n  'http': 0x01e0,\\n  'json': 0x0200,\\n  'messagepack': 0x0201,\\n  'libp2p-peer-record': 0x0301,\\n  'sha2-256-trunc254-padded': 0x1012,\\n  'ripemd-128': 0x1052,\\n  'ripemd-160': 0x1053,\\n  'ripemd-256': 0x1054,\\n  'ripemd-320': 0x1055,\\n  'x11': 0x1100,\\n  'p256-pub': 0x1200,\\n  'p384-pub': 0x1201,\\n  'p521-pub': 0x1202,\\n  'ed448-pub': 0x1203,\\n  'x448-pub': 0x1204,\\n  'ed25519-priv': 0x1300,\\n  'kangarootwelve': 0x1d01,\\n  'sm3-256': 0x534d,\\n  'blake2b-8': 0xb201,\\n  'blake2b-16': 0xb202,\\n  'blake2b-24': 0xb203,\\n  'blake2b-32': 0xb204,\\n  'blake2b-40': 0xb205,\\n  'blake2b-48': 0xb206,\\n  'blake2b-56': 0xb207,\\n  'blake2b-64': 0xb208,\\n  'blake2b-72': 0xb209,\\n  'blake2b-80': 0xb20a,\\n  'blake2b-88': 0xb20b,\\n  'blake2b-96': 0xb20c,\\n  'blake2b-104': 0xb20d,\\n  'blake2b-112': 0xb20e,\\n  'blake2b-120': 0xb20f,\\n  'blake2b-128': 0xb210,\\n  'blake2b-136': 0xb211,\\n  'blake2b-144': 0xb212,\\n  'blake2b-152': 0xb213,\\n  'blake2b-160': 0xb214,\\n  'blake2b-168': 0xb215,\\n  'blake2b-176': 0xb216,\\n  'blake2b-184': 0xb217,\\n  'blake2b-192': 0xb218,\\n  'blake2b-200': 0xb219,\\n  'blake2b-208': 0xb21a,\\n  'blake2b-216': 0xb21b,\\n  'blake2b-224': 0xb21c,\\n  'blake2b-232': 0xb21d,\\n  'blake2b-240': 0xb21e,\\n  'blake2b-248': 0xb21f,\\n  'blake2b-256': 0xb220,\\n  'blake2b-264': 0xb221,\\n  'blake2b-272': 0xb222,\\n  'blake2b-280': 0xb223,\\n  'blake2b-288': 0xb224,\\n  'blake2b-296': 0xb225,\\n  'blake2b-304': 0xb226,\\n  'blake2b-312': 0xb227,\\n  'blake2b-320': 0xb228,\\n  'blake2b-328': 0xb229,\\n  'blake2b-336': 0xb22a,\\n  'blake2b-344': 0xb22b,\\n  'blake2b-352': 0xb22c,\\n  'blake2b-360': 0xb22d,\\n  'blake2b-368': 0xb22e,\\n  'blake2b-376': 0xb22f,\\n  'blake2b-384': 0xb230,\\n  'blake2b-392': 0xb231,\\n  'blake2b-400': 0xb232,\\n  'blake2b-408': 0xb233,\\n  'blake2b-416': 0xb234,\\n  'blake2b-424': 0xb235,\\n  'blake2b-432': 0xb236,\\n  'blake2b-440': 0xb237,\\n  'blake2b-448': 0xb238,\\n  'blake2b-456': 0xb239,\\n  'blake2b-464': 0xb23a,\\n  'blake2b-472': 0xb23b,\\n  'blake2b-480': 0xb23c,\\n  'blake2b-488': 0xb23d,\\n  'blake2b-496': 0xb23e,\\n  'blake2b-504': 0xb23f,\\n  'blake2b-512': 0xb240,\\n  'blake2s-8': 0xb241,\\n  'blake2s-16': 0xb242,\\n  'blake2s-24': 0xb243,\\n  'blake2s-32': 0xb244,\\n  'blake2s-40': 0xb245,\\n  'blake2s-48': 0xb246,\\n  'blake2s-56': 0xb247,\\n  'blake2s-64': 0xb248,\\n  'blake2s-72': 0xb249,\\n  'blake2s-80': 0xb24a,\\n  'blake2s-88': 0xb24b,\\n  'blake2s-96': 0xb24c,\\n  'blake2s-104': 0xb24d,\\n  'blake2s-112': 0xb24e,\\n  'blake2s-120': 0xb24f,\\n  'blake2s-128': 0xb250,\\n  'blake2s-136': 0xb251,\\n  'blake2s-144': 0xb252,\\n  'blake2s-152': 0xb253,\\n  'blake2s-160': 0xb254,\\n  'blake2s-168': 0xb255,\\n  'blake2s-176': 0xb256,\\n  'blake2s-184': 0xb257,\\n  'blake2s-192': 0xb258,\\n  'blake2s-200': 0xb259,\\n  'blake2s-208': 0xb25a,\\n  'blake2s-216': 0xb25b,\\n  'blake2s-224': 0xb25c,\\n  'blake2s-232': 0xb25d,\\n  'blake2s-240': 0xb25e,\\n  'blake2s-248': 0xb25f,\\n  'blake2s-256': 0xb260,\\n  'skein256-8': 0xb301,\\n  'skein256-16': 0xb302,\\n  'skein256-24': 0xb303,\\n  'skein256-32': 0xb304,\\n  'skein256-40': 0xb305,\\n  'skein256-48': 0xb306,\\n  'skein256-56': 0xb307,\\n  'skein256-64': 0xb308,\\n  'skein256-72': 0xb309,\\n  'skein256-80': 0xb30a,\\n  'skein256-88': 0xb30b,\\n  'skein256-96': 0xb30c,\\n  'skein256-104': 0xb30d,\\n  'skein256-112': 0xb30e,\\n  'skein256-120': 0xb30f,\\n  'skein256-128': 0xb310,\\n  'skein256-136': 0xb311,\\n  'skein256-144': 0xb312,\\n  'skein256-152': 0xb313,\\n  'skein256-160': 0xb314,\\n  'skein256-168': 0xb315,\\n  'skein256-176': 0xb316,\\n  'skein256-184': 0xb317,\\n  'skein256-192': 0xb318,\\n  'skein256-200': 0xb319,\\n  'skein256-208': 0xb31a,\\n  'skein256-216': 0xb31b,\\n  'skein256-224': 0xb31c,\\n  'skein256-232': 0xb31d,\\n  'skein256-240': 0xb31e,\\n  'skein256-248': 0xb31f,\\n  'skein256-256': 0xb320,\\n  'skein512-8': 0xb321,\\n  'skein512-16': 0xb322,\\n  'skein512-24': 0xb323,\\n  'skein512-32': 0xb324,\\n  'skein512-40': 0xb325,\\n  'skein512-48': 0xb326,\\n  'skein512-56': 0xb327,\\n  'skein512-64': 0xb328,\\n  'skein512-72': 0xb329,\\n  'skein512-80': 0xb32a,\\n  'skein512-88': 0xb32b,\\n  'skein512-96': 0xb32c,\\n  'skein512-104': 0xb32d,\\n  'skein512-112': 0xb32e,\\n  'skein512-120': 0xb32f,\\n  'skein512-128': 0xb330,\\n  'skein512-136': 0xb331,\\n  'skein512-144': 0xb332,\\n  'skein512-152': 0xb333,\\n  'skein512-160': 0xb334,\\n  'skein512-168': 0xb335,\\n  'skein512-176': 0xb336,\\n  'skein512-184': 0xb337,\\n  'skein512-192': 0xb338,\\n  'skein512-200': 0xb339,\\n  'skein512-208': 0xb33a,\\n  'skein512-216': 0xb33b,\\n  'skein512-224': 0xb33c,\\n  'skein512-232': 0xb33d,\\n  'skein512-240': 0xb33e,\\n  'skein512-248': 0xb33f,\\n  'skein512-256': 0xb340,\\n  'skein512-264': 0xb341,\\n  'skein512-272': 0xb342,\\n  'skein512-280': 0xb343,\\n  'skein512-288': 0xb344,\\n  'skein512-296': 0xb345,\\n  'skein512-304': 0xb346,\\n  'skein512-312': 0xb347,\\n  'skein512-320': 0xb348,\\n  'skein512-328': 0xb349,\\n  'skein512-336': 0xb34a,\\n  'skein512-344': 0xb34b,\\n  'skein512-352': 0xb34c,\\n  'skein512-360': 0xb34d,\\n  'skein512-368': 0xb34e,\\n  'skein512-376': 0xb34f,\\n  'skein512-384': 0xb350,\\n  'skein512-392': 0xb351,\\n  'skein512-400': 0xb352,\\n  'skein512-408': 0xb353,\\n  'skein512-416': 0xb354,\\n  'skein512-424': 0xb355,\\n  'skein512-432': 0xb356,\\n  'skein512-440': 0xb357,\\n  'skein512-448': 0xb358,\\n  'skein512-456': 0xb359,\\n  'skein512-464': 0xb35a,\\n  'skein512-472': 0xb35b,\\n  'skein512-480': 0xb35c,\\n  'skein512-488': 0xb35d,\\n  'skein512-496': 0xb35e,\\n  'skein512-504': 0xb35f,\\n  'skein512-512': 0xb360,\\n  'skein1024-8': 0xb361,\\n  'skein1024-16': 0xb362,\\n  'skein1024-24': 0xb363,\\n  'skein1024-32': 0xb364,\\n  'skein1024-40': 0xb365,\\n  'skein1024-48': 0xb366,\\n  'skein1024-56': 0xb367,\\n  'skein1024-64': 0xb368,\\n  'skein1024-72': 0xb369,\\n  'skein1024-80': 0xb36a,\\n  'skein1024-88': 0xb36b,\\n  'skein1024-96': 0xb36c,\\n  'skein1024-104': 0xb36d,\\n  'skein1024-112': 0xb36e,\\n  'skein1024-120': 0xb36f,\\n  'skein1024-128': 0xb370,\\n  'skein1024-136': 0xb371,\\n  'skein1024-144': 0xb372,\\n  'skein1024-152': 0xb373,\\n  'skein1024-160': 0xb374,\\n  'skein1024-168': 0xb375,\\n  'skein1024-176': 0xb376,\\n  'skein1024-184': 0xb377,\\n  'skein1024-192': 0xb378,\\n  'skein1024-200': 0xb379,\\n  'skein1024-208': 0xb37a,\\n  'skein1024-216': 0xb37b,\\n  'skein1024-224': 0xb37c,\\n  'skein1024-232': 0xb37d,\\n  'skein1024-240': 0xb37e,\\n  'skein1024-248': 0xb37f,\\n  'skein1024-256': 0xb380,\\n  'skein1024-264': 0xb381,\\n  'skein1024-272': 0xb382,\\n  'skein1024-280': 0xb383,\\n  'skein1024-288': 0xb384,\\n  'skein1024-296': 0xb385,\\n  'skein1024-304': 0xb386,\\n  'skein1024-312': 0xb387,\\n  'skein1024-320': 0xb388,\\n  'skein1024-328': 0xb389,\\n  'skein1024-336': 0xb38a,\\n  'skein1024-344': 0xb38b,\\n  'skein1024-352': 0xb38c,\\n  'skein1024-360': 0xb38d,\\n  'skein1024-368': 0xb38e,\\n  'skein1024-376': 0xb38f,\\n  'skein1024-384': 0xb390,\\n  'skein1024-392': 0xb391,\\n  'skein1024-400': 0xb392,\\n  'skein1024-408': 0xb393,\\n  'skein1024-416': 0xb394,\\n  'skein1024-424': 0xb395,\\n  'skein1024-432': 0xb396,\\n  'skein1024-440': 0xb397,\\n  'skein1024-448': 0xb398,\\n  'skein1024-456': 0xb399,\\n  'skein1024-464': 0xb39a,\\n  'skein1024-472': 0xb39b,\\n  'skein1024-480': 0xb39c,\\n  'skein1024-488': 0xb39d,\\n  'skein1024-496': 0xb39e,\\n  'skein1024-504': 0xb39f,\\n  'skein1024-512': 0xb3a0,\\n  'skein1024-520': 0xb3a1,\\n  'skein1024-528': 0xb3a2,\\n  'skein1024-536': 0xb3a3,\\n  'skein1024-544': 0xb3a4,\\n  'skein1024-552': 0xb3a5,\\n  'skein1024-560': 0xb3a6,\\n  'skein1024-568': 0xb3a7,\\n  'skein1024-576': 0xb3a8,\\n  'skein1024-584': 0xb3a9,\\n  'skein1024-592': 0xb3aa,\\n  'skein1024-600': 0xb3ab,\\n  'skein1024-608': 0xb3ac,\\n  'skein1024-616': 0xb3ad,\\n  'skein1024-624': 0xb3ae,\\n  'skein1024-632': 0xb3af,\\n  'skein1024-640': 0xb3b0,\\n  'skein1024-648': 0xb3b1,\\n  'skein1024-656': 0xb3b2,\\n  'skein1024-664': 0xb3b3,\\n  'skein1024-672': 0xb3b4,\\n  'skein1024-680': 0xb3b5,\\n  'skein1024-688': 0xb3b6,\\n  'skein1024-696': 0xb3b7,\\n  'skein1024-704': 0xb3b8,\\n  'skein1024-712': 0xb3b9,\\n  'skein1024-720': 0xb3ba,\\n  'skein1024-728': 0xb3bb,\\n  'skein1024-736': 0xb3bc,\\n  'skein1024-744': 0xb3bd,\\n  'skein1024-752': 0xb3be,\\n  'skein1024-760': 0xb3bf,\\n  'skein1024-768': 0xb3c0,\\n  'skein1024-776': 0xb3c1,\\n  'skein1024-784': 0xb3c2,\\n  'skein1024-792': 0xb3c3,\\n  'skein1024-800': 0xb3c4,\\n  'skein1024-808': 0xb3c5,\\n  'skein1024-816': 0xb3c6,\\n  'skein1024-824': 0xb3c7,\\n  'skein1024-832': 0xb3c8,\\n  'skein1024-840': 0xb3c9,\\n  'skein1024-848': 0xb3ca,\\n  'skein1024-856': 0xb3cb,\\n  'skein1024-864': 0xb3cc,\\n  'skein1024-872': 0xb3cd,\\n  'skein1024-880': 0xb3ce,\\n  'skein1024-888': 0xb3cf,\\n  'skein1024-896': 0xb3d0,\\n  'skein1024-904': 0xb3d1,\\n  'skein1024-912': 0xb3d2,\\n  'skein1024-920': 0xb3d3,\\n  'skein1024-928': 0xb3d4,\\n  'skein1024-936': 0xb3d5,\\n  'skein1024-944': 0xb3d6,\\n  'skein1024-952': 0xb3d7,\\n  'skein1024-960': 0xb3d8,\\n  'skein1024-968': 0xb3d9,\\n  'skein1024-976': 0xb3da,\\n  'skein1024-984': 0xb3db,\\n  'skein1024-992': 0xb3dc,\\n  'skein1024-1000': 0xb3dd,\\n  'skein1024-1008': 0xb3de,\\n  'skein1024-1016': 0xb3df,\\n  'skein1024-1024': 0xb3e0,\\n  'poseidon-bls12_381-a2-fc1': 0xb401,\\n  'poseidon-bls12_381-a2-fc1-sc': 0xb402,\\n  'zeroxcert-imprint-256': 0xce11,\\n  'fil-commitment-unsealed': 0xf101,\\n  'fil-commitment-sealed': 0xf102,\\n  'holochain-adr-v0': 0x807124,\\n  'holochain-adr-v1': 0x817124,\\n  'holochain-key-v0': 0x947124,\\n  'holochain-key-v1': 0x957124,\\n  'holochain-sig-v0': 0xa27124,\\n  'holochain-sig-v1': 0xa37124,\\n  'skynet-ns': 0xb19910\\n})\\n\\nmodule.exports = { baseTable }\\n\\n},{}],184:[function(require,module,exports){\\n/**\\n * Implementation of the multicodec specification.\\n *\\n * @module multicodec\\n * @example\\n * const multicodec = require('multicodec')\\n *\\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\\n * // prefixedProtobuf 0x50...\\n *\\n */\\n'use strict'\\n\\n/** @typedef {import('./generated-types').CodecName} CodecName */\\n/** @typedef {import('./generated-types').CodecCode} CodecCode */\\n\\nconst varint = require('varint')\\nconst uint8ArrayConcat = require('uint8arrays/concat')\\nconst util = require('./util')\\nconst { nameToVarint, constantToCode, nameToCode, codeToName } = require('./maps')\\n\\n/**\\n * Prefix a buffer with a multicodec-packed.\\n *\\n * @param {CodecName|Uint8Array} multicodecStrOrCode\\n * @param {Uint8Array} data\\n * @returns {Uint8Array}\\n */\\nfunction addPrefix (multicodecStrOrCode, data) {\\n  let prefix\\n\\n  if (multicodecStrOrCode instanceof Uint8Array) {\\n    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)\\n  } else {\\n    if (nameToVarint[multicodecStrOrCode]) {\\n      prefix = nameToVarint[multicodecStrOrCode]\\n    } else {\\n      throw new Error('multicodec not recognized')\\n    }\\n  }\\n\\n  return uint8ArrayConcat([prefix, data], prefix.length + data.length)\\n}\\n\\n/**\\n * Decapsulate the multicodec-packed prefix from the data.\\n *\\n * @param {Uint8Array} data\\n * @returns {Uint8Array}\\n */\\nfunction rmPrefix (data) {\\n  varint.decode(/** @type {Buffer} */(data))\\n  return data.slice(varint.decode.bytes)\\n}\\n\\n/**\\n * Get the codec name of the prefixed data.\\n *\\n * @param {Uint8Array} prefixedData\\n * @returns {CodecName}\\n */\\nfunction getNameFromData (prefixedData) {\\n  const code = /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))\\n  const name = codeToName[code]\\n  if (name === undefined) {\\n    throw new Error(`Code \\\"${code}\\\" not found`)\\n  }\\n  return name\\n}\\n\\n/**\\n * Get the codec name from a code.\\n *\\n * @param {CodecCode} codec\\n * @returns {CodecName}\\n */\\nfunction getNameFromCode (codec) {\\n  return codeToName[codec]\\n}\\n\\n/**\\n * Get the code of the codec\\n *\\n * @param {CodecName} name\\n * @returns {CodecCode}\\n */\\nfunction getCodeFromName (name) {\\n  const code = nameToCode[name]\\n  if (code === undefined) {\\n    throw new Error(`Codec \\\"${name}\\\" not found`)\\n  }\\n  return code\\n}\\n\\n/**\\n * Get the code of the prefixed data.\\n *\\n * @param {Uint8Array} prefixedData\\n * @returns {CodecCode}\\n */\\nfunction getCodeFromData (prefixedData) {\\n  return /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))\\n}\\n\\n/**\\n * Get the code as varint of a codec name.\\n *\\n * @param {CodecName} name\\n * @returns {Uint8Array}\\n */\\nfunction getVarintFromName (name) {\\n  const code = nameToVarint[name]\\n  if (code === undefined) {\\n    throw new Error(`Codec \\\"${name}\\\" not found`)\\n  }\\n  return code\\n}\\n\\n/**\\n * Get the varint of a code.\\n *\\n * @param {CodecCode} code\\n * @returns {Uint8Array}\\n */\\nfunction getVarintFromCode (code) {\\n  return util.varintEncode(code)\\n}\\n\\n/**\\n * Get the codec name of the prefixed data.\\n *\\n * @deprecated use getNameFromData instead.\\n * @param {Uint8Array} prefixedData\\n * @returns {CodecName}\\n */\\nfunction getCodec (prefixedData) {\\n  return getNameFromData(prefixedData)\\n}\\n\\n/**\\n * Get the codec name from a code.\\n *\\n * @deprecated use getNameFromCode instead.\\n * @param {CodecCode} codec\\n * @returns {CodecName}\\n */\\nfunction getName (codec) {\\n  return getNameFromCode(codec)\\n}\\n\\n/**\\n * Get the code of the codec\\n *\\n * @deprecated use getCodeFromName instead.\\n * @param {CodecName} name\\n * @returns {CodecCode}\\n */\\nfunction getNumber (name) {\\n  return getCodeFromName(name)\\n}\\n\\n/**\\n * Get the code of the prefixed data.\\n *\\n * @deprecated use getCodeFromData instead.\\n * @param {Uint8Array} prefixedData\\n * @returns {CodecCode}\\n */\\nfunction getCode (prefixedData) {\\n  return getCodeFromData(prefixedData)\\n}\\n\\n/**\\n * Get the code as varint of a codec name.\\n *\\n * @deprecated use getVarintFromName instead.\\n * @param {CodecName} name\\n * @returns {Uint8Array}\\n */\\nfunction getCodeVarint (name) {\\n  return getVarintFromName(name)\\n}\\n\\n/**\\n * Get the varint of a code.\\n *\\n * @deprecated use getVarintFromCode instead.\\n * @param {CodecCode} code\\n * @returns {Array.<number>}\\n */\\nfunction getVarint (code) {\\n  return Array.from(getVarintFromCode(code))\\n}\\n\\nmodule.exports = {\\n  addPrefix,\\n  rmPrefix,\\n  getNameFromData,\\n  getNameFromCode,\\n  getCodeFromName,\\n  getCodeFromData,\\n  getVarintFromName,\\n  getVarintFromCode,\\n  // Deprecated\\n  getCodec,\\n  getName,\\n  getNumber,\\n  getCode,\\n  getCodeVarint,\\n  getVarint,\\n  // Make the constants top-level constants\\n  ...constantToCode,\\n  // Export the maps\\n  nameToVarint,\\n  nameToCode,\\n  codeToName\\n}\\n\\n},{\\\"./maps\\\":185,\\\"./util\\\":186,\\\"uint8arrays/concat\\\":176,\\\"varint\\\":181}],185:[function(require,module,exports){\\n'use strict'\\n\\n/** @typedef {import('./generated-types').ConstantCodeMap} ConstantCodeMap */\\n/** @typedef {import('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */\\n/** @typedef {import('./generated-types').CodeNameMap} CodeNameMap */\\n/** @typedef {import('./generated-types').CodecName} CodecName */\\n/** @typedef {import('./generated-types').CodecConstant} CodecConstant */\\n\\nconst { baseTable } = require('./generated-table')\\nconst varintEncode = require('./util').varintEncode\\n\\nconst nameToVarint = /** @type {NameUint8ArrayMap} */ ({})\\nconst constantToCode = /** @type {ConstantCodeMap} */({})\\nconst codeToName = /** @type {CodeNameMap} */({})\\n\\n// eslint-disable-next-line guard-for-in\\nfor (const name in baseTable) {\\n  const codecName = /** @type {CodecName} */(name)\\n  const code = baseTable[codecName]\\n  nameToVarint[codecName] = varintEncode(code)\\n\\n  const constant = /** @type {CodecConstant} */(codecName.toUpperCase().replace(/-/g, '_'))\\n  constantToCode[constant] = code\\n\\n  if (!codeToName[code]) {\\n    codeToName[code] = codecName\\n  }\\n}\\n\\nObject.freeze(nameToVarint)\\nObject.freeze(constantToCode)\\nObject.freeze(codeToName)\\nconst nameToCode = Object.freeze(baseTable)\\nmodule.exports = {\\n  nameToVarint,\\n  constantToCode,\\n  nameToCode,\\n  codeToName\\n}\\n\\n},{\\\"./generated-table\\\":183,\\\"./util\\\":186}],186:[function(require,module,exports){\\n'use strict'\\n\\nconst varint = require('varint')\\nconst uint8ArrayToString = require('uint8arrays/to-string')\\nconst uint8ArrayFromString = require('uint8arrays/from-string')\\n\\nmodule.exports = {\\n  numberToUint8Array,\\n  uint8ArrayToNumber,\\n  varintUint8ArrayEncode,\\n  varintEncode\\n}\\n\\n/**\\n * @param {Uint8Array} buf\\n */\\nfunction uint8ArrayToNumber (buf) {\\n  return parseInt(uint8ArrayToString(buf, 'base16'), 16)\\n}\\n\\n/**\\n * @param {number} num\\n */\\nfunction numberToUint8Array (num) {\\n  let hexString = num.toString(16)\\n  if (hexString.length % 2 === 1) {\\n    hexString = '0' + hexString\\n  }\\n  return uint8ArrayFromString(hexString, 'base16')\\n}\\n\\n/**\\n * @param {Uint8Array} input\\n */\\nfunction varintUint8ArrayEncode (input) {\\n  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))\\n}\\n\\n/**\\n * @param {number} num\\n */\\nfunction varintEncode (num) {\\n  return Uint8Array.from(varint.encode(num))\\n}\\n\\n},{\\\"uint8arrays/from-string\\\":177,\\\"uint8arrays/to-string\\\":178,\\\"varint\\\":181}],187:[function(require,module,exports){\\narguments[4][15][0].apply(exports,arguments)\\n},{\\\"dup\\\":15}],188:[function(require,module,exports){\\narguments[4][177][0].apply(exports,arguments)\\n},{\\\"dup\\\":177,\\\"multibase\\\":173}],189:[function(require,module,exports){\\narguments[4][17][0].apply(exports,arguments)\\n},{\\\"dup\\\":17,\\\"multibase\\\":173}],190:[function(require,module,exports){\\narguments[4][179][0].apply(exports,arguments)\\n},{\\\"dup\\\":179}],191:[function(require,module,exports){\\narguments[4][180][0].apply(exports,arguments)\\n},{\\\"dup\\\":180}],192:[function(require,module,exports){\\narguments[4][181][0].apply(exports,arguments)\\n},{\\\"./decode.js\\\":190,\\\"./encode.js\\\":191,\\\"./length.js\\\":193,\\\"dup\\\":181}],193:[function(require,module,exports){\\narguments[4][182][0].apply(exports,arguments)\\n},{\\\"dup\\\":182}],194:[function(require,module,exports){\\n/* eslint quote-props: off */\\n'use strict'\\n\\n/**\\n * Names for all available hashes\\n *\\n * @typedef { \\\"identity\\\" | \\\"sha1\\\" | \\\"sha2-256\\\" | \\\"sha2-512\\\" | \\\"sha3-512\\\" | \\\"sha3-384\\\" | \\\"sha3-256\\\" | \\\"sha3-224\\\" | \\\"shake-128\\\" | \\\"shake-256\\\" | \\\"keccak-224\\\" | \\\"keccak-256\\\" | \\\"keccak-384\\\" | \\\"keccak-512\\\" | \\\"blake3\\\" | \\\"murmur3-128\\\" | \\\"murmur3-32\\\" | \\\"dbl-sha2-256\\\" | \\\"md4\\\" | \\\"md5\\\" | \\\"bmt\\\" | \\\"sha2-256-trunc254-padded\\\" | \\\"ripemd-128\\\" | \\\"ripemd-160\\\" | \\\"ripemd-256\\\" | \\\"ripemd-320\\\" | \\\"x11\\\" | \\\"kangarootwelve\\\" | \\\"sm3-256\\\" | \\\"blake2b-8\\\" | \\\"blake2b-16\\\" | \\\"blake2b-24\\\" | \\\"blake2b-32\\\" | \\\"blake2b-40\\\" | \\\"blake2b-48\\\" | \\\"blake2b-56\\\" | \\\"blake2b-64\\\" | \\\"blake2b-72\\\" | \\\"blake2b-80\\\" | \\\"blake2b-88\\\" | \\\"blake2b-96\\\" | \\\"blake2b-104\\\" | \\\"blake2b-112\\\" | \\\"blake2b-120\\\" | \\\"blake2b-128\\\" | \\\"blake2b-136\\\" | \\\"blake2b-144\\\" | \\\"blake2b-152\\\" | \\\"blake2b-160\\\" | \\\"blake2b-168\\\" | \\\"blake2b-176\\\" | \\\"blake2b-184\\\" | \\\"blake2b-192\\\" | \\\"blake2b-200\\\" | \\\"blake2b-208\\\" | \\\"blake2b-216\\\" | \\\"blake2b-224\\\" | \\\"blake2b-232\\\" | \\\"blake2b-240\\\" | \\\"blake2b-248\\\" | \\\"blake2b-256\\\" | \\\"blake2b-264\\\" | \\\"blake2b-272\\\" | \\\"blake2b-280\\\" | \\\"blake2b-288\\\" | \\\"blake2b-296\\\" | \\\"blake2b-304\\\" | \\\"blake2b-312\\\" | \\\"blake2b-320\\\" | \\\"blake2b-328\\\" | \\\"blake2b-336\\\" | \\\"blake2b-344\\\" | \\\"blake2b-352\\\" | \\\"blake2b-360\\\" | \\\"blake2b-368\\\" | \\\"blake2b-376\\\" | \\\"blake2b-384\\\" | \\\"blake2b-392\\\" | \\\"blake2b-400\\\" | \\\"blake2b-408\\\" | \\\"blake2b-416\\\" | \\\"blake2b-424\\\" | \\\"blake2b-432\\\" | \\\"blake2b-440\\\" | \\\"blake2b-448\\\" | \\\"blake2b-456\\\" | \\\"blake2b-464\\\" | \\\"blake2b-472\\\" | \\\"blake2b-480\\\" | \\\"blake2b-488\\\" | \\\"blake2b-496\\\" | \\\"blake2b-504\\\" | \\\"blake2b-512\\\" | \\\"blake2s-8\\\" | \\\"blake2s-16\\\" | \\\"blake2s-24\\\" | \\\"blake2s-32\\\" | \\\"blake2s-40\\\" | \\\"blake2s-48\\\" | \\\"blake2s-56\\\" | \\\"blake2s-64\\\" | \\\"blake2s-72\\\" | \\\"blake2s-80\\\" | \\\"blake2s-88\\\" | \\\"blake2s-96\\\" | \\\"blake2s-104\\\" | \\\"blake2s-112\\\" | \\\"blake2s-120\\\" | \\\"blake2s-128\\\" | \\\"blake2s-136\\\" | \\\"blake2s-144\\\" | \\\"blake2s-152\\\" | \\\"blake2s-160\\\" | \\\"blake2s-168\\\" | \\\"blake2s-176\\\" | \\\"blake2s-184\\\" | \\\"blake2s-192\\\" | \\\"blake2s-200\\\" | \\\"blake2s-208\\\" | \\\"blake2s-216\\\" | \\\"blake2s-224\\\" | \\\"blake2s-232\\\" | \\\"blake2s-240\\\" | \\\"blake2s-248\\\" | \\\"blake2s-256\\\" | \\\"skein256-8\\\" | \\\"skein256-16\\\" | \\\"skein256-24\\\" | \\\"skein256-32\\\" | \\\"skein256-40\\\" | \\\"skein256-48\\\" | \\\"skein256-56\\\" | \\\"skein256-64\\\" | \\\"skein256-72\\\" | \\\"skein256-80\\\" | \\\"skein256-88\\\" | \\\"skein256-96\\\" | \\\"skein256-104\\\" | \\\"skein256-112\\\" | \\\"skein256-120\\\" | \\\"skein256-128\\\" | \\\"skein256-136\\\" | \\\"skein256-144\\\" | \\\"skein256-152\\\" | \\\"skein256-160\\\" | \\\"skein256-168\\\" | \\\"skein256-176\\\" | \\\"skein256-184\\\" | \\\"skein256-192\\\" | \\\"skein256-200\\\" | \\\"skein256-208\\\" | \\\"skein256-216\\\" | \\\"skein256-224\\\" | \\\"skein256-232\\\" | \\\"skein256-240\\\" | \\\"skein256-248\\\" | \\\"skein256-256\\\" | \\\"skein512-8\\\" | \\\"skein512-16\\\" | \\\"skein512-24\\\" | \\\"skein512-32\\\" | \\\"skein512-40\\\" | \\\"skein512-48\\\" | \\\"skein512-56\\\" | \\\"skein512-64\\\" | \\\"skein512-72\\\" | \\\"skein512-80\\\" | \\\"skein512-88\\\" | \\\"skein512-96\\\" | \\\"skein512-104\\\" | \\\"skein512-112\\\" | \\\"skein512-120\\\" | \\\"skein512-128\\\" | \\\"skein512-136\\\" | \\\"skein512-144\\\" | \\\"skein512-152\\\" | \\\"skein512-160\\\" | \\\"skein512-168\\\" | \\\"skein512-176\\\" | \\\"skein512-184\\\" | \\\"skein512-192\\\" | \\\"skein512-200\\\" | \\\"skein512-208\\\" | \\\"skein512-216\\\" | \\\"skein512-224\\\" | \\\"skein512-232\\\" | \\\"skein512-240\\\" | \\\"skein512-248\\\" | \\\"skein512-256\\\" | \\\"skein512-264\\\" | \\\"skein512-272\\\" | \\\"skein512-280\\\" | \\\"skein512-288\\\" | \\\"skein512-296\\\" | \\\"skein512-304\\\" | \\\"skein512-312\\\" | \\\"skein512-320\\\" | \\\"skein512-328\\\" | \\\"skein512-336\\\" | \\\"skein512-344\\\" | \\\"skein512-352\\\" | \\\"skein512-360\\\" | \\\"skein512-368\\\" | \\\"skein512-376\\\" | \\\"skein512-384\\\" | \\\"skein512-392\\\" | \\\"skein512-400\\\" | \\\"skein512-408\\\" | \\\"skein512-416\\\" | \\\"skein512-424\\\" | \\\"skein512-432\\\" | \\\"skein512-440\\\" | \\\"skein512-448\\\" | \\\"skein512-456\\\" | \\\"skein512-464\\\" | \\\"skein512-472\\\" | \\\"skein512-480\\\" | \\\"skein512-488\\\" | \\\"skein512-496\\\" | \\\"skein512-504\\\" | \\\"skein512-512\\\" | \\\"skein1024-8\\\" | \\\"skein1024-16\\\" | \\\"skein1024-24\\\" | \\\"skein1024-32\\\" | \\\"skein1024-40\\\" | \\\"skein1024-48\\\" | \\\"skein1024-56\\\" | \\\"skein1024-64\\\" | \\\"skein1024-72\\\" | \\\"skein1024-80\\\" | \\\"skein1024-88\\\" | \\\"skein1024-96\\\" | \\\"skein1024-104\\\" | \\\"skein1024-112\\\" | \\\"skein1024-120\\\" | \\\"skein1024-128\\\" | \\\"skein1024-136\\\" | \\\"skein1024-144\\\" | \\\"skein1024-152\\\" | \\\"skein1024-160\\\" | \\\"skein1024-168\\\" | \\\"skein1024-176\\\" | \\\"skein1024-184\\\" | \\\"skein1024-192\\\" | \\\"skein1024-200\\\" | \\\"skein1024-208\\\" | \\\"skein1024-216\\\" | \\\"skein1024-224\\\" | \\\"skein1024-232\\\" | \\\"skein1024-240\\\" | \\\"skein1024-248\\\" | \\\"skein1024-256\\\" | \\\"skein1024-264\\\" | \\\"skein1024-272\\\" | \\\"skein1024-280\\\" | \\\"skein1024-288\\\" | \\\"skein1024-296\\\" | \\\"skein1024-304\\\" | \\\"skein1024-312\\\" | \\\"skein1024-320\\\" | \\\"skein1024-328\\\" | \\\"skein1024-336\\\" | \\\"skein1024-344\\\" | \\\"skein1024-352\\\" | \\\"skein1024-360\\\" | \\\"skein1024-368\\\" | \\\"skein1024-376\\\" | \\\"skein1024-384\\\" | \\\"skein1024-392\\\" | \\\"skein1024-400\\\" | \\\"skein1024-408\\\" | \\\"skein1024-416\\\" | \\\"skein1024-424\\\" | \\\"skein1024-432\\\" | \\\"skein1024-440\\\" | \\\"skein1024-448\\\" | \\\"skein1024-456\\\" | \\\"skein1024-464\\\" | \\\"skein1024-472\\\" | \\\"skein1024-480\\\" | \\\"skein1024-488\\\" | \\\"skein1024-496\\\" | \\\"skein1024-504\\\" | \\\"skein1024-512\\\" | \\\"skein1024-520\\\" | \\\"skein1024-528\\\" | \\\"skein1024-536\\\" | \\\"skein1024-544\\\" | \\\"skein1024-552\\\" | \\\"skein1024-560\\\" | \\\"skein1024-568\\\" | \\\"skein1024-576\\\" | \\\"skein1024-584\\\" | \\\"skein1024-592\\\" | \\\"skein1024-600\\\" | \\\"skein1024-608\\\" | \\\"skein1024-616\\\" | \\\"skein1024-624\\\" | \\\"skein1024-632\\\" | \\\"skein1024-640\\\" | \\\"skein1024-648\\\" | \\\"skein1024-656\\\" | \\\"skein1024-664\\\" | \\\"skein1024-672\\\" | \\\"skein1024-680\\\" | \\\"skein1024-688\\\" | \\\"skein1024-696\\\" | \\\"skein1024-704\\\" | \\\"skein1024-712\\\" | \\\"skein1024-720\\\" | \\\"skein1024-728\\\" | \\\"skein1024-736\\\" | \\\"skein1024-744\\\" | \\\"skein1024-752\\\" | \\\"skein1024-760\\\" | \\\"skein1024-768\\\" | \\\"skein1024-776\\\" | \\\"skein1024-784\\\" | \\\"skein1024-792\\\" | \\\"skein1024-800\\\" | \\\"skein1024-808\\\" | \\\"skein1024-816\\\" | \\\"skein1024-824\\\" | \\\"skein1024-832\\\" | \\\"skein1024-840\\\" | \\\"skein1024-848\\\" | \\\"skein1024-856\\\" | \\\"skein1024-864\\\" | \\\"skein1024-872\\\" | \\\"skein1024-880\\\" | \\\"skein1024-888\\\" | \\\"skein1024-896\\\" | \\\"skein1024-904\\\" | \\\"skein1024-912\\\" | \\\"skein1024-920\\\" | \\\"skein1024-928\\\" | \\\"skein1024-936\\\" | \\\"skein1024-944\\\" | \\\"skein1024-952\\\" | \\\"skein1024-960\\\" | \\\"skein1024-968\\\" | \\\"skein1024-976\\\" | \\\"skein1024-984\\\" | \\\"skein1024-992\\\" | \\\"skein1024-1000\\\" | \\\"skein1024-1008\\\" | \\\"skein1024-1016\\\" | \\\"skein1024-1024\\\" | \\\"poseidon-bls12_381-a2-fc1\\\" | \\\"poseidon-bls12_381-a2-fc1-sc\\\" } HashName\\n */\\n/**\\n * Codes for all available hashes\\n *\\n * @typedef { 0x00 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x1a | 0x1b | 0x1c | 0x1d | 0x1e | 0x22 | 0x23 | 0x56 | 0xd4 | 0xd5 | 0xd6 | 0x1012 | 0x1052 | 0x1053 | 0x1054 | 0x1055 | 0x1100 | 0x1d01 | 0x534d | 0xb201 | 0xb202 | 0xb203 | 0xb204 | 0xb205 | 0xb206 | 0xb207 | 0xb208 | 0xb209 | 0xb20a | 0xb20b | 0xb20c | 0xb20d | 0xb20e | 0xb20f | 0xb210 | 0xb211 | 0xb212 | 0xb213 | 0xb214 | 0xb215 | 0xb216 | 0xb217 | 0xb218 | 0xb219 | 0xb21a | 0xb21b | 0xb21c | 0xb21d | 0xb21e | 0xb21f | 0xb220 | 0xb221 | 0xb222 | 0xb223 | 0xb224 | 0xb225 | 0xb226 | 0xb227 | 0xb228 | 0xb229 | 0xb22a | 0xb22b | 0xb22c | 0xb22d | 0xb22e | 0xb22f | 0xb230 | 0xb231 | 0xb232 | 0xb233 | 0xb234 | 0xb235 | 0xb236 | 0xb237 | 0xb238 | 0xb239 | 0xb23a | 0xb23b | 0xb23c | 0xb23d | 0xb23e | 0xb23f | 0xb240 | 0xb241 | 0xb242 | 0xb243 | 0xb244 | 0xb245 | 0xb246 | 0xb247 | 0xb248 | 0xb249 | 0xb24a | 0xb24b | 0xb24c | 0xb24d | 0xb24e | 0xb24f | 0xb250 | 0xb251 | 0xb252 | 0xb253 | 0xb254 | 0xb255 | 0xb256 | 0xb257 | 0xb258 | 0xb259 | 0xb25a | 0xb25b | 0xb25c | 0xb25d | 0xb25e | 0xb25f | 0xb260 | 0xb301 | 0xb302 | 0xb303 | 0xb304 | 0xb305 | 0xb306 | 0xb307 | 0xb308 | 0xb309 | 0xb30a | 0xb30b | 0xb30c | 0xb30d | 0xb30e | 0xb30f | 0xb310 | 0xb311 | 0xb312 | 0xb313 | 0xb314 | 0xb315 | 0xb316 | 0xb317 | 0xb318 | 0xb319 | 0xb31a | 0xb31b | 0xb31c | 0xb31d | 0xb31e | 0xb31f | 0xb320 | 0xb321 | 0xb322 | 0xb323 | 0xb324 | 0xb325 | 0xb326 | 0xb327 | 0xb328 | 0xb329 | 0xb32a | 0xb32b | 0xb32c | 0xb32d | 0xb32e | 0xb32f | 0xb330 | 0xb331 | 0xb332 | 0xb333 | 0xb334 | 0xb335 | 0xb336 | 0xb337 | 0xb338 | 0xb339 | 0xb33a | 0xb33b | 0xb33c | 0xb33d | 0xb33e | 0xb33f | 0xb340 | 0xb341 | 0xb342 | 0xb343 | 0xb344 | 0xb345 | 0xb346 | 0xb347 | 0xb348 | 0xb349 | 0xb34a | 0xb34b | 0xb34c | 0xb34d | 0xb34e | 0xb34f | 0xb350 | 0xb351 | 0xb352 | 0xb353 | 0xb354 | 0xb355 | 0xb356 | 0xb357 | 0xb358 | 0xb359 | 0xb35a | 0xb35b | 0xb35c | 0xb35d | 0xb35e | 0xb35f | 0xb360 | 0xb361 | 0xb362 | 0xb363 | 0xb364 | 0xb365 | 0xb366 | 0xb367 | 0xb368 | 0xb369 | 0xb36a | 0xb36b | 0xb36c | 0xb36d | 0xb36e | 0xb36f | 0xb370 | 0xb371 | 0xb372 | 0xb373 | 0xb374 | 0xb375 | 0xb376 | 0xb377 | 0xb378 | 0xb379 | 0xb37a | 0xb37b | 0xb37c | 0xb37d | 0xb37e | 0xb37f | 0xb380 | 0xb381 | 0xb382 | 0xb383 | 0xb384 | 0xb385 | 0xb386 | 0xb387 | 0xb388 | 0xb389 | 0xb38a | 0xb38b | 0xb38c | 0xb38d | 0xb38e | 0xb38f | 0xb390 | 0xb391 | 0xb392 | 0xb393 | 0xb394 | 0xb395 | 0xb396 | 0xb397 | 0xb398 | 0xb399 | 0xb39a | 0xb39b | 0xb39c | 0xb39d | 0xb39e | 0xb39f | 0xb3a0 | 0xb3a1 | 0xb3a2 | 0xb3a3 | 0xb3a4 | 0xb3a5 | 0xb3a6 | 0xb3a7 | 0xb3a8 | 0xb3a9 | 0xb3aa | 0xb3ab | 0xb3ac | 0xb3ad | 0xb3ae | 0xb3af | 0xb3b0 | 0xb3b1 | 0xb3b2 | 0xb3b3 | 0xb3b4 | 0xb3b5 | 0xb3b6 | 0xb3b7 | 0xb3b8 | 0xb3b9 | 0xb3ba | 0xb3bb | 0xb3bc | 0xb3bd | 0xb3be | 0xb3bf | 0xb3c0 | 0xb3c1 | 0xb3c2 | 0xb3c3 | 0xb3c4 | 0xb3c5 | 0xb3c6 | 0xb3c7 | 0xb3c8 | 0xb3c9 | 0xb3ca | 0xb3cb | 0xb3cc | 0xb3cd | 0xb3ce | 0xb3cf | 0xb3d0 | 0xb3d1 | 0xb3d2 | 0xb3d3 | 0xb3d4 | 0xb3d5 | 0xb3d6 | 0xb3d7 | 0xb3d8 | 0xb3d9 | 0xb3da | 0xb3db | 0xb3dc | 0xb3dd | 0xb3de | 0xb3df | 0xb3e0 | 0xb401 | 0xb402 } HashCode\\n */\\n\\n/**\\n * @type { Record<HashName,HashCode> }\\n */\\nconst names = Object.freeze({\\n  'identity': 0x00,\\n  'sha1': 0x11,\\n  'sha2-256': 0x12,\\n  'sha2-512': 0x13,\\n  'sha3-512': 0x14,\\n  'sha3-384': 0x15,\\n  'sha3-256': 0x16,\\n  'sha3-224': 0x17,\\n  'shake-128': 0x18,\\n  'shake-256': 0x19,\\n  'keccak-224': 0x1a,\\n  'keccak-256': 0x1b,\\n  'keccak-384': 0x1c,\\n  'keccak-512': 0x1d,\\n  'blake3': 0x1e,\\n  'murmur3-128': 0x22,\\n  'murmur3-32': 0x23,\\n  'dbl-sha2-256': 0x56,\\n  'md4': 0xd4,\\n  'md5': 0xd5,\\n  'bmt': 0xd6,\\n  'sha2-256-trunc254-padded': 0x1012,\\n  'ripemd-128': 0x1052,\\n  'ripemd-160': 0x1053,\\n  'ripemd-256': 0x1054,\\n  'ripemd-320': 0x1055,\\n  'x11': 0x1100,\\n  'kangarootwelve': 0x1d01,\\n  'sm3-256': 0x534d,\\n  'blake2b-8': 0xb201,\\n  'blake2b-16': 0xb202,\\n  'blake2b-24': 0xb203,\\n  'blake2b-32': 0xb204,\\n  'blake2b-40': 0xb205,\\n  'blake2b-48': 0xb206,\\n  'blake2b-56': 0xb207,\\n  'blake2b-64': 0xb208,\\n  'blake2b-72': 0xb209,\\n  'blake2b-80': 0xb20a,\\n  'blake2b-88': 0xb20b,\\n  'blake2b-96': 0xb20c,\\n  'blake2b-104': 0xb20d,\\n  'blake2b-112': 0xb20e,\\n  'blake2b-120': 0xb20f,\\n  'blake2b-128': 0xb210,\\n  'blake2b-136': 0xb211,\\n  'blake2b-144': 0xb212,\\n  'blake2b-152': 0xb213,\\n  'blake2b-160': 0xb214,\\n  'blake2b-168': 0xb215,\\n  'blake2b-176': 0xb216,\\n  'blake2b-184': 0xb217,\\n  'blake2b-192': 0xb218,\\n  'blake2b-200': 0xb219,\\n  'blake2b-208': 0xb21a,\\n  'blake2b-216': 0xb21b,\\n  'blake2b-224': 0xb21c,\\n  'blake2b-232': 0xb21d,\\n  'blake2b-240': 0xb21e,\\n  'blake2b-248': 0xb21f,\\n  'blake2b-256': 0xb220,\\n  'blake2b-264': 0xb221,\\n  'blake2b-272': 0xb222,\\n  'blake2b-280': 0xb223,\\n  'blake2b-288': 0xb224,\\n  'blake2b-296': 0xb225,\\n  'blake2b-304': 0xb226,\\n  'blake2b-312': 0xb227,\\n  'blake2b-320': 0xb228,\\n  'blake2b-328': 0xb229,\\n  'blake2b-336': 0xb22a,\\n  'blake2b-344': 0xb22b,\\n  'blake2b-352': 0xb22c,\\n  'blake2b-360': 0xb22d,\\n  'blake2b-368': 0xb22e,\\n  'blake2b-376': 0xb22f,\\n  'blake2b-384': 0xb230,\\n  'blake2b-392': 0xb231,\\n  'blake2b-400': 0xb232,\\n  'blake2b-408': 0xb233,\\n  'blake2b-416': 0xb234,\\n  'blake2b-424': 0xb235,\\n  'blake2b-432': 0xb236,\\n  'blake2b-440': 0xb237,\\n  'blake2b-448': 0xb238,\\n  'blake2b-456': 0xb239,\\n  'blake2b-464': 0xb23a,\\n  'blake2b-472': 0xb23b,\\n  'blake2b-480': 0xb23c,\\n  'blake2b-488': 0xb23d,\\n  'blake2b-496': 0xb23e,\\n  'blake2b-504': 0xb23f,\\n  'blake2b-512': 0xb240,\\n  'blake2s-8': 0xb241,\\n  'blake2s-16': 0xb242,\\n  'blake2s-24': 0xb243,\\n  'blake2s-32': 0xb244,\\n  'blake2s-40': 0xb245,\\n  'blake2s-48': 0xb246,\\n  'blake2s-56': 0xb247,\\n  'blake2s-64': 0xb248,\\n  'blake2s-72': 0xb249,\\n  'blake2s-80': 0xb24a,\\n  'blake2s-88': 0xb24b,\\n  'blake2s-96': 0xb24c,\\n  'blake2s-104': 0xb24d,\\n  'blake2s-112': 0xb24e,\\n  'blake2s-120': 0xb24f,\\n  'blake2s-128': 0xb250,\\n  'blake2s-136': 0xb251,\\n  'blake2s-144': 0xb252,\\n  'blake2s-152': 0xb253,\\n  'blake2s-160': 0xb254,\\n  'blake2s-168': 0xb255,\\n  'blake2s-176': 0xb256,\\n  'blake2s-184': 0xb257,\\n  'blake2s-192': 0xb258,\\n  'blake2s-200': 0xb259,\\n  'blake2s-208': 0xb25a,\\n  'blake2s-216': 0xb25b,\\n  'blake2s-224': 0xb25c,\\n  'blake2s-232': 0xb25d,\\n  'blake2s-240': 0xb25e,\\n  'blake2s-248': 0xb25f,\\n  'blake2s-256': 0xb260,\\n  'skein256-8': 0xb301,\\n  'skein256-16': 0xb302,\\n  'skein256-24': 0xb303,\\n  'skein256-32': 0xb304,\\n  'skein256-40': 0xb305,\\n  'skein256-48': 0xb306,\\n  'skein256-56': 0xb307,\\n  'skein256-64': 0xb308,\\n  'skein256-72': 0xb309,\\n  'skein256-80': 0xb30a,\\n  'skein256-88': 0xb30b,\\n  'skein256-96': 0xb30c,\\n  'skein256-104': 0xb30d,\\n  'skein256-112': 0xb30e,\\n  'skein256-120': 0xb30f,\\n  'skein256-128': 0xb310,\\n  'skein256-136': 0xb311,\\n  'skein256-144': 0xb312,\\n  'skein256-152': 0xb313,\\n  'skein256-160': 0xb314,\\n  'skein256-168': 0xb315,\\n  'skein256-176': 0xb316,\\n  'skein256-184': 0xb317,\\n  'skein256-192': 0xb318,\\n  'skein256-200': 0xb319,\\n  'skein256-208': 0xb31a,\\n  'skein256-216': 0xb31b,\\n  'skein256-224': 0xb31c,\\n  'skein256-232': 0xb31d,\\n  'skein256-240': 0xb31e,\\n  'skein256-248': 0xb31f,\\n  'skein256-256': 0xb320,\\n  'skein512-8': 0xb321,\\n  'skein512-16': 0xb322,\\n  'skein512-24': 0xb323,\\n  'skein512-32': 0xb324,\\n  'skein512-40': 0xb325,\\n  'skein512-48': 0xb326,\\n  'skein512-56': 0xb327,\\n  'skein512-64': 0xb328,\\n  'skein512-72': 0xb329,\\n  'skein512-80': 0xb32a,\\n  'skein512-88': 0xb32b,\\n  'skein512-96': 0xb32c,\\n  'skein512-104': 0xb32d,\\n  'skein512-112': 0xb32e,\\n  'skein512-120': 0xb32f,\\n  'skein512-128': 0xb330,\\n  'skein512-136': 0xb331,\\n  'skein512-144': 0xb332,\\n  'skein512-152': 0xb333,\\n  'skein512-160': 0xb334,\\n  'skein512-168': 0xb335,\\n  'skein512-176': 0xb336,\\n  'skein512-184': 0xb337,\\n  'skein512-192': 0xb338,\\n  'skein512-200': 0xb339,\\n  'skein512-208': 0xb33a,\\n  'skein512-216': 0xb33b,\\n  'skein512-224': 0xb33c,\\n  'skein512-232': 0xb33d,\\n  'skein512-240': 0xb33e,\\n  'skein512-248': 0xb33f,\\n  'skein512-256': 0xb340,\\n  'skein512-264': 0xb341,\\n  'skein512-272': 0xb342,\\n  'skein512-280': 0xb343,\\n  'skein512-288': 0xb344,\\n  'skein512-296': 0xb345,\\n  'skein512-304': 0xb346,\\n  'skein512-312': 0xb347,\\n  'skein512-320': 0xb348,\\n  'skein512-328': 0xb349,\\n  'skein512-336': 0xb34a,\\n  'skein512-344': 0xb34b,\\n  'skein512-352': 0xb34c,\\n  'skein512-360': 0xb34d,\\n  'skein512-368': 0xb34e,\\n  'skein512-376': 0xb34f,\\n  'skein512-384': 0xb350,\\n  'skein512-392': 0xb351,\\n  'skein512-400': 0xb352,\\n  'skein512-408': 0xb353,\\n  'skein512-416': 0xb354,\\n  'skein512-424': 0xb355,\\n  'skein512-432': 0xb356,\\n  'skein512-440': 0xb357,\\n  'skein512-448': 0xb358,\\n  'skein512-456': 0xb359,\\n  'skein512-464': 0xb35a,\\n  'skein512-472': 0xb35b,\\n  'skein512-480': 0xb35c,\\n  'skein512-488': 0xb35d,\\n  'skein512-496': 0xb35e,\\n  'skein512-504': 0xb35f,\\n  'skein512-512': 0xb360,\\n  'skein1024-8': 0xb361,\\n  'skein1024-16': 0xb362,\\n  'skein1024-24': 0xb363,\\n  'skein1024-32': 0xb364,\\n  'skein1024-40': 0xb365,\\n  'skein1024-48': 0xb366,\\n  'skein1024-56': 0xb367,\\n  'skein1024-64': 0xb368,\\n  'skein1024-72': 0xb369,\\n  'skein1024-80': 0xb36a,\\n  'skein1024-88': 0xb36b,\\n  'skein1024-96': 0xb36c,\\n  'skein1024-104': 0xb36d,\\n  'skein1024-112': 0xb36e,\\n  'skein1024-120': 0xb36f,\\n  'skein1024-128': 0xb370,\\n  'skein1024-136': 0xb371,\\n  'skein1024-144': 0xb372,\\n  'skein1024-152': 0xb373,\\n  'skein1024-160': 0xb374,\\n  'skein1024-168': 0xb375,\\n  'skein1024-176': 0xb376,\\n  'skein1024-184': 0xb377,\\n  'skein1024-192': 0xb378,\\n  'skein1024-200': 0xb379,\\n  'skein1024-208': 0xb37a,\\n  'skein1024-216': 0xb37b,\\n  'skein1024-224': 0xb37c,\\n  'skein1024-232': 0xb37d,\\n  'skein1024-240': 0xb37e,\\n  'skein1024-248': 0xb37f,\\n  'skein1024-256': 0xb380,\\n  'skein1024-264': 0xb381,\\n  'skein1024-272': 0xb382,\\n  'skein1024-280': 0xb383,\\n  'skein1024-288': 0xb384,\\n  'skein1024-296': 0xb385,\\n  'skein1024-304': 0xb386,\\n  'skein1024-312': 0xb387,\\n  'skein1024-320': 0xb388,\\n  'skein1024-328': 0xb389,\\n  'skein1024-336': 0xb38a,\\n  'skein1024-344': 0xb38b,\\n  'skein1024-352': 0xb38c,\\n  'skein1024-360': 0xb38d,\\n  'skein1024-368': 0xb38e,\\n  'skein1024-376': 0xb38f,\\n  'skein1024-384': 0xb390,\\n  'skein1024-392': 0xb391,\\n  'skein1024-400': 0xb392,\\n  'skein1024-408': 0xb393,\\n  'skein1024-416': 0xb394,\\n  'skein1024-424': 0xb395,\\n  'skein1024-432': 0xb396,\\n  'skein1024-440': 0xb397,\\n  'skein1024-448': 0xb398,\\n  'skein1024-456': 0xb399,\\n  'skein1024-464': 0xb39a,\\n  'skein1024-472': 0xb39b,\\n  'skein1024-480': 0xb39c,\\n  'skein1024-488': 0xb39d,\\n  'skein1024-496': 0xb39e,\\n  'skein1024-504': 0xb39f,\\n  'skein1024-512': 0xb3a0,\\n  'skein1024-520': 0xb3a1,\\n  'skein1024-528': 0xb3a2,\\n  'skein1024-536': 0xb3a3,\\n  'skein1024-544': 0xb3a4,\\n  'skein1024-552': 0xb3a5,\\n  'skein1024-560': 0xb3a6,\\n  'skein1024-568': 0xb3a7,\\n  'skein1024-576': 0xb3a8,\\n  'skein1024-584': 0xb3a9,\\n  'skein1024-592': 0xb3aa,\\n  'skein1024-600': 0xb3ab,\\n  'skein1024-608': 0xb3ac,\\n  'skein1024-616': 0xb3ad,\\n  'skein1024-624': 0xb3ae,\\n  'skein1024-632': 0xb3af,\\n  'skein1024-640': 0xb3b0,\\n  'skein1024-648': 0xb3b1,\\n  'skein1024-656': 0xb3b2,\\n  'skein1024-664': 0xb3b3,\\n  'skein1024-672': 0xb3b4,\\n  'skein1024-680': 0xb3b5,\\n  'skein1024-688': 0xb3b6,\\n  'skein1024-696': 0xb3b7,\\n  'skein1024-704': 0xb3b8,\\n  'skein1024-712': 0xb3b9,\\n  'skein1024-720': 0xb3ba,\\n  'skein1024-728': 0xb3bb,\\n  'skein1024-736': 0xb3bc,\\n  'skein1024-744': 0xb3bd,\\n  'skein1024-752': 0xb3be,\\n  'skein1024-760': 0xb3bf,\\n  'skein1024-768': 0xb3c0,\\n  'skein1024-776': 0xb3c1,\\n  'skein1024-784': 0xb3c2,\\n  'skein1024-792': 0xb3c3,\\n  'skein1024-800': 0xb3c4,\\n  'skein1024-808': 0xb3c5,\\n  'skein1024-816': 0xb3c6,\\n  'skein1024-824': 0xb3c7,\\n  'skein1024-832': 0xb3c8,\\n  'skein1024-840': 0xb3c9,\\n  'skein1024-848': 0xb3ca,\\n  'skein1024-856': 0xb3cb,\\n  'skein1024-864': 0xb3cc,\\n  'skein1024-872': 0xb3cd,\\n  'skein1024-880': 0xb3ce,\\n  'skein1024-888': 0xb3cf,\\n  'skein1024-896': 0xb3d0,\\n  'skein1024-904': 0xb3d1,\\n  'skein1024-912': 0xb3d2,\\n  'skein1024-920': 0xb3d3,\\n  'skein1024-928': 0xb3d4,\\n  'skein1024-936': 0xb3d5,\\n  'skein1024-944': 0xb3d6,\\n  'skein1024-952': 0xb3d7,\\n  'skein1024-960': 0xb3d8,\\n  'skein1024-968': 0xb3d9,\\n  'skein1024-976': 0xb3da,\\n  'skein1024-984': 0xb3db,\\n  'skein1024-992': 0xb3dc,\\n  'skein1024-1000': 0xb3dd,\\n  'skein1024-1008': 0xb3de,\\n  'skein1024-1016': 0xb3df,\\n  'skein1024-1024': 0xb3e0,\\n  'poseidon-bls12_381-a2-fc1': 0xb401,\\n  'poseidon-bls12_381-a2-fc1-sc': 0xb402\\n})\\n\\nmodule.exports = { names }\\n\\n},{}],195:[function(require,module,exports){\\n/**\\n * Multihash implementation in JavaScript.\\n */\\n'use strict'\\n\\nconst multibase = require('multibase')\\nconst varint = require('varint')\\nconst { names } = require('./constants')\\nconst uint8ArrayToString = require('uint8arrays/to-string')\\nconst uint8ArrayFromString = require('uint8arrays/from-string')\\nconst uint8ArrayConcat = require('uint8arrays/concat')\\n\\nconst codes = /** @type {import('./types').CodeNameMap} */({})\\n\\n// eslint-disable-next-line guard-for-in\\nfor (const key in names) {\\n  const name = /** @type {HashName} */(key)\\n  codes[names[name]] = name\\n}\\nObject.freeze(codes)\\n\\n/**\\n * Convert the given multihash to a hex encoded string.\\n *\\n * @param {Uint8Array} hash\\n * @returns {string}\\n */\\nfunction toHexString (hash) {\\n  if (!(hash instanceof Uint8Array)) {\\n    throw new Error('must be passed a Uint8Array')\\n  }\\n\\n  return uint8ArrayToString(hash, 'base16')\\n}\\n\\n/**\\n * Convert the given hex encoded string to a multihash.\\n *\\n * @param {string} hash\\n * @returns {Uint8Array}\\n */\\nfunction fromHexString (hash) {\\n  return uint8ArrayFromString(hash, 'base16')\\n}\\n\\n/**\\n * Convert the given multihash to a base58 encoded string.\\n *\\n * @param {Uint8Array} hash\\n * @returns {string}\\n */\\nfunction toB58String (hash) {\\n  if (!(hash instanceof Uint8Array)) {\\n    throw new Error('must be passed a Uint8Array')\\n  }\\n\\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\\n}\\n\\n/**\\n * Convert the given base58 encoded string to a multihash.\\n *\\n * @param {string|Uint8Array} hash\\n * @returns {Uint8Array}\\n */\\nfunction fromB58String (hash) {\\n  const encoded = hash instanceof Uint8Array\\n    ? uint8ArrayToString(hash)\\n    : hash\\n\\n  return multibase.decode('z' + encoded)\\n}\\n\\n/**\\n * Decode a hash from the given multihash.\\n *\\n * @param {Uint8Array} bytes\\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\\n */\\nfunction decode (bytes) {\\n  if (!(bytes instanceof Uint8Array)) {\\n    throw new Error('multihash must be a Uint8Array')\\n  }\\n\\n  if (bytes.length < 2) {\\n    throw new Error('multihash too short. must be > 2 bytes.')\\n  }\\n\\n  const code = /** @type {HashCode} */(varint.decode(bytes))\\n  if (!isValidCode(code)) {\\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\\n  }\\n  bytes = bytes.slice(varint.decode.bytes)\\n\\n  const len = varint.decode(bytes)\\n  if (len < 0) {\\n    throw new Error(`multihash invalid length: ${len}`)\\n  }\\n  bytes = bytes.slice(varint.decode.bytes)\\n\\n  if (bytes.length !== len) {\\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\\n  }\\n\\n  return {\\n    code,\\n    name: codes[code],\\n    length: len,\\n    digest: bytes\\n  }\\n}\\n\\n/**\\n * Encode a hash digest along with the specified function code.\\n *\\n * > **Note:** the length is derived from the length of the digest itself.\\n *\\n * @param {Uint8Array} digest\\n * @param {HashName | HashCode} code\\n * @param {number} [length]\\n * @returns {Uint8Array}\\n */\\nfunction encode (digest, code, length) {\\n  if (!digest || code === undefined) {\\n    throw new Error('multihash encode requires at least two args: digest, code')\\n  }\\n\\n  // ensure it's a hashfunction code.\\n  const hashfn = coerceCode(code)\\n\\n  if (!(digest instanceof Uint8Array)) {\\n    throw new Error('digest should be a Uint8Array')\\n  }\\n\\n  if (length == null) {\\n    length = digest.length\\n  }\\n\\n  if (length && digest.length !== length) {\\n    throw new Error('digest length should be equal to specified length.')\\n  }\\n\\n  const hash = varint.encode(hashfn)\\n  const len = varint.encode(length)\\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\\n}\\n\\n/**\\n * Converts a hash function name into the matching code.\\n * If passed a number it will return the number if it's a valid code.\\n *\\n * @param {HashName | number} name\\n * @returns {number}\\n */\\nfunction coerceCode (name) {\\n  let code = name\\n\\n  if (typeof name === 'string') {\\n    if (names[name] === undefined) {\\n      throw new Error(`Unrecognized hash function named: ${name}`)\\n    }\\n    code = names[name]\\n  }\\n\\n  if (typeof code !== 'number') {\\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\\n  }\\n\\n  // @ts-ignore\\n  if (codes[code] === undefined && !isAppCode(code)) {\\n    throw new Error(`Unrecognized function code: ${code}`)\\n  }\\n\\n  return code\\n}\\n\\n/**\\n * Checks if a code is part of the app range\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\nfunction isAppCode (code) {\\n  return code > 0 && code < 0x10\\n}\\n\\n/**\\n * Checks whether a multihash code is valid.\\n *\\n * @param {HashCode} code\\n * @returns {boolean}\\n */\\nfunction isValidCode (code) {\\n  if (isAppCode(code)) {\\n    return true\\n  }\\n\\n  if (codes[code]) {\\n    return true\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Uint8Array} multihash\\n * @returns {void}\\n * @throws {Error}\\n */\\nfunction validate (multihash) {\\n  decode(multihash) // throws if bad.\\n}\\n\\n/**\\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Uint8Array} multihash\\n * @returns {Uint8Array}\\n * @throws {Error}\\n */\\nfunction prefix (multihash) {\\n  validate(multihash)\\n\\n  return multihash.subarray(0, 2)\\n}\\n\\nmodule.exports = {\\n  names,\\n  codes,\\n  toHexString,\\n  fromHexString,\\n  toB58String,\\n  fromB58String,\\n  decode,\\n  encode,\\n  coerceCode,\\n  isAppCode,\\n  validate,\\n  prefix,\\n  isValidCode\\n}\\n\\n/**\\n * @typedef { import(\\\"./constants\\\").HashCode } HashCode\\n * @typedef { import(\\\"./constants\\\").HashName } HashName\\n */\\n\\n},{\\\"./constants\\\":194,\\\"multibase\\\":173,\\\"uint8arrays/concat\\\":187,\\\"uint8arrays/from-string\\\":188,\\\"uint8arrays/to-string\\\":189,\\\"varint\\\":192}],196:[function(require,module,exports){\\n(function (process){(function (){\\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\\n// transplited with Babel\\n\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\nfunction assertPath(path) {\\n  if (typeof path !== 'string') {\\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\\n  }\\n}\\n\\n// Resolves . and .. elements in a path with directory names\\nfunction normalizeStringPosix(path, allowAboveRoot) {\\n  var res = '';\\n  var lastSegmentLength = 0;\\n  var lastSlash = -1;\\n  var dots = 0;\\n  var code;\\n  for (var i = 0; i <= path.length; ++i) {\\n    if (i < path.length)\\n      code = path.charCodeAt(i);\\n    else if (code === 47 /*/*/)\\n      break;\\n    else\\n      code = 47 /*/*/;\\n    if (code === 47 /*/*/) {\\n      if (lastSlash === i - 1 || dots === 1) {\\n        // NOOP\\n      } else if (lastSlash !== i - 1 && dots === 2) {\\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\\n          if (res.length > 2) {\\n            var lastSlashIndex = res.lastIndexOf('/');\\n            if (lastSlashIndex !== res.length - 1) {\\n              if (lastSlashIndex === -1) {\\n                res = '';\\n                lastSegmentLength = 0;\\n              } else {\\n                res = res.slice(0, lastSlashIndex);\\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\\n              }\\n              lastSlash = i;\\n              dots = 0;\\n              continue;\\n            }\\n          } else if (res.length === 2 || res.length === 1) {\\n            res = '';\\n            lastSegmentLength = 0;\\n            lastSlash = i;\\n            dots = 0;\\n            continue;\\n          }\\n        }\\n        if (allowAboveRoot) {\\n          if (res.length > 0)\\n            res += '/..';\\n          else\\n            res = '..';\\n          lastSegmentLength = 2;\\n        }\\n      } else {\\n        if (res.length > 0)\\n          res += '/' + path.slice(lastSlash + 1, i);\\n        else\\n          res = path.slice(lastSlash + 1, i);\\n        lastSegmentLength = i - lastSlash - 1;\\n      }\\n      lastSlash = i;\\n      dots = 0;\\n    } else if (code === 46 /*.*/ && dots !== -1) {\\n      ++dots;\\n    } else {\\n      dots = -1;\\n    }\\n  }\\n  return res;\\n}\\n\\nfunction _format(sep, pathObject) {\\n  var dir = pathObject.dir || pathObject.root;\\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\\n  if (!dir) {\\n    return base;\\n  }\\n  if (dir === pathObject.root) {\\n    return dir + base;\\n  }\\n  return dir + sep + base;\\n}\\n\\nvar posix = {\\n  // path.resolve([from ...], to)\\n  resolve: function resolve() {\\n    var resolvedPath = '';\\n    var resolvedAbsolute = false;\\n    var cwd;\\n\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path;\\n      if (i >= 0)\\n        path = arguments[i];\\n      else {\\n        if (cwd === undefined)\\n          cwd = process.cwd();\\n        path = cwd;\\n      }\\n\\n      assertPath(path);\\n\\n      // Skip empty entries\\n      if (path.length === 0) {\\n        continue;\\n      }\\n\\n      resolvedPath = path + '/' + resolvedPath;\\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path, but\\n    // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n    // Normalize the path\\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\\n\\n    if (resolvedAbsolute) {\\n      if (resolvedPath.length > 0)\\n        return '/' + resolvedPath;\\n      else\\n        return '/';\\n    } else if (resolvedPath.length > 0) {\\n      return resolvedPath;\\n    } else {\\n      return '.';\\n    }\\n  },\\n\\n  normalize: function normalize(path) {\\n    assertPath(path);\\n\\n    if (path.length === 0) return '.';\\n\\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\\n\\n    // Normalize the path\\n    path = normalizeStringPosix(path, !isAbsolute);\\n\\n    if (path.length === 0 && !isAbsolute) path = '.';\\n    if (path.length > 0 && trailingSeparator) path += '/';\\n\\n    if (isAbsolute) return '/' + path;\\n    return path;\\n  },\\n\\n  isAbsolute: function isAbsolute(path) {\\n    assertPath(path);\\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\\n  },\\n\\n  join: function join() {\\n    if (arguments.length === 0)\\n      return '.';\\n    var joined;\\n    for (var i = 0; i < arguments.length; ++i) {\\n      var arg = arguments[i];\\n      assertPath(arg);\\n      if (arg.length > 0) {\\n        if (joined === undefined)\\n          joined = arg;\\n        else\\n          joined += '/' + arg;\\n      }\\n    }\\n    if (joined === undefined)\\n      return '.';\\n    return posix.normalize(joined);\\n  },\\n\\n  relative: function relative(from, to) {\\n    assertPath(from);\\n    assertPath(to);\\n\\n    if (from === to) return '';\\n\\n    from = posix.resolve(from);\\n    to = posix.resolve(to);\\n\\n    if (from === to) return '';\\n\\n    // Trim any leading backslashes\\n    var fromStart = 1;\\n    for (; fromStart < from.length; ++fromStart) {\\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\\n        break;\\n    }\\n    var fromEnd = from.length;\\n    var fromLen = fromEnd - fromStart;\\n\\n    // Trim any leading backslashes\\n    var toStart = 1;\\n    for (; toStart < to.length; ++toStart) {\\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\\n        break;\\n    }\\n    var toEnd = to.length;\\n    var toLen = toEnd - toStart;\\n\\n    // Compare paths to find the longest common path from root\\n    var length = fromLen < toLen ? fromLen : toLen;\\n    var lastCommonSep = -1;\\n    var i = 0;\\n    for (; i <= length; ++i) {\\n      if (i === length) {\\n        if (toLen > length) {\\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\\n            // We get here if `from` is the exact base path for `to`.\\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\\n            return to.slice(toStart + i + 1);\\n          } else if (i === 0) {\\n            // We get here if `from` is the root\\n            // For example: from='/'; to='/foo'\\n            return to.slice(toStart + i);\\n          }\\n        } else if (fromLen > length) {\\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\\n            // We get here if `to` is the exact base path for `from`.\\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\\n            lastCommonSep = i;\\n          } else if (i === 0) {\\n            // We get here if `to` is the root.\\n            // For example: from='/foo'; to='/'\\n            lastCommonSep = 0;\\n          }\\n        }\\n        break;\\n      }\\n      var fromCode = from.charCodeAt(fromStart + i);\\n      var toCode = to.charCodeAt(toStart + i);\\n      if (fromCode !== toCode)\\n        break;\\n      else if (fromCode === 47 /*/*/)\\n        lastCommonSep = i;\\n    }\\n\\n    var out = '';\\n    // Generate the relative path based on the path difference between `to`\\n    // and `from`\\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\\n        if (out.length === 0)\\n          out += '..';\\n        else\\n          out += '/..';\\n      }\\n    }\\n\\n    // Lastly, append the rest of the destination (`to`) path that comes after\\n    // the common path parts\\n    if (out.length > 0)\\n      return out + to.slice(toStart + lastCommonSep);\\n    else {\\n      toStart += lastCommonSep;\\n      if (to.charCodeAt(toStart) === 47 /*/*/)\\n        ++toStart;\\n      return to.slice(toStart);\\n    }\\n  },\\n\\n  _makeLong: function _makeLong(path) {\\n    return path;\\n  },\\n\\n  dirname: function dirname(path) {\\n    assertPath(path);\\n    if (path.length === 0) return '.';\\n    var code = path.charCodeAt(0);\\n    var hasRoot = code === 47 /*/*/;\\n    var end = -1;\\n    var matchedSlash = true;\\n    for (var i = path.length - 1; i >= 1; --i) {\\n      code = path.charCodeAt(i);\\n      if (code === 47 /*/*/) {\\n          if (!matchedSlash) {\\n            end = i;\\n            break;\\n          }\\n        } else {\\n        // We saw the first non-path separator\\n        matchedSlash = false;\\n      }\\n    }\\n\\n    if (end === -1) return hasRoot ? '/' : '.';\\n    if (hasRoot && end === 1) return '//';\\n    return path.slice(0, end);\\n  },\\n\\n  basename: function basename(path, ext) {\\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\\\"ext\\\" argument must be a string');\\n    assertPath(path);\\n\\n    var start = 0;\\n    var end = -1;\\n    var matchedSlash = true;\\n    var i;\\n\\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\\n      if (ext.length === path.length && ext === path) return '';\\n      var extIdx = ext.length - 1;\\n      var firstNonSlashEnd = -1;\\n      for (i = path.length - 1; i >= 0; --i) {\\n        var code = path.charCodeAt(i);\\n        if (code === 47 /*/*/) {\\n            // If we reached a path separator that was not part of a set of path\\n            // separators at the end of the string, stop now\\n            if (!matchedSlash) {\\n              start = i + 1;\\n              break;\\n            }\\n          } else {\\n          if (firstNonSlashEnd === -1) {\\n            // We saw the first non-path separator, remember this index in case\\n            // we need it if the extension ends up not matching\\n            matchedSlash = false;\\n            firstNonSlashEnd = i + 1;\\n          }\\n          if (extIdx >= 0) {\\n            // Try to match the explicit extension\\n            if (code === ext.charCodeAt(extIdx)) {\\n              if (--extIdx === -1) {\\n                // We matched the extension, so mark this as the end of our path\\n                // component\\n                end = i;\\n              }\\n            } else {\\n              // Extension does not match, so our result is the entire path\\n              // component\\n              extIdx = -1;\\n              end = firstNonSlashEnd;\\n            }\\n          }\\n        }\\n      }\\n\\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\\n      return path.slice(start, end);\\n    } else {\\n      for (i = path.length - 1; i >= 0; --i) {\\n        if (path.charCodeAt(i) === 47 /*/*/) {\\n            // If we reached a path separator that was not part of a set of path\\n            // separators at the end of the string, stop now\\n            if (!matchedSlash) {\\n              start = i + 1;\\n              break;\\n            }\\n          } else if (end === -1) {\\n          // We saw the first non-path separator, mark this as the end of our\\n          // path component\\n          matchedSlash = false;\\n          end = i + 1;\\n        }\\n      }\\n\\n      if (end === -1) return '';\\n      return path.slice(start, end);\\n    }\\n  },\\n\\n  extname: function extname(path) {\\n    assertPath(path);\\n    var startDot = -1;\\n    var startPart = 0;\\n    var end = -1;\\n    var matchedSlash = true;\\n    // Track the state of characters (if any) we see before our first dot and\\n    // after any path separator we find\\n    var preDotState = 0;\\n    for (var i = path.length - 1; i >= 0; --i) {\\n      var code = path.charCodeAt(i);\\n      if (code === 47 /*/*/) {\\n          // If we reached a path separator that was not part of a set of path\\n          // separators at the end of the string, stop now\\n          if (!matchedSlash) {\\n            startPart = i + 1;\\n            break;\\n          }\\n          continue;\\n        }\\n      if (end === -1) {\\n        // We saw the first non-path separator, mark this as the end of our\\n        // extension\\n        matchedSlash = false;\\n        end = i + 1;\\n      }\\n      if (code === 46 /*.*/) {\\n          // If this is our first dot, mark it as the start of our extension\\n          if (startDot === -1)\\n            startDot = i;\\n          else if (preDotState !== 1)\\n            preDotState = 1;\\n      } else if (startDot !== -1) {\\n        // We saw a non-dot and non-path separator before our dot, so we should\\n        // have a good chance at having a non-empty extension\\n        preDotState = -1;\\n      }\\n    }\\n\\n    if (startDot === -1 || end === -1 ||\\n        // We saw a non-dot character immediately before the dot\\n        preDotState === 0 ||\\n        // The (right-most) trimmed path component is exactly '..'\\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\\n      return '';\\n    }\\n    return path.slice(startDot, end);\\n  },\\n\\n  format: function format(pathObject) {\\n    if (pathObject === null || typeof pathObject !== 'object') {\\n      throw new TypeError('The \\\"pathObject\\\" argument must be of type Object. Received type ' + typeof pathObject);\\n    }\\n    return _format('/', pathObject);\\n  },\\n\\n  parse: function parse(path) {\\n    assertPath(path);\\n\\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\\n    if (path.length === 0) return ret;\\n    var code = path.charCodeAt(0);\\n    var isAbsolute = code === 47 /*/*/;\\n    var start;\\n    if (isAbsolute) {\\n      ret.root = '/';\\n      start = 1;\\n    } else {\\n      start = 0;\\n    }\\n    var startDot = -1;\\n    var startPart = 0;\\n    var end = -1;\\n    var matchedSlash = true;\\n    var i = path.length - 1;\\n\\n    // Track the state of characters (if any) we see before our first dot and\\n    // after any path separator we find\\n    var preDotState = 0;\\n\\n    // Get non-dir info\\n    for (; i >= start; --i) {\\n      code = path.charCodeAt(i);\\n      if (code === 47 /*/*/) {\\n          // If we reached a path separator that was not part of a set of path\\n          // separators at the end of the string, stop now\\n          if (!matchedSlash) {\\n            startPart = i + 1;\\n            break;\\n          }\\n          continue;\\n        }\\n      if (end === -1) {\\n        // We saw the first non-path separator, mark this as the end of our\\n        // extension\\n        matchedSlash = false;\\n        end = i + 1;\\n      }\\n      if (code === 46 /*.*/) {\\n          // If this is our first dot, mark it as the start of our extension\\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\\n        } else if (startDot !== -1) {\\n        // We saw a non-dot and non-path separator before our dot, so we should\\n        // have a good chance at having a non-empty extension\\n        preDotState = -1;\\n      }\\n    }\\n\\n    if (startDot === -1 || end === -1 ||\\n    // We saw a non-dot character immediately before the dot\\n    preDotState === 0 ||\\n    // The (right-most) trimmed path component is exactly '..'\\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\\n      if (end !== -1) {\\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\\n      }\\n    } else {\\n      if (startPart === 0 && isAbsolute) {\\n        ret.name = path.slice(1, startDot);\\n        ret.base = path.slice(1, end);\\n      } else {\\n        ret.name = path.slice(startPart, startDot);\\n        ret.base = path.slice(startPart, end);\\n      }\\n      ret.ext = path.slice(startDot, end);\\n    }\\n\\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\\n\\n    return ret;\\n  },\\n\\n  sep: '/',\\n  delimiter: ':',\\n  win32: null,\\n  posix: null\\n};\\n\\nposix.posix = posix;\\n\\nmodule.exports = posix;\\n\\n}).call(this)}).call(this,require('_process'))\\n},{\\\"_process\\\":197}],197:[function(require,module,exports){\\n// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n},{}],198:[function(require,module,exports){\\n'use strict';\\nvar escapeStringRegexp = require('escape-string-regexp');\\n\\nmodule.exports = function (str, sub) {\\n\\tif (typeof str !== 'string' || typeof sub !== 'string') {\\n\\t\\tthrow new TypeError();\\n\\t}\\n\\n\\tsub = escapeStringRegexp(sub);\\n\\treturn str.replace(new RegExp('^' + sub + '|' + sub + '$', 'g'), '');\\n};\\n\\n},{\\\"escape-string-regexp\\\":153}],199:[function(require,module,exports){\\n'use strict';\\nvar escapeStringRegexp = require('escape-string-regexp');\\n\\nmodule.exports = function (str, target) {\\n\\tif (typeof str !== 'string' || typeof target !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\treturn str.replace(new RegExp('(?:' + escapeStringRegexp(target) + '){2,}', 'g'), target);\\n};\\n\\n},{\\\"escape-string-regexp\\\":153}],200:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Can be used with Array.sort to sort and array with Uint8Array entries\\n *\\n * @param {Uint8Array} a\\n * @param {Uint8Array} b\\n */\\nfunction compare (a, b) {\\n  for (let i = 0; i < a.byteLength; i++) {\\n    if (a[i] < b[i]) {\\n      return -1\\n    }\\n\\n    if (a[i] > b[i]) {\\n      return 1\\n    }\\n  }\\n\\n  if (a.byteLength > b.byteLength) {\\n    return 1\\n  }\\n\\n  if (a.byteLength < b.byteLength) {\\n    return -1\\n  }\\n\\n  return 0\\n}\\n\\nmodule.exports = compare\\n\\n},{}],201:[function(require,module,exports){\\narguments[4][15][0].apply(exports,arguments)\\n},{\\\"dup\\\":15}],202:[function(require,module,exports){\\narguments[4][16][0].apply(exports,arguments)\\n},{\\\"dup\\\":16}],203:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst utf8Encoder = new TextEncoder()\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings\\n */\\n\\n/**\\n * Interprets each character in a string as a byte and\\n * returns a Uint8Array of those bytes.\\n *\\n * @param {string} string - The string to turn into an array\\n */\\nfunction asciiStringToUint8Array (string) {\\n  const array = new Uint8Array(string.length)\\n\\n  for (let i = 0; i < string.length; i++) {\\n    array[i] = string.charCodeAt(i)\\n  }\\n\\n  return array\\n}\\n\\n/**\\n * Create a `Uint8Array` from the passed string\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {string} string\\n * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc\\n * @returns {Uint8Array}\\n */\\nfunction fromString (string, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Encoder.encode(string)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return asciiStringToUint8Array(string)\\n  }\\n\\n  return getCodec(encoding).decode(string)\\n}\\n\\nmodule.exports = fromString\\n\\n},{\\\"multibase\\\":173}],204:[function(require,module,exports){\\n'use strict'\\nconst compare = require('./compare')\\nconst concat = require('./concat')\\nconst equals = require('./equals')\\nconst fromString = require('./from-string')\\nconst toString = require('./to-string')\\nconst xor = require('./xor')\\n\\nmodule.exports = {\\n  compare,\\n  concat,\\n  equals,\\n  fromString,\\n  toString,\\n  xor\\n}\\n\\n},{\\\"./compare\\\":200,\\\"./concat\\\":201,\\\"./equals\\\":202,\\\"./from-string\\\":203,\\\"./to-string\\\":205,\\\"./xor\\\":206}],205:[function(require,module,exports){\\n'use strict'\\n\\nconst { encoding: getCodec } = require('multibase')\\nconst utf8Decoder = new TextDecoder('utf8')\\n\\n/**\\n * @typedef {import('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings\\n */\\n\\n/**\\n * Turns a Uint8Array of bytes into a string with each\\n * character being the char code of the corresponding byte\\n *\\n * @param {Uint8Array} array - The array to turn into a string\\n */\\nfunction uint8ArrayToAsciiString (array) {\\n  let string = ''\\n\\n  for (let i = 0; i < array.length; i++) {\\n    string += String.fromCharCode(array[i])\\n  }\\n  return string\\n}\\n\\n/**\\n * Turns a `Uint8Array` into a string.\\n *\\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\\n *\\n * Also `ascii` which is similar to node's 'binary' encoding.\\n *\\n * @param {Uint8Array} array - The array to turn into a string\\n * @param {SupportedEncodings} [encoding=utf8] - The encoding to use\\n * @returns {string}\\n */\\nfunction toString (array, encoding = 'utf8') {\\n  if (encoding === 'utf8' || encoding === 'utf-8') {\\n    return utf8Decoder.decode(array)\\n  }\\n\\n  if (encoding === 'ascii') {\\n    return uint8ArrayToAsciiString(array)\\n  }\\n\\n  return getCodec(encoding).encode(array)\\n}\\n\\nmodule.exports = toString\\n\\n},{\\\"multibase\\\":173}],206:[function(require,module,exports){\\n'use strict'\\n\\n/**\\n * Returns the xor distance between two arrays\\n *\\n * @param {Uint8Array} a\\n * @param {Uint8Array} b\\n */\\nfunction xor (a, b) {\\n  if (a.length !== b.length) {\\n    throw new Error('Inputs should have the same length')\\n  }\\n\\n  const result = new Uint8Array(a.length)\\n\\n  for (let i = 0; i < a.length; i++) {\\n    result[i] = a[i] ^ b[i]\\n  }\\n\\n  return result\\n}\\n\\nmodule.exports = xor\\n\\n},{}]},{},[1])(1)\\n});\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-controller.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-controller.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-controller.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Controller\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const EnsAction = require('$:/plugins/ipfs/ens-action.js').EnsAction\\n  const EnsWrapper = require('$:/plugins/ipfs/ens-wrapper.js').EnsWrapper\\n\\n  const IpfsAction = require('$:/plugins/ipfs/ipfs-action.js').IpfsAction\\n  const IpfsBundle = require('$:/plugins/ipfs/ipfs-bundle.js').IpfsBundle\\n  const IpfsTiddler = require('$:/plugins/ipfs/ipfs-tiddler.js').IpfsTiddler\\n  const IpfsWrapper = require('$:/plugins/ipfs/ipfs-wrapper.js').IpfsWrapper\\n\\n  const ipnsKeyword = 'ipns'\\n\\n  const name = 'ipfs-controller'\\n\\n  var IpfsController = function () {\\n    this.pin = []\\n    this.unpin = []\\n  }\\n\\n  IpfsController.prototype.init = function () {\\n    // Init once\\n    if (this.once) {\\n      return\\n    }\\n    this.ipfsBundle = new IpfsBundle()\\n    this.ipfsBundle.init()\\n    this.ensWrapper = new EnsWrapper(this.ipfsBundle.ensLibrary)\\n    this.ipfsWrapper = new IpfsWrapper(this.ipfsBundle)\\n    // Listener\\n    this.ensAction = new EnsAction()\\n    this.ipfsAction = new IpfsAction()\\n    this.ipfsTiddler = new IpfsTiddler()\\n    // Init\\n    this.ensAction.init()\\n    this.ipfsAction.init()\\n    this.ipfsTiddler.init()\\n    // Load sigUtil early if needed\\n    if ($tw.crypto.hasEncryptionPublicKey() && globalThis.sigUtil === 'undefined') {\\n      this.loadEthSigUtilLibrary()\\n    }\\n    // Init once\\n    this.once = true\\n  }\\n\\n  IpfsController.prototype.getLogger = function () {\\n    const log = globalThis.log !== undefined && globalThis.log !== null ? globalThis.log : null\\n    if (log !== null) {\\n      const loggers = log.getLoggers()\\n      const eruda = loggers.eruda\\n      if (eruda !== undefined && eruda !== null) {\\n        return eruda\\n      }\\n      const ipfs = loggers.ipfs\\n      if (ipfs !== undefined && ipfs !== null) {\\n        return ipfs\\n      }\\n    }\\n    return console\\n  }\\n\\n  IpfsController.prototype.handleImportFile = async function (info) {\\n    return await this.ipfsTiddler.handleImportFile(info)\\n  }\\n\\n  IpfsController.prototype.loadToBase64 = async function (url, password) {\\n    return await this.ipfsBundle.loadToBase64(url, password)\\n  }\\n\\n  IpfsController.prototype.loadToUtf8 = async function (url, password) {\\n    return await this.ipfsBundle.loadToUtf8(url, password)\\n  }\\n\\n  IpfsController.prototype.Base64ToUint8Array = function (b64) {\\n    return this.ipfsBundle.Base64ToUint8Array(b64)\\n  }\\n\\n  IpfsController.prototype.Uint8ArrayToBase64 = function (ua) {\\n    return this.ipfsBundle.Uint8ArrayToBase64(ua)\\n  }\\n\\n  IpfsController.prototype.StringToUint8Array = function (string) {\\n    return this.ipfsBundle.StringToUint8Array(string)\\n  }\\n\\n  IpfsController.prototype.Utf8ArrayToStr = function (array) {\\n    return this.ipfsBundle.Utf8ArrayToStr(array)\\n  }\\n\\n  IpfsController.prototype.fetchUint8Array = async function (url) {\\n    return await this.ipfsBundle.fetchUint8Array(url)\\n  }\\n\\n  IpfsController.prototype.processContent = async function (tiddler, content, encoding, type) {\\n    if (content === undefined || content == null) {\\n      throw new Error('Unknown content...')\\n    }\\n    encoding = encoding !== undefined && encoding !== null && encoding.trim() !== '' ? encoding.trim() : null\\n    if (encoding == null) {\\n      throw new Error('Unknown encoding...')\\n    }\\n    type = type !== undefined && type !== null && type.trim() !== '' ? type.trim() : null\\n    if (type == null) {\\n      throw new Error('Unknown type...')\\n    }\\n    var compress = $tw.wiki.getTiddler('$:/isCompressed')\\n    compress = compress !== undefined ? compress.fields.text === 'yes' : false\\n    if (encoding === 'base64' || type === 'image/svg+xml') {\\n      compress = false\\n    }\\n    compress = tiddler !== undefined && tiddler.fields._compress !== undefined && tiddler.fields._compress.trim() !== '' ? tiddler.fields._compress.trim() === 'yes' : compress\\n    var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypted = encrypted !== undefined ? encrypted.fields.text === 'yes' : false\\n    var password = tiddler !== undefined && tiddler.fields._password !== undefined && tiddler.fields._password.trim() !== '' ? tiddler.fields._password.trim() : null\\n    var publicKey =\\n      tiddler !== undefined && tiddler.fields._encryption_public_key !== undefined && tiddler.fields._encryption_public_key.trim() !== ''\\n        ? tiddler.fields._encryption_public_key.trim()\\n        : null\\n    var sign = $tw.wiki.getTiddler('$:/isSigned')\\n    sign = sign !== undefined ? sign.fields.text === 'yes' : false\\n    sign = tiddler !== undefined && tiddler.fields._sign !== undefined && tiddler.fields._sign.trim() !== '' ? tiddler.fields._sign.trim() === 'yes' : sign\\n    var hasPublicKey = publicKey || $tw.crypto.hasEncryptionPublicKey()\\n    if (encrypted || password || hasPublicKey) {\\n      try {\\n        if (hasPublicKey && globalThis.sigUtil === 'undefined') {\\n          await this.loadEthSigUtilLibrary()\\n        }\\n        if (compress) {\\n          content = { compressed: this.deflate(content) }\\n          content.compressed = $tw.crypto.encrypt(content.compressed, password, publicKey)\\n          if (hasPublicKey && sign) {\\n            content.keccak256 = $tw.crypto.keccak256(content.compressed)\\n            content.signature = await this.personalSign(content.keccak256)\\n            content.signature = $tw.crypto.encrypt(content.signature, null, publicKey)\\n          }\\n          content = JSON.stringify(content)\\n        } else {\\n          // https://github.com/xmaysonnave/tiddlywiki-ipfs/issues/9\\n          if (encoding === 'base64') {\\n            content = atob(content)\\n          }\\n          if (hasPublicKey) {\\n            content = { encrypted: content }\\n            content.encrypted = $tw.crypto.encrypt(content.encrypted, null, publicKey)\\n            if (sign) {\\n              content.keccak256 = $tw.crypto.keccak256(content.encrypted)\\n              content.signature = await this.personalSign(content.keccak256)\\n              content.signature = $tw.crypto.encrypt(content.signature, null, publicKey)\\n            }\\n            content = JSON.stringify(content)\\n          } else {\\n            content = $tw.crypto.encrypt(content, password)\\n          }\\n        }\\n        content = $tw.ipfs.StringToUint8Array(content)\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, 'Failed to process encrypted content...')\\n        return null\\n      }\\n    } else {\\n      try {\\n        if (compress) {\\n          content = { compressed: this.deflate(content) }\\n          content = JSON.stringify(content)\\n          content = $tw.ipfs.StringToUint8Array(content)\\n        } else {\\n          if (encoding === 'base64') {\\n            content = $tw.ipfs.Base64ToUint8Array(content)\\n          } else {\\n            content = $tw.ipfs.StringToUint8Array(content)\\n          }\\n        }\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, 'Failed to process content...')\\n        return null\\n      }\\n    }\\n    return content\\n  }\\n\\n  IpfsController.prototype.addToPin = function (ipfsPath) {\\n    ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? decodeURI(ipfsPath.toString().trim()) : null\\n    if (ipfsPath !== null) {\\n      var index = this.unpin.indexOf(ipfsPath)\\n      if (index !== -1) {\\n        this.unpin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Unpin:\\n${ipfsPath}`\\n        )\\n        return false\\n      }\\n      if (this.pin.indexOf(ipfsPath) === -1) {\\n        this.pin.push(ipfsPath)\\n        $tw.ipfs.getLogger().info(\\n          `Request to Pin:\\n${ipfsPath}`\\n        )\\n        return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  IpfsController.prototype.addToUnpin = function (ipfsPath) {\\n    ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? decodeURI(ipfsPath.toString().trim()) : null\\n    if (ipfsPath !== null) {\\n      // Discard\\n      var index = this.pin.indexOf(ipfsPath)\\n      if (index !== -1) {\\n        this.pin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Pin:\\n${ipfsPath}`\\n        )\\n        return false\\n      }\\n      // Add to unpin\\n      if (this.unpin.indexOf(ipfsPath) === -1) {\\n        this.unpin.push(ipfsPath)\\n        $tw.ipfs.getLogger().info(\\n          `Request to unpin:\\n${ipfsPath}`\\n        )\\n        return true\\n      }\\n    }\\n    return false\\n  }\\n\\n  IpfsController.prototype.removeFromPinUnpin = function (ipfsPath) {\\n    ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? decodeURI(ipfsPath.toString().trim()) : null\\n    if (ipfsPath !== null) {\\n      var index = this.pin.indexOf(ipfsPath)\\n      if (index !== -1) {\\n        this.pin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Pin:\\n ${ipfsPath}`\\n        )\\n      }\\n      index = this.unpin.indexOf(ipfsPath)\\n      if (index !== -1) {\\n        this.unpin.splice(index, 1)\\n        $tw.ipfs.getLogger().info(\\n          `Cancel request to Unpin:\\n ${ipfsPath}`\\n        )\\n      }\\n    }\\n  }\\n\\n  IpfsController.prototype.pinToIpfs = async function (ipfsPath, recursive) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.pinToIpfs(ipfs, ipfsPath, recursive)\\n  }\\n\\n  IpfsController.prototype.unpinFromIpfs = async function (ipfsPath, recursive) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.unpinFromIpfs(ipfs, ipfsPath, recursive)\\n  }\\n\\n  IpfsController.prototype.addContentToIpfs = async function (upload, wrapWithDirectory) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.addContentToIpfs(ipfs, upload, wrapWithDirectory)\\n  }\\n\\n  IpfsController.prototype.generateIpnsCid = async function (ipnsKey) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.generateIpnsCid(ipfs, ipnsKey)\\n  }\\n\\n  IpfsController.prototype.removeIpnsKey = async function (ipnsKey) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.removeIpnsKey(ipfs, ipnsKey)\\n  }\\n\\n  IpfsController.prototype.renameIpnsKey = async function (oldIpnsKey, newIpnsKey) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.renameIpnsKey(ipfs, oldIpnsKey, newIpnsKey)\\n  }\\n\\n  IpfsController.prototype.resolveIpfs = async function (value, timeout) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.resolveIpfs(ipfs, value, timeout)\\n  }\\n\\n  IpfsController.prototype.resolveIpfsContainer = async function (value, timeout) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.resolveIpfsContainer(ipfs, value, timeout)\\n  }\\n\\n  IpfsController.prototype.getIpnsIdentifier = async function (identifier, resolveIpnsKey, base, path, ipnsKey) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.getIpnsIdentifier(ipfs, identifier, resolveIpnsKey, base, path, ipnsKey)\\n  }\\n\\n  IpfsController.prototype.fetchDagNode = async function (cid, timeout) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.fetchDagNode(ipfs, cid, timeout)\\n  }\\n\\n  IpfsController.prototype.resolveIpnsKey = async function (ipnsKey, timeout) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey, timeout)\\n  }\\n\\n  IpfsController.prototype.publishIpnsKey = async function (ipfsCid, ipnsCid, ipnsKey, options) {\\n    const { ipfs } = await this.getIpfsClient()\\n    return await this.ipfsWrapper.publishIpnsKey(ipfs, ipfsCid, ipnsCid, ipnsKey, options)\\n  }\\n\\n  IpfsController.prototype.isJson = function (content) {\\n    return this.ipfsBundle.isJson(content)\\n  }\\n\\n  IpfsController.prototype.filenamify = function (name, options) {\\n    return this.ipfsBundle.filenamify(name, options)\\n  }\\n\\n  IpfsController.prototype.getBase = function (base) {\\n    return this.ipfsBundle.getBase(base)\\n  }\\n\\n  IpfsController.prototype.getIpfsBaseUrl = function () {\\n    return this.ipfsBundle.getIpfsBaseUrl()\\n  }\\n\\n  IpfsController.prototype.normalizeUrl = function (value, base) {\\n    return this.ipfsBundle.normalizeUrl(value, base)\\n  }\\n\\n  IpfsController.prototype.getDocumentUrl = function () {\\n    return this.ipfsBundle.getDocumentUrl()\\n  }\\n\\n  IpfsController.prototype.getIpfsDefaultApi = function () {\\n    return this.ipfsBundle.getIpfsDefaultApi()\\n  }\\n\\n  IpfsController.prototype.getIpfsDefaultGateway = function () {\\n    return this.ipfsBundle.getIpfsDefaultGateway()\\n  }\\n\\n  IpfsController.prototype.getIpfsApiUrl = function () {\\n    return this.ipfsBundle.getIpfsApiUrl()\\n  }\\n\\n  IpfsController.prototype.getIpfsGatewayUrl = function () {\\n    return this.ipfsBundle.getIpfsGatewayUrl()\\n  }\\n\\n  IpfsController.prototype.getUrl = function (url, base) {\\n    return this.ipfsBundle.getUrl(url, base)\\n  }\\n\\n  IpfsController.prototype.resolveUrl = async function (value, resolveIpns, resolveIpnsKey, resolveEns, base, web3) {\\n    var ipfsCid = null\\n    var ipnsCid = null\\n    var ipnsKey = null\\n    var normalizedUrl = null\\n    var resolvedUrl = null\\n    value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n    if (value == null) {\\n      return {\\n        ipfsCid: null,\\n        ipnsCid: null,\\n        ipnsKey: null,\\n        normalizedUrl: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    base = base !== undefined && base !== null && base.toString().trim() !== '' ? base.toString().trim() : null\\n    try {\\n      normalizedUrl = this.normalizeUrl(value, base)\\n    } catch (error) {\\n      // Ignore\\n    }\\n    if (normalizedUrl == null) {\\n      return {\\n        ipfsCid: null,\\n        ipnsCid: null,\\n        ipnsKey: null,\\n        normalizedUrl: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    var { ipfsCid, ipnsIdentifier, ipfsPath } = this.getIpfsIdentifier(normalizedUrl)\\n    if (ipnsIdentifier !== null) {\\n      var { ipfsCid, ipnsCid, ipnsKey, normalizedUrl, resolvedUrl } = await this.resolveIpns(ipnsIdentifier, resolveIpns, resolveIpnsKey, base, ipfsPath)\\n    } else if (resolveEns && ipfsCid == null && ipnsIdentifier == null && (normalizedUrl.hostname.endsWith('.eth') || normalizedUrl.hostname.endsWith('.eth.link'))) {\\n      var { identifier, protocol, normalizedUrl, resolvedUrl } = await this.resolveEns(normalizedUrl.hostname, base, ipfsPath, web3)\\n      if (protocol === ipnsKeyword) {\\n        var { ipfsCid, ipnsCid, ipnsKey, normalizedUrl, resolvedUrl } = await this.resolveIpns(identifier, resolveIpns, resolveIpnsKey, base, ipfsPath)\\n      }\\n    }\\n    return {\\n      ipfsCid: ipfsCid,\\n      ipnsCid: ipnsCid,\\n      ipnsKey: ipnsKey,\\n      normalizedUrl: normalizedUrl,\\n      resolvedUrl: resolvedUrl !== null ? resolvedUrl : normalizedUrl,\\n    }\\n  }\\n\\n  IpfsController.prototype.resolveIpns = async function (identifier, resolveIpfsCid, resolveIpnsKey, base, path) {\\n    identifier = identifier !== undefined && identifier !== null && identifier.toString().trim() !== '' ? identifier.toString().trim() : null\\n    path = path !== undefined && path !== null && path.trim() !== '' ? path.trim() : ''\\n    if (identifier == null) {\\n      return {\\n        ipfsCid: null,\\n        ipnsCid: null,\\n        ipnsKey: null,\\n        normalizedUrl: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    var ipfsCid = null\\n    var resolvedUrl = null\\n    var { ipnsKey, ipnsCid, normalizedUrl } = await this.getIpnsIdentifier(identifier, resolveIpnsKey, base, path)\\n    if (ipnsCid !== null && resolveIpfsCid) {\\n      var { cid: ipfsCid, remainderPath } = await this.resolveIpfs(normalizedUrl.pathname)\\n      if (ipfsCid !== null) {\\n        var credential = ''\\n        var { base } = this.ipfsBundle.getBase(normalizedUrl)\\n        if (normalizedUrl.username && normalizedUrl.password) {\\n          credential = `${normalizedUrl.username}:${normalizedUrl.password}@`\\n        }\\n        resolvedUrl = this.getUrl(`${base.protocol}//${credential}${base.host}/ipfs/${ipfsCid}${remainderPath}${normalizedUrl.search}${normalizedUrl.hash}`)\\n        if (normalizedUrl.toString() !== resolvedUrl.toString()) {\\n          $tw.ipfs.getLogger().info(\\n            `Resolved IPNS:\\n ${normalizedUrl}\\n ${resolvedUrl}`\\n          )\\n        } else {\\n          $tw.ipfs.getLogger().info(\\n            `Resolved IPNS:\\n ${resolvedUrl}`\\n          )\\n        }\\n      }\\n    }\\n    return {\\n      ipfsCid: ipfsCid,\\n      ipnsCid: ipnsCid,\\n      ipnsKey: ipnsKey,\\n      normalizedUrl: normalizedUrl,\\n      resolvedUrl: resolvedUrl !== undefined && resolvedUrl !== null ? resolvedUrl : normalizedUrl,\\n    }\\n  }\\n\\n  IpfsController.prototype.resolveEns = async function (ensDomain, base, path, web3) {\\n    ensDomain = ensDomain !== undefined && ensDomain !== null && ensDomain.toString().trim() !== '' ? ensDomain.toString().trim() : null\\n    if (ensDomain == null) {\\n      return {\\n        identifier: null,\\n        protocol: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    if (ensDomain.endsWith('.eth.link')) {\\n      ensDomain = ensDomain.substring(0, ensDomain.indexOf('.link'))\\n    }\\n    path = path !== undefined && path !== null && path.trim() !== '' ? path.trim() : ''\\n    if (web3 === undefined || web3 == null) {\\n      var { web3 } = await this.getWeb3Provider()\\n    }\\n    const { content, protocol } = await this.ensWrapper.getContentHash(ensDomain, web3)\\n    if (content == null || protocol == null) {\\n      return {\\n        identifier: null,\\n        protocol: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    const url = this.normalizeUrl(`/${protocol}/${content}${path}`, base)\\n    $tw.ipfs.getLogger().info(\\n      `Fetched ENS domain content: \\\"${ensDomain}\\\"\\n${url}`\\n    )\\n    return {\\n      identifier: content,\\n      protocol: protocol,\\n      resolvedUrl: url,\\n    }\\n  }\\n\\n  IpfsController.prototype.getIpfsClient = async function () {\\n    // Provider\\n    const ipfsProvider = $tw.utils.getIpfsProvider()\\n    // IPFS companion\\n    if (ipfsProvider === 'window') {\\n      const client = await this.ipfsWrapper.getWindowIpfsClient()\\n      return {\\n        ipfs: client.ipfs,\\n        provider: client.provider,\\n      }\\n    }\\n    // Default, try IPFS companion\\n    if (ipfsProvider === 'default') {\\n      try {\\n        const client = await this.ipfsWrapper.getWindowIpfsClient()\\n        return {\\n          ipfs: client.ipfs,\\n          provider: client.provider,\\n        }\\n      } catch (error) {\\n        // Ignore, fallback to HTTP\\n      }\\n    }\\n    const url = this.getIpfsApiUrl()\\n    if (url === undefined || url == null || url.toString().trim() === '') {\\n      throw new Error('Undefined IPFS API URL...')\\n    }\\n    const { ipfs, provider } = await this.ipfsWrapper.getHttpIpfsClient(url)\\n    return {\\n      ipfs: ipfs,\\n      provider: provider,\\n    }\\n  }\\n\\n  IpfsController.prototype.setContentHash = async function (ensDomain, identifier, web3, account) {\\n    if (account === undefined || account == null || web3 === undefined || web3 == null) {\\n      var { account, web3 } = await this.getEnabledWeb3Provider()\\n    }\\n    await this.ensWrapper.setContentHash(ensDomain, identifier, web3, account)\\n    const url = this.normalizeUrl(identifier)\\n    $tw.ipfs.getLogger().info(\\n      `Set ENS domain content:\\n ${url}\\n to: \\\"${ensDomain}\\\"`\\n    )\\n    return true\\n  }\\n\\n  IpfsController.prototype.getIpfsIdentifier = function (value) {\\n    return this.ipfsBundle.getIpfsIdentifier(value)\\n  }\\n\\n  IpfsController.prototype.getCid = function (cid) {\\n    return this.ipfsBundle.getCid(cid)\\n  }\\n\\n  IpfsController.prototype.cidToBase58CidV0 = function (cid, log) {\\n    return this.ipfsBundle.cidToBase58CidV0(cid, log)\\n  }\\n\\n  IpfsController.prototype.cidToCidV1 = function (cid, protocol, log) {\\n    return this.ipfsBundle.cidToCidV1(cid, protocol, log)\\n  }\\n\\n  IpfsController.prototype.cidToLibp2pKeyCidV1 = function (cid, multibaseName, log) {\\n    return this.ipfsBundle.cidToLibp2pKeyCidV1(cid, multibaseName, log)\\n  }\\n\\n  IpfsController.prototype.isEnsOwner = async function (domain, web3, account) {\\n    return await this.ipfsBundle.isEnsOwner(domain, web3, account)\\n  }\\n\\n  IpfsController.prototype.personalRecover = async function (message, signature) {\\n    return await this.ipfsBundle.personalRecover(message, signature)\\n  }\\n\\n  IpfsController.prototype.personalSign = async function (message, provider) {\\n    return await this.ipfsBundle.personalSign(message, provider)\\n  }\\n\\n  IpfsController.prototype.decrypt = async function (text, provider) {\\n    return await this.ipfsBundle.decrypt(text, provider)\\n  }\\n\\n  IpfsController.prototype.getPublicEncryptionKey = async function (provider) {\\n    return await this.ipfsBundle.getPublicEncryptionKey(provider)\\n  }\\n\\n  IpfsController.prototype.getEthereumProvider = async function () {\\n    return await this.ipfsBundle.getEthereumProvider()\\n  }\\n\\n  IpfsController.prototype.getEnabledWeb3Provider = async function () {\\n    return await this.ipfsBundle.getEnabledWeb3Provider()\\n  }\\n\\n  IpfsController.prototype.getWeb3Provider = async function () {\\n    return await this.ipfsBundle.getWeb3Provider()\\n  }\\n\\n  IpfsController.prototype.getBlockExplorerRegistry = function () {\\n    return this.ipfsBundle.getBlockExplorerRegistry()\\n  }\\n\\n  IpfsController.prototype.getNetworkRegistry = function () {\\n    return this.ipfsBundle.getNetworkRegistry()\\n  }\\n\\n  IpfsController.prototype.getENSRegistry = function () {\\n    return this.ipfsBundle.getENSRegistry()\\n  }\\n\\n  IpfsController.prototype.loadErudaLibrary = async function () {\\n    await this.ipfsBundle.loadErudaLibrary()\\n  }\\n\\n  IpfsController.prototype.loadEthSigUtilLibrary = async function () {\\n    await this.ipfsBundle.loadEthSigUtilLibrary()\\n  }\\n\\n  IpfsController.prototype.deflate = function (str) {\\n    return this.ipfsBundle.deflate(str)\\n  }\\n\\n  IpfsController.prototype.inflate = function (b64) {\\n    return this.ipfsBundle.inflate(b64)\\n  }\\n\\n  exports.IpfsController = IpfsController\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-import.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-import.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-import.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Import\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const name = 'ipfs-import'\\n  const IPFS_IMPORT_TITLE = '$:/IpfsImport'\\n\\n  const tiddlyWikiType = 'text/vnd.tiddlywiki'\\n\\n  const local = '<a href=\\\"'\\n  const remote = '<a class=\\\"tc-tiddlylink-external\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\" href=\\\"'\\n\\n  const alertFailed = function (strings, msg, key, field, parentField, parentUrl, parentTitle) {\\n    var space = strings[1]\\n    var endH1 = strings[2]\\n    var endL1 = strings[3]\\n    var from = strings[4]\\n    var endH2 = strings[5]\\n    var endL2 = strings[6]\\n    if (parentUrl.hostname === $tw.ipfs.getDocumentUrl().hostname && parentUrl.pathname === $tw.ipfs.getDocumentUrl().pathname) {\\n      return `${msg}${space}${remote}${key}${endH1}${field}${endL1}${parentField}${from}${local}${parentUrl}${endH2}${parentTitle}${endL2}`\\n    } else {\\n      return `${msg}${space}${remote}${key}${endH1}${field}${endL1}${parentField}${from}${remote}${parentUrl}${endH2}${parentTitle}${endL2}`\\n    }\\n  }\\n\\n  const alertFieldFailed = function (strings, msg, field, url, title) {\\n    var failed = strings[1]\\n    var from = strings[2]\\n    var endH = strings[3]\\n    var endL = strings[4]\\n    if (url.hostname === $tw.ipfs.getDocumentUrl().hostname && url.pathname === $tw.ipfs.getDocumentUrl().pathname) {\\n      return `${msg}${failed}${field}${from}${local}${url}${endH}${title}${endL}`\\n    } else {\\n      return `${msg}${failed}${field}${from}${remote}${url}${endH}${title}${endL}`\\n    }\\n  }\\n\\n  const alertConditionFailed = function (strings, msg, condition, key, title, parentUrl) {\\n    var space = strings[1]\\n    var from = strings[2]\\n    var endH1 = strings[3]\\n    var endL1 = strings[4]\\n    var endH2 = strings[5]\\n    var endL2 = strings[6]\\n    if (parentUrl.hostname === $tw.ipfs.getDocumentUrl().hostname && parentUrl.pathname === $tw.ipfs.getDocumentUrl().pathname) {\\n      return `${msg}${space}${condition}${from}${remote}${key}${endH1}${title}${endL1}${local}${parentUrl}${endH2}${title}${endL2}`\\n    } else {\\n      return `${msg}${space}${condition}${from}${remote}${key}${endH1}${title}${endL1}${remote}${parentUrl}${endH2}${title}${endL2}`\\n    }\\n  }\\n\\n  var IpfsImport = function () {}\\n\\n  IpfsImport.prototype.removeTiddlers = function (keys, title) {\\n    var removed = 0\\n    for (var key of this.loaded.keys()) {\\n      if (keys.indexOf(key) !== -1) {\\n        continue\\n      }\\n      const { imported, resolvedKey } = this.loaded.get(key)\\n      if (imported.delete(title)) {\\n        const msg = 'Remove:'\\n        const field = ''\\n        $tw.ipfs.getLogger().info(\\n          `${msg} ${field}\\\"${title}\\\"\\n ${resolvedKey}`\\n        )\\n        $tw.utils.alert(name, alertFieldFailed`${msg} ${field}${resolvedKey}\\\">${title}</a>`)\\n        removed += 1\\n      }\\n    }\\n    return removed\\n  }\\n\\n  IpfsImport.prototype.getKey = async function (value, base) {\\n    var ipfsCid = null\\n    var ipnsCid = null\\n    var key = null\\n    var normalizedUrl = null\\n    var resolvedUrl = null\\n    value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n    if (value == null) {\\n      return {\\n        key: null,\\n        resolvedUrl: null,\\n      }\\n    }\\n    var { ipfsCid, ipnsCid, normalizedUrl, resolvedUrl } = await $tw.ipfs.resolveUrl(value, true, false, true, base)\\n    if (normalizedUrl == null && resolvedUrl == null) {\\n      throw new Error(`Failed to resolve value: ${value}`)\\n    }\\n    if (normalizedUrl.hostname.endsWith('.eth') || normalizedUrl.hostname.endsWith('.eth.link')) {\\n      key = normalizedUrl.hostname\\n      if (normalizedUrl.hostname.endsWith('.eth.link')) {\\n        key = normalizedUrl.hostname.substring(0, normalizedUrl.hostname.indexOf('.link'))\\n      }\\n    } else if (ipfsCid !== null) {\\n      key = `ipfs://${ipfsCid}`\\n    } else if (ipnsCid !== null) {\\n      key = `ipns://${ipnsCid}`\\n    } else {\\n      key = normalizedUrl.toString()\\n    }\\n    return {\\n      key: key,\\n      resolvedUrl: resolvedUrl,\\n    }\\n  }\\n\\n  IpfsImport.prototype.isIpfs = async function (key) {\\n    key = key !== undefined && key !== null && key.trim() !== '' ? key.trim() : null\\n    if (key == null) {\\n      return false\\n    }\\n    const { ipfsCid, ipnsIdentifier } = $tw.ipfs.getIpfsIdentifier(key)\\n    if (key.endsWith('.eth') || ipfsCid !== null || ipnsIdentifier !== null) {\\n      return true\\n    }\\n    return false\\n  }\\n\\n  IpfsImport.prototype.import = async function (canonicalUri, importUri, tiddler) {\\n    canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n    importUri = importUri !== undefined && importUri !== null && importUri.toString().trim() !== '' ? importUri.toString().trim() : null\\n    var password = tiddler.fields._password\\n    password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n    const { type } = $tw.utils.getContentType(tiddler)\\n    this.loaded = new Map()\\n    this.notLoaded = []\\n    this.isEmpty = []\\n    this.resolved = new Map()\\n    this.notResolved = []\\n    this.merged = new Map()\\n    try {\\n      // Load and prepare imported tiddlers to be processed\\n      const host = $tw.ipfs.getUrl(`#${encodeURI(IPFS_IMPORT_TITLE)}`, $tw.ipfs.getDocumentUrl())\\n      if (canonicalUri !== null || importUri !== null) {\\n        if (importUri !== null) {\\n          await this.load(host, IPFS_IMPORT_TITLE, '_import_uri', importUri, password, true)\\n        }\\n        if (canonicalUri !== null) {\\n          await this.load(host, IPFS_IMPORT_TITLE, '_canonical_uri', canonicalUri, password, tiddlyWikiType === type)\\n        }\\n        // Process\\n        this.processImported()\\n        // Import\\n        var rootUri = importUri !== null ? importUri : canonicalUri\\n        var { key: rootUriKey } = await this.getKey(rootUri)\\n        this.importTiddlers(rootUri)\\n        // Deleted\\n        var deleted = new Map()\\n        var titles = $tw.wiki.getTiddlers({ includeSystem: true })\\n        for (var i = 0; i < titles.length; i++) {\\n          const title = titles[i] !== undefined && titles[i] !== null && titles[i].trim() !== '' ? titles[i].trim() : null\\n          if (title == null) {\\n            continue\\n          }\\n          const current = $tw.wiki.getTiddler(title)\\n          canonicalUri = current.fields._canonical_uri\\n          canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n          if (canonicalUri !== null) {\\n            var key = this.resolved.get(canonicalUri)\\n            if (key === undefined) {\\n              var { key } = await this.getKey(canonicalUri, rootUri)\\n            }\\n            if (key === rootUriKey && this.merged.get(title) === undefined && deleted.get(title) === undefined) {\\n              deleted.set(title, JSON.parse($tw.wiki.getTiddlerAsJson(title)))\\n            }\\n          }\\n          importUri = current.fields._import_uri\\n          importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n          if (importUri !== null) {\\n            var key = this.resolved.get(importUri)\\n            if (key === undefined) {\\n              var { key } = await this.getKey(importUri, rootUri)\\n            }\\n            if (key === rootUriKey && this.merged.get(title) === undefined && deleted.get(title) === undefined) {\\n              deleted.set(title, JSON.parse($tw.wiki.getTiddlerAsJson(title)))\\n            }\\n          }\\n        }\\n        return {\\n          merged: this.merged,\\n          deleted: deleted,\\n          loaded: this.loaded,\\n          isEmpty: this.isEmpty,\\n          notLoaded: this.notLoaded,\\n          notResolved: this.notResolved,\\n        }\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n    }\\n    return null\\n  }\\n\\n  IpfsImport.prototype.load = async function (parentUrl, parentTitle, field, url, password, load) {\\n    var loaded = 0\\n    var removed = 0\\n    var key = null\\n    var resolvedUrl = null\\n    if (url !== null && this.notResolved.indexOf(url) === -1 && this.resolved.get(url) === undefined) {\\n      var { key, resolvedUrl } = await this.getKey(url, parentUrl)\\n      this.resolved.set(url, key)\\n    }\\n    if (load && key !== null && resolvedUrl !== null && this.notLoaded.indexOf(key) === -1 && this.loaded.get(key) === undefined) {\\n      const { loaded: loadedAdded, removed: loadedRemoved } = await this.loadResource(parentUrl, parentTitle, field, url, key, resolvedUrl, password)\\n      loaded = loadedAdded\\n      removed = loadedRemoved\\n    }\\n    return {\\n      loaded: loaded,\\n      removed: removed,\\n    }\\n  }\\n\\n  /**\\n   * https://stackoverflow.com/questions/15458876/check-if-a-string-is-html-or-not/15458987\\n   */\\n  IpfsImport.prototype.isHTML = function (text) {\\n    /*eslint max-len:\\\"off\\\"*/\\n    return /<(br|basefont|hr|input|source|frame|param|area|meta|!--|col|link|option|base|img|wbr|!DOCTYPE).*?>|<(a|abbr|acronym|address|applet|article|aside|audio|b|bdi|bdo|big|blockquote|body|button|canvas|caption|center|cite|code|colgroup|command|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|em|embed|fieldset|figcaption|figure|font|footer|form|frameset|head|header|hgroup|h1|h2|h3|h4|h5|h6|html|i|iframe|ins|kbd|keygen|label|legend|li|map|mark|menu|meter|nav|noframes|noscript|object|ol|optgroup|output|p|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|span|strike|strong|style|sub|summary|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video).*?<\\\\/\\\\2>/i.test(\\n      text\\n    )\\n  }\\n\\n  IpfsImport.prototype.loadResource = async function (parentUrl, parentTitle, parentField, url, key, resolvedKey, password) {\\n    var loaded = 0\\n    var removed = 0\\n    var content = null\\n    var imported = new Map()\\n    var tiddlers = null\\n    const creationFields = $tw.wiki.getCreationFields()\\n    try {\\n      // Load\\n      content = await $tw.ipfs.loadToUtf8(resolvedKey, password)\\n      // HTML\\n      if (this.isHTML(content)) {\\n        content = $tw.wiki.deserializeTiddlers('text/html', content, creationFields)\\n        if ($tw.utils.isArray(content) && content.length === 1 && content[0].text && $tw.ipfs.isJson(content[0].text)) {\\n          tiddlers = Object.values(JSON.parse(content[0].text))\\n        } else {\\n          tiddlers = content\\n        }\\n      } else {\\n        if ($tw.ipfs.isJson(content)) {\\n          tiddlers = $tw.wiki.deserializeTiddlers('application/json', content, creationFields)\\n        } else {\\n          tiddlers = $tw.wiki.deserializeTiddlers('application/x-tiddler', content, creationFields)\\n        }\\n      }\\n      // Loaded\\n      if (tiddlers !== undefined && tiddlers !== null) {\\n        this.loaded.set(key, {\\n          imported: imported,\\n          resolvedKey: resolvedKey,\\n          url: url,\\n        })\\n        for (var i in tiddlers) {\\n          const tiddler = tiddlers[i]\\n          var title = tiddler.title\\n          if (title === undefined || title == null || title.trim() === '') {\\n            const msg = 'Ignore Unknown:'\\n            const field = 'Title'\\n            $tw.ipfs.getLogger().info(\\n              `${msg} \\\"${field}\\\"\\n ${resolvedKey}\\nfrom \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n            )\\n            $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${field}</a>, from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n            removed += 1\\n            continue\\n          }\\n          if (imported.get(title) !== undefined) {\\n            const msg = 'Ignore Duplicate:'\\n            $tw.ipfs.getLogger().info(\\n              `${msg} \\\"${title}\\\"\\n ${resolvedKey}\\nfrom \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n            )\\n            $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${title}</a>, from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n            removed += 1\\n            continue\\n          }\\n          var type = tiddler.type\\n          if (type === undefined || type == null) {\\n            type = tiddlyWikiType\\n          }\\n          var info = $tw.config.contentTypeInfo[type]\\n          if (info === undefined || info == null) {\\n            const msg = 'Unknown:'\\n            const field = 'Content-Type'\\n            $tw.ipfs.getLogger().info(\\n              `${msg} \\\"${field}\\\": \\\"${title}\\\"\\n ${resolvedKey}`\\n            )\\n            $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\": ${resolvedKey}\\\">${title}</a>`)\\n            // Default\\n            type = tiddlyWikiType\\n            info = $tw.config.contentTypeInfo[type]\\n          }\\n          tiddler.type = type\\n          // Next\\n          var canonicalUri = tiddler._canonical_uri\\n          canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n          tiddler._canonical_uri = canonicalUri\\n          var importUri = tiddler._import_uri\\n          importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n          tiddler._import_uri = importUri\\n          if (canonicalUri !== null || importUri !== null) {\\n            password = tiddler._password\\n            password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n            if (importUri !== null) {\\n              const { loaded: loadedAdded, removed: loadedRemoved } = await this.load(resolvedKey, title, '_import_uri', importUri, password, true)\\n              loaded += loadedAdded\\n              removed += loadedRemoved\\n            }\\n            if (canonicalUri !== null) {\\n              const { loaded: loadedAdded, removed: loadedRemoved } = await this.load(resolvedKey, title, '_canonical_uri', canonicalUri, password, tiddlyWikiType === tiddler.type)\\n              loaded += loadedAdded\\n              removed += loadedRemoved\\n            }\\n          }\\n          imported.set(title, tiddler)\\n          loaded += 1\\n        }\\n      }\\n      if (imported.size === 0) {\\n        this.isEmpty.push(key)\\n        const msg = 'Empty Import:'\\n        const field = 'Resource'\\n        $tw.ipfs.getLogger().info(\\n          `${msg} \\\"${field}\\\"\\n ${resolvedKey}\\nfrom \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n        )\\n        $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${field}</a> from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n      }\\n    } catch (error) {\\n      this.notLoaded.push(key)\\n      const msg = 'Failed to Import:'\\n      const field = 'Resource'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\"\\n ${resolvedKey}\\nfrom \\\"${parentField}\\\", \\\"${parentTitle}\\\"\\n ${parentUrl}`\\n      )\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, alertFailed`${msg} ${resolvedKey}\\\">${field}</a> from \\\"${parentField}\\\", ${parentUrl}\\\">${parentTitle}</a>`)\\n    }\\n    return {\\n      loaded: loaded,\\n      removed: removed,\\n    }\\n  }\\n\\n  IpfsImport.prototype.performImport = function (toBeAdded, toBeUpdated, toBeDeleted) {\\n    // New and Updated\\n    for (var [title, merged] of this.merged.entries()) {\\n      if (toBeAdded.indexOf(title) || toBeUpdated.indexOf(title) !== -1) {\\n        $tw.wiki.addTiddler(merged)\\n      }\\n    }\\n    // Deleted\\n    for (var i = 0; i < toBeDeleted.length; i++) {\\n      $tw.wiki.deleteTiddler(toBeDeleted[i])\\n    }\\n  }\\n\\n  IpfsImport.prototype.processImported = function () {\\n    var processed = 0\\n    var removed = 0\\n    var processedTitles = []\\n    for (var key of this.loaded.keys()) {\\n      const { imported, resolvedKey } = this.loaded.get(key)\\n      for (var title of imported.keys()) {\\n        if (processedTitles.indexOf(title) !== -1) {\\n          continue\\n        }\\n        const keys = []\\n        const tiddler = imported.get(title)\\n        var type = tiddler.type\\n        var canonicalUri = tiddler._canonical_uri\\n        canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n        var importUri = tiddler._import_uri\\n        importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n        if (canonicalUri == null && importUri == null) {\\n          keys.push(key)\\n        } else if (canonicalUri == null && importUri !== null) {\\n          const msg = 'Missing:'\\n          const field = '_canonical_uri'\\n          $tw.ipfs.getLogger().info(\\n            `${msg} \\\"${field}\\\" from ${title}\\\"\\n ${resolvedKey}`\\n          )\\n          $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a>`)\\n        } else {\\n          var canonicalKey = null\\n          if (canonicalUri !== null && this.notResolved.indexOf(canonicalUri) === -1) {\\n            canonicalKey = this.resolved.get(canonicalUri)\\n          }\\n          if (canonicalKey !== undefined && canonicalKey !== null) {\\n            if (key === canonicalKey) {\\n              const msg = 'Cycle:'\\n              const field = '_canonical_uri'\\n              $tw.ipfs.getLogger().info(\\n                `${msg} \\\"${field}\\\" from ${title}\\\"\\n ${resolvedKey}`\\n              )\\n              $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a>`)\\n            } else if (this.processCanonicalKey(keys, resolvedKey, title, canonicalKey, type)) {\\n              var importKey = null\\n              if (importUri !== null && this.notResolved.indexOf(importUri) === -1) {\\n                importKey = this.resolved.get(importUri)\\n              }\\n              if (importKey === undefined || importKey == null) {\\n                keys.push(key)\\n              } else {\\n                if (canonicalKey === importKey) {\\n                  const msg = 'Matching:'\\n                  const field = '\\\"_canonical_uri\\\" and \\\"_import_uri\\\"'\\n                  $tw.ipfs.getLogger().info(\\n                    `${msg} ${field} from \\\"${title}\\\"\\n ${resolvedKey}`\\n                  )\\n                  $tw.utils.alert(name, alertFieldFailed`${msg} ${field} from ${resolvedKey}\\\">${title}</a>`)\\n                } else if (key === importKey) {\\n                  const msg = 'Cycle:'\\n                  const field = '_import_uri'\\n                  $tw.ipfs.getLogger().info(\\n                    `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${resolvedKey}`\\n                  )\\n                  $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a>`)\\n                } else {\\n                  keys.push(key)\\n                  this.processImportKey(keys, resolvedKey, title, canonicalKey, importKey)\\n                }\\n              }\\n            }\\n          }\\n        }\\n        processed += keys.length\\n        removed += this.removeTiddlers(keys, title)\\n        processedTitles.push(title)\\n      }\\n    }\\n    return {\\n      processed: processed,\\n      removed: removed,\\n    }\\n  }\\n\\n  IpfsImport.prototype.processCanonicalKey = function (keys, parentResolvedKey, title, canonicalKey, type) {\\n    if (tiddlyWikiType !== type) {\\n      keys.push(canonicalKey)\\n      return true\\n    }\\n    if (this.notLoaded.indexOf(canonicalKey) !== -1) {\\n      return false\\n    }\\n    if (this.loaded.get(canonicalKey) === undefined) {\\n      return false\\n    }\\n    const { imported, resolvedKey } = this.loaded.get(canonicalKey)\\n    if (imported === undefined) {\\n      return false\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    var canonicalUri = tiddler._canonical_uri\\n    canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n    if (canonicalUri !== null) {\\n      const msg = 'Inconsistency:'\\n      const field = '_canonical_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${resolvedKey}\\nand ${parentResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertConditionFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a> and ${parentResolvedKey}\\\">${title}</a>`)\\n      return false\\n    }\\n    var importUri = tiddler._import_uri\\n    importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n    if (importUri !== null) {\\n      const msg = 'Inconsistency:'\\n      const field = '_import_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${resolvedKey}\\nand ${parentResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertConditionFailed`${msg} \\\"${field}\\\" from ${resolvedKey}\\\">${title}</a> and ${parentResolvedKey}\\\">${title}</a>`)\\n      return false\\n    }\\n    keys.push(canonicalKey)\\n    return true\\n  }\\n\\n  IpfsImport.prototype.processImportKey = function (keys, parentResolvedKey, title, canonicalKey, importKey) {\\n    if (this.notLoaded.indexOf(importKey) !== -1) {\\n      return\\n    }\\n    if (this.loaded.get(importKey) === undefined) {\\n      return\\n    }\\n    const { imported, resolvedKey: importResolvedKey } = this.loaded.get(importKey)\\n    if (imported === undefined) {\\n      return\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return\\n    }\\n    var targetCanonicalUri = tiddler._canonical_uri\\n    targetCanonicalUri = targetCanonicalUri !== undefined && targetCanonicalUri !== null && targetCanonicalUri.trim() === '' ? targetCanonicalUri.trim() : null\\n    var targetCanonicalKey = null\\n    if (targetCanonicalUri !== null && this.notResolved.indexOf(targetCanonicalUri) === -1) {\\n      targetCanonicalKey = this.resolved.get(targetCanonicalUri)\\n    }\\n    if (targetCanonicalKey !== undefined && targetCanonicalKey !== null && canonicalKey !== targetCanonicalKey) {\\n      const msg = 'Inconsistency:'\\n      const field = '_canonical_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${importResolvedKey}\\nand ${parentResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertConditionFailed`${msg} \\\"${field}\\\" from ${importResolvedKey}\\\">${title}</a> and ${parentResolvedKey}\\\">${title}</a>`)\\n      return\\n    }\\n    var nextImportUri = tiddler._import_uri\\n    nextImportUri = nextImportUri !== undefined && nextImportUri !== null && nextImportUri.trim() !== '' ? nextImportUri.trim() : null\\n    if (targetCanonicalUri == null && nextImportUri !== null) {\\n      const msg = 'Missing:'\\n      const field = '_canonical_uri'\\n      $tw.ipfs.getLogger().info(\\n        `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${importResolvedKey}`\\n      )\\n      $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${importResolvedKey}\\\">${title}</a>`)\\n      return\\n    }\\n    if (nextImportUri == null) {\\n      keys.push(importKey)\\n    } else {\\n      var nextImportKey = null\\n      if (nextImportUri !== null && this.notResolved.indexOf(nextImportUri) === -1) {\\n        nextImportKey = this.resolved.get(nextImportUri)\\n      }\\n      if (nextImportKey !== undefined && nextImportKey !== null) {\\n        if (canonicalKey === nextImportKey) {\\n          const msg = 'Matching:'\\n          const field = '\\\"_canonical_uri\\\" and \\\"_import_uri\\\"'\\n          $tw.ipfs.getLogger().info(\\n            `${msg} ${field} from \\\"${title}\\\"\\n ${importResolvedKey}`\\n          )\\n          $tw.utils.alert(name, alertFieldFailed`${msg} ${field} from ${importResolvedKey}\\\">${title}</a>`)\\n        } else if (keys.indexOf(nextImportKey) !== -1) {\\n          const msg = 'Cycle:'\\n          const field = '_import_uri'\\n          $tw.ipfs.getLogger().info(\\n            `${msg} \\\"${field}\\\" from \\\"${title}\\\"\\n ${importResolvedKey}`\\n          )\\n          $tw.utils.alert(name, alertFieldFailed`${msg} \\\"${field}\\\" from ${importResolvedKey}\\\">${title}</a>`)\\n        } else {\\n          keys.push(importKey)\\n          this.processImportKey(keys, importResolvedKey, title, canonicalKey, nextImportKey)\\n        }\\n      }\\n    }\\n  }\\n\\n  IpfsImport.prototype.importTiddlers = function (rootUri) {\\n    var processedTitles = []\\n    for (var key of this.loaded.keys()) {\\n      const { imported, url } = this.loaded.get(key)\\n      for (var title of imported.keys()) {\\n        if (processedTitles.indexOf(title) !== -1) {\\n          continue\\n        }\\n        const tiddler = imported.get(title)\\n        var type = tiddler.type\\n        var canonicalUri = tiddler._canonical_uri\\n        canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n        var importUri = tiddler._import_uri\\n        importUri = importUri === undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n        var processed\\n        if (importUri !== null) {\\n          processed = this.importTiddler(title, importUri)\\n        }\\n        if (processed === false && canonicalUri !== null && tiddlyWikiType === type) {\\n          this.importTiddler(title, canonicalUri)\\n        }\\n        if (this.mergeTiddler(title, url)) {\\n          const merged = this.merged.get(title)\\n          var type = merged.type\\n          if (tiddlyWikiType !== type) {\\n            if (rootUri.startsWith('blob:') === false) {\\n              merged._import_uri = rootUri\\n            }\\n          } else {\\n            var canonicalUri = merged._canonical_uri\\n            if (canonicalUri === undefined || canonicalUri == null) {\\n              if (url !== rootUri) {\\n                merged._canonical_uri = this.resolved.get(url)\\n                if (rootUri.startsWith('blob:') === false) {\\n                  merged._import_uri = rootUri\\n                }\\n              } else {\\n                if (rootUri.startsWith('blob:') === false) {\\n                  merged._canonical_uri = rootUri\\n                }\\n              }\\n            } else {\\n              merged._canonical_uri = this.resolved.get(canonicalUri)\\n              if (canonicalUri !== rootUri && rootUri.startsWith('blob:') === false) {\\n                merged._import_uri = rootUri\\n              }\\n            }\\n          }\\n        }\\n        processedTitles.push(title)\\n      }\\n    }\\n  }\\n\\n  IpfsImport.prototype.importTiddler = function (title, uri) {\\n    const key = this.resolved.get(uri)\\n    if (key === undefined) {\\n      return false\\n    }\\n    if (this.loaded.get(key) === undefined) {\\n      return false\\n    }\\n    const { imported } = this.loaded.get(key)\\n    if (imported === undefined) {\\n      return false\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    var type = tiddler.type\\n    var importUri = tiddler._import_uri\\n    importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n    var canonicalUri = tiddler._canonical_uri\\n    canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n    var processed = false\\n    if (importUri !== null) {\\n      processed = this.importTiddler(title, importUri)\\n    }\\n    if (processed === false && canonicalUri !== null && tiddlyWikiType === type) {\\n      this.importTiddler(title, canonicalUri)\\n    }\\n    return this.mergeTiddler(title, uri)\\n  }\\n\\n  IpfsImport.prototype.mergeTiddler = function (title, uri) {\\n    title = title !== undefined && title !== null && title.trim() !== '' ? title.trim() : null\\n    if (title == null) {\\n      return false\\n    }\\n    const key = this.resolved.get(uri)\\n    if (key === undefined) {\\n      return false\\n    }\\n    if (this.loaded.get(key) === undefined) {\\n      return false\\n    }\\n    const { imported } = this.loaded.get(key)\\n    if (imported === undefined) {\\n      return false\\n    }\\n    const tiddler = imported.get(title)\\n    if (tiddler === undefined) {\\n      return false\\n    }\\n    // Retrieve target host Tiddler\\n    var currentTiddler = $tw.wiki.getTiddler(title)\\n    // Retrieve or prepare merged content\\n    var merged = this.merged.get(title)\\n    if (merged === undefined) {\\n      merged = {}\\n      this.merged.set(title, merged)\\n    }\\n    // Tags\\n    var tags = tiddler.tags !== undefined ? tiddler.tags : ''\\n    // Fields\\n    var hasModified = false\\n    for (var field in tiddler) {\\n      // Discard\\n      if (field === 'tags') {\\n        continue\\n      }\\n      if (field === 'modified') {\\n        hasModified = true\\n      }\\n      // Unknown from leaf to top, we keep the top modified field\\n      if (merged[field] === undefined || merged[field] == null || field === '_canonical_uri' || field === '_import_uri' || field === 'modified') {\\n        merged[field] = tiddler[field]\\n      }\\n    }\\n    if (hasModified === false) {\\n      merged.modified = new Date()\\n    }\\n    // Merge current Tiddler Tags\\n    if (currentTiddler !== undefined && currentTiddler !== null) {\\n      const currentTags = (currentTiddler.fields.tags || []).slice(0)\\n      for (var i = 0; i < currentTags.length; i++) {\\n        const currentTag = currentTags[i]\\n        if (tags.includes(currentTag) === false) {\\n          tags = `${tags} [[${currentTag}]]`\\n        }\\n      }\\n    }\\n    // Merge Tags\\n    if (merged.tags !== undefined && merged.tags !== null) {\\n      const mergedTags = $tw.utils.parseStringArray(merged.tags, false)\\n      for (var i = 0; i < mergedTags.length; i++) {\\n        const mergedTag = mergedTags[i]\\n        if (tags.includes(mergedTag) === false) {\\n          tags = `${tags} [[${mergedTag}]]`\\n        }\\n      }\\n    }\\n    // IPFS tag\\n    if (this.isIpfs(key) && tags.includes('$:/isIpfs') === false) {\\n      tags = `${tags} $:/isIpfs`\\n    }\\n    // Imported tag\\n    if (tags.includes('$:/isImported') === false) {\\n      tags = `${tags} $:/isImported`\\n    }\\n    // Processed tags\\n    merged.tags = tags\\n    // Processed\\n    return true\\n  }\\n\\n  exports.IpfsImport = IpfsImport\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-tiddler.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-tiddler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-tiddler.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Tiddler\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const IpfsImport = require('$:/plugins/ipfs/ipfs-import.js').IpfsImport\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-tiddler'\\n\\n  var IpfsTiddler = function () {\\n    this.once = false\\n  }\\n\\n  IpfsTiddler.prototype.init = function () {\\n    // Init once\\n    if (this.once) {\\n      return\\n    }\\n    const self = this\\n    // Events\\n    $tw.wiki.addEventListener('change', function (changes) {\\n      return self.handleChangeEvent(changes)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipfs-pin', function (event) {\\n      return self.handleIpfsPin(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-ipfs-unpin', function (event) {\\n      return self.handleIpfsUnpin(event)\\n    })\\n    $tw.rootWidget.addEventListener('tm-refresh-tiddler', function (event) {\\n      return self.handleRefreshTiddler(event)\\n    })\\n    // Hooks\\n    $tw.hooks.addHook('th-deleting-tiddler', async function (tiddler) {\\n      return await self.handleDeleteTiddler(tiddler)\\n    })\\n    $tw.hooks.addHook('th-saving-tiddler', async function (tiddler) {\\n      return await self.handleSaveTiddler(tiddler)\\n    })\\n    // Init once\\n    this.once = true\\n  }\\n\\n  IpfsTiddler.prototype.handleChangeEvent = function (changes) {\\n    // Gateway preference\\n    const api = changes['$:/ipfs/saver/api']\\n    if (api !== undefined && api.modified) {\\n      $tw.ipfs.getLogger().info(`IPFS API: ${$tw.ipfs.getIpfsApiUrl()}`)\\n    }\\n    // Gateway preference\\n    const gateway = changes['$:/ipfs/saver/gateway']\\n    if (gateway !== undefined && gateway.modified) {\\n      const base = $tw.ipfs.getIpfsBaseUrl()\\n      if ($tw.utils.getIpfsUrlPolicy() === 'gateway') {\\n        $tw.ipfs.getLogger().info(`Gateway Policy: ${base}`)\\n      }\\n    }\\n    // Policy preference\\n    const policy = changes['$:/ipfs/saver/policy']\\n    if (policy !== undefined && policy.modified) {\\n      const base = $tw.ipfs.getIpfsBaseUrl()\\n      if ($tw.utils.getIpfsUrlPolicy() === 'origin') {\\n        $tw.ipfs.getLogger().info(`Origin Policy: ${base}`)\\n      } else {\\n        $tw.ipfs.getLogger().info(`Gateway Policy: ${base}`)\\n      }\\n    }\\n    // Pin preference\\n    const pin = changes['$:/ipfs/saver/pin']\\n    if (pin !== undefined && pin.modified) {\\n      if ($tw.utils.getIpfsPin()) {\\n        $tw.ipfs.getLogger().info('Pin current IPFS content...')\\n      } else {\\n        $tw.ipfs.getLogger().info('Do not pin current IPFS content...')\\n      }\\n    }\\n    // Unpin preference\\n    const unpin = changes['$:/ipfs/saver/unpin']\\n    if (unpin !== undefined && unpin.modified) {\\n      if ($tw.utils.getIpfsUnpin()) {\\n        $tw.ipfs.getLogger().info('Unpin previous IPFS content...')\\n      } else {\\n        $tw.ipfs.getLogger().info('Do not unpin previous IPFS content...')\\n      }\\n    }\\n    // Verbose preference\\n    const verbose = changes['$:/ipfs/saver/verbose']\\n    if (verbose !== undefined && verbose.modified) {\\n      var log = globalThis.log !== undefined && globalThis.log !== null ? globalThis.log : null\\n      if (log !== null) {\\n        if ($tw.utils.getIpfsVerbose()) {\\n          log.setLevel('info', false)\\n        } else {\\n          log.setLevel('warn', false)\\n        }\\n      }\\n    }\\n  }\\n\\n  IpfsTiddler.prototype.handleIpfsPin = function (event) {\\n    const title = event.tiddlerTitle\\n    const tiddler = $tw.wiki.getTiddler(title)\\n    // Tiddler\\n    if (tiddler !== undefined && title !== '$:/plugins/tiddlywiki/menubar/items/pagecontrols') {\\n      if (event.param) {\\n        // Tiddler\\n        for (var field in tiddler.fields) {\\n          if ($tw.utils.isTiddlyWikiReservedWord(field)) {\\n            continue\\n          }\\n          var value = tiddler.getFieldString(field)\\n          value = value !== undefined && value !== null && value.trim() !== '' ? value.trim() : null\\n          if (value !== null) {\\n            this.ipfsPin(value, field)\\n          }\\n        }\\n        return true\\n      }\\n      return false\\n    }\\n    // Wiki\\n    this.ipfsPin($tw.ipfs.getDocumentUrl().toString(), 'Wiki')\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.ipfsPin = function (value, field) {\\n    $tw.ipfs\\n      .resolveUrl(value, $tw.utils.getIpnsResolve(), false, true)\\n      .then(data => {\\n        const { ipfsCid, ipnsCid, resolvedUrl } = data\\n        if (ipfsCid != null || ipnsCid !== null) {\\n          $tw.ipfs\\n            .pinToIpfs(decodeURI(resolvedUrl.pathname))\\n            .then(pin => {\\n              if (pin !== undefined && pin !== null) {\\n                $tw.ipfs.removeFromPinUnpin(resolvedUrl.pathname)\\n                if (field !== undefined && field !== null) {\\n                  $tw.ipfs.getLogger().info(\\n                    `Pinned: \\\"${field}\\\"\\n ${decodeURI(resolvedUrl.pathname)}`\\n                  )\\n                  $tw.utils.alert(name, `Pinned: '${field}'`)\\n                }\\n              }\\n            })\\n            .catch(error => {\\n              $tw.ipfs.getLogger().error(error)\\n              $tw.utils.alert(name, error.message)\\n            })\\n        }\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n  }\\n\\n  IpfsTiddler.prototype.handleIpfsUnpin = async function (event) {\\n    const title = event.tiddlerTitle\\n    const tiddler = $tw.wiki.getTiddler(title)\\n    if (tiddler !== undefined && title !== '$:/plugins/tiddlywiki/menubar/items/pagecontrols') {\\n      const { type, info } = $tw.utils.getContentType(tiddler)\\n      if (event.param) {\\n        // Tiddler\\n        for (var field in tiddler.fields) {\\n          if ($tw.utils.isTiddlyWikiReservedWord(field)) {\\n            continue\\n          }\\n          var value = tiddler.getFieldString(field)\\n          value = value !== undefined && value !== null && value.trim() !== '' ? value.trim() : null\\n          if (value !== null) {\\n            if (info.encoding !== 'base64' && type !== 'image/svg+xml') {\\n              if (field === '_canonical_uri' || field === '_import_uri') {\\n                continue\\n              }\\n            }\\n            this.ipfsUnpin(value, field)\\n          }\\n        }\\n        return true\\n      }\\n      return false\\n    }\\n    // Wiki\\n    this.ipfsUnpin($tw.ipfs.getDocumentUrl().toString(), 'Wiki')\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.ipfsUnpin = function (value, field) {\\n    field = field !== undefined && field !== null && field.trim() !== '' ? field.trim() : null\\n    $tw.ipfs\\n      .resolveUrl(value, $tw.utils.getIpnsResolve(), false, true)\\n      .then(data => {\\n        const { ipfsCid, ipnsCid, resolvedUrl } = data\\n        if (ipfsCid != null || ipnsCid !== null) {\\n          $tw.ipfs\\n            .unpinFromIpfs(decodeURI(resolvedUrl.pathname))\\n            .then(unpin => {\\n              if (unpin !== undefined && unpin !== null) {\\n                $tw.ipfs.removeFromPinUnpin(resolvedUrl.pathname)\\n                if (field !== undefined && field !== null) {\\n                  $tw.ipfs.getLogger().info(\\n                    `Unpinned: \\\"${field}\\n ${decodeURI(resolvedUrl.pathname)}`\\n                  )\\n                  $tw.utils.alert(name, `Unpinned: '${field}'`)\\n                }\\n              }\\n            })\\n            .catch(error => {\\n              $tw.ipfs.getLogger().error(error)\\n              $tw.utils.alert(name, error.message)\\n            })\\n        }\\n      })\\n      .catch(error => {\\n        $tw.ipfs.getLogger().error(error)\\n        $tw.utils.alert(name, error.message)\\n      })\\n  }\\n\\n  IpfsTiddler.prototype.handleDeleteTiddler = async function (tiddler) {\\n    try {\\n      for (var field in tiddler.fields) {\\n        var ipfsCid = null\\n        var ipnsCid = null\\n        var resolvedUrl = null\\n        const value = tiddler.getFieldString(field)\\n        var { ipfsCid, ipnsCid, resolvedUrl } = await $tw.ipfs.resolveUrl(value, false, false, true)\\n        if (ipfsCid == null && ipnsCid == null) {\\n          continue\\n        }\\n        $tw.ipfs.addToUnpin(resolvedUrl !== null ? resolvedUrl.pathname : null)\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n      $tw.utils.alert(name, error.message)\\n    }\\n    return tiddler\\n  }\\n\\n  IpfsTiddler.prototype.handleRefreshTiddler = function (event) {\\n    const title = event.tiddlerTitle\\n    const tiddler = $tw.wiki.getTiddler(title)\\n    // Ignore\\n    if (tiddler === undefined || title === '$:/plugins/tiddlywiki/menubar/items/pagecontrols') {\\n      return false\\n    }\\n    if (tiddler.fields.type === 'application/json' && tiddler.hasField('plugin-type')) {\\n      return false\\n    }\\n    // Process\\n    var canonicalUri = tiddler.fields._canonical_uri\\n    canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n    var importUri = tiddler.fields._import_uri\\n    importUri = importUri !== undefined && importUri !== null && importUri.trim() !== '' ? importUri.trim() : null\\n    // Reload\\n    if (canonicalUri !== null && importUri == null) {\\n      const updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        fields: [{ key: 'text', value: '' }],\\n      })\\n      $tw.wiki.addTiddler(updatedTiddler)\\n      return true\\n    }\\n    // Import\\n    if (canonicalUri !== null || importUri !== null) {\\n      const ipfsImport = new IpfsImport()\\n      ipfsImport\\n        .import(canonicalUri, importUri, tiddler)\\n        .then(data => {\\n          if (data !== undefined && data !== null) {\\n            if (data.merged.size > 0 || data.deleted.size > 0) {\\n              const navigator = $tw.utils.locateNavigatorWidget($tw.pageWidgetNode)\\n              if (navigator !== undefined && navigator !== null) {\\n                navigator.dispatchEvent({\\n                  type: 'tm-ipfs-import-tiddlers',\\n                  param: data,\\n                })\\n              }\\n            }\\n          }\\n        })\\n        .catch(error => {\\n          $tw.ipfs.getLogger().error(error)\\n          $tw.utils.alert(name, error.message)\\n        })\\n      return true\\n    }\\n    // Refresh\\n    $tw.wiki.clearCache(title)\\n    const changedTiddler = $tw.utils.getChangedTiddler(title)\\n    $tw.rootWidget.refresh(changedTiddler)\\n    return true\\n  }\\n\\n  IpfsTiddler.prototype.handleImportFile = async function (info) {\\n    const dummy = new $tw.Tiddler({\\n      title: $tw.wiki.generateNewTitle('Untitled'),\\n      type: info.type,\\n    })\\n    var type = null\\n    if (info !== undefined && info !== null && info.type !== undefined && info.type !== null) {\\n      type = info.type\\n    }\\n    if (type == null) {\\n      return false\\n    }\\n    if (type !== 'text/html' && type !== 'application/json' && type !== 'application/x-tiddler') {\\n      return false\\n    }\\n    try {\\n      const ipfsImport = new IpfsImport()\\n      const url = URL.createObjectURL(info.file)\\n      try {\\n        const data = await ipfsImport.import(null, url, dummy)\\n        if (data === undefined || data == null) {\\n          return false\\n        }\\n        if (data.merged.size > 0 || data.deleted.size > 0) {\\n          info.callback(data)\\n          return true\\n        }\\n      } catch (error) {\\n        $tw.ipfs.getLogger().error(error)\\n      } finally {\\n        URL.revokeObjectURL(url)\\n      }\\n    } catch (error) {\\n      $tw.ipfs.getLogger().error(error)\\n    }\\n    return false\\n  }\\n\\n  IpfsTiddler.prototype.handleSaveTiddler = async function (tiddler) {\\n    const oldTiddler = $tw.wiki.getTiddler(tiddler.fields.title)\\n    const { type, info } = $tw.utils.getContentType(tiddler)\\n    var password = tiddler.fields._password\\n    password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n    // Prepare\\n    var updatedTiddler = new $tw.Tiddler(tiddler)\\n    if (oldTiddler !== undefined && oldTiddler !== null) {\\n      // Title update\\n      if ($tw.utils.getWrappedDirectory() && tiddler.fields.title !== oldTiddler.fields.title) {\\n        // Process\\n        if (tiddler.fields._canonical_uri) {\\n        }\\n      }\\n      // Process deleted fields\\n      for (var field in oldTiddler.fields) {\\n        // Not a reserved keyword\\n        if ($tw.utils.isTiddlyWikiReservedWord(field)) {\\n          continue\\n        }\\n        // Updated\\n        const discard = tiddler.fields[field]\\n        if (discard && tiddler.getFieldString(field)) {\\n          continue\\n        }\\n        // Old value\\n        var oldResolvedUrl = null\\n        var oldValue = oldTiddler.getFieldString(field)\\n        try {\\n          var { resolvedUrl: oldResolvedUrl } = await $tw.ipfs.resolveUrl(oldValue, $tw.utils.getIpnsResolve(), false, true)\\n        } catch (error) {\\n          $tw.ipfs.getLogger().error(error)\\n          $tw.utils.alert(name, error.message)\\n          $tw.wiki.addTiddler(updatedTiddler)\\n          return updatedTiddler\\n        }\\n        // Deleted\\n        oldResolvedUrl = oldResolvedUrl !== undefined && oldResolvedUrl !== null && oldResolvedUrl.toString().trim() !== '' ? oldResolvedUrl.toString().trim() : null\\n        if (oldResolvedUrl !== null && field === '_canonical_uri') {\\n          var addTags = []\\n          var msg = 'Embed'\\n          var data = tiddler.fields.text\\n          try {\\n            if (info.encoding === 'base64') {\\n              addTags = ['$:/isAttachment', '$:/isEmbedded']\\n              msg = `${msg} attachment '${type}':`\\n              data = await $tw.ipfs.loadToBase64(oldResolvedUrl, password)\\n            } else if (type === 'image/svg+xml') {\\n              addTags = ['$:/isAttachment', '$:/isEmbedded']\\n              msg = `${msg} attachment '${type}':`\\n              data = await $tw.ipfs.loadToUtf8(oldResolvedUrl, password)\\n            } else if (oldTiddler.fields.text && oldTiddler.fields.text !== '') {\\n              msg = `${msg} '${type}':`\\n              data = oldTiddler.fields.text\\n            } else {\\n              msg = `${msg} '${type}':`\\n              data = await $tw.ipfs.loadToUtf8(oldResolvedUrl, password)\\n            }\\n            if (tiddler.fields.type === 'application/json' && tiddler.hasField('plugin-type')) {\\n              const innerData = JSON.parse(data)\\n              if (innerData.text !== undefined && innerData.text !== null && innerData.text !== '') {\\n                updatedTiddler = $tw.utils.updateTiddler({\\n                  tiddler: updatedTiddler,\\n                  addTags: addTags,\\n                  fields: [{ key: 'text', value: innerData.text }],\\n                })\\n                $tw.wiki.setPluginInfo(tiddler.fields.title, JSON.parse(innerData.text))\\n              }\\n            } else {\\n              updatedTiddler = $tw.utils.updateTiddler({\\n                tiddler: updatedTiddler,\\n                addTags: addTags,\\n                fields: [{ key: 'text', value: data }],\\n              })\\n            }\\n            $tw.ipfs.getLogger().info(\\n              `${msg} ${data.length}\\n ${oldResolvedUrl}`\\n            )\\n          } catch (error) {\\n            $tw.ipfs.getLogger().error(error)\\n            $tw.utils.alert(name, error.message)\\n            $tw.wiki.addTiddler(updatedTiddler)\\n            return updatedTiddler\\n          }\\n        }\\n        $tw.ipfs.addToUnpin(oldResolvedUrl !== null ? oldResolvedUrl.pathname : null)\\n      }\\n    }\\n    // Process exports\\n    var oldCanonicalUri = oldTiddler !== undefined && oldTiddler !== null ? oldTiddler.fields._canonical_uri : null\\n    oldCanonicalUri = oldCanonicalUri !== undefined && oldCanonicalUri !== null && oldCanonicalUri.trim() !== '' ? oldCanonicalUri.trim() : null\\n    var canonicalUri = tiddler.fields._canonical_uri\\n    canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.trim() !== '' ? canonicalUri.trim() : null\\n    const { ipnsCid, normalizedUrl } = await $tw.ipfs.resolveUrl(canonicalUri, false, false, true)\\n    // Process new canonical_uri\\n    if (oldCanonicalUri == null && ipnsCid !== null && canonicalUri !== null && tiddler.fields.text !== '') {\\n      const { info } = $tw.utils.getContentType(tiddler)\\n      const content = await $tw.ipfs.processContent(tiddler, tiddler.fields.text, info.encoding, type)\\n      var filename = '/'\\n      var incomingName = null\\n      if ($tw.utils.getWrappedDirectory()) {\\n        try {\\n          var path = null\\n          const pathname = normalizedUrl.pathname.slice(`/ipns/${ipnsCid}`.length)\\n          if (pathname !== undefined && pathname !== null && pathname.trim() !== '') {\\n            path = pathname.substring(0, pathname.lastIndexOf('/'))\\n            if (path !== undefined && path !== null && path.trim() !== '') {\\n              const incoming = pathname.split('/').pop()\\n              if (incoming !== undefined && incoming !== null && incoming.trim() !== '') {\\n                incomingName = decodeURI(incoming)\\n                filename = `${path}/${incomingName}`\\n              }\\n            }\\n          }\\n          if (filename === '/') {\\n            const url = $tw.ipfs.getUrl(tiddler.fields.title, $tw.ipfs.getIpfsBaseUrl())\\n            if (path === undefined || path == null || path.trim() === '') {\\n              path = url.pathname.substring(0, url.pathname.lastIndexOf('/'))\\n            }\\n            if (path !== undefined && path !== null && path.trim() !== '') {\\n              const incoming = url.pathname.split('/').pop()\\n              if (incoming !== undefined && incoming !== null && incoming.trim() !== '') {\\n                incomingName = decodeURI(incoming)\\n                filename = `${path}/${incomingName}`\\n              }\\n            }\\n          }\\n        } catch (error) {\\n          // Ignore\\n        }\\n        if (filename === '/') {\\n          incomingName = $tw.ipfs.filenamify(tiddler.fields.title)\\n          filename = `${filename}${incomingName}`\\n        } else {\\n          incomingName = $tw.ipfs.filenamify(filename.substring(filename.lastIndexOf('/') + 1))\\n          filename = `/${incomingName}`\\n        }\\n        if (filename.endsWith(info.extension) === false) {\\n          incomingName = `${incomingName}${info.extension}`\\n          filename = `${filename}${info.extension}`\\n        }\\n      }\\n      // Beware, async...\\n      const fields = [{ key: 'text', value: '' }]\\n      $tw.utils.exportToIpfs(tiddler, content, fields, '_canonical_uri', filename, incomingName)\\n    } else {\\n      updatedTiddler = await $tw.utils.processUpdatedTiddler(tiddler, oldTiddler, updatedTiddler)\\n    }\\n    $tw.wiki.addTiddler(updatedTiddler)\\n    return updatedTiddler\\n  }\\n\\n  exports.IpfsTiddler = IpfsTiddler\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-wrapper.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-wrapper.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-wrapper.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIPFS Wrapper\\n\\n\\\\*/\\n/*jslint node:true,browser:true*/\\n/*global $tw:false*/\\n'use strict'\\n\\nconst cidAnalyser = 'https://cid.ipfs.io/#'\\n\\nconst ipfsKeyword = 'ipfs'\\nconst ipnsKeyword = 'ipns'\\n\\n/*eslint no-unused-vars:\\\"off\\\"*/\\nconst name = 'ipfs-wrapper'\\n\\nvar IpfsWrapper = function (ipfsBundle) {\\n  this.ipfsBundle = ipfsBundle\\n  this.ipfsLibrary = ipfsBundle.ipfsLibrary\\n  this.ipfsUrl = ipfsBundle.ipfsUrl\\n}\\n\\nIpfsWrapper.prototype.getLogger = function () {\\n  return this.ipfsBundle.getLogger()\\n}\\n\\nIpfsWrapper.prototype.getWindowIpfsClient = async function () {\\n  // IPFS Companion\\n  try {\\n    const policy = await this.ipfsLibrary.getWindowIpfs()\\n    if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n      return policy\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to retrieve IPFS Companion...')\\n}\\n\\nIpfsWrapper.prototype.getHttpIpfsClient = async function (url) {\\n  // HTTP Client\\n  try {\\n    const { ipfs, provider } = await this.ipfsLibrary.getHttpIpfs(url)\\n    if (ipfs !== null && provider !== null) {\\n      return {\\n        ipfs: ipfs,\\n        provider: provider,\\n      }\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to retrieve an IPFS HTTP provider...')\\n}\\n\\nIpfsWrapper.prototype.getIpfsClient = async function (url) {\\n  try {\\n    var policy = null\\n    const ipfsProvider = $tw.utils.getIpfsProvider()\\n    if (ipfsProvider === 'window') {\\n      policy = await this.ipfsLibrary.getWindowIpfs()\\n    } else if (ipfsProvider === 'http') {\\n      policy = await this.ipfsLibrary.getHttpIpfs(url)\\n    } else {\\n      policy = await this.ipfsLibrary.getDefaultIpfs(url)\\n    }\\n    if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n      return policy\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to retrieve an IPFS provider...')\\n}\\n\\nIpfsWrapper.prototype.getIpnsIdentifier = async function (ipfs, identifier, resolveIpnsKey, base, path, ipnsKey) {\\n  identifier = identifier !== undefined && identifier !== null && identifier.toString().trim() !== '' ? identifier.toString().trim() : null\\n  ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.trim() !== '' ? ipnsKey.trim() : null\\n  if (identifier == null && ipnsKey == null) {\\n    throw new Error('Undefined IPNS identifiers...')\\n  }\\n  path = path !== undefined && path !== null && path.trim() !== '' ? path.trim() : ''\\n  var ipnsCid = null\\n  if (this.ipfsBundle.getCid(identifier) !== null) {\\n    ipnsCid = identifier\\n  }\\n  var found = false\\n  var keys = null\\n  if (resolveIpnsKey || ipnsCid == null) {\\n    try {\\n      keys = await this.getIpnsKeys(ipfs)\\n    } catch (error) {\\n      this.getLogger().error(error)\\n      $tw.utils.alert(name, 'Unable to resolve IPNS keys...')\\n    }\\n  }\\n  // Do our best\\n  if (keys !== null && keys !== undefined && Array.isArray(keys)) {\\n    if (ipnsKey !== null && identifier !== null) {\\n      for (var index = 0; index < keys.length; index++) {\\n        const cidv1b32 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base32', false).toString()\\n        const cidv1b36 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base36', false).toString()\\n        if ((keys[index].id === identifier || cidv1b32 === identifier || cidv1b36 === identifier) && keys[index].name === ipnsKey) {\\n          ipnsCid = keys[index].id\\n          found = true\\n          break\\n        }\\n      }\\n    } else if (ipnsKey !== null) {\\n      for (var index = 0; index < keys.length; index++) {\\n        if (keys[index].name === ipnsKey) {\\n          ipnsCid = keys[index].id\\n          found = true\\n          break\\n        }\\n      }\\n    } else {\\n      for (var index = 0; index < keys.length; index++) {\\n        const cidv1b32 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base32', false).toString()\\n        const cidv1b36 = this.ipfsBundle.cidToLibp2pKeyCidV1(keys[index].id, 'base36', false).toString()\\n        if (keys[index].id === identifier || cidv1b32 === identifier || cidv1b36 === identifier || keys[index].name === identifier) {\\n          ipnsCid = keys[index].id\\n          ipnsKey = keys[index].name\\n          found = true\\n          break\\n        }\\n      }\\n    }\\n    if (found === false) {\\n      if (this.ipfsBundle.getCid(identifier) == null) {\\n        throw new Error('Unknown IPNS identifier...')\\n      }\\n    }\\n  }\\n  // Path\\n  var normalizedUrl = null\\n  const startPath = `/${ipnsKeyword}/${ipnsCid}`\\n  if (path.startsWith(startPath)) {\\n    path = path.slice(startPath.length)\\n  }\\n  path = `${startPath}${path}`\\n  // Lets build an url, the resolver will do the final check, we cannot do more here\\n  if (found) {\\n    const cidv0 = this.ipfsBundle.cidToBase58CidV0(ipnsCid, false).toString()\\n    const cidv1b32 = this.ipfsBundle.cidToLibp2pKeyCidV1(cidv0, 'base32', false).toString()\\n    ipnsCid = this.ipfsBundle.cidToLibp2pKeyCidV1(cidv1b32, 'base36', false)\\n    normalizedUrl = this.ipfsUrl.normalizeUrl(path, base)\\n    this.getLogger().info(\\n      `Fetched IPNS key: '${ipnsKey}':\\n'dag-pb' \\\"cidv0\\\" (base58btc): ${cidAnalyser}${cidv0}\\nto 'libp2p-key' \\\"cidv1\\\" (base32): ${cidAnalyser}${cidv1b32}\\nto 'libp2p-key' \\\"cidv1\\\" (base36): ${cidAnalyser}${ipnsCid}\\n${normalizedUrl}`\\n    )\\n  } else {\\n    normalizedUrl = this.ipfsUrl.normalizeUrl(path, base)\\n    this.getLogger().info(\\n      `Unable to Fetch IPNS identifiers, default to\\n${normalizedUrl}`\\n    )\\n  }\\n  return {\\n    ipnsCid: ipnsCid !== null ? ipnsCid.toString() : null,\\n    ipnsKey: ipnsKey,\\n    normalizedUrl: normalizedUrl,\\n  }\\n}\\n\\nIpfsWrapper.prototype.generateIpnsCid = async function (ipfs, ipnsKey) {\\n  try {\\n    var ipnsCid = await this.ipfsLibrary.genKey(ipfs, ipnsKey)\\n    ipnsCid = this.ipfsBundle.cidToLibp2pKeyCidV1(ipnsCid, 'base36', true).toString()\\n    const url = this.ipfsUrl.normalizeUrl(`/${ipnsKeyword}/${ipnsCid}`)\\n    this.getLogger().info(\\n      `Generated IPNS cid with IPNS key '${ipnsKey}'\\n${url}`\\n    )\\n    return ipnsCid\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error(`Failed to generate IPNS cid with IPNS key '${ipnsKey}'...`)\\n}\\n\\nIpfsWrapper.prototype.removeIpnsKey = async function (ipfs, ipnsKey) {\\n  try {\\n    const ipnsCid = await this.ipfsLibrary.rmKey(ipfs, ipnsKey)\\n    this.getLogger().info(`Removed IPNS key: ${ipnsKey}`)\\n    return ipnsCid\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to remove an IPNS Key...')\\n}\\n\\nIpfsWrapper.prototype.renameIpnsKey = async function (ipfs, oldIpnsKey, newIpnsKey) {\\n  try {\\n    var { ipnsCid, was, now } = await this.ipfsLibrary.keyRename(ipfs, oldIpnsKey, newIpnsKey)\\n    ipnsCid = this.ipfsBundle.cidToLibp2pKeyCidV1(ipnsCid, 'base36', true).toString()\\n    this.getLogger().info(`Renamed IPNS key: ${was} with ${now}`)\\n    return {\\n      ipnsCid: ipnsCid,\\n      ipnsKey: now,\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to rename an IPNS key...')\\n}\\n\\nIpfsWrapper.prototype.getIpnsKeys = async function (ipfs) {\\n  try {\\n    this.getLogger().info('Fetch IPNS keys...')\\n    const keyList = await this.ipfsLibrary.keyList(ipfs)\\n    return keyList\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to fetch IPNS keys...')\\n}\\n\\nIpfsWrapper.prototype.fetchFromIpfs = async function (ipfs, cid) {\\n  cid = cid !== undefined && cid !== null && cid.toString().trim() !== '' ? cid.toString().trim() : null\\n  if (cid == null) {\\n    throw new Error('Undefined IPNS identifier...')\\n  }\\n  try {\\n    const pathname = `/${ipfsKeyword}/${cid}`\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    this.getLogger().info(`Fetch:\\n${url}`)\\n    const fetched = await this.ipfsLibrary.cat(ipfs, pathname)\\n    return fetched\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to fetch from IPFS...')\\n}\\n\\nIpfsWrapper.prototype.resolveIpfs = async function (ipfs, value, timeout) {\\n  value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n  if (value == null) {\\n    throw new Error('Undefined value...')\\n  }\\n  var cid = null\\n  var remainderPath = null\\n  try {\\n    var { cid, remainderPath } = await this.ipfsBundle.resolveIpfs(ipfs, value, timeout)\\n    if (cid !== null) {\\n      const url = this.ipfsUrl.normalizeUrl(`/ipfs/${cid}${remainderPath}`)\\n      this.getLogger().info(`Resolved IPFS path:\\n  ${url}`)\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n    $tw.utils.alert(name, 'Unable to resolve IPFS path...')\\n  }\\n  return {\\n    cid: cid,\\n    remainderPath: remainderPath,\\n  }\\n}\\n\\nIpfsWrapper.prototype.resolveIpfsContainer = async function (ipfs, value, timeout) {\\n  value = value !== undefined && value !== null && value.toString().trim() !== '' ? value.toString().trim() : null\\n  if (value == null) {\\n    throw new Error('Undefined value...')\\n  }\\n  var cid = null\\n  try {\\n    cid = await this.ipfsBundle.resolveIpfsContainer(ipfs, value, timeout)\\n    if (cid !== null) {\\n      const url = this.ipfsUrl.normalizeUrl(`/ipfs/${cid}`)\\n      this.getLogger().info(`Resolved IPFS container:\\n  ${url}`)\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  return cid\\n}\\n\\nIpfsWrapper.prototype.fetchDagNode = async function (ipfs, cid, timeout) {\\n  cid = cid !== undefined && cid !== null && cid.toString().trim() !== '' ? cid.toString().trim() : null\\n  if (cid == null) {\\n    throw new Error('Undefined IPFS cid...')\\n  }\\n  const options = {\\n    localResolve: false,\\n  }\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null\\n  if (timeout !== null) {\\n    options.timeout = timeout\\n  }\\n  var node = null\\n  try {\\n    node = this.ipfsBundle.dagGet(ipfs, cid, options)\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  return node\\n}\\n\\nIpfsWrapper.prototype.resolveIpnsKey = async function (ipfs, ipnsKey, timeout) {\\n  ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.toString().trim() !== '' ? ipnsKey.toString().trim() : null\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...')\\n  }\\n  const options = {\\n    nocache: false,\\n    recursive: true,\\n  }\\n  timeout = timeout !== undefined && timeout !== null ? timeout : null\\n  if (timeout !== null) {\\n    options.timeout = timeout\\n  }\\n  // The IPNS address you want to resolve.\\n  // eg: const addr = '/ipns/ipfs.io'\\n  const pathname = `/${ipnsKeyword}/${ipnsKey}`\\n  try {\\n    const url = this.ipfsUrl.normalizeUrl(pathname)\\n    const resolved = await this.ipfsLibrary.nameResolve(ipfs, pathname, options)\\n    const { ipfsCid } = this.ipfsBundle.getIpfsIdentifier(resolved)\\n    if (ipfsCid !== null) {\\n      const parsed = this.ipfsUrl.normalizeUrl(resolved)\\n      this.getLogger().info(\\n        `Resolved IPNS:\\n${url}\\n${parsed}`\\n      )\\n      return ipfsCid\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to resolve an IPNS key...')\\n}\\n\\nIpfsWrapper.prototype.addContentToIpfs = async function (ipfs, upload, wrapWithDirectory) {\\n  try {\\n    if (upload === undefined || upload == null) {\\n      throw new Error('Undefined content...')\\n    }\\n    wrapWithDirectory = wrapWithDirectory || $tw.utils.getWrappedDirectory()\\n    const options = {\\n      chunker: 'rabin-262144-524288-1048576',\\n      cidVersion: 0,\\n      hashAlg: 'sha2-256',\\n      pin: false,\\n      rawLeaves: false,\\n      wrapWithDirectory: wrapWithDirectory,\\n    }\\n    var cid = null\\n    var parentCid = null\\n    var parentSize = null\\n    var ipfsPath = upload.length === 1 ? upload[0].path : ''\\n    if (ipfsPath === '/') {\\n      options.wrapWithDirectory = false\\n    }\\n    const added = await this.ipfsLibrary.addAll(ipfs, upload, options)\\n    for (var [cid, details] of added.entries()) {\\n      if (details.path === '') {\\n        parentCid = cid\\n        parentSize = details.size\\n      }\\n    }\\n    const url = this.ipfsUrl.normalizeUrl(`/${ipfsKeyword}/${parentCid}${ipfsPath}`)\\n    this.getLogger().info(`Added: ${parentSize} bytes,\\n${url}`)\\n    return {\\n      cid: parentCid,\\n      path: `/ipfs/${parentCid}${ipfsPath}`,\\n      size: parentSize,\\n      uri: `ipfs://${parentCid}${ipfsPath}`,\\n    }\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to add content to IPFS...')\\n}\\n\\nIpfsWrapper.prototype.publishIpnsKey = async function (ipfs, ipfsCid, ipnsCid, ipnsKey, options) {\\n  ipfsCid = ipfsCid !== undefined && ipfsCid !== null && ipfsCid.toString().trim() !== '' ? ipfsCid.toString().trim() : null\\n  if (ipfsCid == null) {\\n    throw new Error('Undefined IPFS cid...')\\n  }\\n  ipnsCid = ipnsCid !== undefined && ipnsCid !== null && ipnsCid.trim() !== '' ? ipnsCid.trim() : null\\n  if (ipnsCid == null) {\\n    throw new Error('Undefined IPNS cid...')\\n  }\\n  ipnsKey = ipnsKey !== undefined && ipnsKey !== null && ipnsKey.toString().trim() !== '' ? ipnsKey.toString().trim() : null\\n  if (ipnsKey == null) {\\n    throw new Error('Undefined IPNS key...')\\n  }\\n  // Path\\n  try {\\n    // Publish\\n    const result = await this.ipfsBundle.namePublish(ipfs, ipnsKey, ipfsCid, options)\\n    const ipnsUrl = this.ipfsUrl.normalizeUrl(`/${ipnsKeyword}/${ipnsCid}`)\\n    const ipfsUrl = this.ipfsUrl.normalizeUrl(`/${ipfsKeyword}/${ipfsCid}`)\\n    this.getLogger().info(\\n      `Published IPNS key: ${ipnsKey}\\n${ipnsUrl}\\n${ipfsUrl}`\\n    )\\n    return result\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to publish an IPNS key...')\\n}\\n\\nIpfsWrapper.prototype.pinToIpfs = async function (ipfs, ipfsPath, recursive) {\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...')\\n  }\\n  try {\\n    const pinned = await this.ipfsLibrary.pinAdd(ipfs, ipfsPath, {\\n      recursive: recursive,\\n    })\\n    const url = this.ipfsUrl.normalizeUrl(ipfsPath)\\n    this.getLogger().info(\\n      `Pinned:\\n${url}`\\n    )\\n    return pinned\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to pin...')\\n}\\n\\nIpfsWrapper.prototype.unpinFromIpfs = async function (ipfs, ipfsPath, recursive) {\\n  ipfsPath = ipfsPath !== undefined && ipfsPath !== null && ipfsPath.toString().trim() !== '' ? ipfsPath.toString().trim() : null\\n  if (ipfsPath == null) {\\n    throw new Error('Undefined IPFS path...')\\n  }\\n  try {\\n    const unpinned = await this.ipfsLibrary.pinRm(ipfs, ipfsPath, {\\n      recursive: recursive,\\n    })\\n    const url = this.ipfsUrl.normalizeUrl(ipfsPath)\\n    this.getLogger().info(\\n      `Unpinned:\\n${url}`\\n    )\\n    return unpinned\\n  } catch (error) {\\n    this.getLogger().error(error)\\n  }\\n  throw new Error('Failed to unpin...')\\n}\\n\\nexports.IpfsWrapper = IpfsWrapper\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/core/modules/macros/infosaver.js\": {\n            \"title\": \"$:/core/modules/macros/infosaver.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/macros/infosaver.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  exports.name = 'infosaver'\\n\\n  exports.params = [{ name: 'tiddler' }]\\n\\n  exports.run = function (tiddler) {\\n    return $tw.saverHandler.getSaver(tiddler).module.info.name\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-console-tooltip.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-console-tooltip.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macros/ipfs-console-tooltip.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  exports.name = 'ipfs-console-tooltip'\\n\\n  exports.params = []\\n\\n  exports.run = function () {\\n    var tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Hint')\\n    if (typeof window.eruda === 'undefined') {\\n      tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Load')\\n    } else if ($tw.ipfs.ipfsAction !== undefined) {\\n      if ($tw.ipfs.ipfsAction.console) {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Hide')\\n      } else {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Console/Mobile/Show')\\n      }\\n    }\\n    return tiddler.fields.text\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-edition-build.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-edition-build.js\",\n            \"text\": \"/*\\\\\\ntitle:  $:/plugins/ipfs/macros/ipfs-edition-build.js\\ntype: application/javascript\\nmodule-type: macro\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.name = 'ipfs-edition-build'\\n\\n  exports.params = []\\n\\n  exports.run = function () {\\n    if ($tw && $tw.wiki) {\\n      const build = $tw.wiki.getTiddler('$:/ipfs/edition-build')\\n      if (build !== undefined && build !== null) {\\n        return build.fields.build\\n      }\\n      if ($tw.utils && $tw.utils.getIpfsEditionBuild) {\\n        return $tw.utils.getIpfsEditionBuild()\\n      }\\n    }\\n    return ''\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-edition-version.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-edition-version.js\",\n            \"text\": \"/*\\\\\\ntitle:  $:/plugins/ipfs/macros/ipfs-edition-version.js\\ntype: application/javascript\\nmodule-type: macro\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.name = 'ipfs-edition-version'\\n\\n  exports.params = []\\n\\n  exports.run = function () {\\n    if ($tw && $tw.wiki) {\\n      const build = $tw.wiki.getTiddler('$:/ipfs/edition-build')\\n      if (build !== undefined && build !== null) {\\n        return build.fields.version\\n      }\\n      if ($tw.utils && $tw.utils.getIpfsEditionVersion) {\\n        return $tw.utils.getIpfsEditionVersion()\\n      }\\n    }\\n    return ''\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/ipfs-encryption-tooltip.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/ipfs-encryption-tooltip.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macros/ipfs-encryption-tooltip.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  exports.name = 'ipfs-encryption-tooltip'\\n\\n  exports.params = []\\n\\n  exports.run = function () {\\n    var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\\n    if (encrypted !== undefined && encrypted !== null && encrypted.fields.text === 'yes') {\\n      encrypted = true\\n    } else {\\n      encrypted = false\\n    }\\n    var tiddler\\n    var encryption = $tw.wiki.getTiddler('$:/config/encryption')\\n    if (encrypted) {\\n      tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/ClearEncryptionPublicKey/Hint')\\n      if (encryption.fields.text === 'standford') {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/ClearPassword/Hint')\\n      }\\n    } else {\\n      tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/SetEncryptionPublicKey/Hint')\\n      if (encryption.fields.text === 'standford') {\\n        tiddler = $tw.wiki.getTiddler('$:/language/Buttons/Encryption/SetPassword/Hint')\\n      }\\n    }\\n    return tiddler.fields.text\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/core/modules/macros/jsontiddler.js\": {\n            \"title\": \"$:/core/modules/macros/jsontiddler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/macros/jsontiddler.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nMacro to output a single tiddler to JSON\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.name = 'jsontiddler'\\n\\n  exports.params = [{ name: 'title' }]\\n\\n  exports.run = function (title) {\\n    title = title || this.getVariable('currentTiddler')\\n    var tiddler = !!title && this.wiki.getTiddler(title)\\n    var fields = {}\\n    if (tiddler) {\\n      for (var field in tiddler.fields) {\\n        fields[field] = tiddler.getFieldString(field)\\n      }\\n    }\\n    var content = JSON.stringify(fields, null, $tw.config.preferences.jsonSpaces)\\n    var compress = $tw.wiki.getTiddler('$:/isCompressed')\\n    compress = compress !== undefined ? compress.fields.text === 'yes' : false\\n    if (compress) {\\n      content = { compressed: $tw.compress.deflate(content) }\\n    }\\n    var encrypt = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypt = encrypt !== undefined ? encrypt.fields.text === 'yes' : false\\n    if (encrypt) {\\n      content.compressed = $tw.crypto.encrypt(compress ? content.compressed : content)\\n      if ($tw.crypto.hasEncryptionPublicKey()) {\\n        content.keccak256 = $tw.crypto.keccak256(compress ? content.compressed : content)\\n      }\\n    }\\n    if (compress || encrypt) {\\n      content = JSON.stringify(content)\\n    }\\n    return content\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/core/modules/macros/jsontiddlers.js\": {\n            \"title\": \"$:/core/modules/macros/jsontiddlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/macros/jsontiddlers.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nMacro to output tiddlers matching a filter to JSON\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  exports.name = 'jsontiddlers'\\n\\n  exports.params = [{ name: 'filter' }, { name: 'spaces' }]\\n\\n  exports.run = function (filter, spaces) {\\n    var content = this.wiki.getTiddlersAsJson(filter, $tw.utils.parseInt(spaces))\\n    var compress = $tw.wiki.getTiddler('$:/isCompressed')\\n    compress = compress !== undefined ? compress.fields.text === 'yes' : false\\n    if (compress) {\\n      content = { compressed: $tw.compress.deflate(content) }\\n    }\\n    var encrypt = $tw.wiki.getTiddler('$:/isEncrypted')\\n    encrypt = encrypt !== undefined ? encrypt.fields.text === 'yes' : false\\n    if (encrypt) {\\n      content.compressed = $tw.crypto.encrypt(compress ? content.compressed : content)\\n      if ($tw.crypto.hasEncryptionPublicKey()) {\\n        content.keccak256 = $tw.crypto.keccak256(compress ? content.compressed : content)\\n      }\\n    }\\n    if (compress || encrypt) {\\n      content = JSON.stringify(content)\\n    }\\n    return content\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/macros/version-url.js\": {\n            \"title\": \"$:/plugins/ipfs/macros/version-url.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macros/version-url.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  exports.name = 'version-url'\\n\\n  exports.params = [{ name: 'title' }, { name: 'ipath' }]\\n\\n  exports.run = function (title, ipath) {\\n    title = title !== undefined && title !== null && title.trim() !== '' ? title.trim() : null\\n    if (title === null) {\\n      return ''\\n    }\\n    ipath = ipath !== undefined && ipath !== null && ipath.trim() !== '' ? ipath.trim() : ''\\n    const rootBuild = $tw !== undefined && $tw !== null ? $tw.wiki.getTiddler('$:/ipfs/build/ipns/cid') : null\\n    const tiddler = $tw !== undefined && $tw !== null ? $tw.wiki.getTiddler(title) : null\\n    if (rootBuild !== undefined && rootBuild !== null && tiddler !== undefined && tiddler !== null) {\\n      if (ipath === 'editions') {\\n        return `${rootBuild.fields.text}/editions/${tiddler.fields.name}/${tiddler.fields.build}/`\\n      } else {\\n        return `${rootBuild.fields.text}/${ipath}/${tiddler.fields.build}/`\\n      }\\n    }\\n    return ''\\n  }\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/core/modules/parsers/audioparser.js\": {\n            \"title\": \"$:/core/modules/parsers/audioparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/audioparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe audio parser parses an audio tiddler into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  var name = 'ipfs-audioparser'\\n\\n  var AudioParser = function (type, text, options) {\\n    var value = `data:${type};base64,`\\n    var element = {\\n      type: 'element',\\n      tag: 'audio',\\n      attributes: {\\n        controls: { type: 'string', value: 'controls' },\\n        style: { type: 'string', value: 'width: 100%; object-fit: contain' },\\n      },\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToBase64(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['audio/ogg'] = AudioParser\\n  exports['audio/mpeg'] = AudioParser\\n  exports['audio/mp3'] = AudioParser\\n  exports['audio/mp4'] = AudioParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/binaryparser.js\": {\n            \"title\": \"$:/core/modules/parsers/binaryparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/binaryparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe binary parser parses a binary tiddler into a warning message and download link\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars:\\\"off\\\"*/\\n  const name = 'ipfs-binaryparser'\\n\\n  var BINARY_WARNING_MESSAGE = '$:/core/ui/BinaryWarning'\\n  var EXPORT_BUTTON_IMAGE = '$:/core/images/export-button'\\n\\n  var BinaryParser = function (type, text, options) {\\n    var self = this\\n    var value = `data:${type};base64,`\\n    // Transclude the binary data tiddler warning message\\n    var warn = {\\n      type: 'element',\\n      tag: 'p',\\n      children: [\\n        {\\n          type: 'transclude',\\n          attributes: {\\n            tiddler: { type: 'string', value: BINARY_WARNING_MESSAGE },\\n          },\\n        },\\n      ],\\n    }\\n    // Create download link based on binary tiddler title\\n    var link = {\\n      type: 'element',\\n      tag: 'a',\\n      attributes: {\\n        title: { type: 'indirect', textReference: '!!title' },\\n        download: { type: 'indirect', textReference: '!!title' },\\n      },\\n      children: [\\n        {\\n          type: 'transclude',\\n          attributes: {\\n            tiddler: { type: 'string', value: EXPORT_BUTTON_IMAGE },\\n          },\\n        },\\n      ],\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToBase64(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    link.attributes.href = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        link.attributes.href = {\\n          type: 'string',\\n          value: `${value}${text}`,\\n        }\\n      }\\n    }\\n    // Combine warning message and download link in a div\\n    var element = {\\n      type: 'element',\\n      tag: 'div',\\n      attributes: {\\n        class: { type: 'string', value: 'tc-binary-warning' },\\n      },\\n      children: [warn, link],\\n    }\\n    this.tree = [element]\\n  }\\n\\n  exports['application/octet-stream'] = BinaryParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/csvparser.js\": {\n            \"title\": \"$:/core/modules/parsers/csvparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/csvparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe CSV text parser processes CSV files into a table wrapped in a scrollable widget\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-cvsparser'\\n\\n  var CsvParser = function (type, text, options) {\\n    var self = this\\n    // Table framework\\n    this.tree = [\\n      {\\n        type: 'scrollable',\\n        children: [\\n          {\\n            type: 'element',\\n            tag: 'table',\\n            children: [\\n              {\\n                type: 'element',\\n                tag: 'tbody',\\n                children: [],\\n              },\\n            ],\\n            attributes: {\\n              class: { type: 'string', value: 'tc-csv-table' },\\n            },\\n          },\\n        ],\\n      },\\n    ]\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    self.split(data)\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        this.split(text)\\n      }\\n    }\\n  }\\n\\n  CsvParser.prototype.split = function (text) {\\n    // Split the text into lines\\n    var lines = text.split(/\\\\r?\\\\n/gm)\\n    var tag = 'th'\\n    for (var line = 0; line < lines.length; line++) {\\n      var lineText = lines[line]\\n      if (lineText) {\\n        var row = {\\n          type: 'element',\\n          tag: 'tr',\\n          children: [],\\n        }\\n        var columns = lineText.split(',')\\n        for (var column = 0; column < columns.length; column++) {\\n          row.children.push({\\n            type: 'element',\\n            tag: tag,\\n            children: [\\n              {\\n                type: 'text',\\n                text: columns[column],\\n              },\\n            ],\\n          })\\n        }\\n        tag = 'td'\\n        this.tree[0].children[0].children[0].children.push(row)\\n      }\\n    }\\n  }\\n  exports['text/csv'] = CsvParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/htmlparser.js\": {\n            \"title\": \"$:/core/modules/parsers/htmlparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/htmlparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe HTML parser displays text as raw HTML\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-htmlparser'\\n\\n  var HtmlParser = function (type, text, options) {\\n    var src = ''\\n    var self = this\\n    var value = 'data:text/html;charset=utf-8,'\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              self.tree[0].attributes.src = { type: 'string', value: resolvedUrl.href }\\n              var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n              $tw.rootWidget.refresh(parsedTiddler)\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        src = `${value}${encodeURIComponent(text)}`\\n      }\\n    }\\n    this.tree = [\\n      {\\n        type: 'element',\\n        tag: 'iframe',\\n        attributes: {\\n          src: { type: 'string', value: src },\\n        },\\n      },\\n    ]\\n    if ($tw.wiki.getTiddlerText('$:/config/HtmlParser/DisableSandbox', 'no') !== 'yes') {\\n      var tokens = $tw.wiki.getTiddlerText('$:/config/HtmlParser/SandboxTokens', '')\\n      if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n        var tiddlerTokens = options.tiddler.getFieldString('_sandbox_tokens')\\n        tiddlerTokens = tiddlerTokens !== undefined && tiddlerTokens !== null && tiddlerTokens.trim() !== '' ? tiddlerTokens.trim() : null\\n        if (tiddlerTokens !== null) {\\n          tokens = tiddlerTokens\\n        }\\n      }\\n      this.tree[0].attributes.sandbox = { type: 'string', value: tokens }\\n    }\\n  }\\n\\n  exports['text/html'] = HtmlParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/imageparser.js\": {\n            \"title\": \"$:/core/modules/parsers/imageparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/imageparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe image parser parses an image into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  var name = 'ipfs-imageparser'\\n\\n  var ImageParser = function (type, text, options) {\\n    var value = `data:${type};base64,`\\n    var element = {\\n      type: 'element',\\n      tag: 'img',\\n      attributes: {},\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToBase64(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['image/gif'] = ImageParser\\n  exports['image/heic'] = ImageParser\\n  exports['image/heif'] = ImageParser\\n  exports['image/jpeg'] = ImageParser\\n  exports['image/jpg'] = ImageParser\\n  exports['image/png'] = ImageParser\\n  exports['image/vnd.microsoft.icon'] = ImageParser\\n  exports['image/webp'] = ImageParser\\n  exports['image/x-icon'] = ImageParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/pdfparser.js\": {\n            \"title\": \"$:/core/modules/parsers/pdfparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/pdfparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe PDF parser embeds a PDF viewer\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-pdfparser'\\n\\n  var PdfParser = function (type, text, options) {\\n    var value = 'data:application/pdf;base64,'\\n    var element = {\\n      type: 'element',\\n      tag: 'object',\\n      attributes: {},\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToBase64(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['application/pdf'] = PdfParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/svgparser.js\": {\n            \"title\": \"$:/core/modules/parsers/svgparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/svgparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe image parser parses an image into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-svgparser'\\n\\n  var SvgParser = function (type, text, options) {\\n    var value = 'data:image/svg+xml;utf8,'\\n    var element = {\\n      type: 'element',\\n      tag: 'img',\\n      attributes: {},\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${encodeURIComponent(data)}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        element.attributes.src = {\\n          type: 'string',\\n          value: `${value}${encodeURIComponent(text)}`,\\n        }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['image/svg+xml'] = SvgParser\\n  exports['.svg'] = SvgParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/textparser.js\": {\n            \"title\": \"$:/core/modules/parsers/textparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/textparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe plain text parser processes blocks of source text into a degenerate parse tree consisting of a single text node\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-textparser'\\n\\n  var TextParser = function (type, text, options) {\\n    var element = {\\n      type: 'codeblock',\\n      attributes: {\\n        code: { type: 'string', value: text !== undefined && text !== null ? text : '' },\\n        language: { type: 'string', value: type },\\n      },\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToUtf8(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.code.value = data\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['application/javascript'] = TextParser\\n  exports['application/json'] = TextParser\\n  exports['application/x-tiddler-dictionary'] = TextParser\\n  exports['text/css'] = TextParser\\n  exports['text/plain'] = TextParser\\n  exports['text/x-tiddlywiki'] = TextParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/videoparser.js\": {\n            \"title\": \"$:/core/modules/parsers/videoparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/videoparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe video parser parses a video tiddler into an embeddable HTML element\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  /*eslint no-unused-vars: \\\"off\\\"*/\\n  const name = 'ipfs-videoparser'\\n\\n  var VideoParser = function (type, text, options) {\\n    var value = `data:${type};base64,`\\n    var element = {\\n      type: 'element',\\n      tag: 'video',\\n      attributes: {\\n        controls: { type: 'string', value: 'controls' },\\n        style: { type: 'string', value: 'width: 100%; object-fit: contain' },\\n      },\\n    }\\n    if ($tw.browser && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      if ((text || '') === '' && canonicalUri !== null) {\\n        var password = options.tiddler.fields._password\\n        password = password !== undefined && password !== null && password.trim() !== '' ? password.trim() : null\\n        $tw.ipfs\\n          .resolveUrl(canonicalUri, false, false, false)\\n          .then(data => {\\n            var { resolvedUrl } = data\\n            if (resolvedUrl !== null) {\\n              $tw.ipfs\\n                .loadToBase64(resolvedUrl, password)\\n                .then(data => {\\n                  if (data) {\\n                    element.attributes.src = {\\n                      type: 'string',\\n                      value: `${value}${data}`,\\n                    }\\n                    var parsedTiddler = $tw.utils.getChangedTiddler(options.tiddler)\\n                    $tw.rootWidget.refresh(parsedTiddler)\\n                  }\\n                })\\n                .catch(error => {\\n                  $tw.ipfs.getLogger().error(error)\\n                  $tw.utils.alert(name, error.message)\\n                })\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n          })\\n      } else if (text !== undefined && text !== null) {\\n        element.attributes.src = { type: 'string', value: `${value}${text}` }\\n      }\\n    }\\n    // Return the parsed tree\\n    this.tree = [element]\\n  }\\n\\n  exports['video/mp4'] = VideoParser\\n  exports['video/ogg'] = VideoParser\\n  exports['video/quicktime'] = VideoParser\\n  exports['video/webm'] = VideoParser\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/parsers/wikiparser/wikiparser.js\": {\n            \"title\": \"$:/core/modules/parsers/wikiparser/wikiparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/parsers/wikiparser/wikiparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe wiki text parser processes blocks of source text into a parse tree.\\n\\nThe parse tree is made up of nested arrays of these JavaScript objects:\\n\\n\\t{type: \\\"element\\\", tag: <string>, attributes: {}, children: []} - an HTML element\\n\\t{type: \\\"text\\\", text: <string>} - a text node\\n\\t{type: \\\"entity\\\", value: <string>} - an entity\\n\\t{type: \\\"raw\\\", html: <string>} - raw HTML\\n\\nAttributes are stored as hashmaps of the following objects:\\n\\n\\t{type: \\\"string\\\", value: <string>} - literal string\\n\\t{type: \\\"indirect\\\", textReference: <textReference>} - indirect through a text reference\\n\\t{type: \\\"macro\\\", macro: <TBD>} - indirect through a macro invocation\\n\\n\\\\*/\\n;(function () {\\n  /*jslint node:true,browser:true*/\\n  /*global $tw:false*/\\n  'use strict'\\n\\n  const IpfsImport = require('$:/plugins/ipfs/ipfs-import.js').IpfsImport\\n\\n  var name = 'ipfs-wikiparser'\\n\\n  var WikiParser = function (type, text, options) {\\n    this.wiki = options.wiki\\n    // Check for an externally linked tiddler\\n    if ($tw.browser && (text || '') === '' && options.tiddler !== undefined && options.tiddler !== null) {\\n      var canonicalUri = options.tiddler.fields._canonical_uri\\n      canonicalUri = canonicalUri !== undefined && canonicalUri !== null && canonicalUri.toString().trim() !== '' ? canonicalUri.toString().trim() : null\\n      var importUri = options.tiddler.fields._import_uri\\n      importUri = importUri !== undefined && importUri !== null && importUri.toString().trim() !== '' ? importUri.toString().trim() : null\\n      if (canonicalUri !== null || importUri !== null) {\\n        var ipfsImport = new IpfsImport()\\n        ipfsImport\\n          .import(canonicalUri, importUri, options.tiddler)\\n          .then(data => {\\n            if (data !== undefined && data !== null) {\\n              if (data.merged.size > 0 || data.deleted.size > 0) {\\n                const navigator = $tw.utils.locateNavigatorWidget($tw.pageWidgetNode)\\n                if (navigator) {\\n                  navigator.dispatchEvent({\\n                    type: 'tm-ipfs-import-tiddlers',\\n                    param: data,\\n                  })\\n                }\\n              }\\n            }\\n          })\\n          .catch(error => {\\n            $tw.ipfs.getLogger().error(error)\\n            $tw.utils.alert(name, error.message)\\n          })\\n        text = `''${$tw.language.getRawString('LazyLoadingWarning')}''`\\n      }\\n    }\\n    // Save the parse text\\n    this.type = type || 'text/vnd.tiddlywiki'\\n    this.source = text || ''\\n    this.sourceLength = this.source.length\\n    // Flag for ignoring whitespace\\n    this.configTrimWhiteSpace = false\\n    // Set current parse position\\n    this.pos = 0\\n    // Start with empty output\\n    this.tree = []\\n    // Assemble the rule classes we're going to use\\n    var pragmaRuleClasses, blockRuleClasses, inlineRuleClasses\\n    if (options.rules) {\\n      pragmaRuleClasses = options.rules.pragma\\n      blockRuleClasses = options.rules.block\\n      inlineRuleClasses = options.rules.inline\\n    } else {\\n      // Setup the rule classes if we don't have them already\\n      if (!this.pragmaRuleClasses) {\\n        WikiParser.prototype.pragmaRuleClasses = $tw.modules.createClassesFromModules('wikirule', 'pragma', $tw.WikiRuleBase)\\n        this.setupRules(WikiParser.prototype.pragmaRuleClasses, '$:/config/WikiParserRules/Pragmas/')\\n      }\\n      pragmaRuleClasses = this.pragmaRuleClasses\\n      if (!this.blockRuleClasses) {\\n        WikiParser.prototype.blockRuleClasses = $tw.modules.createClassesFromModules('wikirule', 'block', $tw.WikiRuleBase)\\n        this.setupRules(WikiParser.prototype.blockRuleClasses, '$:/config/WikiParserRules/Block/')\\n      }\\n      blockRuleClasses = this.blockRuleClasses\\n      if (!this.inlineRuleClasses) {\\n        WikiParser.prototype.inlineRuleClasses = $tw.modules.createClassesFromModules('wikirule', 'inline', $tw.WikiRuleBase)\\n        this.setupRules(WikiParser.prototype.inlineRuleClasses, '$:/config/WikiParserRules/Inline/')\\n      }\\n      inlineRuleClasses = this.inlineRuleClasses\\n    }\\n    // Instantiate the pragma parse rules\\n    this.pragmaRules = this.instantiateRules(pragmaRuleClasses, 'pragma', 0)\\n    // Instantiate the parser block and inline rules\\n    this.blockRules = this.instantiateRules(blockRuleClasses, 'block', 0)\\n    this.inlineRules = this.instantiateRules(inlineRuleClasses, 'inline', 0)\\n    // Parse any pragmas\\n    var topBranch = this.parsePragmas()\\n    // Parse the text into inline runs or blocks\\n    if (options.parseAsInline) {\\n      topBranch.push.apply(topBranch, this.parseInlineRun())\\n    } else {\\n      topBranch.push.apply(topBranch, this.parseBlocks())\\n    }\\n    // Return the parsed tree\\n  }\\n\\n  /*\\n   */\\n  WikiParser.prototype.setupRules = function (proto, configPrefix) {\\n    var self = this\\n    if (!$tw.safemode) {\\n      $tw.utils.each(proto, function (object, name) {\\n        if (self.wiki.getTiddlerText(configPrefix + name, 'enable') !== 'enable') {\\n          delete proto[name]\\n        }\\n      })\\n    }\\n  }\\n\\n  /*\\nInstantiate an array of parse rules\\n*/\\n  WikiParser.prototype.instantiateRules = function (classes, type, startPos) {\\n    var rulesInfo = []\\n    var self = this\\n    $tw.utils.each(classes, function (RuleClass) {\\n      // Instantiate the rule\\n      var rule = new RuleClass(self)\\n      rule.is = {}\\n      rule.is[type] = true\\n      rule.init(self)\\n      var matchIndex = rule.findNextMatch(startPos)\\n      if (matchIndex !== undefined) {\\n        rulesInfo.push({\\n          rule: rule,\\n          matchIndex: matchIndex,\\n        })\\n      }\\n    })\\n    return rulesInfo\\n  }\\n\\n  /*\\nSkip any whitespace at the current position. Options are:\\n  treatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace\\n*/\\n  WikiParser.prototype.skipWhitespace = function (options) {\\n    options = options || {}\\n    var whitespaceRegExp = options.treatNewlinesAsNonWhitespace ? /([^\\\\S\\\\n]+)/gm : /(\\\\s+)/gm\\n    whitespaceRegExp.lastIndex = this.pos\\n    var whitespaceMatch = whitespaceRegExp.exec(this.source)\\n    if (whitespaceMatch && whitespaceMatch.index === this.pos) {\\n      this.pos = whitespaceRegExp.lastIndex\\n    }\\n  }\\n\\n  /*\\nGet the next match out of an array of parse rule instances\\n*/\\n  WikiParser.prototype.findNextMatch = function (rules, startPos) {\\n    // Find the best matching rule by finding the closest match position\\n    var matchingRule\\n    var matchingRulePos = this.sourceLength\\n    // Step through each rule\\n    for (var t = 0; t < rules.length; t++) {\\n      var ruleInfo = rules[t]\\n      // Ask the rule to get the next match if we've moved past the current one\\n      if (ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex < startPos) {\\n        ruleInfo.matchIndex = ruleInfo.rule.findNextMatch(startPos)\\n      }\\n      // Adopt this match if it's closer than the current best match\\n      if (ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex <= matchingRulePos) {\\n        matchingRule = ruleInfo\\n        matchingRulePos = ruleInfo.matchIndex\\n      }\\n    }\\n    return matchingRule\\n  }\\n\\n  /*\\nParse any pragmas at the beginning of a block of parse text\\n*/\\n  WikiParser.prototype.parsePragmas = function () {\\n    var currentTreeBranch = this.tree\\n    while (true) {\\n      // Skip whitespace\\n      this.skipWhitespace()\\n      // Check for the end of the text\\n      if (this.pos >= this.sourceLength) {\\n        break\\n      }\\n      // Check if we've arrived at a pragma rule match\\n      var nextMatch = this.findNextMatch(this.pragmaRules, this.pos)\\n      // If not, just exit\\n      if (!nextMatch || nextMatch.matchIndex !== this.pos) {\\n        break\\n      }\\n      // Process the pragma rule\\n      var subTree = nextMatch.rule.parse()\\n      if (subTree.length > 0) {\\n        // Quick hack; we only cope with a single parse tree node being returned, which is true at the moment\\n        currentTreeBranch.push.apply(currentTreeBranch, subTree)\\n        subTree[0].children = []\\n        currentTreeBranch = subTree[0].children\\n      }\\n    }\\n    return currentTreeBranch\\n  }\\n\\n  /*\\nParse a block from the current position\\n  terminatorRegExpString: optional regular expression string that identifies the end of plain paragraphs. Must not include capturing parenthesis\\n*/\\n  WikiParser.prototype.parseBlock = function (terminatorRegExpString) {\\n    var terminatorRegExp = terminatorRegExpString ? new RegExp('(' + terminatorRegExpString + '|\\\\\\\\r?\\\\\\\\n\\\\\\\\r?\\\\\\\\n)', 'mg') : /(\\\\r?\\\\n\\\\r?\\\\n)/gm\\n    this.skipWhitespace()\\n    if (this.pos >= this.sourceLength) {\\n      return []\\n    }\\n    // Look for a block rule that applies at the current position\\n    var nextMatch = this.findNextMatch(this.blockRules, this.pos)\\n    if (nextMatch && nextMatch.matchIndex === this.pos) {\\n      return nextMatch.rule.parse()\\n    }\\n    // Treat it as a paragraph if we didn't find a block rule\\n    return [\\n      {\\n        type: 'element',\\n        tag: 'p',\\n        children: this.parseInlineRun(terminatorRegExp),\\n      },\\n    ]\\n  }\\n\\n  /*\\nParse a series of blocks of text until a terminating regexp is encountered or the end of the text\\n  terminatorRegExpString: terminating regular expression\\n*/\\n  WikiParser.prototype.parseBlocks = function (terminatorRegExpString) {\\n    if (terminatorRegExpString) {\\n      return this.parseBlocksTerminated(terminatorRegExpString)\\n    } else {\\n      return this.parseBlocksUnterminated()\\n    }\\n  }\\n\\n  /*\\nParse a block from the current position to the end of the text\\n*/\\n  WikiParser.prototype.parseBlocksUnterminated = function () {\\n    var tree = []\\n    while (this.pos < this.sourceLength) {\\n      tree.push.apply(tree, this.parseBlock())\\n    }\\n    return tree\\n  }\\n\\n  /*\\nParse blocks of text until a terminating regexp is encountered\\n*/\\n  WikiParser.prototype.parseBlocksTerminated = function (terminatorRegExpString) {\\n    var terminatorRegExp = new RegExp('(' + terminatorRegExpString + ')', 'mg')\\n    var tree = []\\n    // Skip any whitespace\\n    this.skipWhitespace()\\n    //  Check if we've got the end marker\\n    terminatorRegExp.lastIndex = this.pos\\n    var match = terminatorRegExp.exec(this.source)\\n    // Parse the text into blocks\\n    while (this.pos < this.sourceLength && !(match && match.index === this.pos)) {\\n      var blocks = this.parseBlock(terminatorRegExpString)\\n      tree.push.apply(tree, blocks)\\n      // Skip any whitespace\\n      this.skipWhitespace()\\n      //  Check if we've got the end marker\\n      terminatorRegExp.lastIndex = this.pos\\n      match = terminatorRegExp.exec(this.source)\\n    }\\n    if (match && match.index === this.pos) {\\n      this.pos = match.index + match[0].length\\n    }\\n    return tree\\n  }\\n\\n  /*\\nParse a run of text at the current position\\n  terminatorRegExp: a regexp at which to stop the run\\n  options: see below\\nOptions available:\\n  eatTerminator: move the parse position past any encountered terminator (default false)\\n*/\\n  WikiParser.prototype.parseInlineRun = function (terminatorRegExp, options) {\\n    if (terminatorRegExp) {\\n      return this.parseInlineRunTerminated(terminatorRegExp, options)\\n    } else {\\n      return this.parseInlineRunUnterminated(options)\\n    }\\n  }\\n\\n  WikiParser.prototype.parseInlineRunUnterminated = function (options) {\\n    var tree = []\\n    // Find the next occurrence of an inline rule\\n    var nextMatch = this.findNextMatch(this.inlineRules, this.pos)\\n    // Loop around the matches until we've reached the end of the text\\n    while (this.pos < this.sourceLength && nextMatch) {\\n      // Process the text preceding the run rule\\n      if (nextMatch.matchIndex > this.pos) {\\n        this.pushTextWidget(tree, this.source.substring(this.pos, nextMatch.matchIndex))\\n        this.pos = nextMatch.matchIndex\\n      }\\n      // Process the run rule\\n      tree.push.apply(tree, nextMatch.rule.parse())\\n      // Look for the next run rule\\n      nextMatch = this.findNextMatch(this.inlineRules, this.pos)\\n    }\\n    // Process the remaining text\\n    if (this.pos < this.sourceLength) {\\n      this.pushTextWidget(tree, this.source.substr(this.pos))\\n    }\\n    this.pos = this.sourceLength\\n    return tree\\n  }\\n\\n  WikiParser.prototype.parseInlineRunTerminated = function (terminatorRegExp, options) {\\n    options = options || {}\\n    var tree = []\\n    // Find the next occurrence of the terminator\\n    terminatorRegExp.lastIndex = this.pos\\n    var terminatorMatch = terminatorRegExp.exec(this.source)\\n    // Find the next occurrence of a inlinerule\\n    var inlineRuleMatch = this.findNextMatch(this.inlineRules, this.pos)\\n    // Loop around until we've reached the end of the text\\n    while (this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {\\n      // Return if we've found the terminator, and it precedes any inline rule match\\n      if (terminatorMatch) {\\n        if (!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {\\n          if (terminatorMatch.index > this.pos) {\\n            this.pushTextWidget(tree, this.source.substring(this.pos, terminatorMatch.index))\\n          }\\n          this.pos = terminatorMatch.index\\n          if (options.eatTerminator) {\\n            this.pos += terminatorMatch[0].length\\n          }\\n          return tree\\n        }\\n      }\\n      // Process any inline rule, along with the text preceding it\\n      if (inlineRuleMatch) {\\n        // Preceding text\\n        if (inlineRuleMatch.matchIndex > this.pos) {\\n          this.pushTextWidget(tree, this.source.substring(this.pos, inlineRuleMatch.matchIndex))\\n          this.pos = inlineRuleMatch.matchIndex\\n        }\\n        // Process the inline rule\\n        tree.push.apply(tree, inlineRuleMatch.rule.parse())\\n        // Look for the next inline rule\\n        inlineRuleMatch = this.findNextMatch(this.inlineRules, this.pos)\\n        // Look for the next terminator match\\n        terminatorRegExp.lastIndex = this.pos\\n        term€€