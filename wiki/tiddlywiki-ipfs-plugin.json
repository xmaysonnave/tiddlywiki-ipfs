{
    "title": "$:/plugins/ipfs",
    "description": "IPFS with TiddlyWiki",
    "author": "Xavier Maysonnave",
    "version": "v0.3.0-200421280",
    "license": "GPL-3.0-or-later",
    "core-version": ">=5.1.2",
    "source": "https://github.com/xmaysonnave/tiddlywiki-ipfs",
    "plugin-type": "plugin",
    "list": "readme changelog",
    "dependents": "",
    "type": "application/json",
    "text": "{\n    \"tiddlers\": {\n        \"$:/core/images/ens\": {\n            \"title\": \"$:/core/images/ens\",\n            \"created\": \"20200120044634920\",\n            \"modified\": \"20200120044634920\",\n            \"_source_uri\": \"https://github.com/ensdomains/ens-app/blob/dev/public/safari-pinned-tab.svg\",\n            \"_license_uri\": \"https://github.com/ensdomains/ens-app/blob/dev/LICENSE\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment\",\n            \"type\": \"image/svg+xml\",\n            \"text\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<svg\\n   xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n   xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n   xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:sodipodi=\\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\\"\\n   xmlns:inkscape=\\\"http://www.inkscape.org/namespaces/inkscape\\\"\\n   version=\\\"1.0\\\"\\n   width=\\\"18\\\"\\n   height=\\\"18\\\"\\n   viewBox=\\\"0 0 128 128\\\"\\n   class=\\\"tc-image-button\\\"\\n   preserveAspectRatio=\\\"xMidYMid meet\\\"\\n   id=\\\"svg14\\\"\\n   sodipodi:docname=\\\"ens-small.svg\\\"\\n   inkscape:version=\\\"0.92.4 (5da689c313, 2019-01-14)\\\"\\n>\\n  <defs\\n     id=\\\"defs18\\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\\"#ffffff\\\"\\n     bordercolor=\\\"#666666\\\"\\n     borderopacity=\\\"1\\\"\\n     objecttolerance=\\\"10\\\"\\n     gridtolerance=\\\"10\\\"\\n     guidetolerance=\\\"10\\\"\\n     inkscape:pageopacity=\\\"0\\\"\\n     inkscape:pageshadow=\\\"2\\\"\\n     inkscape:window-width=\\\"1920\\\"\\n     inkscape:window-height=\\\"1020\\\"\\n     id=\\\"namedview16\\\"\\n     showgrid=\\\"false\\\"\\n     inkscape:zoom=\\\"12.361274\\\"\\n     inkscape:cx=\\\"41.295086\\\"\\n     inkscape:cy=\\\"21.734019\\\"\\n     inkscape:window-x=\\\"0\\\"\\n     inkscape:window-y=\\\"31\\\"\\n     inkscape:window-maximized=\\\"1\\\"\\n     inkscape:current-layer=\\\"svg14\\\" />\\n  <metadata\\n     id=\\\"metadata2\\\">\\nCreated by potrace 1.11, written by Peter Selinger 2001-2013\\n<rdf:RDF>\\n  <cc:Work\\n     rdf:about=\\\"\\\">\\n    <dc:format>image/svg+xml</dc:format>\\n    <dc:type\\n       rdf:resource=\\\"http://purl.org/dc/dcmitype/StillImage\\\" />\\n    <dc:title></dc:title>\\n  </cc:Work>\\n</rdf:RDF>\\n</metadata>\\n  <g\\n     transform=\\\"matrix(0.08837363,0,0,-0.07925696,-8.0787259,127.6037)\\\"\\n     id=\\\"g12\\\"\\n     style=\\\"fill:#000000;stroke:none\\\">\\n    <path\\n       d=\\\"m 640,1519 c -69,-48 -173,-122 -231,-163 -94,-65 -110,-82 -134,-129 -30,-63 -37,-155 -15,-222 15,-49 61,-135 71,-135 6,0 437,704 447,731 7,19 -17,4 -138,-82 z\\\"\\n       id=\\\"path4\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"m 856,1598 c 4,-7 44,-67 89,-133 118,-175 286,-437 393,-615 93,-154 122,-224 125,-300 2,-55 17,-35 52,75 26,80 28,92 22,217 -7,185 -45,284 -149,387 -35,36 -520,381 -534,381 -3,0 -2,-6 2,-12 z\\\"\\n       id=\\\"path6\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"M 141,1068 C 97,969 87,913 93,776 98,649 106,607 146,523 163,485 224,403 254,378 291,346 772,9 776,12 c 2,2 -57,95 -131,206 -132,199 -320,496 -404,639 -48,81 -70,145 -73,210 -1,23 -3,43 -4,43 -2,0 -12,-19 -23,-42 z\\\"\\n       id=\\\"path8\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"M 1079,398 C 962,204 859,34 851,20 l -16,-25 30,21 c 306,211 436,304 461,331 51,53 72,165 49,254 -14,51 -63,149 -76,149 -4,0 -103,-159 -220,-352 z\\\"\\n       id=\\\"path10\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n  </g>\\n</svg>\"\n        },\n        \"$:/ipfs/logo/vector/ice/text\": {\n            \"title\": \"$:/ipfs/logo/vector/ice/text\",\n            \"created\": \"20200205040051030\",\n            \"modified\": \"20200205040053586\",\n            \"_source_uri\": \"https://github.com/ipfs/logo/blob/master/vector/ipfs-logo-vector-ice-text.svg\",\n            \"_license_uri\": \"https://github.com/ipfs/logo/blob/master/LICENSE\",\n            \"tags\": \"$:/isAttachment $:/isEmbedded\",\n            \"type\": \"image/svg+xml\",\n            \"text\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<svg\\n  xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n  style=\\\"enable-background:new\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n  height=\\\"512\\\"\\n  width=\\\"512\\\"\\n  version=\\\"1.1\\\"\\n  xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n  xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n  viewBox=\\\"0 0 512 512\\\"\\n>\\n  <defs>\\n    <linearGradient id=\\\"c\\\" y2=\\\"771.51\\\" gradientUnits=\\\"userSpaceOnUse\\\" y1=\\\"771.51\\\" x2=\\\"527.72\\\" x1=\\\"84.315\\\">\\n      <stop stop-color=\\\"#4a9ea1\\\" offset=\\\"0\\\"/>\\n    </linearGradient>\\n    <linearGradient id=\\\"d\\\" y2=\\\"771.48\\\" gradientUnits=\\\"userSpaceOnUse\\\" y1=\\\"771.48\\\" x2=\\\"512.36\\\" x1=\\\"99.675\\\">\\n      <stop stop-color=\\\"#63d3d7\\\" offset=\\\"0\\\"/>\\n    </linearGradient>\\n  </defs>\\n  <g>\\n    <g style=\\\"enable-background:new\\\" transform=\\\"translate(-50.017,-515.51)\\\">\\n      <path fill=\\\"url(#c)\\\" d=\\\"m84.315 899.51 221.7 128 221.7-128v-256l-221.7-127.99-221.7 128z\\\"/>\\n      <path fill=\\\"url(#d)\\\" d=\\\"m283.13 546.35-160.74 92.806c0.32126 2.8543 0.32125 5.7352 0 8.5894l160.75 92.806c13.554-10.001 32.043-10.001 45.597 0l160.75-92.807c-0.32126-2.8543-0.32293-5.7338-0.001-8.588l-160.74-92.806c-13.554 10.001-32.044 10.001-45.599 0zm221.79 127.03-160.92 93.84c1.884 16.739-7.3611 32.751-22.799 39.489l0.18062 184.58c2.6325 1.1489 5.1267 2.5886 7.438 4.294l160.75-92.805c-1.884-16.739 7.3611-32.752 22.799-39.49v-185.61c-2.6325-1.1489-5.1281-2.5886-7.4394-4.294zm-397.81 1.0315c-2.3112 1.7054-4.8054 3.1465-7.438 4.2954v185.61c15.438 6.7378 24.683 22.75 22.799 39.489l160.74 92.806c2.3112-1.7054 4.8069-3.1465 7.4394-4.2954v-185.61c-15.438-6.7378-24.683-22.75-22.799-39.489l-160.74-92.81z\\\"/>\\n    </g>\\n    <g style=\\\"enable-background:new\\\" transform=\\\"translate(0,-196.66)\\\">\\n      <path fill-opacity=\\\".25098\\\" d=\\\"m256 708.66 221.7-128v-256l-221.7 128v256z\\\"/>\\n      <path fill-opacity=\\\".039216\\\" d=\\\"m256 708.66v-256l-221.7-128v256l221.7 128z\\\"/>\\n      <path fill-opacity=\\\".13018\\\" d=\\\"m34.298 324.66 221.7 128 221.7-128-221.7-128-221.7 128z\\\"/>\\n    </g>\\n  </g>\\n  <g style=\\\"enable-background:new\\\" fill=\\\"#fff\\\">\\n    <path d=\\\"m103.09 186h-29.2v141.2h29.2v-141.2z\\\"/>\\n    <path d=\\\"m153.97 327.2v-51.8c7.2 0.6 14.4 0.6 20.4 0.6 41.6 0 53.6-20.6 53.6-46 0-30.8-22-44-56-44h-47.2v141.2h29.2zm15.8-71.8c-5.4 0-13.4 0-15.8-0.2v-48h18.2c17.6 0 27.6 8.4 27.6 23.8v0.4c0 12-4.4 24-30 24z\\\"/>\\n    <path d=\\\"m327.95 186h-88.6v141.2h29.2v-62.2h55.4v-21.2h-55.6v-36.4h57.6l2-21.4z\\\"/>\\n    <path d=\\\"m423.51 213.6 7.6-19.6c-11.4-8.2-26.8-11.2-46.2-11.2-28.2 0-51.4 13.2-51.4 40.2 0 24.2 17.8 33.8 35.6 39.6l17.8 6c12.2 4.2 22.2 8.2 22.2 21.4 0 12-10.4 16.8-26.2 16.8-16 0-33.2-4.8-43-11l-7.6 21.2c12.8 8.2 29 12.2 50.8 12.2 31 0 55-13.6 55-42.6 0-27-20.6-35.6-41.4-42.6l-19.4-6.4c-8.4-2.8-14.8-6.6-14.8-17.4 0-11 9-15.4 22.4-15.4 16.4 0 29.2 3 38.6 8.8z\\\"/>\\n  </g>\\n</svg>\"\n        },\n        \"$:/core/images/ipfs\": {\n            \"title\": \"$:/core/images/ipfs\",\n            \"created\": \"20200120044634920\",\n            \"modified\": \"20200120044634920\",\n            \"_source_uri\": \"https://github.com/ipfs/logo/blob/master/vector/ipfs-logo-vector-black.svg\",\n            \"_license_uri\": \"https://github.com/ipfs/logo/blob/master/LICENSE\",\n            \"tags\": \"$:/tags/Image $:/ipfs/core $:/isAttachment\",\n            \"type\": \"image/svg+xml\",\n            \"text\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<svg\\n   xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n   xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n   xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:sodipodi=\\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\\"\\n   xmlns:inkscape=\\\"http://www.inkscape.org/namespaces/inkscape\\\"\\n   style=\\\"enable-background:new\\\"\\n   height=\\\"22\\\"\\n   width=\\\"22\\\"\\n   version=\\\"1.1\\\"\\n   viewBox=\\\"0 0 128 128\\\"\\n   class=\\\"tc-image-button\\\"\\n   id=\\\"svg24\\\"\\n   sodipodi:docname=\\\"ipfs-small.svg\\\"\\n   inkscape:version=\\\"0.92.4 (5da689c313, 2019-01-14)\\\"\\n>\\n  <metadata\\n     id=\\\"metadata28\\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\\"\\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\\"http://purl.org/dc/dcmitype/StillImage\\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <sodipodi:namedview\\n     pagecolor=\\\"#ffffff\\\"\\n     bordercolor=\\\"#666666\\\"\\n     borderopacity=\\\"1\\\"\\n     objecttolerance=\\\"10\\\"\\n     gridtolerance=\\\"10\\\"\\n     guidetolerance=\\\"10\\\"\\n     inkscape:pageopacity=\\\"0\\\"\\n     inkscape:pageshadow=\\\"2\\\"\\n     inkscape:window-width=\\\"1920\\\"\\n     inkscape:window-height=\\\"1020\\\"\\n     id=\\\"namedview26\\\"\\n     showgrid=\\\"false\\\"\\n     units=\\\"pt\\\"\\n     inkscape:zoom=\\\"5.2149125\\\"\\n     inkscape:cx=\\\"133.61143\\\"\\n     inkscape:cy=\\\"41.576599\\\"\\n     inkscape:window-x=\\\"0\\\"\\n     inkscape:window-y=\\\"31\\\"\\n     inkscape:window-maximized=\\\"1\\\"\\n     inkscape:current-layer=\\\"svg24\\\" />\\n  <defs\\n     id=\\\"defs8\\\">\\n    <linearGradient\\n       id=\\\"b\\\"\\n       y2=\\\"771.51001\\\"\\n       gradientUnits=\\\"userSpaceOnUse\\\"\\n       x2=\\\"527.71997\\\"\\n       y1=\\\"771.51001\\\"\\n       x1=\\\"84.315002\\\">\\n      <stop\\n         offset=\\\"0\\\"\\n         id=\\\"stop2\\\" />\\n    </linearGradient>\\n    <linearGradient\\n       id=\\\"a\\\"\\n       y2=\\\"771.47998\\\"\\n       gradientUnits=\\\"userSpaceOnUse\\\"\\n       x2=\\\"512.35999\\\"\\n       y1=\\\"771.47998\\\"\\n       x1=\\\"99.675003\\\">\\n      <stop\\n         stop-color=\\\"#d8d8d8\\\"\\n         offset=\\\"0\\\"\\n         id=\\\"stop5\\\" />\\n    </linearGradient>\\n  </defs>\\n  <g\\n     transform=\\\"matrix(0.28867709,0,0,0.24999998,-24.339808,-128.87748)\\\"\\n     id=\\\"g14\\\">\\n    <path\\n       d=\\\"m 84.315,899.51 221.7,128 221.7,-128 v -256 l -221.7,-127.99 -221.7,128 z\\\"\\n       id=\\\"path10\\\"\\n       style=\\\"fill:url(#b)\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n    <path\\n       d=\\\"m 283.13,546.35 -160.74,92.806 c 0.32126,2.8543 0.32125,5.7352 0,8.5894 l 160.75,92.806 c 13.554,-10.001 32.043,-10.001 45.597,0 l 160.75,-92.807 c -0.32126,-2.8543 -0.32293,-5.7338 -0.001,-8.588 l -160.74,-92.806 c -13.554,10.001 -32.044,10.001 -45.599,0 z M 504.92,673.38 344,767.22 c 1.884,16.739 -7.3611,32.751 -22.799,39.489 l 0.18062,184.58 c 2.6325,1.1489 5.1267,2.5886 7.438,4.294 l 160.75,-92.805 c -1.884,-16.739 7.3611,-32.752 22.799,-39.49 v -185.61 c -2.6325,-1.1489 -5.1281,-2.5886 -7.4394,-4.294 z m -397.81,1.0315 c -2.3112,1.7054 -4.8054,3.1465 -7.438,4.2954 v 185.61 c 15.438,6.7378 24.683,22.75 22.799,39.489 l 160.74,92.806 c 2.3112,-1.7054 4.8069,-3.1465 7.4394,-4.2954 v -185.61 c -15.438,-6.7378 -24.683,-22.75 -22.799,-39.489 l -160.74,-92.81 z\\\"\\n       id=\\\"path12\\\"\\n       style=\\\"fill:url(#a)\\\"\\n       inkscape:connector-curvature=\\\"0\\\" />\\n  </g>\\n  <g\\n     transform=\\\"matrix(0.28867709,0,0,0.24999998,-9.9010468,-49.164992)\\\"\\n     id=\\\"g22\\\">\\n    <path\\n       d=\\\"m 256,708.66 221.7,-128 v -256 l -221.7,128 z\\\"\\n       id=\\\"path16\\\"\\n       inkscape:connector-curvature=\\\"0\\\"\\n       style=\\\"fill-opacity:0.25097997\\\" />\\n    <path\\n       d=\\\"m 256,708.66 v -256 l -221.7,-128 v 256 z\\\"\\n       id=\\\"path18\\\"\\n       inkscape:connector-curvature=\\\"0\\\"\\n       style=\\\"fill-opacity:0.03921599\\\" />\\n    <path\\n       d=\\\"m 34.298,324.66 221.7,128 221.7,-128 -221.7,-128 z\\\"\\n       id=\\\"path20\\\"\\n       inkscape:connector-curvature=\\\"0\\\"\\n       style=\\\"fill-opacity:0.13018003\\\" />\\n  </g>\\n</svg>\"\n        },\n        \"$:/ipfs/saver/api\": {\n            \"title\": \"$:/ipfs/saver/api\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"$:/ipfs/saver/api/https/ipfs.infura.io/5001\"\n        },\n        \"$:/ipfs/saver/ens/domain\": {\n            \"title\": \"$:/ipfs/saver/ens/domain\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\"\n        },\n        \"$:/ipfs/saver/export\": {\n            \"title\": \"$:/ipfs/saver/export\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"json\"\n        },\n        \"$:/ipfs/saver/gateway\": {\n            \"title\": \"$:/ipfs/saver/gateway\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"$:/ipfs/saver/gateway/https/ipfs.infura.io\"\n        },\n        \"$:/ipfs/saver/ipns/key\": {\n            \"title\": \"$:/ipfs/saver/ipns/key\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\"\n        },\n        \"$:/ipfs/saver/ipns/name\": {\n            \"title\": \"$:/ipfs/saver/ipns/name\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"\"\n        },\n        \"$:/ipfs/saver/policy\": {\n            \"title\": \"$:/ipfs/saver/policy\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"gateway\"\n        },\n        \"$:/config/PreferredSaver\": {\n            \"title\": \"$:/config/PreferredSaver\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"$:/plugins/ipfs/ipfs-saver.js\"\n        },\n        \"$:/ipfs/saver/protocol\": {\n            \"title\": \"$:/ipfs/saver/protocol\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ipfs\"\n        },\n        \"$:/ipfs/saver/provider\": {\n            \"title\": \"$:/ipfs/saver/provider\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"http\"\n        },\n        \"$:/plugins/ipfs/modules/parsers/audioparser.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/parsers/audioparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/parsers/audioparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe audio parser parses an audio tiddler into an embeddable HTML element\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  var name = \\\"ipfs-audioparser\\\";\\n\\n  var AudioParser = function(type, text, options) {\\n    var self = this;\\n    var value = \\\"data:\\\" + type + \\\";base64,\\\";\\n    var element = {\\n      type: \\\"element\\\",\\n      tag: \\\"audio\\\",\\n      attributes: {\\n        controls: { type: \\\"string\\\", value: \\\"controls\\\" },\\n        style: { type: \\\"string\\\", value: \\\"width: 100%; object-fit: contain\\\" }\\n      }\\n    };\\n    var tiddler = options.tiddler;\\n    var uri = options._canonical_uri;\\n    // Load external resource\\n    if (uri) {\\n      $tw.ipfs\\n        .normalizeIpfsUrl(uri)\\n        .then(normalized_uri => {\\n          // Load\\n          $tw.utils\\n            .loadToBase64(normalized_uri)\\n            .then(loaded => {\\n              element.attributes.src = { type: \\\"string\\\", value: value + loaded.data };\\n              const parsedTiddler = $tw.utils.getChangedTiddler(tiddler);\\n              $tw.rootWidget.refresh(parsedTiddler);\\n            })\\n            .catch(error => {\\n              self.getLogger().error(error);\\n              $tw.utils.alert(name, error.message);\\n            });\\n        })\\n        .catch(error => {\\n          self.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        });\\n    } else if (text) {\\n      element.attributes.src = { type: \\\"string\\\", value: value + text };\\n    }\\n    // Return the parsed tree\\n    this.tree = [element];\\n  };\\n\\n  AudioParser.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  exports[\\\"audio/ogg\\\"] = AudioParser;\\n  exports[\\\"audio/mpeg\\\"] = AudioParser;\\n  exports[\\\"audio/mp3\\\"] = AudioParser;\\n  exports[\\\"audio/mp4\\\"] = AudioParser;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/plugins/ipfs/modules/parsers/imageparser.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/parsers/imageparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/parsers/imageparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe image parser parses an image into an embeddable HTML element\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  var name = \\\"ipfs-imageparser\\\";\\n\\n  var ImageParser = function(type, text, options) {\\n    var self = this;\\n    var value = \\\"data:\\\" + type + \\\";base64,\\\";\\n    var element = {\\n      type: \\\"element\\\",\\n      tag: \\\"img\\\",\\n      attributes: {}\\n    };\\n    var tiddler = options.tiddler;\\n    var uri = options._canonical_uri;\\n    // Load external resource\\n    if (uri) {\\n      $tw.ipfs\\n        .normalizeIpfsUrl(uri)\\n        .then(normalized_uri => {\\n          // Load\\n          $tw.utils\\n            .loadToBase64(normalized_uri)\\n            .then(loaded => {\\n              element.attributes.src = { type: \\\"string\\\", value: value + loaded.data };\\n              const parsedTiddler = $tw.utils.getChangedTiddler(tiddler);\\n              $tw.rootWidget.refresh(parsedTiddler);\\n            })\\n            .catch(error => {\\n              self.getLogger().error(error);\\n              $tw.utils.alert(name, error.message);\\n            });\\n        })\\n        .catch(error => {\\n          self.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        });\\n    } else if (text) {\\n      element.attributes.src = { type: \\\"string\\\", value: value + text };\\n    }\\n    // Return the parsed tree\\n    this.tree = [element];\\n  };\\n\\n  ImageParser.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  exports[\\\"image/jpg\\\"] = ImageParser;\\n  exports[\\\"image/jpeg\\\"] = ImageParser;\\n  exports[\\\"image/png\\\"] = ImageParser;\\n  exports[\\\"image/gif\\\"] = ImageParser;\\n  exports[\\\"image/webp\\\"] = ImageParser;\\n  exports[\\\"image/heic\\\"] = ImageParser;\\n  exports[\\\"image/heif\\\"] = ImageParser;\\n  exports[\\\"image/x-icon\\\"] = ImageParser;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/plugins/ipfs/modules/parsers/pdfparser.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/parsers/pdfparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/parsers/pdfparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe PDF parser embeds a PDF viewer\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const name = \\\"ipfs-pdfparser\\\";\\n\\n  var PdfParser = function(type, text, options) {\\n    var self = this;\\n    var value = \\\"data:application/pdf;base64,\\\";\\n    var element = {\\n      type: \\\"element\\\",\\n      tag: \\\"embed\\\",\\n      attributes: {}\\n    };\\n    var tiddler = options.tiddler;\\n    var uri = options._canonical_uri;\\n    // Load external resource\\n    if (uri) {\\n      $tw.ipfs\\n        .normalizeIpfsUrl(uri)\\n        .then(normalized_uri => {\\n          // Load\\n          $tw.utils\\n            .loadToBase64(normalized_uri)\\n            .then(loaded => {\\n              element.attributes.src = { type: \\\"string\\\", value: value + loaded.data };\\n              var parsedTiddler = $tw.utils.getChangedTiddler(tiddler);\\n              $tw.rootWidget.refresh(parsedTiddler);\\n            })\\n            .catch(error => {\\n              self.getLogger().error(error);\\n              $tw.utils.alert(name, error.message);\\n            });\\n        })\\n        .catch(error => {\\n          self.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        });\\n    } else if (text) {\\n      element.attributes.src = { type: \\\"string\\\", value: value + text };\\n    }\\n    // Return the parsed tree\\n    this.tree = [element];\\n  };\\n\\n  PdfParser.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  exports[\\\"application/pdf\\\"] = PdfParser;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/plugins/ipfs/modules/parsers/svgparser.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/parsers/svgparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/parsers/svgparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe image parser parses an image into an embeddable HTML element\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const name = \\\"ipfs-svgparser\\\";\\n\\n  var SvgParser = function(type, text, options) {\\n    var self = this;\\n    var value = \\\"data:image/svg+xml,\\\";\\n    var element = {\\n      type: \\\"element\\\",\\n      tag: \\\"img\\\",\\n      attributes: {}\\n    };\\n    var tiddler = options.tiddler;\\n    var uri = options._canonical_uri;\\n    // Load external resource\\n    if (uri) {\\n      $tw.ipfs\\n        .normalizeIpfsUrl(uri)\\n        .then(normalized_uri => {\\n          // Load\\n          $tw.utils\\n            .loadToUtf8(normalized_uri)\\n            .then(loaded => {\\n              element.attributes.src = { type: \\\"string\\\", value: value + encodeURIComponent(loaded.data) };\\n              var parsedTiddler = $tw.utils.getChangedTiddler(tiddler);\\n              $tw.rootWidget.refresh(parsedTiddler);\\n            })\\n            .catch(error => {\\n              self.getLogger().error(error);\\n              $tw.utils.alert(name, error.message);\\n            });\\n        })\\n        .catch(error => {\\n          self.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        });\\n    } else {\\n      element.attributes.src = { type: \\\"string\\\", value: value + encodeURIComponent(text) };\\n    }\\n    // Return the parsed tree\\n    this.tree = [element];\\n  };\\n\\n  SvgParser.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  exports[\\\"image/svg+xml\\\"] = SvgParser;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/plugins/ipfs/modules/parsers/videoparser.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/parsers/videoparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/parsers/videoparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nThe video parser parses a video tiddler into an embeddable HTML element\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const name = \\\"ipfs-videoparser\\\";\\n\\n  var VideoParser = function(type, text, options) {\\n    var self = this;\\n    var value = \\\"data:\\\" + type + \\\";base64,\\\";\\n    var element = {\\n      type: \\\"element\\\",\\n      tag: \\\"video\\\",\\n      attributes: {\\n        controls: { type: \\\"string\\\", value: \\\"controls\\\" },\\n        style: { type: \\\"string\\\", value: \\\"width: 100%; object-fit: contain\\\" }\\n      }\\n    };\\n    var tiddler = options.tiddler;\\n    var uri = options._canonical_uri;\\n    // Load external resource\\n    if (uri) {\\n      $tw.ipfs\\n        .normalizeIpfsUrl(uri)\\n        .then(normalized_uri => {\\n          // Load\\n          $tw.utils\\n            .loadToBase64(normalized_uri)\\n            .then(loaded => {\\n              element.attributes.src = { type: \\\"string\\\", value: value + loaded.data };\\n              var parsedTiddler = $tw.utils.getChangedTiddler(tiddler);\\n              $tw.rootWidget.refresh(parsedTiddler);\\n            })\\n            .catch(error => {\\n              self.getLogger().error(error);\\n              $tw.utils.alert(name, error.message);\\n            });\\n        })\\n        .catch(error => {\\n          self.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        });\\n    } else if (text) {\\n      element.attributes.src = { type: \\\"string\\\", value: value + text };\\n    }\\n    // Return the parsed tree\\n    this.tree = [element];\\n  };\\n\\n  VideoParser.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  exports[\\\"video/ogg\\\"] = VideoParser;\\n  exports[\\\"video/webm\\\"] = VideoParser;\\n  exports[\\\"video/mp4\\\"] = VideoParser;\\n  exports[\\\"video/quicktime\\\"] = VideoParser;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/plugins/ipfs/modules/parsers/wikiparser/wikiparser.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/parsers/wikiparser/wikiparser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/parsers/wikiparser/wikiparser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: parser\\n\\nwikiparser\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2020, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  var name = \\\"ipfs-wikiparser\\\";\\n\\n  var WikiParser = function(type, text, options) {\\n    this.wiki = options.wiki;\\n    // Check for an externally linked tiddler\\n    if ($tw.browser && (text || \\\"\\\") === \\\"\\\" && options._canonical_uri) {\\n      this.loadRemoteTiddlers(options.tiddler, options._canonical_uri);\\n      text = $tw.language.getRawString(\\\"LazyLoadingWarning\\\");\\n    }\\n    // Initialise the classes if we don't have them already\\n    if (!this.pragmaRuleClasses) {\\n      WikiParser.prototype.pragmaRuleClasses = $tw.modules.createClassesFromModules(\\n        \\\"wikirule\\\",\\n        \\\"pragma\\\",\\n        $tw.WikiRuleBase\\n      );\\n      this.setupRules(WikiParser.prototype.pragmaRuleClasses, \\\"$:/config/WikiParserRules/Pragmas/\\\");\\n    }\\n    if (!this.blockRuleClasses) {\\n      WikiParser.prototype.blockRuleClasses = $tw.modules.createClassesFromModules(\\n        \\\"wikirule\\\",\\n        \\\"block\\\",\\n        $tw.WikiRuleBase\\n      );\\n      this.setupRules(WikiParser.prototype.blockRuleClasses, \\\"$:/config/WikiParserRules/Block/\\\");\\n    }\\n    if (!this.inlineRuleClasses) {\\n      WikiParser.prototype.inlineRuleClasses = $tw.modules.createClassesFromModules(\\n        \\\"wikirule\\\",\\n        \\\"inline\\\",\\n        $tw.WikiRuleBase\\n      );\\n      this.setupRules(WikiParser.prototype.inlineRuleClasses, \\\"$:/config/WikiParserRules/Inline/\\\");\\n    }\\n    // Save the parse text\\n    this.type = type || \\\"text/vnd.tiddlywiki\\\";\\n    this.source = text || \\\"\\\";\\n    this.sourceLength = this.source.length;\\n    // Flag for ignoring whitespace\\n    this.configTrimWhiteSpace = false;\\n    // Set current parse position\\n    this.pos = 0;\\n    // Instantiate the pragma parse rules\\n    this.pragmaRules = this.instantiateRules(this.pragmaRuleClasses, \\\"pragma\\\", 0);\\n    // Instantiate the parser block and inline rules\\n    this.blockRules = this.instantiateRules(this.blockRuleClasses, \\\"block\\\", 0);\\n    this.inlineRules = this.instantiateRules(this.inlineRuleClasses, \\\"inline\\\", 0);\\n    // Parse any pragmas\\n    this.tree = [];\\n    var topBranch = this.parsePragmas();\\n    // Parse the text into inline runs or blocks\\n    if (options.parseAsInline) {\\n      topBranch.push.apply(topBranch, this.parseInlineRun());\\n    } else {\\n      topBranch.push.apply(topBranch, this.parseBlocks());\\n    }\\n    // Return the parsed tree\\n  };\\n\\n  WikiParser.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  WikiParser.prototype.isJSON = function(content) {\\n    if (content !== undefined && content !== null && typeof content === \\\"string\\\") {\\n      try {\\n        JSON.parse(content);\\n        return true;\\n      } catch (error) {\\n        // Ignore\\n      }\\n    }\\n    return false;\\n  };\\n\\n  /*\\n   */\\n  WikiParser.prototype.loadRemoteTiddlers = function(tiddler, uri) {\\n    var self = this;\\n    var localTiddler = tiddler;\\n    var localUri = uri;\\n    // Normalize\\n    $tw.ipfs\\n      .normalizeIpfsUrl(uri)\\n      .then(normalized_uri => {\\n        // Load\\n        $tw.utils\\n          .loadToUtf8(normalized_uri)\\n          .then(loaded => {\\n            self.importTiddlers(localTiddler, localUri, loaded.data);\\n          })\\n          .catch(error => {\\n            self.getLogger().error(error);\\n            $tw.utils.alert(name, error.message);\\n          });\\n      })\\n      .catch(error => {\\n        self.getLogger().error(error);\\n        $tw.utils.alert(name, error.message);\\n      });\\n  };\\n\\n  /*\\n   * imported tiddler supersed hosting tiddler\\n   */\\n  WikiParser.prototype.importTiddlers = function(tiddler, uri, loaded) {\\n    var head = tiddler;\\n    var headTitle = null;\\n    var newHeadTitle = null;\\n    var importedTiddlers = null;\\n    var processed = [];\\n    if (this.isJSON(loaded)) {\\n      importedTiddlers = $tw.wiki.deserializeTiddlers(\\\".json\\\", loaded, $tw.wiki.getCreationFields());\\n    } else {\\n      importedTiddlers = $tw.wiki.deserializeTiddlers(\\\".tid\\\", loaded, $tw.wiki.getCreationFields());\\n    }\\n    // IPFS tag\\n    var { cid } = $tw.ipfs.decodeCid(uri);\\n\\n    // Process new and existing\\n    $tw.utils.each(importedTiddlers, function(importedTiddler) {\\n      var importedTags = importedTiddler[\\\"tags\\\"] !== undefined ? importedTiddler[\\\"tags\\\"] : \\\"\\\";\\n\\n      var current = null;\\n      var title = importedTiddler[\\\"title\\\"];\\n\\n      // Type\\n      var type = importedTiddler[\\\"type\\\"];\\n      // Default\\n      if (type == undefined || type == null || type.trim() === \\\"\\\") {\\n        type = \\\"text/vnd.tiddlywiki\\\";\\n      }\\n\\n      // Content Type\\n      const info = $tw.config.contentTypeInfo[type];\\n\\n      // Check\\n      if (info == undefined || info == null) {\\n        throw new Error(\\\"Unknown Tiddler type: \\\" + type);\\n      }\\n\\n      // Head\\n      if (head !== null) {\\n        current = head;\\n        // Title\\n        headTitle = current.getFieldString(\\\"title\\\");\\n        if (title !== undefined && title !== null && title.trim() !== \\\"\\\" && title !== headTitle) {\\n          var existing = $tw.wiki.getTiddler(title);\\n          if (existing !== undefined && existing !== null) {\\n            throw new Error(\\\"Imported Tiddler already exists: \\\" + title);\\n          }\\n          newHeadTitle = title;\\n        }\\n        // Children\\n      } else {\\n        current = $tw.wiki.getTiddler(title);\\n      }\\n\\n      // Merge tags and fields\\n      if (current !== undefined && current !== null) {\\n        // Merge\\n        for (var name in current.fields) {\\n          // field is an array of values, we use the string instead\\n          var value = current.getFieldString(name);\\n          if (importedTiddler[name] == undefined || importedTiddler[name] == null) {\\n            importedTiddler[name] = value;\\n          }\\n        }\\n        // Merge tags\\n        var tags = (current.fields.tags || []).slice(0);\\n        // Merge imported tags with current tags\\n        for (var i = 0; i < tags.length; i++) {\\n          var tag = tags[i];\\n          if (importedTags.includes(tag) == false) {\\n            importedTags = importedTags + \\\" \\\" + tag;\\n          }\\n        }\\n      }\\n\\n      // canonical_uri\\n      if (info.encoding === \\\"base64\\\" || type === \\\"image/svg+xml\\\") {\\n        importedTiddler[\\\"_import_uri\\\"] = uri;\\n      } else {\\n        var canonical_uri = importedTiddler[\\\"_canonical_uri\\\"];\\n        if (canonical_uri == undefined || canonical_uri == null) {\\n          importedTiddler[\\\"_canonical_uri\\\"] = uri;\\n          // import_uri\\n        } else if (canonical_uri !== uri) {\\n          importedTiddler[\\\"_import_uri\\\"] = uri;\\n        }\\n      }\\n\\n      // IPFS tag\\n      if (cid !== null) {\\n        if (importedTags.includes(\\\"$:/isIpfs\\\") == false) {\\n          importedTags = importedTags + \\\" $:/isIpfs\\\";\\n        }\\n      }\\n      // Imported tag\\n      if (importedTags.includes(\\\"$:/isImported\\\") == false) {\\n        importedTags = importedTags + \\\" $:/isImported\\\";\\n      }\\n      // Processed tags\\n      importedTiddler[\\\"tags\\\"] = importedTags;\\n\\n      // Update current\\n      $tw.wiki.addTiddler(importedTiddler);\\n\\n      // Rename Head Tiddler if necessary\\n      if (head !== null && newHeadTitle !== null) {\\n        $tw.wiki.renameTiddler(headTitle, newHeadTitle);\\n      }\\n\\n      // Store title to process deleted Tiddlers\\n      processed.push(title);\\n\\n      // Head has been processed\\n      if (head !== null) {\\n        head = null;\\n        headTitle = null;\\n        newHeadTitle = null;\\n      }\\n    });\\n\\n    // Process Tiddlers to be deleted\\n    $tw.wiki.forEachTiddler({ includeSystem: true }, function(title, tiddler) {\\n      var canonical_uri = tiddler.getFieldString(\\\"_canonical_uri\\\");\\n      if (\\n        canonical_uri !== undefined &&\\n        canonical_uri !== null &&\\n        canonical_uri === uri &&\\n        processed.indexOf(title) === -1\\n      ) {\\n        $tw.wiki.deleteTiddler(title);\\n        return;\\n      }\\n      var import_uri = tiddler.getFieldString(\\\"_import_uri\\\");\\n      if (import_uri !== undefined && import_uri !== null && import_uri === uri && processed.indexOf(title) === -1) {\\n        $tw.wiki.deleteTiddler(title);\\n        return;\\n      }\\n    });\\n  };\\n\\n  /*\\n   */\\n  WikiParser.prototype.setupRules = function(proto, configPrefix) {\\n    var self = this;\\n    if (!$tw.safemode) {\\n      $tw.utils.each(proto, function(object, name) {\\n        if (self.wiki.getTiddlerText(configPrefix + name, \\\"enable\\\") !== \\\"enable\\\") {\\n          delete proto[name];\\n        }\\n      });\\n    }\\n  };\\n\\n  /*\\nInstantiate an array of parse rules\\n*/\\n  WikiParser.prototype.instantiateRules = function(classes, type, startPos) {\\n    var rulesInfo = [],\\n      self = this;\\n    $tw.utils.each(classes, function(RuleClass) {\\n      // Instantiate the rule\\n      var rule = new RuleClass(self);\\n      rule.is = {};\\n      rule.is[type] = true;\\n      rule.init(self);\\n      var matchIndex = rule.findNextMatch(startPos);\\n      if (matchIndex !== undefined) {\\n        rulesInfo.push({\\n          rule: rule,\\n          matchIndex: matchIndex\\n        });\\n      }\\n    });\\n    return rulesInfo;\\n  };\\n\\n  /*\\nSkip any whitespace at the current position. Options are:\\n  treatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace\\n*/\\n  WikiParser.prototype.skipWhitespace = function(options) {\\n    options = options || {};\\n    var whitespaceRegExp = options.treatNewlinesAsNonWhitespace ? /([^\\\\S\\\\n]+)/gm : /(\\\\s+)/gm;\\n    whitespaceRegExp.lastIndex = this.pos;\\n    var whitespaceMatch = whitespaceRegExp.exec(this.source);\\n    if (whitespaceMatch && whitespaceMatch.index === this.pos) {\\n      this.pos = whitespaceRegExp.lastIndex;\\n    }\\n  };\\n\\n  /*\\nGet the next match out of an array of parse rule instances\\n*/\\n  WikiParser.prototype.findNextMatch = function(rules, startPos) {\\n    // Find the best matching rule by finding the closest match position\\n    var matchingRule,\\n      matchingRulePos = this.sourceLength;\\n    // Step through each rule\\n    for (var t = 0; t < rules.length; t++) {\\n      var ruleInfo = rules[t];\\n      // Ask the rule to get the next match if we've moved past the current one\\n      if (ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex < startPos) {\\n        ruleInfo.matchIndex = ruleInfo.rule.findNextMatch(startPos);\\n      }\\n      // Adopt this match if it's closer than the current best match\\n      if (ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex <= matchingRulePos) {\\n        matchingRule = ruleInfo;\\n        matchingRulePos = ruleInfo.matchIndex;\\n      }\\n    }\\n    return matchingRule;\\n  };\\n\\n  /*\\nParse any pragmas at the beginning of a block of parse text\\n*/\\n  WikiParser.prototype.parsePragmas = function() {\\n    var currentTreeBranch = this.tree;\\n    while (true) {\\n      // Skip whitespace\\n      this.skipWhitespace();\\n      // Check for the end of the text\\n      if (this.pos >= this.sourceLength) {\\n        break;\\n      }\\n      // Check if we've arrived at a pragma rule match\\n      var nextMatch = this.findNextMatch(this.pragmaRules, this.pos);\\n      // If not, just exit\\n      if (!nextMatch || nextMatch.matchIndex !== this.pos) {\\n        break;\\n      }\\n      // Process the pragma rule\\n      var subTree = nextMatch.rule.parse();\\n      if (subTree.length > 0) {\\n        // Quick hack; we only cope with a single parse tree node being returned, which is true at the moment\\n        currentTreeBranch.push.apply(currentTreeBranch, subTree);\\n        subTree[0].children = [];\\n        currentTreeBranch = subTree[0].children;\\n      }\\n    }\\n    return currentTreeBranch;\\n  };\\n\\n  /*\\nParse a block from the current position\\n  terminatorRegExpString: optional regular expression string that identifies the end of plain paragraphs. Must not include capturing parenthesis\\n*/\\n  WikiParser.prototype.parseBlock = function(terminatorRegExpString) {\\n    var terminatorRegExp = terminatorRegExpString\\n      ? new RegExp(\\\"(\\\" + terminatorRegExpString + \\\"|\\\\\\\\r?\\\\\\\\n\\\\\\\\r?\\\\\\\\n)\\\", \\\"mg\\\")\\n      : /(\\\\r?\\\\n\\\\r?\\\\n)/gm;\\n    this.skipWhitespace();\\n    if (this.pos >= this.sourceLength) {\\n      return [];\\n    }\\n    // Look for a block rule that applies at the current position\\n    var nextMatch = this.findNextMatch(this.blockRules, this.pos);\\n    if (nextMatch && nextMatch.matchIndex === this.pos) {\\n      return nextMatch.rule.parse();\\n    }\\n    // Treat it as a paragraph if we didn't find a block rule\\n    return [{ type: \\\"element\\\", tag: \\\"p\\\", children: this.parseInlineRun(terminatorRegExp) }];\\n  };\\n\\n  /*\\nParse a series of blocks of text until a terminating regexp is encountered or the end of the text\\n  terminatorRegExpString: terminating regular expression\\n*/\\n  WikiParser.prototype.parseBlocks = function(terminatorRegExpString) {\\n    if (terminatorRegExpString) {\\n      return this.parseBlocksTerminated(terminatorRegExpString);\\n    } else {\\n      return this.parseBlocksUnterminated();\\n    }\\n  };\\n\\n  /*\\nParse a block from the current position to the end of the text\\n*/\\n  WikiParser.prototype.parseBlocksUnterminated = function() {\\n    var tree = [];\\n    while (this.pos < this.sourceLength) {\\n      tree.push.apply(tree, this.parseBlock());\\n    }\\n    return tree;\\n  };\\n\\n  /*\\nParse blocks of text until a terminating regexp is encountered\\n*/\\n  WikiParser.prototype.parseBlocksTerminated = function(terminatorRegExpString) {\\n    var terminatorRegExp = new RegExp(\\\"(\\\" + terminatorRegExpString + \\\")\\\", \\\"mg\\\"),\\n      tree = [];\\n    // Skip any whitespace\\n    this.skipWhitespace();\\n    //  Check if we've got the end marker\\n    terminatorRegExp.lastIndex = this.pos;\\n    var match = terminatorRegExp.exec(this.source);\\n    // Parse the text into blocks\\n    while (this.pos < this.sourceLength && !(match && match.index === this.pos)) {\\n      var blocks = this.parseBlock(terminatorRegExpString);\\n      tree.push.apply(tree, blocks);\\n      // Skip any whitespace\\n      this.skipWhitespace();\\n      //  Check if we've got the end marker\\n      terminatorRegExp.lastIndex = this.pos;\\n      match = terminatorRegExp.exec(this.source);\\n    }\\n    if (match && match.index === this.pos) {\\n      this.pos = match.index + match[0].length;\\n    }\\n    return tree;\\n  };\\n\\n  /*\\nParse a run of text at the current position\\n  terminatorRegExp: a regexp at which to stop the run\\n  options: see below\\nOptions available:\\n  eatTerminator: move the parse position past any encountered terminator (default false)\\n*/\\n  WikiParser.prototype.parseInlineRun = function(terminatorRegExp, options) {\\n    if (terminatorRegExp) {\\n      return this.parseInlineRunTerminated(terminatorRegExp, options);\\n    } else {\\n      return this.parseInlineRunUnterminated(options);\\n    }\\n  };\\n\\n  WikiParser.prototype.parseInlineRunUnterminated = function(options) {\\n    var tree = [];\\n    // Find the next occurrence of an inline rule\\n    var nextMatch = this.findNextMatch(this.inlineRules, this.pos);\\n    // Loop around the matches until we've reached the end of the text\\n    while (this.pos < this.sourceLength && nextMatch) {\\n      // Process the text preceding the run rule\\n      if (nextMatch.matchIndex > this.pos) {\\n        this.pushTextWidget(tree, this.source.substring(this.pos, nextMatch.matchIndex));\\n        this.pos = nextMatch.matchIndex;\\n      }\\n      // Process the run rule\\n      tree.push.apply(tree, nextMatch.rule.parse());\\n      // Look for the next run rule\\n      nextMatch = this.findNextMatch(this.inlineRules, this.pos);\\n    }\\n    // Process the remaining text\\n    if (this.pos < this.sourceLength) {\\n      this.pushTextWidget(tree, this.source.substr(this.pos));\\n    }\\n    this.pos = this.sourceLength;\\n    return tree;\\n  };\\n\\n  WikiParser.prototype.parseInlineRunTerminated = function(terminatorRegExp, options) {\\n    options = options || {};\\n    var tree = [];\\n    // Find the next occurrence of the terminator\\n    terminatorRegExp.lastIndex = this.pos;\\n    var terminatorMatch = terminatorRegExp.exec(this.source);\\n    // Find the next occurrence of a inlinerule\\n    var inlineRuleMatch = this.findNextMatch(this.inlineRules, this.pos);\\n    // Loop around until we've reached the end of the text\\n    while (this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {\\n      // Return if we've found the terminator, and it precedes any inline rule match\\n      if (terminatorMatch) {\\n        if (!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {\\n          if (terminatorMatch.index > this.pos) {\\n            this.pushTextWidget(tree, this.source.substring(this.pos, terminatorMatch.index));\\n          }\\n          this.pos = terminatorMatch.index;\\n          if (options.eatTerminator) {\\n            this.pos += terminatorMatch[0].length;\\n          }\\n          return tree;\\n        }\\n      }\\n      // Process any inline rule, along with the text preceding it\\n      if (inlineRuleMatch) {\\n        // Preceding text\\n        if (inlineRuleMatch.matchIndex > this.pos) {\\n          this.pushTextWidget(tree, this.source.substring(this.pos, inlineRuleMatch.matchIndex));\\n          this.pos = inlineRuleMatch.matchIndex;\\n        }\\n        // Process the inline rule\\n        tree.push.apply(tree, inlineRuleMatch.rule.parse());\\n        // Look for the next inline rule\\n        inlineRuleMatch = this.findNextMatch(this.inlineRules, this.pos);\\n        // Look for the next terminator match\\n        terminatorRegExp.lastIndex = this.pos;\\n        terminatorMatch = terminatorRegExp.exec(this.source);\\n      }\\n    }\\n    // Process the remaining text\\n    if (this.pos < this.sourceLength) {\\n      this.pushTextWidget(tree, this.source.substr(this.pos));\\n    }\\n    this.pos = this.sourceLength;\\n    return tree;\\n  };\\n\\n  /*\\nPush a text widget onto an array, respecting the configTrimWhiteSpace setting\\n*/\\n  WikiParser.prototype.pushTextWidget = function(array, text) {\\n    if (this.configTrimWhiteSpace) {\\n      text = $tw.utils.trim(text);\\n    }\\n    if (text) {\\n      array.push({ type: \\\"text\\\", text: text });\\n    }\\n  };\\n\\n  /*\\nParse zero or more class specifiers `.classname`\\n*/\\n  WikiParser.prototype.parseClasses = function() {\\n    var classRegExp = /\\\\.([^\\\\s\\\\.]+)/gm,\\n      classNames = [];\\n    classRegExp.lastIndex = this.pos;\\n    var match = classRegExp.exec(this.source);\\n    while (match && match.index === this.pos) {\\n      this.pos = match.index + match[0].length;\\n      classNames.push(match[1]);\\n      match = classRegExp.exec(this.source);\\n    }\\n    return classNames;\\n  };\\n\\n  /*\\nAmend the rules used by this instance of the parser\\n  type: `only` keeps just the named rules, `except` keeps all but the named rules\\n  names: array of rule names\\n*/\\n  WikiParser.prototype.amendRules = function(type, names) {\\n    names = names || [];\\n    // Define the filter function\\n    var keepFilter;\\n    if (type === \\\"only\\\") {\\n      keepFilter = function(name) {\\n        return names.indexOf(name) !== -1;\\n      };\\n    } else if (type === \\\"except\\\") {\\n      keepFilter = function(name) {\\n        return names.indexOf(name) === -1;\\n      };\\n    } else {\\n      return;\\n    }\\n    // Define a function to process each of our rule arrays\\n    var processRuleArray = function(ruleArray) {\\n      for (var t = ruleArray.length - 1; t >= 0; t--) {\\n        if (!keepFilter(ruleArray[t].rule.name)) {\\n          ruleArray.splice(t, 1);\\n        }\\n      }\\n    };\\n    // Process each rule array\\n    processRuleArray(this.pragmaRules);\\n    processRuleArray(this.blockRules);\\n    processRuleArray(this.inlineRules);\\n  };\\n\\n  exports[\\\"text/vnd.tiddlywiki\\\"] = WikiParser;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"parser\"\n        },\n        \"$:/core/modules/saver-handler.js\": {\n            \"title\": \"$:/core/modules/saver-handler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/saver-handler.js\\ntype: application/javascript\\nmodule-type: global\\n\\nThe saver handler tracks changes to the store and handles saving the entire wiki via saver modules.\\n\\n\\\\*/\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\nInstantiate the saver handler with the following options:\\nwiki: wiki to be synced\\ndirtyTracking: true if dirty tracking should be performed\\n*/\\n  function SaverHandler(options) {\\n    var self = this;\\n    this.wiki = options.wiki;\\n    this.dirtyTracking = options.dirtyTracking;\\n    this.preloadDirty = options.preloadDirty || [];\\n    this.pendingAutoSave = false;\\n    // Make a logger\\n    this.logger = new $tw.utils.Logger(\\\"saver-handler\\\");\\n    // Initialise our savers\\n    if ($tw.browser) {\\n      this.initSavers();\\n    }\\n    // Only do dirty tracking if required\\n    if ($tw.browser && this.dirtyTracking) {\\n      // Compile the dirty tiddler filter\\n      this.filterFn = this.wiki.compileFilter(this.wiki.getTiddlerText(this.titleSyncFilter));\\n      // Count of changes that have not yet been saved\\n      var filteredChanges = self.filterFn.call(self.wiki, function(iterator) {\\n        $tw.utils.each(self.preloadDirty, function(title) {\\n          var tiddler = self.wiki.getTiddler(title);\\n          iterator(tiddler, title);\\n        });\\n      });\\n      this.numChanges = filteredChanges.length;\\n      // Listen out for changes to tiddlers\\n      this.wiki.addEventListener(\\\"change\\\", async function(changes) {\\n        // Filter the changes so that we only count changes to tiddlers that we care about\\n        var filteredChanges = self.filterFn.call(self.wiki, function(iterator) {\\n          $tw.utils.each(changes, function(change, title) {\\n            var tiddler = self.wiki.getTiddler(title);\\n            iterator(tiddler, title);\\n          });\\n        });\\n        // Adjust the number of changes\\n        self.numChanges += filteredChanges.length;\\n        self.updateDirtyStatus();\\n        // Do any autosave if one is pending and there's no more change events\\n        if (self.pendingAutoSave && self.wiki.getSizeOfTiddlerEventQueue() === 0) {\\n          // Check if we're dirty\\n          if (self.numChanges > 0) {\\n            await self.saveWiki({\\n              method: \\\"autosave\\\",\\n              downloadType: \\\"text/plain\\\"\\n            });\\n          }\\n          self.pendingAutoSave = false;\\n        }\\n      });\\n      // Listen for the autosave event\\n      $tw.rootWidget.addEventListener(\\\"tm-auto-save-wiki\\\", async function(event) {\\n        // Do the autosave unless there are outstanding tiddler change events\\n        if (self.wiki.getSizeOfTiddlerEventQueue() === 0) {\\n          // Check if we're dirty\\n          if (self.numChanges > 0) {\\n            await self.saveWiki({\\n              method: \\\"autosave\\\",\\n              downloadType: \\\"text/plain\\\"\\n            });\\n          }\\n        } else {\\n          // Otherwise put ourselves in the \\\"pending autosave\\\" state and wait for the change event before we do the autosave\\n          self.pendingAutoSave = true;\\n        }\\n      });\\n      // Set up our beforeunload handler\\n      $tw.addUnloadTask(function(event) {\\n        var confirmationMessage;\\n        if (self.isDirty()) {\\n          confirmationMessage = $tw.language.getString(\\\"UnsavedChangesWarning\\\");\\n          event.returnValue = confirmationMessage; // Gecko\\n        }\\n        return confirmationMessage;\\n      });\\n    }\\n    // Install the save action handlers\\n    if ($tw.browser) {\\n      $tw.rootWidget.addEventListener(\\\"tm-save-wiki\\\", async function(event) {\\n        await self.saveWiki({\\n          template: event.param,\\n          downloadType: \\\"text/plain\\\",\\n          variables: event.paramObject\\n        });\\n      });\\n      $tw.rootWidget.addEventListener(\\\"tm-download-file\\\", async function(event) {\\n        await self.saveWiki({\\n          method: \\\"download\\\",\\n          template: event.param,\\n          downloadType: \\\"text/plain\\\",\\n          variables: event.paramObject\\n        });\\n      });\\n    }\\n  }\\n\\n  SaverHandler.prototype.titleSyncFilter = \\\"$:/config/SaverFilter\\\";\\n  SaverHandler.prototype.titleAutoSave = \\\"$:/config/AutoSave\\\";\\n  SaverHandler.prototype.titleSavedNotification = \\\"$:/language/Notifications/Save/Done\\\";\\n\\n  /*\\nSelect the appropriate saver modules and set them up\\n*/\\n  SaverHandler.prototype.initSavers = function(moduleType) {\\n    moduleType = moduleType || \\\"saver\\\";\\n    // Instantiate the available savers\\n    this.savers = [];\\n    var self = this;\\n    $tw.modules.forEachModuleOfType(moduleType, function(title, module) {\\n      if (module.canSave(self)) {\\n        self.savers.push({ title: title, module: module.create(self.wiki) });\\n      }\\n    });\\n    // Sort savers\\n    this.sortSavers();\\n  };\\n\\n  /*\\n   * Sort the savers into priority order\\n   */\\n  SaverHandler.prototype.sortSavers = function() {\\n    this.savers.sort(function(a, b) {\\n      if (a.module.info.priority < b.module.info.priority) {\\n        return -1;\\n      } else {\\n        if (a.module.info.priority > b.module.info.priority) {\\n          return +1;\\n        } else {\\n          return 0;\\n        }\\n      }\\n    });\\n  };\\n\\n  /*\\nSave the wiki contents. Options are:\\nmethod: \\\"save\\\", \\\"autosave\\\" or \\\"download\\\"\\ntemplate: the tiddler containing the template to save\\ndownloadType: the content type for the saved file\\n*/\\n  SaverHandler.prototype.saveWiki = async function(options) {\\n    options = options || {};\\n    var self = this,\\n      method = options.method || \\\"save\\\";\\n    // Ignore autosave if disabled\\n    if (method === \\\"autosave\\\" && this.wiki.getTiddlerText(this.titleAutoSave, \\\"yes\\\") !== \\\"yes\\\") {\\n      return false;\\n    }\\n    var variables = options.variables || {},\\n      template = options.template || \\\"$:/core/save/all\\\",\\n      downloadType = options.downloadType || \\\"text/plain\\\",\\n      text = this.wiki.renderTiddler(downloadType, template, options),\\n      callback = function(err) {\\n        if (err) {\\n          self.logger.alert($tw.language.getString(\\\"Error/WhileSaving\\\") + \\\": \\\" + err);\\n        } else {\\n          // Clear the task queue if we're saving (rather than downloading)\\n          if (method !== \\\"download\\\") {\\n            self.numChanges = 0;\\n            self.updateDirtyStatus();\\n          }\\n          $tw.notifier.display(self.titleSavedNotification);\\n          if (options.callback) {\\n            options.callback();\\n          }\\n        }\\n      };\\n    // Process preferred if any\\n    var ignorePreferred = null;\\n    var preferredSaver = $tw.wiki.getTiddler(\\\"$:/config/PreferredSaver\\\");\\n    if (preferredSaver !== null && preferredSaver !== undefined) {\\n      var title = preferredSaver.getFieldString(\\\"text\\\");\\n      if (title !== null && title !== undefined && title.trim() !== \\\"\\\") {\\n        ignorePreferred = title;\\n        // Process preferred saver\\n        if (await this.save(this.getSaver(title).module, method, variables, text, callback)) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    // Call the highest priority saver that supports this method\\n    for (var t = this.savers.length - 1; t >= 0; t--) {\\n      // Ignore failed preferred if any\\n      if (this.savers[t].title === ignorePreferred) {\\n        continue;\\n      }\\n      // Process\\n      if (await this.save(this.savers[t].module, method, variables, text, callback)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  SaverHandler.prototype.getSaver = function(title) {\\n    // Locate saver\\n    var saver = null;\\n    for (var i = 0; i < this.savers.length; i++) {\\n      var current = this.savers[i];\\n      if (current.title === title) {\\n        saver = current;\\n        break;\\n      }\\n    }\\n    return saver;\\n  };\\n\\n  SaverHandler.prototype.save = async function(saver, method, variables, text, callback) {\\n    if (\\n      saver.info.capabilities.indexOf(method) !== -1 &&\\n      (await saver.save(text, method, callback, {\\n        variables: { filename: variables.filename }\\n      }))\\n    ) {\\n      this.logger.log(\\\"Saved wiki with method\\\", method, \\\"through saver\\\", saver.info.name);\\n      return true;\\n    }\\n    return false;\\n  };\\n\\n  /*\\nChecks whether the wiki is dirty (ie the window shouldn't be closed)\\n*/\\n  SaverHandler.prototype.isDirty = function() {\\n    return this.numChanges > 0;\\n  };\\n\\n  /*\\nUpdate the document body with the class \\\"tc-dirty\\\" if the wiki has unsaved/unsynced changes\\n*/\\n  SaverHandler.prototype.updateDirtyStatus = function() {\\n    if ($tw.browser) {\\n      $tw.utils.toggleClass(document.body, \\\"tc-dirty\\\", this.isDirty());\\n    }\\n  };\\n\\n  exports.SaverHandler = SaverHandler;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"global\"\n        },\n        \"$:/core/ui/ControlPanel/Saving/General\": {\n            \"title\": \"$:/core/ui/ControlPanel/Saving/General\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/tags/ControlPanel/Saving\",\n            \"caption\": \"{{$:/language/ControlPanel/Saving/General/Caption}}\",\n            \"list-before\": \"\",\n            \"text\": \"\\\\define lingo-base() $:/language/ControlPanel/Settings/\\n\\n\\\\define ipfs-saver()\\n<$text text=<<ipfs-info-saver \\\"$(currentTiddler)$\\\">>/>\\n\\\\end\\n\\n{{$:/language/ControlPanel/Saving/General/Hint}}\\n\\n!! <$link to=\\\"$:/config/PreferredSaver\\\"><<lingo PreferredSaver/Caption>></$link>\\n\\n<$select tiddler=\\\"$:/config/PreferredSaver\\\">\\n<$list filter=\\\"[savers[]]\\\">\\n<option value=<<currentTiddler>>><<ipfs-saver>></option>\\n</$list>\\n</$select>\\n\\n!! <$link to=\\\"$:/config/AutoSave\\\"><<lingo AutoSave/Caption>></$link>\\n\\n<<lingo AutoSave/Hint>>\\n\\n<$radio tiddler=\\\"$:/config/AutoSave\\\" value=\\\"yes\\\"> <<lingo AutoSave/Enabled/Description>> </$radio>\\n\\n<$radio tiddler=\\\"$:/config/AutoSave\\\" value=\\\"no\\\"> <<lingo AutoSave/Disabled/Description>> </$radio>\\n\"\n        },\n        \"$:/core/ui/ControlPanel/Toolbars/ItemTemplate\": {\n            \"title\": \"$:/core/ui/ControlPanel/Toolbars/ItemTemplate\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"text\": \"\\\\define config-title()\\n$(config-base)$$(currentTiddler)$\\n\\\\end\\n\\n<$draggable tiddler=<<currentTiddler>>>\\n<$checkbox tiddler=<<config-title>> field=\\\"text\\\" checked=\\\"show\\\" unchecked=\\\"hide\\\" default=\\\"show\\\"/> <span class=\\\"tc-icon-wrapper tc-icon-ipfs-wrapper\\\"> <$transclude field=\\\"caption\\\"/> <i class=\\\"tc-muted\\\">-- <$transclude field=\\\"description\\\"/></i></span>\\n</$draggable>\\n\"\n        },\n        \"$:/core/ui/EditTemplate/body\": {\n            \"title\": \"$:/core/ui/EditTemplate/body\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/tags/EditTemplate\",\n            \"text\": \"\\\\define lingo-base() $:/language/EditTemplate/Body/\\n\\\\define config-visibility-title()\\n$:/config/EditorToolbarButtons/Visibility/$(currentTiddler)$\\n\\\\end\\n\\n<$list filter=\\\"[all[current]has[_canonical_uri]]\\\">\\n  <div class=\\\"tc-message-box\\\">\\n    <<lingo External/Hint>>\\n    <p><$ipfslink caption={{!!_canonical_uri}} value={{!!_canonical_uri}} tiddler=<<currentTiddler>>/></p>\\n  </div>\\n</$list>\\n\\n<$list filter=\\\"[all[current]!has[_canonical_uri]]\\\">\\n  <$reveal state=\\\"$:/state/showeditpreview\\\" type=\\\"match\\\" text=\\\"yes\\\">\\n    <div class=\\\"tc-tiddler-preview\\\">\\n      <$transclude tiddler=\\\"$:/core/ui/EditTemplate/body/editor\\\" mode=\\\"inline\\\"/>\\n      <div class=\\\"tc-tiddler-preview-preview\\\">\\n        <$transclude tiddler={{$:/state/editpreviewtype}} mode=\\\"inline\\\">\\n          <$transclude tiddler=\\\"$:/core/ui/EditTemplate/body/preview/output\\\" mode=\\\"inline\\\"/>\\n        </$transclude>\\n      </div>\\n    </div>\\n  </$reveal>\\n  <$reveal state=\\\"$:/state/showeditpreview\\\" type=\\\"nomatch\\\" text=\\\"yes\\\">\\n    <$transclude tiddler=\\\"$:/core/ui/EditTemplate/body/editor\\\" mode=\\\"inline\\\"/>\\n  </$reveal>\\n</$list>\"\n        },\n        \"$:/core/ui/EditTemplate/fields\": {\n            \"title\": \"$:/core/ui/EditTemplate/fields\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/tags/EditTemplate\",\n            \"text\": \"\\\\define lingo-base() $:/language/EditTemplate/\\n\\\\define config-title()\\n$:/config/EditTemplateFields/Visibility/$(currentField)$\\n\\\\end\\n\\n\\\\define config-filter()\\n[[hide]] -[title{$(config-title)$}]\\n\\\\end\\n\\n\\\\define current-tiddler-new-field-selector()\\n[data-tiddler-title=\\\"$(currentTiddlerCSSescaped)$\\\"] .tc-edit-field-add-name input\\n\\\\end\\n\\n\\\\define new-field-actions()\\n<$action-sendmessage $message=\\\"tm-add-field\\\" $name={{{ [<newFieldNameTiddler>get[text]] }}} $value={{{ [<newFieldValueTiddler>get[text]] }}}/>\\n<$action-deletetiddler $tiddler=<<newFieldNameTiddler>>/>\\n<$action-deletetiddler $tiddler=<<newFieldValueTiddler>>/>\\n<$action-sendmessage $message=\\\"tm-focus-selector\\\" $param=<<current-tiddler-new-field-selector>>/>\\n\\\\end\\n\\n\\\\define new-field()\\n<$vars name={{{ [<newFieldNameTiddler>get[text]] }}}>\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" default=<<name>>>\\n<$button tooltip=<<lingo Fields/Add/Button/Hint>>>\\n<$action-sendmessage $message=\\\"tm-add-field\\\"\\n$name=<<name>>\\n$value={{{ [<newFieldValueTiddler>get[text]] }}}/>\\n<$action-deletetiddler $tiddler=<<newFieldNameTiddler>>/>\\n<$action-deletetiddler $tiddler=<<newFieldValueTiddler>>/>\\n<<lingo Fields/Add/Button>>\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" default=<<name>>>\\n<$button>\\n<<lingo Fields/Add/Button>>\\n</$button>\\n</$reveal>\\n</$vars>\\n\\\\end\\n\\\\whitespace trim\\n\\n<div class=\\\"tc-edit-fields\\\">\\n<table class=\\\"tc-edit-fields\\\">\\n<tbody>\\n<$list filter=\\\"[all[current]fields[]] +[sort[title]]\\\" variable=\\\"currentField\\\" storyview=\\\"pop\\\">\\n<$list filter=<<config-filter>> variable=\\\"temp\\\">\\n<tr class=\\\"tc-edit-field\\\">\\n<td class=\\\"tc-edit-field-name\\\">\\n<$ipfslink caption=<<currentField>> field=<<currentField>> tiddler=<<currentTiddler>>/>\\n</td>\\n<td class=\\\"tc-edit-field-value\\\">\\n<$edit-text tiddler=<<currentTiddler>> field=<<currentField>> placeholder={{$:/language/EditTemplate/Fields/Add/Value/Placeholder}} tabindex={{$:/config/EditTabIndex}}/>\\n</td>\\n<td class=\\\"tc-edit-field-remove\\\">\\n<$button class=\\\"tc-btn-invisible\\\" tooltip={{$:/language/EditTemplate/Field/Remove/Hint}} aria-label={{$:/language/EditTemplate/Field/Remove/Caption}}>\\n<$action-deletefield $field=<<currentField>>/>\\n{{$:/core/images/delete-button}}\\n</$button>\\n</td>\\n</tr>\\n</$list>\\n</$list>\\n</tbody>\\n</table>\\n</div>\\n\\n<$fieldmangler>\\n<div class=\\\"tc-edit-field-add\\\">\\n<em class=\\\"tc-edit\\\">\\n<<lingo Fields/Add/Prompt>>&nbsp;&nbsp;\\n</em>\\n<span class=\\\"tc-edit-field-add-name\\\">\\n<$edit-text tiddler=<<newFieldNameTiddler>> tag=\\\"input\\\" default=\\\"\\\" placeholder={{$:/language/EditTemplate/Fields/Add/Name/Placeholder}} focusPopup=<<qualify \\\"$:/state/popup/field-dropdown\\\">> class=\\\"tc-edit-texteditor tc-popup-handle\\\" tabindex={{$:/config/EditTabIndex}} focus={{{ [{$:/config/AutoFocus}match[fields]then[true]] ~[[false]] }}}/>\\n</span>&nbsp;\\n<$button popup=<<qualify \\\"$:/state/popup/field-dropdown\\\">> class=\\\"tc-btn-invisible tc-btn-dropdown\\\" tooltip={{$:/language/EditTemplate/Field/Dropdown/Hint}} aria-label={{$:/language/EditTemplate/Field/Dropdown/Caption}}>{{$:/core/images/down-arrow}}</$button>&nbsp;\\n<$reveal state=<<qualify \\\"$:/state/popup/field-dropdown\\\">> type=\\\"nomatch\\\" text=\\\"\\\" default=\\\"\\\">\\n<div class=\\\"tc-block-dropdown tc-edit-type-dropdown\\\">\\n<$set name=\\\"tv-show-missing-links\\\" value=\\\"yes\\\">\\n<$linkcatcher to=<<newFieldNameTiddler>>>\\n<div class=\\\"tc-dropdown-item\\\">\\n<<lingo Fields/Add/Dropdown/User>>\\n</div>\\n<$set name=\\\"newFieldName\\\" value={{{ [<newFieldNameTiddler>get[text]] }}}>\\n<$list filter=\\\"[!is[shadow]!is[system]fields[]search:title<newFieldName>sort[]] -created -creator -draft.of -draft.title -modified -modifier -tags -text -title -type\\\"  variable=\\\"currentField\\\">\\n<$link to=<<currentField>>>\\n<$text text=<<currentField>>/>\\n</$link>\\n</$list>\\n<div class=\\\"tc-dropdown-item\\\">\\n<<lingo Fields/Add/Dropdown/System>>\\n</div>\\n<$list filter=\\\"[fields[]search:title<newFieldName>sort[]] -[!is[shadow]!is[system]fields[]]\\\" variable=\\\"currentField\\\">\\n<$link to=<<currentField>>>\\n<$text text=<<currentField>>/>\\n</$link>\\n</$list>\\n</$set>\\n</$linkcatcher>\\n</$set>\\n</div>\\n</$reveal>\\n<span class=\\\"tc-edit-field-add-value\\\">\\n<$set name=\\\"currentTiddlerCSSescaped\\\" value={{{ [<currentTiddler>escapecss[]] }}}>\\n<$keyboard key=\\\"((add-field))\\\" actions=<<new-field-actions>>>\\n<$edit-text tiddler=<<newFieldValueTiddler>> tag=\\\"input\\\" default=\\\"\\\" placeholder={{$:/language/EditTemplate/Fields/Add/Value/Placeholder}} class=\\\"tc-edit-texteditor\\\" tabindex={{$:/config/EditTabIndex}}/>\\n</$keyboard>\\n</$set>\\n</span>&nbsp;\\n<span class=\\\"tc-edit-field-add-button\\\">\\n<$macrocall $name=\\\"new-field\\\"/>\\n</span>\\n</div>\\n</$fieldmangler>\"\n        },\n        \"$:/core/ui/EditTemplate\": {\n            \"title\": \"$:/core/ui/EditTemplate\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"text\": \"\\\\define save-tiddler-actions()\\n<$action-sendmessage $message=\\\"tm-add-tag\\\" $param={{{ [<newTagNameTiddler>get[text]] }}}/>\\n<$action-deletetiddler $tiddler=<<newTagNameTiddler>>/>\\n<$action-sendmessage $message=\\\"tm-add-field\\\" $name={{{ [<newFieldNameTiddler>get[text]] }}} $value={{{ [<newFieldValueTiddler>get[text]] }}}/>\\n<$action-deletetiddler $tiddler=<<newFieldNameTiddler>>/>\\n<$action-deletetiddler $tiddler=<<newFieldValueTiddler>>/>\\n<$action-sendmessage $message=\\\"tm-save-tiddler\\\"/>\\n\\\\end\\n<div data-tiddler-title=<<currentTiddler>> data-tags={{!!tags}} class={{{ tc-tiddler-frame tc-tiddler-edit-frame [<currentTiddler>is[tiddler]then[tc-tiddler-exists]] [<currentTiddler>is[missing]!is[shadow]then[tc-tiddler-missing]] [<currentTiddler>is[shadow]then[tc-tiddler-exists tc-tiddler-shadow]] [<currentTiddler>is[system]then[tc-tiddler-system]] [{!!class}] [<currentTiddler>tags[]encodeuricomponent[]addprefix[tc-tagged-]] +[join[ ]] }}}>\\n<$fieldmangler>\\n<$vars storyTiddler=<<currentTiddler>> newTagNameTiddler=<<qualify \\\"$:/temp/NewTagName\\\">> newFieldNameTiddler=<<qualify \\\"$:/temp/NewFieldName\\\">> newFieldValueTiddler=<<qualify \\\"$:/temp/NewFieldValue\\\">>>\\n<$keyboard key=\\\"((cancel-edit-tiddler))\\\" message=\\\"tm-cancel-tiddler\\\">\\n<$keyboard key=\\\"((save-tiddler))\\\" actions=<<save-tiddler-actions>>>\\n<$list filter=\\\"[all[shadows+tiddlers]list[$:/tags/EditTemplate]!has[draft.of]]\\\" variable=\\\"listItem\\\">\\n<$set name=\\\"tv-config-toolbar-class\\\" filter=\\\"[<tv-config-toolbar-class>] [<listItem>encodeuricomponent[]addprefix[tc-btn-]]\\\">\\n<$transclude tiddler=<<listItem>>/>\\n</$set>\\n</$list>\\n</$keyboard>\\n</$keyboard>\\n</$vars>\\n</$fieldmangler>\\n</div>\"\n        },\n        \"$:/core/ui/SideBar/Tools\": {\n            \"title\": \"$:/core/ui/SideBar/Tools\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/SideBar\",\n            \"caption\": \"{{$:/language/SideBar/Tools/Caption}}\",\n            \"text\": \"\\\\define lingo-base() $:/language/ControlPanel/\\n\\\\define config-title()\\n$:/config/PageControlButtons/Visibility/$(listItem)$\\n\\\\end\\n\\n<<lingo Basics/Version/Prompt>> <b><<version>></b>, <<lingo Ipfs/Version/Prompt>> <b><<ipfs-version>></b>\\n\\n<$set name=\\\"tv-config-toolbar-icons\\\" value=\\\"yes\\\">\\n\\n<$set name=\\\"tv-config-toolbar-text\\\" value=\\\"yes\\\">\\n\\n<$set name=\\\"tv-config-toolbar-class\\\" value=\\\"\\\">\\n\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/PageControls]!has[draft.of]]\\\" variable=\\\"listItem\\\">\\n\\n<div style=\\\"position:relative;\\\" class={{{ [<listItem>encodeuricomponent[]addprefix[tc-btn-]] }}}>\\n\\n<$checkbox tiddler=<<config-title>> field=\\\"text\\\" checked=\\\"show\\\" unchecked=\\\"hide\\\" default=\\\"show\\\"/> <$transclude tiddler=<<listItem>>/> <i class=\\\"tc-muted\\\"><$transclude tiddler=<<listItem>> field=\\\"description\\\"/></i>\\n\\n</div>\\n\\n</$list>\\n\\n</$set>\\n\\n</$set>\\n\\n</$set>\"\n        },\n        \"$:/plugins/ipfs/modules/widgets/image.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/widgets/image.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/widgets/image.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nThe image widget displays an image referenced with an external URI or with a local tiddler title.\\n\\n```\\n<$image src=\\\"TiddlerTitle\\\" width=\\\"320\\\" height=\\\"400\\\" class=\\\"classnames\\\">\\n```\\n\\nThe image source can be the title of an existing tiddler or the URL of an external image.\\n\\nExternal images always generate an HTML `<img>` tag.\\n\\nTiddlers that have a _canonical_uri field generate an HTML `<img>` tag with the src attribute containing the URI.\\n\\nTiddlers that contain image data generate an HTML `<img>` tag with the src attribute containing a base64 representation of the image.\\n\\nTiddlers that contain wikitext could be rendered to a DIV of the usual size of a tiddler, and then transformed to the size requested.\\n\\nThe width and height attributes are interpreted as a number of pixels, and do not need to include the \\\"px\\\" suffix.\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  var Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n  var name = \\\"ipfs-image\\\";\\n\\n  var ImageWidget = function(parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options);\\n  };\\n\\n  /*\\nInherit from the base widget class\\n*/\\n  ImageWidget.prototype = new Widget();\\n\\n  ImageWidget.prototype.getLogger = function() {\\n    if (window.log) {\\n      return window.log.getLogger(name);\\n    }\\n    return console;\\n  };\\n\\n  /*\\nRender this widget into the DOM\\n*/\\n  ImageWidget.prototype.render = function(parent, nextSibling) {\\n    var self = this;\\n    this.parentDomNode = parent;\\n    this.computeAttributes();\\n    this.execute();\\n    // Create element\\n    // Determine what type of image it is\\n    var tiddler = this.wiki.getTiddler(this.imageSource);\\n    // Create default element\\n    var domNode = this.document.createElement(\\\"img\\\");\\n    if (!tiddler) {\\n      // The source isn't the title of a tiddler, so we'll assume it's a URL\\n      domNode.setAttribute(\\n        \\\"src\\\",\\n        this.getVariable(\\\"tv-get-export-image-link\\\", {\\n          params: [{ name: \\\"src\\\", value: this.imageSource }],\\n          defaultValue: this.imageSource\\n        })\\n      );\\n    } else {\\n      // Check if it is an image tiddler\\n      if (this.wiki.isImageTiddler(this.imageSource)) {\\n        var type = tiddler.fields.type;\\n        var text = tiddler.fields.text;\\n        var _canonical_uri = tiddler.fields._canonical_uri;\\n        // If the tiddler has body text then it doesn't need to be lazily loaded\\n        if (text) {\\n          // Render the appropriate element for the image type\\n          switch (type) {\\n            case \\\"application/pdf\\\":\\n              domNode = this.document.createElement(\\\"embed\\\");\\n              domNode.setAttribute(\\\"src\\\", \\\"data:application/pdf;base64,\\\" + text);\\n              break;\\n            case \\\"image/svg+xml\\\":\\n              domNode.setAttribute(\\\"src\\\", \\\"data:image/svg+xml,\\\" + encodeURIComponent(text));\\n              break;\\n            default:\\n              domNode.setAttribute(\\\"src\\\", \\\"data:\\\" + type + \\\";base64,\\\" + text);\\n              break;\\n          }\\n        } else if (_canonical_uri) {\\n          // Normalize\\n          var uri = _canonical_uri;\\n          $tw.ipfs\\n            .normalizeIpfsUrl(uri)\\n            .then(uri => {\\n              // Process\\n              switch (type) {\\n                case \\\"application/pdf\\\":\\n                  domNode = this.document.createElement(\\\"embed\\\");\\n                  $tw.utils\\n                    .loadToBase64(uri)\\n                    .then(loaded => {\\n                      domNode.setAttribute(\\\"src\\\", \\\"data:application/pdf;base64,\\\" + loaded.data);\\n                    })\\n                    .catch(error => {\\n                      self.getLogger().error(error);\\n                      $tw.utils.alert(name, error.message);\\n                    });\\n                  break;\\n                case \\\"image/svg+xml\\\":\\n                  $tw.utils\\n                    .loadToUtf8(uri)\\n                    .then(loaded => {\\n                      domNode.setAttribute(\\\"src\\\", \\\"data:image/svg+xml,\\\" + encodeURIComponent(loaded.data));\\n                    })\\n                    .catch(error => {\\n                      self.getLogger().error(error);\\n                      $tw.utils.alert(name, error.message);\\n                    });\\n                  break;\\n                default:\\n                  $tw.utils\\n                    .loadToBase64(uri)\\n                    .then(loaded => {\\n                      domNode.setAttribute(\\\"src\\\", \\\"data:\\\" + type + \\\";base64,\\\" + loaded.data);\\n                    })\\n                    .catch(error => {\\n                      self.getLogger().error(error);\\n                      $tw.utils.alert(name, error.message);\\n                    });\\n                  break;\\n              }\\n            })\\n            .catch(error => {\\n              self.getLogger().error(error);\\n              $tw.utils.alert(name, error.message);\\n            });\\n        } else {\\n          // Just trigger loading of the tiddler\\n          this.wiki.getTiddlerText(this.imageSource);\\n          domNode.setAttribute(\\\"src\\\", \\\"\\\");\\n        }\\n      }\\n    }\\n    // Assign the attributes\\n    if (this.imageClass) {\\n      domNode.setAttribute(\\\"class\\\", this.imageClass);\\n    }\\n    if (this.imageWidth) {\\n      domNode.setAttribute(\\\"width\\\", this.imageWidth);\\n    }\\n    if (this.imageHeight) {\\n      domNode.setAttribute(\\\"height\\\", this.imageHeight);\\n    }\\n    if (this.imageTooltip) {\\n      domNode.setAttribute(\\\"title\\\", this.imageTooltip);\\n    }\\n    if (this.imageAlt) {\\n      domNode.setAttribute(\\\"alt\\\", this.imageAlt);\\n    }\\n    // Insert element\\n    parent.insertBefore(domNode, nextSibling);\\n    this.domNodes.push(domNode);\\n  };\\n\\n  /*\\nCompute the internal state of the widget\\n*/\\n  ImageWidget.prototype.execute = function() {\\n    // Get our parameters\\n    this.imageSource = this.getAttribute(\\\"source\\\");\\n    this.imageWidth = this.getAttribute(\\\"width\\\");\\n    this.imageHeight = this.getAttribute(\\\"height\\\");\\n    this.imageClass = this.getAttribute(\\\"class\\\");\\n    this.imageTooltip = this.getAttribute(\\\"tooltip\\\");\\n    this.imageAlt = this.getAttribute(\\\"alt\\\");\\n  };\\n\\n  /*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\n  ImageWidget.prototype.refresh = function(changedTiddlers) {\\n    var changedAttributes = this.computeAttributes();\\n    if (\\n      changedAttributes.source ||\\n      changedAttributes.width ||\\n      changedAttributes.height ||\\n      changedAttributes[\\\"class\\\"] ||\\n      changedAttributes.tooltip ||\\n      changedTiddlers[this.imageSource]\\n    ) {\\n      this.refreshSelf();\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  };\\n\\n  exports.image = ImageWidget;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/encryption\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/encryption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/home\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/home\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/pin\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/pin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/unpin\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/unpin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/console/mobile\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipfs/console/mobile\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/more-page-actions\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/more-page-actions\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"show\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ens/publish\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ens/publish\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipns/publish\": {\n            \"title\": \"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/ipns/publish\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/content\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/content\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/attachment\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/export/attachment\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/refresh\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/refresh\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/pin\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/pin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/unpin\": {\n            \"title\": \"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/ipfs/tiddler/unpin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"hide\"\n        },\n        \"$:/plugins/ipfs/ipfs-wiki.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-wiki.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-wiki.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: wikimethod\\n\\nwikimethod\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\n   * Parse a block of text of a specified MIME type\\n   *  type: content type of text to be parsed\\n   *  text: text\\n   *  options: see below\\n   * Options include:\\n   *  parseAsInline: if true, the text of the tiddler will be parsed as an inline run\\n   *  _canonical_uri: optional string of the canonical URI of this content\\n   */\\n  exports.parseText = function(type, text, options) {\\n    var text = text || \\\"\\\";\\n    var options = options || {};\\n    // Select a parser\\n    var Parser = $tw.Wiki.parsers[type];\\n    if (!Parser && $tw.utils.getFileExtensionInfo(type)) {\\n      Parser = $tw.Wiki.parsers[$tw.utils.getFileExtensionInfo(type).type];\\n    }\\n    if (!Parser) {\\n      Parser = $tw.Wiki.parsers[options.defaultType || \\\"text/vnd.tiddlywiki\\\"];\\n    }\\n    if (!Parser) {\\n      return null;\\n    }\\n    // Return the parser instance\\n    return new Parser(type, text, {\\n      parseAsInline: options.parseAsInline,\\n      wiki: this,\\n      _canonical_uri: options._canonical_uri,\\n      tiddler: options.tiddler\\n    });\\n  };\\n\\n  /*\\n   * Parse a tiddler according to its MIME type\\n   */\\n  exports.parseTiddler = function(title, options) {\\n    options = $tw.utils.extend({}, options);\\n    var cacheType = options.parseAsInline ? \\\"inlineParseTree\\\" : \\\"blockParseTree\\\",\\n      tiddler = this.getTiddler(title),\\n      self = this;\\n    return tiddler\\n      ? this.getCacheForTiddler(title, cacheType, function() {\\n          if (tiddler.hasField(\\\"_canonical_uri\\\")) {\\n            options._canonical_uri = tiddler.fields._canonical_uri;\\n          }\\n          options.tiddler = tiddler;\\n          return self.parseText(tiddler.fields.type, tiddler.fields.text, options);\\n        })\\n      : null;\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"wikimethod\"\n        },\n        \"$:/plugins/ipfs/ens-action.js\": {\n            \"title\": \"$:/plugins/ipfs/ens-action.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ens-action.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nEnsAction\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const EnsWrapper = require(\\\"$:/plugins/ipfs/ens-wrapper.js\\\").EnsWrapper;\\n  const IpfsWrapper = require(\\\"$:/plugins/ipfs/ipfs-wrapper.js\\\").IpfsWrapper;\\n\\n  const fileProtocol = \\\"file:\\\";\\n  const ipfsKeyword = \\\"ipfs\\\";\\n  const ipnsKeyword = \\\"ipns\\\";\\n\\n  const name = \\\"ens-action\\\";\\n\\n  var EnsAction = function() {\\n    this.once = false;\\n    this.ensWrapper = new EnsWrapper();\\n    this.ipfsWrapper = new IpfsWrapper();\\n  };\\n\\n  EnsAction.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  EnsAction.prototype.init = function() {\\n    // Init once\\n    if (this.once) {\\n      return;\\n    }\\n    const self = this;\\n    $tw.rootWidget.addEventListener(\\\"tm-ens-manager-open\\\", function(event) {\\n      return self.handleOpenEnsManager(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ens-resolve-and-open\\\", async function(event) {\\n      return await self.handleResolveEnsAndOpen(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ens-publish\\\", async function(event) {\\n      return await self.handlePublishToEns(event);\\n    });\\n    // Init once\\n    this.once = true;\\n  };\\n\\n  EnsAction.prototype.handleOpenEnsManager = function(event) {\\n    // Retrieve ENS domain\\n    const ensDomain = $tw.utils.getIpfsEnsDomain();\\n    // Check\\n    if (ensDomain == null) {\\n      window.open(\\\"https://app.ens.domains\\\", \\\"_blank\\\", \\\"noopener\\\");\\n    } else {\\n      window.open(\\\"https://app.ens.domains/name/\\\" + ensDomain, \\\"_blank\\\", \\\"noopener\\\");\\n    }\\n    return true;\\n  };\\n\\n  EnsAction.prototype.handleResolveEnsAndOpen = async function(event) {\\n    try {\\n      // Getting default ENS domain\\n      const ensDomain = $tw.utils.getIpfsEnsDomain();\\n      // Check\\n      if (ensDomain == null) {\\n        $tw.utils.alert(name, \\\"Undefined ENS domain...\\\");\\n        return false;\\n      }\\n\\n      this.getLogger().info(\\\"ENS domain: \\\" + ensDomain);\\n\\n      const parsed = await $tw.ipfs.resolveENS(ensDomain);\\n      if (parsed !== null) {\\n        window.open(parsed.toString(), \\\"_blank\\\", \\\"noopener\\\");\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  EnsAction.prototype.handlePublishToEns = async function(event) {\\n    try {\\n      // Process document URL\\n      const wiki = $tw.ipfs.getDocumentUrl();\\n\\n      // Check\\n      if (wiki.protocol === fileProtocol) {\\n        $tw.utils.alert(name, \\\"Undefined IPFS wiki...\\\");\\n        return false;\\n      }\\n\\n      // Extract and check URL IPFS protocol and CID\\n      var { protocol, cid } = this.ipfsWrapper.decodeCid(wiki.pathname);\\n\\n      // Check\\n      if (protocol == null) {\\n        $tw.utils.alert(name, \\\"Unknown IPFS protocol...\\\");\\n        return false;\\n      }\\n      if (cid == null) {\\n        $tw.utils.alert(name, \\\"Unknown IPFS identifier...\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Resolve IPNS key if applicable\\n      if (protocol === ipnsKeyword) {\\n        const { ipnsKey } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, cid);\\n        cid = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n      }\\n\\n      // Getting the default ENS domain\\n      const ensDomain = $tw.utils.getIpfsEnsDomain();\\n      // Check\\n      if (ensDomain == null) {\\n        $tw.utils.alert(name, \\\"Undefined ENS domain...\\\");\\n        return false;\\n      }\\n\\n      // Retrieve a Web3 provider\\n      const { web3, account } = await $tw.ipfs.getEnabledWeb3Provider();\\n\\n      // Fetch ENS domain content\\n      const { content } = await this.ensWrapper.getContenthash(ensDomain, web3);\\n      // Nothing to publish\\n      if (content !== null && content === cid) {\\n        $tw.utils.alert(name, \\\"The current resolved ENS domain content is up to date...\\\");\\n        return false;\\n      }\\n\\n      const parsed = await $tw.ipfs.normalizeIpfsUrl(\\\"/\\\" + ipfsKeyword + \\\"/\\\" + cid);\\n      this.getLogger().info(\\\"Publishing wiki:\\\" + \\\"\\\\n \\\" + parsed.href + \\\"\\\\n to ENS domain: \\\" + ensDomain);\\n\\n      await this.ensWrapper.setContenthash(ensDomain, cid, web3, account);\\n\\n      // Unpin if applicable\\n      if ($tw.utils.getIpfsUnpin() && content !== null) {\\n        try {\\n          await this.ipfsWrapper.unpinFromIpfs(ipfs, content);\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n        }\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  exports.EnsAction = EnsAction;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ens-wrapper.js\": {\n            \"title\": \"$:/plugins/ipfs/ens-wrapper.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ens-wrapper.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nEnsWrapper\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /**\\n   * https://github.com/purposeindustries/window-or-global\\n   * The MIT License (MIT) Copyright (c) Purpose Industries\\n   * version: 1.0.1\\n   */\\n  const root =\\n    (typeof self === \\\"object\\\" && self.self === self && self) ||\\n    (typeof global === \\\"object\\\" && global.global === global && global) ||\\n    this;\\n\\n  const EnsLibrary = require(\\\"./ipfs-bundle.js\\\").EnsLibrary;\\n  const IpfsLibrary = require(\\\"./ipfs-bundle.js\\\").IpfsLibrary;\\n  const IpfsUri = require(\\\"./ipfs-bundle.js\\\").IpfsUri;\\n\\n  const name = \\\"ens-wrapper\\\";\\n\\n  var EnsWrapper = function() {\\n    this.ensLibrary = new EnsLibrary.EnsLibrary();\\n    this.ipfsLibrary = new IpfsLibrary.IpfsLibrary();\\n    this.ipfsUri = new IpfsUri.IpfsUri();\\n  };\\n\\n  EnsWrapper.prototype.getLogger = function() {\\n    return root.log.getLogger(name);\\n  };\\n\\n  EnsWrapper.prototype.getContenthash = async function(domain, web3) {\\n    try {\\n      // Retrieve\\n      var { content, protocol } = await this.ensLibrary.getContenthash(domain, web3);\\n      if (content !== null && protocol !== null) {\\n        // Convert CidV0 to CidV1\\n        content = this.ipfsLibrary.cidV0ToCidV1(content);\\n        // Normalize\\n        const url = await this.ipfsUri.normalizeUrl(\\\"/\\\" + protocol + \\\"/\\\" + content);\\n        this.getLogger().info(\\\"Successfully fetched ENS domain content:\\\" + \\\"\\\\n \\\" + url.href + \\\"\\\\n from: \\\" + domain);\\n        // Success\\n        return {\\n          content: content,\\n          protocol: protocol\\n        };\\n      }\\n      this.getLogger().warn(\\\"Unassigned ENS domain content...\\\");\\n      return {\\n        content: null,\\n        protocol: null\\n      };\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      throw new Error(\\\"Unable to fetch ENS domain content...\\\");\\n    }\\n  };\\n\\n  EnsWrapper.prototype.setContenthash = async function(domain, cid, web3, account) {\\n    try {\\n      // Convert CidV1 to CidV0\\n      const cidv0 = this.ipfsLibrary.cidV1ToCidV0(cid);\\n      // Set\\n      await this.ensLibrary.setContenthash(domain, cidv0, web3, account);\\n      // Normalize\\n      const url = await this.ipfsUri.normalizeUrl(\\\"/ipfs/\\\" + cidv0);\\n      // Success\\n      this.getLogger().info(\\\"Successfully set ENS domain content:\\\" + \\\"\\\\n \\\" + url.href + \\\"\\\\n to: \\\" + domain);\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      throw new Error(\\\"Unable to set ENS domain content...\\\");\\n    }\\n  };\\n\\n  EnsWrapper.prototype.getEnabledWeb3Provider = async function(provider) {\\n    try {\\n      const { web3, chainId, account } = await this.ensLibrary.getEnabledWeb3Provider(provider);\\n      return {\\n        web3: web3,\\n        chainId: chainId,\\n        account: account\\n      };\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      throw new Error(\\\"Unable to retrieve an enabled Ethereum provider...\\\");\\n    }\\n  };\\n\\n  EnsWrapper.prototype.getWeb3Provider = async function(provider) {\\n    try {\\n      const { web3, chainId } = await this.ensLibrary.getWeb3Provider(provider);\\n      return {\\n        web3: web3,\\n        chainId: chainId\\n      };\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      throw new Error(\\\"Unable to retrieve an Ethereum provider...\\\");\\n    }\\n  };\\n\\n  EnsWrapper.prototype.getProvider = async function() {\\n    try {\\n      const provider = await this.ensLibrary.getProvider();\\n      return provider;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      throw new Error(\\\"Unable to retrieve an Ethereum provider...\\\");\\n    }\\n  };\\n\\n  EnsWrapper.prototype.getEtherscanRegistry = function() {\\n    return this.ensLibrary.getEtherscanRegistry();\\n  };\\n\\n  EnsWrapper.prototype.getNetwork = function() {\\n    return this.ensLibrary.getNetwork();\\n  };\\n\\n  EnsWrapper.prototype.getENSRegistry = function() {\\n    return this.ensLibrary.getENSRegistry();\\n  };\\n\\n  exports.EnsWrapper = EnsWrapper;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/loglevel/loglevel.js\": {\n            \"text\": \"/*\\n* loglevel - https://github.com/pimterry/loglevel\\n*\\n* Copyright (c) 2013 Tim Perry\\n* Licensed under the MIT license.\\n*/\\n(function (root, definition) {\\n    \\\"use strict\\\";\\n    if (typeof define === 'function' && define.amd) {\\n        define(definition);\\n    } else if (typeof module === 'object' && module.exports) {\\n        module.exports = definition();\\n    } else {\\n        root.log = definition();\\n    }\\n}(this, function () {\\n    \\\"use strict\\\";\\n\\n    // Slightly dubious tricks to cut down minimized file size\\n    var noop = function() {};\\n    var undefinedType = \\\"undefined\\\";\\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\\n        /Trident\\\\/|MSIE /.test(window.navigator.userAgent)\\n    );\\n\\n    var logMethods = [\\n        \\\"trace\\\",\\n        \\\"debug\\\",\\n        \\\"info\\\",\\n        \\\"warn\\\",\\n        \\\"error\\\"\\n    ];\\n\\n    // Cross-browser bind equivalent that works at least back to IE6\\n    function bindMethod(obj, methodName) {\\n        var method = obj[methodName];\\n        if (typeof method.bind === 'function') {\\n            return method.bind(obj);\\n        } else {\\n            try {\\n                return Function.prototype.bind.call(method, obj);\\n            } catch (e) {\\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\\n                return function() {\\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\\n                };\\n            }\\n        }\\n    }\\n\\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\\n    function traceForIE() {\\n        if (console.log) {\\n            if (console.log.apply) {\\n                console.log.apply(console, arguments);\\n            } else {\\n                // In old IE, native console methods themselves don't have apply().\\n                Function.prototype.apply.apply(console.log, [console, arguments]);\\n            }\\n        }\\n        if (console.trace) console.trace();\\n    }\\n\\n    // Build the best logging method possible for this env\\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\\n    function realMethod(methodName) {\\n        if (methodName === 'debug') {\\n            methodName = 'log';\\n        }\\n\\n        if (typeof console === undefinedType) {\\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\\n        } else if (methodName === 'trace' && isIE) {\\n            return traceForIE;\\n        } else if (console[methodName] !== undefined) {\\n            return bindMethod(console, methodName);\\n        } else if (console.log !== undefined) {\\n            return bindMethod(console, 'log');\\n        } else {\\n            return noop;\\n        }\\n    }\\n\\n    // These private functions always need `this` to be set properly\\n\\n    function replaceLoggingMethods(level, loggerName) {\\n        /*jshint validthis:true */\\n        for (var i = 0; i < logMethods.length; i++) {\\n            var methodName = logMethods[i];\\n            this[methodName] = (i < level) ?\\n                noop :\\n                this.methodFactory(methodName, level, loggerName);\\n        }\\n\\n        // Define log.log as an alias for log.debug\\n        this.log = this.debug;\\n    }\\n\\n    // In old IE versions, the console isn't present until you first open it.\\n    // We build realMethod() replacements here that regenerate logging methods\\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\\n        return function () {\\n            if (typeof console !== undefinedType) {\\n                replaceLoggingMethods.call(this, level, loggerName);\\n                this[methodName].apply(this, arguments);\\n            }\\n        };\\n    }\\n\\n    // By default, we use closely bound real methods wherever possible, and\\n    // otherwise we wait for a console to appear, and then try again.\\n    function defaultMethodFactory(methodName, level, loggerName) {\\n        /*jshint validthis:true */\\n        return realMethod(methodName) ||\\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\\n    }\\n\\n    function Logger(name, defaultLevel, factory) {\\n      var self = this;\\n      var currentLevel;\\n      var storageKey = \\\"loglevel\\\";\\n      if (name) {\\n        storageKey += \\\":\\\" + name;\\n      }\\n\\n      function persistLevelIfPossible(levelNum) {\\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\\n\\n          if (typeof window === undefinedType) return;\\n\\n          // Use localStorage if available\\n          try {\\n              window.localStorage[storageKey] = levelName;\\n              return;\\n          } catch (ignore) {}\\n\\n          // Use session cookie as fallback\\n          try {\\n              window.document.cookie =\\n                encodeURIComponent(storageKey) + \\\"=\\\" + levelName + \\\";\\\";\\n          } catch (ignore) {}\\n      }\\n\\n      function getPersistedLevel() {\\n          var storedLevel;\\n\\n          if (typeof window === undefinedType) return;\\n\\n          try {\\n              storedLevel = window.localStorage[storageKey];\\n          } catch (ignore) {}\\n\\n          // Fallback to cookies if local storage gives us nothing\\n          if (typeof storedLevel === undefinedType) {\\n              try {\\n                  var cookie = window.document.cookie;\\n                  var location = cookie.indexOf(\\n                      encodeURIComponent(storageKey) + \\\"=\\\");\\n                  if (location !== -1) {\\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\\n                  }\\n              } catch (ignore) {}\\n          }\\n\\n          // If the stored level is not valid, treat it as if nothing was stored.\\n          if (self.levels[storedLevel] === undefined) {\\n              storedLevel = undefined;\\n          }\\n\\n          return storedLevel;\\n      }\\n\\n      /*\\n       *\\n       * Public logger API - see https://github.com/pimterry/loglevel for details\\n       *\\n       */\\n\\n      self.name = name;\\n\\n      self.levels = { \\\"TRACE\\\": 0, \\\"DEBUG\\\": 1, \\\"INFO\\\": 2, \\\"WARN\\\": 3,\\n          \\\"ERROR\\\": 4, \\\"SILENT\\\": 5};\\n\\n      self.methodFactory = factory || defaultMethodFactory;\\n\\n      self.getLevel = function () {\\n          return currentLevel;\\n      };\\n\\n      self.setLevel = function (level, persist) {\\n          if (typeof level === \\\"string\\\" && self.levels[level.toUpperCase()] !== undefined) {\\n              level = self.levels[level.toUpperCase()];\\n          }\\n          if (typeof level === \\\"number\\\" && level >= 0 && level <= self.levels.SILENT) {\\n              currentLevel = level;\\n              if (persist !== false) {  // defaults to true\\n                  persistLevelIfPossible(level);\\n              }\\n              replaceLoggingMethods.call(self, level, name);\\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\\n                  return \\\"No console available for logging\\\";\\n              }\\n          } else {\\n              throw \\\"log.setLevel() called with invalid level: \\\" + level;\\n          }\\n      };\\n\\n      self.setDefaultLevel = function (level) {\\n          if (!getPersistedLevel()) {\\n              self.setLevel(level, false);\\n          }\\n      };\\n\\n      self.enableAll = function(persist) {\\n          self.setLevel(self.levels.TRACE, persist);\\n      };\\n\\n      self.disableAll = function(persist) {\\n          self.setLevel(self.levels.SILENT, persist);\\n      };\\n\\n      // Initialize with the right level\\n      var initialLevel = getPersistedLevel();\\n      if (initialLevel == null) {\\n          initialLevel = defaultLevel == null ? \\\"WARN\\\" : defaultLevel;\\n      }\\n      self.setLevel(initialLevel, false);\\n    }\\n\\n    /*\\n     *\\n     * Top-level API\\n     *\\n     */\\n\\n    var defaultLogger = new Logger();\\n\\n    var _loggersByName = {};\\n    defaultLogger.getLogger = function getLogger(name) {\\n        if (typeof name !== \\\"string\\\" || name === \\\"\\\") {\\n          throw new TypeError(\\\"You must supply a name when creating a logger.\\\");\\n        }\\n\\n        var logger = _loggersByName[name];\\n        if (!logger) {\\n          logger = _loggersByName[name] = new Logger(\\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\\n        }\\n        return logger;\\n    };\\n\\n    // Grab the current global log variable in case of overwrite\\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\\n    defaultLogger.noConflict = function() {\\n        if (typeof window !== undefinedType &&\\n               window.log === defaultLogger) {\\n            window.log = _log;\\n        }\\n\\n        return defaultLogger;\\n    };\\n\\n    defaultLogger.getLoggers = function getLoggers() {\\n        return _loggersByName;\\n    };\\n\\n    return defaultLogger;\\n}));\\n\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/ipfs/loglevel/loglevel.js\",\n            \"global-module\": \"true\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/loglevel/license\": {\n            \"text\": \"Copyright (c) 2013 Tim Perry\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person\\r\\nobtaining a copy of this software and associated documentation\\r\\nfiles (the \\\"Software\\\"), to deal in the Software without\\r\\nrestriction, including without limitation the rights to use,\\r\\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\ncopies of the Software, and to permit persons to whom the\\r\\nSoftware is furnished to do so, subject to the following\\r\\nconditions:\\r\\n\\r\\nThe above copyright notice and this permission notice shall be\\r\\nincluded in all copies or substantial portions of the Software.\\r\\n\\r\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\r\\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\\r\\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\r\\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\\r\\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\r\\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\r\\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\\r\\nOTHER DEALINGS IN THE SOFTWARE.\\r\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/ipfs/loglevel/license\"\n        },\n        \"$:/plugins/ipfs/ipfs-action.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-action.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-action.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIpfsAction\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const EnsWrapper = require(\\\"$:/plugins/ipfs/ens-wrapper.js\\\").EnsWrapper;\\n  const IpfsWrapper = require(\\\"$:/plugins/ipfs/ipfs-wrapper.js\\\").IpfsWrapper;\\n\\n  const fileProtocol = \\\"file:\\\";\\n  const ipfsKeyword = \\\"ipfs\\\";\\n  const ipnsKeyword = \\\"ipns\\\";\\n\\n  const name = \\\"ipfs-action\\\";\\n\\n  var IpfsAction = function() {\\n    this.once = false;\\n    this.console = false;\\n    this.ensWrapper = new EnsWrapper();\\n    this.ipfsWrapper = new IpfsWrapper();\\n    this.ipnsName = $tw.utils.getIpfsIpnsName();\\n    this.ipnsKey = $tw.utils.getIpfsIpnsKey();\\n  };\\n\\n  IpfsAction.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  IpfsAction.prototype.init = function() {\\n    // Init once\\n    if (this.once) {\\n      return;\\n    }\\n    const self = this;\\n    // Widget\\n    $tw.rootWidget.addEventListener(\\\"tm-ipfs-export\\\", async function(event) {\\n      return await self.handleExportToIpfs(event, false);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipfs-export-content\\\", async function(event) {\\n      return await self.handleExportToIpfs(event, true);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipns-fetch\\\", async function(event) {\\n      return await self.handleFetchIpnsKey(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipns-generate\\\", async function(event) {\\n      return await self.handleGenerateIpnsKey(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-console-mobile\\\", async function(event) {\\n      return await self.handleMobileConsole(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipfs-export-attachment\\\", async function(event) {\\n      return await self.handleExportAttachmentToIpfs(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipns-publish\\\", async function(event) {\\n      return await self.handlePublishToIpns(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipns-remove\\\", async function(event) {\\n      return await self.handleRemoveIpnsKey(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipns-rename\\\", async function(event) {\\n      return await self.handleRenameIpnsName(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipns-resolve-and-open\\\", async function(event) {\\n      return await self.handleResolveIpnsKeyAndOpen(event);\\n    });\\n    // Init once\\n    this.once = true;\\n  };\\n\\n  IpfsAction.prototype.handleExportToIpfs = async function(event, child) {\\n    try {\\n      var fields = [];\\n      var export_uri = null;\\n      var ipnsKey = null;\\n      var ipnsName = null;\\n      var ipnsContent = null;\\n      var ipfs = null;\\n      var ensContent = null;\\n      var protocol = null;\\n      var cid = null;\\n\\n      const title = event.tiddlerTitle;\\n\\n      // Load tiddler\\n      const tiddler = $tw.wiki.getTiddler(title);\\n      if (tiddler == undefined || tiddler == null) {\\n        $tw.utils.alert(name, \\\"Unknown Tiddler...\\\");\\n        return false;\\n      }\\n\\n      // Type\\n      var type = tiddler.getFieldString(\\\"type\\\");\\n      // Default\\n      if (type == undefined || type == null || type.trim() === \\\"\\\") {\\n        type = \\\"text/vnd.tiddlywiki\\\";\\n      }\\n\\n      // Content Type\\n      const info = $tw.config.contentTypeInfo[type];\\n      // Check\\n      if (info == undefined || info == null) {\\n        $tw.utils.alert(name, \\\"Unknown Tiddler Content Type: \\\" + type);\\n        return false;\\n      }\\n\\n      // Check\\n      export_uri = tiddler.getFieldString(\\\"_export_uri\\\");\\n      if (export_uri == undefined || export_uri == null || export_uri.trim() === \\\"\\\") {\\n        export_uri = null;\\n      } else {\\n        export_uri = export_uri.trim();\\n      }\\n\\n      try {\\n        export_uri = $tw.ipfs.getUrl(export_uri);\\n      } catch (error) {\\n        // Log an continue\\n        this.getLogger().warn(error);\\n        $tw.utils.alert(name, error.message);\\n        export_uri = null;\\n      }\\n\\n      // IPFS client\\n      var { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // URL Analysis\\n      if (export_uri !== null && export_uri.protocol !== fileProtocol) {\\n        // Decode pathname\\n        var { protocol, cid } = this.ipfsWrapper.decodeCid(export_uri.pathname);\\n        // Check\\n        if (protocol != null && cid != null) {\\n          if ($tw.utils.getIpfsUnpin() && protocol === ipfsKeyword) {\\n            $tw.ipfs.requestToUnpin(cid);\\n          }\\n        }\\n      }\\n\\n      // Analyse IPNS\\n      if (protocol == ipnsKeyword) {\\n        var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, cid);\\n        try {\\n          ipnsContent = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n          ipnsContent = null;\\n        }\\n        // Request to unpin\\n        if ($tw.utils.getIpfsUnpin() && ipnsContent !== null) {\\n          $tw.ipfs.requestToUnpin(ipnsContent);\\n        }\\n      }\\n\\n      // Analyse URI\\n      if (export_uri.hostname.endsWith(\\\".eth\\\")) {\\n        // Retrieve a Web3 provider\\n        const { web3 } = await $tw.ipfs.getWeb3Provider();\\n        // Fetch ENS domain content\\n        var { content: ensContent } = await this.ensWrapper.getContenthash(export_uri.hostname, web3);\\n        // Request to unpin\\n        if ($tw.utils.getIpfsUnpin() && ensContent !== null) {\\n          $tw.ipfs.requestToUnpin(ensContent);\\n        }\\n      }\\n\\n      // Getting content\\n      const content = await this.ipfsWrapper.exportTiddler(tiddler, child);\\n\\n      // Check\\n      if (content == null) {\\n        return false;\\n      }\\n\\n      this.getLogger().info(\\\"Uploading Tiddler: \\\" + content.length + \\\" bytes\\\");\\n\\n      // Add\\n      const { added } = await this.ipfsWrapper.addToIpfs(ipfs, content);\\n      // Default\\n      fields.push({ key: \\\"_export_uri\\\", value: \\\"/\\\" + ipfsKeyword + \\\"/\\\" + added });\\n\\n      try {\\n        await this.ipfsWrapper.pinToIpfs(ipfs, added);\\n      } catch (error) {\\n        // Log and continue\\n        this.getLogger().warn(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n\\n      // Publish to IPNS\\n      if (protocol == ipnsKeyword) {\\n        this.getLogger().info(\\\"Publishing IPNS Tiddler: \\\" + ipnsName);\\n        try {\\n          await this.ipfsWrapper.publishToIpns(ipfs, ipnsKey, ipnsName, added);\\n          fields.push({ key: \\\"_export_uri\\\", value: \\\"/\\\" + ipnsKeyword + \\\"/\\\" + ipnsKey });\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n          // Discard unpin request\\n          $tw.ipfs.discardRequestToUnpin(ipnsContent);\\n        }\\n      }\\n\\n      // Publish to ENS\\n      if (export_uri.hostname.endsWith(\\\".eth\\\")) {\\n        this.getLogger().info(\\\"Publishing ENS domain content: \\\" + export_uri.hostname);\\n        try {\\n          // Retrieve an enabled Web3 provider\\n          const { web3, account } = await $tw.ipfs.getEnabledWeb3Provider();\\n          // Set ENS domain content\\n          await this.ensWrapper.setContenthash(export_uri.hostname, added, web3, account);\\n          fields.push({ key: \\\"_export_uri\\\", value: \\\"https://\\\" + export_uri.hostname });\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n          // Discard unpin request\\n          $tw.ipfs.discardRequestToUnpin(ensContent);\\n        }\\n      }\\n\\n      var updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        addTags: [\\\"$:/isExported\\\", \\\"$:/isIpfs\\\"],\\n        fields: fields\\n      });\\n      $tw.wiki.addTiddler(updatedTiddler);\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleExportAttachmentToIpfs = async function(event) {\\n    try {\\n      const title = event.tiddlerTitle;\\n\\n      // Load tiddler\\n      const tiddler = $tw.wiki.getTiddler(title);\\n      if (tiddler == undefined || tiddler == null) {\\n        $tw.utils.alert(name, \\\"Unknown Tiddler...\\\");\\n        return false;\\n      }\\n\\n      // Type\\n      var type = tiddler.getFieldString(\\\"type\\\");\\n      // Default\\n      if (type == undefined || type == null || type.trim() === \\\"\\\") {\\n        type = \\\"text/vnd.tiddlywiki\\\";\\n      }\\n\\n      // Content Type\\n      const info = $tw.config.contentTypeInfo[type];\\n      // Check\\n      if (info == undefined || info == null) {\\n        $tw.utils.alert(name, \\\"Unknown Tiddler Content Type: \\\" + type);\\n        return false;\\n      }\\n\\n      // Check\\n      if (info.encoding !== \\\"base64\\\" && type !== \\\"image/svg+xml\\\") {\\n        $tw.utils.alert(name, \\\"This Tiddler do not contain any attachment...\\\");\\n        return false;\\n      }\\n\\n      // Do not process if _canonical_uri is set\\n      const canonical_uri = tiddler.getFieldString(\\\"_canonical_uri\\\");\\n      if (canonical_uri !== undefined && canonical_uri !== null && canonical_uri.trim() !== \\\"\\\") {\\n        $tw.utils.alert(name, \\\"Attachment is already published...\\\");\\n        return false;\\n      }\\n\\n      // Getting content\\n      const content = this.ipfsWrapper.getTiddlerContent(tiddler);\\n      // Check\\n      if (content == null) {\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      this.getLogger().info(\\\"Uploading attachment: \\\" + content.length + \\\" bytes\\\");\\n\\n      // Add\\n      const { added } = await this.ipfsWrapper.addToIpfs(ipfs, content);\\n\\n      try {\\n        await this.ipfsWrapper.pinToIpfs(ipfs, added);\\n      } catch (error) {\\n        // Log an continue\\n        this.getLogger().warn(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n\\n      var addTags = [];\\n      var removeTags = [];\\n      if ($tw.crypto.hasPassword()) {\\n        addTags = [\\\"$:/isAttachment\\\", \\\"$:/isIpfs\\\"];\\n        removeTags = [\\\"$:/isEmbedded\\\"];\\n      } else {\\n        addTags = [\\\"$:/isAttachment\\\", \\\"$:/isIpfs\\\"];\\n        removeTags = [\\\"$:/isEmbedded\\\"];\\n      }\\n      // Update\\n      const updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: tiddler,\\n        addTags: addTags,\\n        removeTags: removeTags,\\n        fields: [\\n          { key: \\\"text\\\", value: \\\"\\\" },\\n          { key: \\\"_canonical_uri\\\", value: \\\"/\\\" + ipfsKeyword + \\\"/\\\" + added }\\n        ]\\n      });\\n      $tw.wiki.addTiddler(updatedTiddler);\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleRenameIpnsName = async function(event) {\\n    try {\\n      // Retrieve default IPNS name\\n      var ipnsName = $tw.utils.getIpfsIpnsName();\\n\\n      // Check\\n      if (ipnsName == null) {\\n        $tw.utils.alert(name, \\\"Undefined IPNS name....\\\");\\n        return false;\\n      }\\n      if (this.ipnsName == null || this.ipnsName === ipnsName) {\\n        $tw.utils.alert(name, \\\"Nothing to rename....\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Rename IPNS name\\n      const { key } = await this.ipfsWrapper.renameIpnsName(ipfs, this.ipnsName, ipnsName);\\n\\n      // Update Tiddler\\n      const tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n      if (tiddler !== undefined) {\\n        const updatedTiddler = $tw.utils.updateTiddler({\\n          tiddler: tiddler,\\n          fields: [{ key: \\\"text\\\", value: key }]\\n        });\\n        $tw.wiki.addTiddler(updatedTiddler);\\n      }\\n\\n      // Successfully renamed\\n      this.ipnsName = ipnsName;\\n      this.ipnsKey = key;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleGenerateIpnsKey = async function(event) {\\n    try {\\n      // Retrieve default IPNS name\\n      var ipnsName = $tw.utils.getIpfsIpnsName();\\n\\n      // Check\\n      if (ipnsName == null) {\\n        $tw.utils.alert(name, \\\"Undefined IPNS name....\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Generate IPNS key\\n      const key = await this.ipfsWrapper.generateIpnsKey(ipfs, ipnsName);\\n\\n      // Update Tiddler\\n      const tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n      if (tiddler !== undefined) {\\n        const updatedTiddler = $tw.utils.updateTiddler({\\n          tiddler: tiddler,\\n          fields: [{ key: \\\"text\\\", value: key }]\\n        });\\n        $tw.wiki.addTiddler(updatedTiddler);\\n      }\\n\\n      // Successfully generated\\n      this.ipnsName = ipnsName;\\n      this.ipnsKey = key;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleRemoveIpnsKey = async function(event) {\\n    try {\\n      // Retrieve default IPNS name\\n      var cid = null;\\n      var ipnsName = $tw.utils.getIpfsIpnsName();\\n      var ipnsKey = $tw.utils.getIpfsIpnsKey();\\n\\n      // Check\\n      if (ipnsName == null) {\\n        $tw.utils.alert(name, \\\"Undefined IPNS name....\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Resolve CID,\\n      var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n      try {\\n        cid = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n      } catch (error) {\\n        // Log and continue\\n        this.getLogger().warn(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n\\n      // Unpin previous\\n      if ($tw.utils.getIpfsUnpin() && cid != null) {\\n        try {\\n          await this.ipfsWrapper.unpinFromIpfs(ipfs, cid);\\n          $tw.ipfs.discardRequestToUnpin(cid);\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n        }\\n      }\\n\\n      // Remove IPNS key\\n      await this.ipfsWrapper.removeIpnsKey(ipfs, ipnsKey, ipnsName);\\n\\n      // Update Tiddlers\\n      var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/name\\\");\\n      if (tiddler !== undefined) {\\n        const updatedTiddler = $tw.utils.updateTiddler({\\n          tiddler: tiddler,\\n          fields: [{ key: \\\"text\\\", value: \\\"\\\" }]\\n        });\\n        $tw.wiki.addTiddler(updatedTiddler);\\n      }\\n      tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n      if (tiddler !== undefined && $tw.utils.getIpfsIpnsKey() !== null) {\\n        const updatedTiddler = $tw.utils.updateTiddler({\\n          tiddler: tiddler,\\n          fields: [{ key: \\\"text\\\", value: \\\"\\\" }]\\n        });\\n        $tw.wiki.addTiddler(updatedTiddler);\\n      }\\n\\n      // Successfully removed\\n      this.ipnsName = null;\\n      this.ipnsKey = null;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleFetchIpnsKey = async function(event) {\\n    try {\\n      // Retrieve default IPNS name\\n      var ipnsName = $tw.utils.getIpfsIpnsName();\\n      var ipnsKey = $tw.utils.getIpfsIpnsKey();\\n\\n      // Check\\n      if (ipnsName == null) {\\n        $tw.utils.alert(name, \\\"Undefined IPNS name....\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Fetch\\n      const { ipnsKey: resolvedIpnsKey } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n\\n      // Update Tiddler\\n      var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n      if (tiddler !== undefined && this.ipnsKey !== resolvedIpnsKey) {\\n        const updatedTiddler = $tw.utils.updateTiddler({\\n          tiddler: tiddler,\\n          fields: [{ key: \\\"text\\\", value: resolvedIpnsKey }]\\n        });\\n        $tw.wiki.addTiddler(updatedTiddler);\\n        this.ipnsKey = resolvedIpnsKey;\\n      }\\n      this.ipnsName = ipnsName;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleResolveIpnsKeyAndOpen = async function(event) {\\n    try {\\n      // Retrieve default IPNS name\\n      var ipnsName = $tw.utils.getIpfsIpnsName();\\n      var ipnsKey = $tw.utils.getIpfsIpnsKey();\\n\\n      // Check\\n      if (ipnsName == null) {\\n        $tw.utils.alert(name, \\\"Undefined IPNS name....\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Resolve CID\\n      var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n      const resolved = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n\\n      // Update Tiddler\\n      var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n      if (tiddler !== undefined && this.ipnsKey !== ipnsKey) {\\n        $tw.utils.updateTiddler({\\n          tiddler: tiddler,\\n          fields: [{ key: \\\"text\\\", value: ipnsKey }]\\n        });\\n        this.ipnsKey = ipnsKey;\\n      }\\n      this.ipnsName = ipnsName;\\n\\n      if (resolved !== null) {\\n        // Build URL\\n        const parsed = await $tw.ipfs.normalizeIpfsUrl(\\\"/\\\" + ipfsKeyword + \\\"/\\\" + resolved);\\n        window.open(parsed.toString(), \\\"_blank\\\", \\\"noopener\\\");\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsAction.prototype.handleMobileConsole = async function(tiddler) {\\n    // Load mobile console if applicable\\n    if (typeof window.eruda === \\\"undefined\\\") {\\n      try {\\n        // Load eruda\\n        await $tw.ipfs.getLoader().loadErudaLibrary();\\n      } catch (error) {\\n        this.getLogger().error(error);\\n        throw new Error(error.message);\\n      }\\n      const eruda = window.document.createElement(\\\"div\\\");\\n      window.document.body.appendChild(eruda);\\n      window.eruda.init({\\n        container: eruda,\\n        tool: [\\\"console\\\"],\\n        useShadowDom: false\\n      });\\n      // Inherit font\\n      eruda.style.fontFamily = \\\"inherit\\\";\\n      // Preserve user preference if any, default is 80\\n      if (window.eruda.get().config.get(\\\"displaySize\\\") === 80) {\\n        window.eruda.get().config.set(\\\"displaySize\\\", 40);\\n      }\\n      // Preserve user preference if any, default is 0.95\\n      if (window.eruda.get().config.get(\\\"transparency\\\") === 0.95) {\\n        window.eruda.get().config.set(\\\"transparency\\\", 1);\\n      }\\n      // Remove the button\\n      const buttons = document.getElementsByClassName(\\\"eruda-entry-btn\\\");\\n      for (var i = 0; i < buttons.length; i++) {\\n        buttons[i].remove();\\n      }\\n      // The first output line is eaten...\\n      this.getLogger().info(\\\"Mobile console has been loaded...\\\");\\n    }\\n    if (this.console == false) {\\n      // Show\\n      window.eruda.show();\\n      window.eruda.show(\\\"console\\\");\\n      this.console = true;\\n    } else {\\n      window.eruda.hide();\\n      this.console = false;\\n    }\\n  };\\n\\n  IpfsAction.prototype.handlePublishToIpns = async function(event) {\\n    try {\\n      // Process document URL\\n      const wiki = $tw.ipfs.getDocumentUrl();\\n\\n      // Check\\n      if (wiki.protocol === fileProtocol) {\\n        $tw.utils.alert(name, \\\"Undefined IPFS identifier...\\\");\\n        return false;\\n      }\\n      if (wiki.pathname === \\\"/\\\") {\\n        $tw.utils.alert(name, \\\"Unknown IPFS identifier...\\\");\\n        return false;\\n      }\\n\\n      // Extract and check URL IPFS protocol and CID\\n      var { protocol, cid } = this.ipfsWrapper.decodeCid(wiki.pathname);\\n\\n      // Check\\n      if (protocol == null) {\\n        $tw.utils.alert(name, \\\"Unknown IPFS protocol...\\\");\\n        return false;\\n      }\\n      if (cid == null) {\\n        $tw.utils.alert(name, \\\"Unknown IPFS identifier...\\\");\\n        return false;\\n      }\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Default IPNS key and IPNS name\\n      var ipnsKey = $tw.utils.getIpfsIpnsKey();\\n      var ipnsName = $tw.utils.getIpfsIpnsName();\\n      var resolved = null;\\n\\n      // Check\\n      if (ipnsKey == null) {\\n        $tw.utils.alert(name, \\\"Undefined default IPNS key....\\\");\\n        return false;\\n      }\\n\\n      if (protocol === ipnsKeyword) {\\n        // Check\\n        if (ipnsKey === cid) {\\n          $tw.utils.alert(name, \\\"Default IPNS key matches current IPNS key....\\\");\\n          return false;\\n        }\\n        // Resolve current IPNS key\\n        this.getLogger().info(\\\"Processing current IPNS...\\\");\\n        const { ipnsKey: currentIpnsKey } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, cid);\\n        try {\\n          cid = await this.ipfsWrapper.resolveIpnsKey(ipfs, currentIpnsKey);\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n        }\\n      }\\n\\n      // Resolve default IPNS key and IPNS name\\n      this.getLogger().info(\\\"Processing default IPNS...\\\");\\n      var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n      try {\\n        resolved = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n      } catch (error) {\\n        // Log and continue\\n        this.getLogger().warn(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n\\n      // Check\\n      if (resolved !== null && resolved === cid) {\\n        $tw.utils.alert(name, \\\"IPFS identifiers are matching....\\\");\\n        return false;\\n      }\\n\\n      this.getLogger().info(\\\"Publishing IPNS name: \\\" + ipnsName);\\n\\n      await this.ipfsWrapper.publishToIpns(ipfs, ipnsKey, ipnsName, cid);\\n\\n      // Unpin previous\\n      if ($tw.utils.getIpfsUnpin() && resolved != null) {\\n        try {\\n          await this.ipfsWrapper.unpinFromIpfs(ipfs, resolved);\\n          $tw.ipfs.discardRequestToUnpin(resolved);\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n        }\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  exports.IpfsAction = IpfsAction;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-bundle.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-bundle.js\",\n            \"text\": \"(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.IpfsBundle = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\\\"function\\\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\\\"Cannot find module '\\\"+i+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\\\"function\\\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\\nfunction _asyncIterator(iterable) {\\n  var method;\\n\\n  if (typeof Symbol !== \\\"undefined\\\") {\\n    if (Symbol.asyncIterator) {\\n      method = iterable[Symbol.asyncIterator];\\n      if (method != null) return method.call(iterable);\\n    }\\n\\n    if (Symbol.iterator) {\\n      method = iterable[Symbol.iterator];\\n      if (method != null) return method.call(iterable);\\n    }\\n  }\\n\\n  throw new TypeError(\\\"Object is not async iterable\\\");\\n}\\n\\nmodule.exports = _asyncIterator;\\n},{}],2:[function(require,module,exports){\\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\\n  try {\\n    var info = gen[key](arg);\\n    var value = info.value;\\n  } catch (error) {\\n    reject(error);\\n    return;\\n  }\\n\\n  if (info.done) {\\n    resolve(value);\\n  } else {\\n    Promise.resolve(value).then(_next, _throw);\\n  }\\n}\\n\\nfunction _asyncToGenerator(fn) {\\n  return function () {\\n    var self = this,\\n        args = arguments;\\n    return new Promise(function (resolve, reject) {\\n      var gen = fn.apply(self, args);\\n\\n      function _next(value) {\\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \\\"next\\\", value);\\n      }\\n\\n      function _throw(err) {\\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \\\"throw\\\", err);\\n      }\\n\\n      _next(undefined);\\n    });\\n  };\\n}\\n\\nmodule.exports = _asyncToGenerator;\\n},{}],3:[function(require,module,exports){\\nfunction _interopRequireDefault(obj) {\\n  return obj && obj.__esModule ? obj : {\\n    \\\"default\\\": obj\\n  };\\n}\\n\\nmodule.exports = _interopRequireDefault;\\n},{}],4:[function(require,module,exports){\\nfunction _typeof(obj) {\\n  \\\"@babel/helpers - typeof\\\";\\n\\n  if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") {\\n    module.exports = _typeof = function _typeof(obj) {\\n      return typeof obj;\\n    };\\n  } else {\\n    module.exports = _typeof = function _typeof(obj) {\\n      return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n    };\\n  }\\n\\n  return _typeof(obj);\\n}\\n\\nmodule.exports = _typeof;\\n},{}],5:[function(require,module,exports){\\nmodule.exports = require(\\\"regenerator-runtime\\\");\\n\\n},{\\\"regenerator-runtime\\\":52}],6:[function(require,module,exports){\\n'use strict'\\n// base-x encoding / decoding\\n// Copyright (c) 2018 base-x contributors\\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\\n// Distributed under the MIT software license, see the accompanying\\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\\n// @ts-ignore\\nvar _Buffer = require('safe-buffer').Buffer\\nfunction base (ALPHABET) {\\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\\n  var BASE_MAP = new Uint8Array(256)\\n  for (var j = 0; j < BASE_MAP.length; j++) {\\n    BASE_MAP[j] = 255\\n  }\\n  for (var i = 0; i < ALPHABET.length; i++) {\\n    var x = ALPHABET.charAt(i)\\n    var xc = x.charCodeAt(0)\\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\\n    BASE_MAP[xc] = i\\n  }\\n  var BASE = ALPHABET.length\\n  var LEADER = ALPHABET.charAt(0)\\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\\n  function encode (source) {\\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\\n    if (source.length === 0) { return '' }\\n        // Skip & count leading zeroes.\\n    var zeroes = 0\\n    var length = 0\\n    var pbegin = 0\\n    var pend = source.length\\n    while (pbegin !== pend && source[pbegin] === 0) {\\n      pbegin++\\n      zeroes++\\n    }\\n        // Allocate enough space in big-endian base58 representation.\\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\\n    var b58 = new Uint8Array(size)\\n        // Process the bytes.\\n    while (pbegin !== pend) {\\n      var carry = source[pbegin]\\n            // Apply \\\"b58 = b58 * 256 + ch\\\".\\n      var i = 0\\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\\n        carry += (256 * b58[it1]) >>> 0\\n        b58[it1] = (carry % BASE) >>> 0\\n        carry = (carry / BASE) >>> 0\\n      }\\n      if (carry !== 0) { throw new Error('Non-zero carry') }\\n      length = i\\n      pbegin++\\n    }\\n        // Skip leading zeroes in base58 result.\\n    var it2 = size - length\\n    while (it2 !== size && b58[it2] === 0) {\\n      it2++\\n    }\\n        // Translate the result into a string.\\n    var str = LEADER.repeat(zeroes)\\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\\n    return str\\n  }\\n  function decodeUnsafe (source) {\\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\\n    if (source.length === 0) { return _Buffer.alloc(0) }\\n    var psz = 0\\n        // Skip leading spaces.\\n    if (source[psz] === ' ') { return }\\n        // Skip and count leading '1's.\\n    var zeroes = 0\\n    var length = 0\\n    while (source[psz] === LEADER) {\\n      zeroes++\\n      psz++\\n    }\\n        // Allocate enough space in big-endian base256 representation.\\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\\n    var b256 = new Uint8Array(size)\\n        // Process the characters.\\n    while (source[psz]) {\\n            // Decode character\\n      var carry = BASE_MAP[source.charCodeAt(psz)]\\n            // Invalid character\\n      if (carry === 255) { return }\\n      var i = 0\\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\\n        carry += (BASE * b256[it3]) >>> 0\\n        b256[it3] = (carry % 256) >>> 0\\n        carry = (carry / 256) >>> 0\\n      }\\n      if (carry !== 0) { throw new Error('Non-zero carry') }\\n      length = i\\n      psz++\\n    }\\n        // Skip trailing spaces.\\n    if (source[psz] === ' ') { return }\\n        // Skip leading zeroes in b256.\\n    var it4 = size - length\\n    while (it4 !== size && b256[it4] === 0) {\\n      it4++\\n    }\\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\\n    vch.fill(0x00, 0, zeroes)\\n    var j = zeroes\\n    while (it4 !== size) {\\n      vch[j++] = b256[it4++]\\n    }\\n    return vch\\n  }\\n  function decode (string) {\\n    var buffer = decodeUnsafe(string)\\n    if (buffer) { return buffer }\\n    throw new Error('Non-base' + BASE + ' character')\\n  }\\n  return {\\n    encode: encode,\\n    decodeUnsafe: decodeUnsafe,\\n    decode: decode\\n  }\\n}\\nmodule.exports = base\\n\\n},{\\\"safe-buffer\\\":53}],7:[function(require,module,exports){\\n'use strict'\\n\\nexports.byteLength = byteLength\\nexports.toByteArray = toByteArray\\nexports.fromByteArray = fromByteArray\\n\\nvar lookup = []\\nvar revLookup = []\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\nfor (var i = 0, len = code.length; i < len; ++i) {\\n  lookup[i] = code[i]\\n  revLookup[code.charCodeAt(i)] = i\\n}\\n\\n// Support decoding URL-safe base64 strings, as Node.js does.\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\nrevLookup['-'.charCodeAt(0)] = 62\\nrevLookup['_'.charCodeAt(0)] = 63\\n\\nfunction getLens (b64) {\\n  var len = b64.length\\n\\n  if (len % 4 > 0) {\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\n  }\\n\\n  // Trim off extra bytes after placeholder bytes are found\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\n  var validLen = b64.indexOf('=')\\n  if (validLen === -1) validLen = len\\n\\n  var placeHoldersLen = validLen === len\\n    ? 0\\n    : 4 - (validLen % 4)\\n\\n  return [validLen, placeHoldersLen]\\n}\\n\\n// base64 is 4/3 + up to two characters of the original data\\nfunction byteLength (b64) {\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction toByteArray (b64) {\\n  var tmp\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\n\\n  var curByte = 0\\n\\n  // if there are placeholders, only get up to the last complete 4 chars\\n  var len = placeHoldersLen > 0\\n    ? validLen - 4\\n    : validLen\\n\\n  var i\\n  for (i = 0; i < len; i += 4) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\n      revLookup[b64.charCodeAt(i + 3)]\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 2) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 1) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  return arr\\n}\\n\\nfunction tripletToBase64 (num) {\\n  return lookup[num >> 18 & 0x3F] +\\n    lookup[num >> 12 & 0x3F] +\\n    lookup[num >> 6 & 0x3F] +\\n    lookup[num & 0x3F]\\n}\\n\\nfunction encodeChunk (uint8, start, end) {\\n  var tmp\\n  var output = []\\n  for (var i = start; i < end; i += 3) {\\n    tmp =\\n      ((uint8[i] << 16) & 0xFF0000) +\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\n      (uint8[i + 2] & 0xFF)\\n    output.push(tripletToBase64(tmp))\\n  }\\n  return output.join('')\\n}\\n\\nfunction fromByteArray (uint8) {\\n  var tmp\\n  var len = uint8.length\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n  var parts = []\\n  var maxChunkLength = 16383 // must be multiple of 3\\n\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n    parts.push(encodeChunk(\\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\\n    ))\\n  }\\n\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\n  if (extraBytes === 1) {\\n    tmp = uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 2] +\\n      lookup[(tmp << 4) & 0x3F] +\\n      '=='\\n    )\\n  } else if (extraBytes === 2) {\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 10] +\\n      lookup[(tmp >> 4) & 0x3F] +\\n      lookup[(tmp << 2) & 0x3F] +\\n      '='\\n    )\\n  }\\n\\n  return parts.join('')\\n}\\n\\n},{}],8:[function(require,module,exports){\\n(function (Buffer){\\n/*!\\n * The buffer module from node.js, for the browser.\\n *\\n * @author   Feross Aboukhadijeh <https://feross.org>\\n * @license  MIT\\n */\\n/* eslint-disable no-proto */\\n\\n'use strict'\\n\\nvar base64 = require('base64-js')\\nvar ieee754 = require('ieee754')\\n\\nexports.Buffer = Buffer\\nexports.SlowBuffer = SlowBuffer\\nexports.INSPECT_MAX_BYTES = 50\\n\\nvar K_MAX_LENGTH = 0x7fffffff\\nexports.kMaxLength = K_MAX_LENGTH\\n\\n/**\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\n *   === true    Use Uint8Array implementation (fastest)\\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\\n *               implementation (most compatible, even IE6)\\n *\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\n * Opera 11.6+, iOS 4.2+.\\n *\\n * We report that the browser does not support typed arrays if the are not subclassable\\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\\n * for __proto__ and has a buggy typed array implementation.\\n */\\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\\n\\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\\n    typeof console.error === 'function') {\\n  console.error(\\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\\n  )\\n}\\n\\nfunction typedArraySupport () {\\n  // Can typed array instances can be augmented?\\n  try {\\n    var arr = new Uint8Array(1)\\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\\n    return arr.foo() === 42\\n  } catch (e) {\\n    return false\\n  }\\n}\\n\\nObject.defineProperty(Buffer.prototype, 'parent', {\\n  enumerable: true,\\n  get: function () {\\n    if (!Buffer.isBuffer(this)) return undefined\\n    return this.buffer\\n  }\\n})\\n\\nObject.defineProperty(Buffer.prototype, 'offset', {\\n  enumerable: true,\\n  get: function () {\\n    if (!Buffer.isBuffer(this)) return undefined\\n    return this.byteOffset\\n  }\\n})\\n\\nfunction createBuffer (length) {\\n  if (length > K_MAX_LENGTH) {\\n    throw new RangeError('The value \\\"' + length + '\\\" is invalid for option \\\"size\\\"')\\n  }\\n  // Return an augmented `Uint8Array` instance\\n  var buf = new Uint8Array(length)\\n  buf.__proto__ = Buffer.prototype\\n  return buf\\n}\\n\\n/**\\n * The Buffer constructor returns instances of `Uint8Array` that have their\\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\\n * returns a single octet.\\n *\\n * The `Uint8Array` prototype remains unmodified.\\n */\\n\\nfunction Buffer (arg, encodingOrOffset, length) {\\n  // Common case.\\n  if (typeof arg === 'number') {\\n    if (typeof encodingOrOffset === 'string') {\\n      throw new TypeError(\\n        'The \\\"string\\\" argument must be of type string. Received type number'\\n      )\\n    }\\n    return allocUnsafe(arg)\\n  }\\n  return from(arg, encodingOrOffset, length)\\n}\\n\\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\\n    Buffer[Symbol.species] === Buffer) {\\n  Object.defineProperty(Buffer, Symbol.species, {\\n    value: null,\\n    configurable: true,\\n    enumerable: false,\\n    writable: false\\n  })\\n}\\n\\nBuffer.poolSize = 8192 // not used by this implementation\\n\\nfunction from (value, encodingOrOffset, length) {\\n  if (typeof value === 'string') {\\n    return fromString(value, encodingOrOffset)\\n  }\\n\\n  if (ArrayBuffer.isView(value)) {\\n    return fromArrayLike(value)\\n  }\\n\\n  if (value == null) {\\n    throw TypeError(\\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\\n      'or Array-like Object. Received type ' + (typeof value)\\n    )\\n  }\\n\\n  if (isInstance(value, ArrayBuffer) ||\\n      (value && isInstance(value.buffer, ArrayBuffer))) {\\n    return fromArrayBuffer(value, encodingOrOffset, length)\\n  }\\n\\n  if (typeof value === 'number') {\\n    throw new TypeError(\\n      'The \\\"value\\\" argument must not be of type number. Received type number'\\n    )\\n  }\\n\\n  var valueOf = value.valueOf && value.valueOf()\\n  if (valueOf != null && valueOf !== value) {\\n    return Buffer.from(valueOf, encodingOrOffset, length)\\n  }\\n\\n  var b = fromObject(value)\\n  if (b) return b\\n\\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\\n      typeof value[Symbol.toPrimitive] === 'function') {\\n    return Buffer.from(\\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\\n    )\\n  }\\n\\n  throw new TypeError(\\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\\n    'or Array-like Object. Received type ' + (typeof value)\\n  )\\n}\\n\\n/**\\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\\n * if value is a number.\\n * Buffer.from(str[, encoding])\\n * Buffer.from(array)\\n * Buffer.from(buffer)\\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\\n **/\\nBuffer.from = function (value, encodingOrOffset, length) {\\n  return from(value, encodingOrOffset, length)\\n}\\n\\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\\n// https://github.com/feross/buffer/pull/148\\nBuffer.prototype.__proto__ = Uint8Array.prototype\\nBuffer.__proto__ = Uint8Array\\n\\nfunction assertSize (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('\\\"size\\\" argument must be of type number')\\n  } else if (size < 0) {\\n    throw new RangeError('The value \\\"' + size + '\\\" is invalid for option \\\"size\\\"')\\n  }\\n}\\n\\nfunction alloc (size, fill, encoding) {\\n  assertSize(size)\\n  if (size <= 0) {\\n    return createBuffer(size)\\n  }\\n  if (fill !== undefined) {\\n    // Only pay attention to encoding if it's a string. This\\n    // prevents accidentally sending in a number that would\\n    // be interpretted as a start offset.\\n    return typeof encoding === 'string'\\n      ? createBuffer(size).fill(fill, encoding)\\n      : createBuffer(size).fill(fill)\\n  }\\n  return createBuffer(size)\\n}\\n\\n/**\\n * Creates a new filled Buffer instance.\\n * alloc(size[, fill[, encoding]])\\n **/\\nBuffer.alloc = function (size, fill, encoding) {\\n  return alloc(size, fill, encoding)\\n}\\n\\nfunction allocUnsafe (size) {\\n  assertSize(size)\\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\\n}\\n\\n/**\\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\\n * */\\nBuffer.allocUnsafe = function (size) {\\n  return allocUnsafe(size)\\n}\\n/**\\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\\n */\\nBuffer.allocUnsafeSlow = function (size) {\\n  return allocUnsafe(size)\\n}\\n\\nfunction fromString (string, encoding) {\\n  if (typeof encoding !== 'string' || encoding === '') {\\n    encoding = 'utf8'\\n  }\\n\\n  if (!Buffer.isEncoding(encoding)) {\\n    throw new TypeError('Unknown encoding: ' + encoding)\\n  }\\n\\n  var length = byteLength(string, encoding) | 0\\n  var buf = createBuffer(length)\\n\\n  var actual = buf.write(string, encoding)\\n\\n  if (actual !== length) {\\n    // Writing a hex string, for example, that contains invalid characters will\\n    // cause everything after the first invalid character to be ignored. (e.g.\\n    // 'abxxcd' will be treated as 'ab')\\n    buf = buf.slice(0, actual)\\n  }\\n\\n  return buf\\n}\\n\\nfunction fromArrayLike (array) {\\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\\n  var buf = createBuffer(length)\\n  for (var i = 0; i < length; i += 1) {\\n    buf[i] = array[i] & 255\\n  }\\n  return buf\\n}\\n\\nfunction fromArrayBuffer (array, byteOffset, length) {\\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\\n    throw new RangeError('\\\"offset\\\" is outside of buffer bounds')\\n  }\\n\\n  if (array.byteLength < byteOffset + (length || 0)) {\\n    throw new RangeError('\\\"length\\\" is outside of buffer bounds')\\n  }\\n\\n  var buf\\n  if (byteOffset === undefined && length === undefined) {\\n    buf = new Uint8Array(array)\\n  } else if (length === undefined) {\\n    buf = new Uint8Array(array, byteOffset)\\n  } else {\\n    buf = new Uint8Array(array, byteOffset, length)\\n  }\\n\\n  // Return an augmented `Uint8Array` instance\\n  buf.__proto__ = Buffer.prototype\\n  return buf\\n}\\n\\nfunction fromObject (obj) {\\n  if (Buffer.isBuffer(obj)) {\\n    var len = checked(obj.length) | 0\\n    var buf = createBuffer(len)\\n\\n    if (buf.length === 0) {\\n      return buf\\n    }\\n\\n    obj.copy(buf, 0, 0, len)\\n    return buf\\n  }\\n\\n  if (obj.length !== undefined) {\\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\\n      return createBuffer(0)\\n    }\\n    return fromArrayLike(obj)\\n  }\\n\\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\n    return fromArrayLike(obj.data)\\n  }\\n}\\n\\nfunction checked (length) {\\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\\n  // length is NaN (which is otherwise coerced to zero.)\\n  if (length >= K_MAX_LENGTH) {\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\\n  }\\n  return length | 0\\n}\\n\\nfunction SlowBuffer (length) {\\n  if (+length != length) { // eslint-disable-line eqeqeq\\n    length = 0\\n  }\\n  return Buffer.alloc(+length)\\n}\\n\\nBuffer.isBuffer = function isBuffer (b) {\\n  return b != null && b._isBuffer === true &&\\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\\n}\\n\\nBuffer.compare = function compare (a, b) {\\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\n    throw new TypeError(\\n      'The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array'\\n    )\\n  }\\n\\n  if (a === b) return 0\\n\\n  var x = a.length\\n  var y = b.length\\n\\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\\n    if (a[i] !== b[i]) {\\n      x = a[i]\\n      y = b[i]\\n      break\\n    }\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\nBuffer.isEncoding = function isEncoding (encoding) {\\n  switch (String(encoding).toLowerCase()) {\\n    case 'hex':\\n    case 'utf8':\\n    case 'utf-8':\\n    case 'ascii':\\n    case 'latin1':\\n    case 'binary':\\n    case 'base64':\\n    case 'ucs2':\\n    case 'ucs-2':\\n    case 'utf16le':\\n    case 'utf-16le':\\n      return true\\n    default:\\n      return false\\n  }\\n}\\n\\nBuffer.concat = function concat (list, length) {\\n  if (!Array.isArray(list)) {\\n    throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\n  }\\n\\n  if (list.length === 0) {\\n    return Buffer.alloc(0)\\n  }\\n\\n  var i\\n  if (length === undefined) {\\n    length = 0\\n    for (i = 0; i < list.length; ++i) {\\n      length += list[i].length\\n    }\\n  }\\n\\n  var buffer = Buffer.allocUnsafe(length)\\n  var pos = 0\\n  for (i = 0; i < list.length; ++i) {\\n    var buf = list[i]\\n    if (isInstance(buf, Uint8Array)) {\\n      buf = Buffer.from(buf)\\n    }\\n    if (!Buffer.isBuffer(buf)) {\\n      throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\n    }\\n    buf.copy(buffer, pos)\\n    pos += buf.length\\n  }\\n  return buffer\\n}\\n\\nfunction byteLength (string, encoding) {\\n  if (Buffer.isBuffer(string)) {\\n    return string.length\\n  }\\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\\n    return string.byteLength\\n  }\\n  if (typeof string !== 'string') {\\n    throw new TypeError(\\n      'The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\\n      'Received type ' + typeof string\\n    )\\n  }\\n\\n  var len = string.length\\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\\n  if (!mustMatch && len === 0) return 0\\n\\n  // Use a for loop to avoid recursion\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'ascii':\\n      case 'latin1':\\n      case 'binary':\\n        return len\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8ToBytes(string).length\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return len * 2\\n      case 'hex':\\n        return len >>> 1\\n      case 'base64':\\n        return base64ToBytes(string).length\\n      default:\\n        if (loweredCase) {\\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\\n        }\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\nBuffer.byteLength = byteLength\\n\\nfunction slowToString (encoding, start, end) {\\n  var loweredCase = false\\n\\n  // No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\n  // property of a typed array.\\n\\n  // This behaves neither like String nor Uint8Array in that we set start/end\\n  // to their upper/lower bounds if the value passed is out of range.\\n  // undefined is handled specially as per ECMA-262 6th Edition,\\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\n  if (start === undefined || start < 0) {\\n    start = 0\\n  }\\n  // Return early if start > this.length. Done here to prevent potential uint32\\n  // coercion fail below.\\n  if (start > this.length) {\\n    return ''\\n  }\\n\\n  if (end === undefined || end > this.length) {\\n    end = this.length\\n  }\\n\\n  if (end <= 0) {\\n    return ''\\n  }\\n\\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\n  end >>>= 0\\n  start >>>= 0\\n\\n  if (end <= start) {\\n    return ''\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  while (true) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexSlice(this, start, end)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Slice(this, start, end)\\n\\n      case 'ascii':\\n        return asciiSlice(this, start, end)\\n\\n      case 'latin1':\\n      case 'binary':\\n        return latin1Slice(this, start, end)\\n\\n      case 'base64':\\n        return base64Slice(this, start, end)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return utf16leSlice(this, start, end)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = (encoding + '').toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\\n// reliably in a browserify context because there could be multiple different\\n// copies of the 'buffer' package in use. This method works even for Buffer\\n// instances that were created from another copy of the `buffer` package.\\n// See: https://github.com/feross/buffer/issues/154\\nBuffer.prototype._isBuffer = true\\n\\nfunction swap (b, n, m) {\\n  var i = b[n]\\n  b[n] = b[m]\\n  b[m] = i\\n}\\n\\nBuffer.prototype.swap16 = function swap16 () {\\n  var len = this.length\\n  if (len % 2 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\\n  }\\n  for (var i = 0; i < len; i += 2) {\\n    swap(this, i, i + 1)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.swap32 = function swap32 () {\\n  var len = this.length\\n  if (len % 4 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\\n  }\\n  for (var i = 0; i < len; i += 4) {\\n    swap(this, i, i + 3)\\n    swap(this, i + 1, i + 2)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.swap64 = function swap64 () {\\n  var len = this.length\\n  if (len % 8 !== 0) {\\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\\n  }\\n  for (var i = 0; i < len; i += 8) {\\n    swap(this, i, i + 7)\\n    swap(this, i + 1, i + 6)\\n    swap(this, i + 2, i + 5)\\n    swap(this, i + 3, i + 4)\\n  }\\n  return this\\n}\\n\\nBuffer.prototype.toString = function toString () {\\n  var length = this.length\\n  if (length === 0) return ''\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\n  return slowToString.apply(this, arguments)\\n}\\n\\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\\n\\nBuffer.prototype.equals = function equals (b) {\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\n  if (this === b) return true\\n  return Buffer.compare(this, b) === 0\\n}\\n\\nBuffer.prototype.inspect = function inspect () {\\n  var str = ''\\n  var max = exports.INSPECT_MAX_BYTES\\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\\n  if (this.length > max) str += ' ... '\\n  return '<Buffer ' + str + '>'\\n}\\n\\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\\n  if (isInstance(target, Uint8Array)) {\\n    target = Buffer.from(target, target.offset, target.byteLength)\\n  }\\n  if (!Buffer.isBuffer(target)) {\\n    throw new TypeError(\\n      'The \\\"target\\\" argument must be one of type Buffer or Uint8Array. ' +\\n      'Received type ' + (typeof target)\\n    )\\n  }\\n\\n  if (start === undefined) {\\n    start = 0\\n  }\\n  if (end === undefined) {\\n    end = target ? target.length : 0\\n  }\\n  if (thisStart === undefined) {\\n    thisStart = 0\\n  }\\n  if (thisEnd === undefined) {\\n    thisEnd = this.length\\n  }\\n\\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\n    throw new RangeError('out of range index')\\n  }\\n\\n  if (thisStart >= thisEnd && start >= end) {\\n    return 0\\n  }\\n  if (thisStart >= thisEnd) {\\n    return -1\\n  }\\n  if (start >= end) {\\n    return 1\\n  }\\n\\n  start >>>= 0\\n  end >>>= 0\\n  thisStart >>>= 0\\n  thisEnd >>>= 0\\n\\n  if (this === target) return 0\\n\\n  var x = thisEnd - thisStart\\n  var y = end - start\\n  var len = Math.min(x, y)\\n\\n  var thisCopy = this.slice(thisStart, thisEnd)\\n  var targetCopy = target.slice(start, end)\\n\\n  for (var i = 0; i < len; ++i) {\\n    if (thisCopy[i] !== targetCopy[i]) {\\n      x = thisCopy[i]\\n      y = targetCopy[i]\\n      break\\n    }\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\\n//\\n// Arguments:\\n// - buffer - a Buffer to search\\n// - val - a string, Buffer, or number\\n// - byteOffset - an index into `buffer`; will be clamped to an int32\\n// - encoding - an optional encoding, relevant is val is a string\\n// - dir - true for indexOf, false for lastIndexOf\\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\\n  // Empty buffer means no match\\n  if (buffer.length === 0) return -1\\n\\n  // Normalize byteOffset\\n  if (typeof byteOffset === 'string') {\\n    encoding = byteOffset\\n    byteOffset = 0\\n  } else if (byteOffset > 0x7fffffff) {\\n    byteOffset = 0x7fffffff\\n  } else if (byteOffset < -0x80000000) {\\n    byteOffset = -0x80000000\\n  }\\n  byteOffset = +byteOffset // Coerce to Number.\\n  if (numberIsNaN(byteOffset)) {\\n    // byteOffset: it it's undefined, null, NaN, \\\"foo\\\", etc, search whole buffer\\n    byteOffset = dir ? 0 : (buffer.length - 1)\\n  }\\n\\n  // Normalize byteOffset: negative offsets start from the end of the buffer\\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\\n  if (byteOffset >= buffer.length) {\\n    if (dir) return -1\\n    else byteOffset = buffer.length - 1\\n  } else if (byteOffset < 0) {\\n    if (dir) byteOffset = 0\\n    else return -1\\n  }\\n\\n  // Normalize val\\n  if (typeof val === 'string') {\\n    val = Buffer.from(val, encoding)\\n  }\\n\\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\\n  if (Buffer.isBuffer(val)) {\\n    // Special case: looking for empty string/buffer always fails\\n    if (val.length === 0) {\\n      return -1\\n    }\\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\\n  } else if (typeof val === 'number') {\\n    val = val & 0xFF // Search for a byte value [0-255]\\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\\n      if (dir) {\\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\\n      } else {\\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\\n      }\\n    }\\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\\n  }\\n\\n  throw new TypeError('val must be string, number or Buffer')\\n}\\n\\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\\n  var indexSize = 1\\n  var arrLength = arr.length\\n  var valLength = val.length\\n\\n  if (encoding !== undefined) {\\n    encoding = String(encoding).toLowerCase()\\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\\n        encoding === 'utf16le' || encoding === 'utf-16le') {\\n      if (arr.length < 2 || val.length < 2) {\\n        return -1\\n      }\\n      indexSize = 2\\n      arrLength /= 2\\n      valLength /= 2\\n      byteOffset /= 2\\n    }\\n  }\\n\\n  function read (buf, i) {\\n    if (indexSize === 1) {\\n      return buf[i]\\n    } else {\\n      return buf.readUInt16BE(i * indexSize)\\n    }\\n  }\\n\\n  var i\\n  if (dir) {\\n    var foundIndex = -1\\n    for (i = byteOffset; i < arrLength; i++) {\\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\n        if (foundIndex === -1) foundIndex = i\\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\\n      } else {\\n        if (foundIndex !== -1) i -= i - foundIndex\\n        foundIndex = -1\\n      }\\n    }\\n  } else {\\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\\n    for (i = byteOffset; i >= 0; i--) {\\n      var found = true\\n      for (var j = 0; j < valLength; j++) {\\n        if (read(arr, i + j) !== read(val, j)) {\\n          found = false\\n          break\\n        }\\n      }\\n      if (found) return i\\n    }\\n  }\\n\\n  return -1\\n}\\n\\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\\n  return this.indexOf(val, byteOffset, encoding) !== -1\\n}\\n\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\\n}\\n\\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\\n}\\n\\nfunction hexWrite (buf, string, offset, length) {\\n  offset = Number(offset) || 0\\n  var remaining = buf.length - offset\\n  if (!length) {\\n    length = remaining\\n  } else {\\n    length = Number(length)\\n    if (length > remaining) {\\n      length = remaining\\n    }\\n  }\\n\\n  var strLen = string.length\\n\\n  if (length > strLen / 2) {\\n    length = strLen / 2\\n  }\\n  for (var i = 0; i < length; ++i) {\\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\\n    if (numberIsNaN(parsed)) return i\\n    buf[offset + i] = parsed\\n  }\\n  return i\\n}\\n\\nfunction utf8Write (buf, string, offset, length) {\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nfunction asciiWrite (buf, string, offset, length) {\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\n}\\n\\nfunction latin1Write (buf, string, offset, length) {\\n  return asciiWrite(buf, string, offset, length)\\n}\\n\\nfunction base64Write (buf, string, offset, length) {\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\n}\\n\\nfunction ucs2Write (buf, string, offset, length) {\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\n  // Buffer#write(string)\\n  if (offset === undefined) {\\n    encoding = 'utf8'\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, encoding)\\n  } else if (length === undefined && typeof offset === 'string') {\\n    encoding = offset\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, offset[, length][, encoding])\\n  } else if (isFinite(offset)) {\\n    offset = offset >>> 0\\n    if (isFinite(length)) {\\n      length = length >>> 0\\n      if (encoding === undefined) encoding = 'utf8'\\n    } else {\\n      encoding = length\\n      length = undefined\\n    }\\n  } else {\\n    throw new Error(\\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\\n    )\\n  }\\n\\n  var remaining = this.length - offset\\n  if (length === undefined || length > remaining) length = remaining\\n\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\n    throw new RangeError('Attempt to write outside buffer bounds')\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexWrite(this, string, offset, length)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Write(this, string, offset, length)\\n\\n      case 'ascii':\\n        return asciiWrite(this, string, offset, length)\\n\\n      case 'latin1':\\n      case 'binary':\\n        return latin1Write(this, string, offset, length)\\n\\n      case 'base64':\\n        // Warning: maxLength not taken into account in base64Write\\n        return base64Write(this, string, offset, length)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return ucs2Write(this, string, offset, length)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\nBuffer.prototype.toJSON = function toJSON () {\\n  return {\\n    type: 'Buffer',\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\n  }\\n}\\n\\nfunction base64Slice (buf, start, end) {\\n  if (start === 0 && end === buf.length) {\\n    return base64.fromByteArray(buf)\\n  } else {\\n    return base64.fromByteArray(buf.slice(start, end))\\n  }\\n}\\n\\nfunction utf8Slice (buf, start, end) {\\n  end = Math.min(buf.length, end)\\n  var res = []\\n\\n  var i = start\\n  while (i < end) {\\n    var firstByte = buf[i]\\n    var codePoint = null\\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\\n      : (firstByte > 0xDF) ? 3\\n        : (firstByte > 0xBF) ? 2\\n          : 1\\n\\n    if (i + bytesPerSequence <= end) {\\n      var secondByte, thirdByte, fourthByte, tempCodePoint\\n\\n      switch (bytesPerSequence) {\\n        case 1:\\n          if (firstByte < 0x80) {\\n            codePoint = firstByte\\n          }\\n          break\\n        case 2:\\n          secondByte = buf[i + 1]\\n          if ((secondByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\n            if (tempCodePoint > 0x7F) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 3:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 4:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          fourthByte = buf[i + 3]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n      }\\n    }\\n\\n    if (codePoint === null) {\\n      // we did not generate a valid codePoint so insert a\\n      // replacement char (U+FFFD) and advance only 1 byte\\n      codePoint = 0xFFFD\\n      bytesPerSequence = 1\\n    } else if (codePoint > 0xFFFF) {\\n      // encode to utf16 (surrogate pair dance)\\n      codePoint -= 0x10000\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\n    }\\n\\n    res.push(codePoint)\\n    i += bytesPerSequence\\n  }\\n\\n  return decodeCodePointsArray(res)\\n}\\n\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\n// the lowest limit is Chrome, with 0x10000 args.\\n// We go 1 magnitude less, for safety\\nvar MAX_ARGUMENTS_LENGTH = 0x1000\\n\\nfunction decodeCodePointsArray (codePoints) {\\n  var len = codePoints.length\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\n  }\\n\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\n  var res = ''\\n  var i = 0\\n  while (i < len) {\\n    res += String.fromCharCode.apply(\\n      String,\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\n    )\\n  }\\n  return res\\n}\\n\\nfunction asciiSlice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; ++i) {\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\n  }\\n  return ret\\n}\\n\\nfunction latin1Slice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; ++i) {\\n    ret += String.fromCharCode(buf[i])\\n  }\\n  return ret\\n}\\n\\nfunction hexSlice (buf, start, end) {\\n  var len = buf.length\\n\\n  if (!start || start < 0) start = 0\\n  if (!end || end < 0 || end > len) end = len\\n\\n  var out = ''\\n  for (var i = start; i < end; ++i) {\\n    out += toHex(buf[i])\\n  }\\n  return out\\n}\\n\\nfunction utf16leSlice (buf, start, end) {\\n  var bytes = buf.slice(start, end)\\n  var res = ''\\n  for (var i = 0; i < bytes.length; i += 2) {\\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\\n  }\\n  return res\\n}\\n\\nBuffer.prototype.slice = function slice (start, end) {\\n  var len = this.length\\n  start = ~~start\\n  end = end === undefined ? len : ~~end\\n\\n  if (start < 0) {\\n    start += len\\n    if (start < 0) start = 0\\n  } else if (start > len) {\\n    start = len\\n  }\\n\\n  if (end < 0) {\\n    end += len\\n    if (end < 0) end = 0\\n  } else if (end > len) {\\n    end = len\\n  }\\n\\n  if (end < start) end = start\\n\\n  var newBuf = this.subarray(start, end)\\n  // Return an augmented `Uint8Array` instance\\n  newBuf.__proto__ = Buffer.prototype\\n  return newBuf\\n}\\n\\n/*\\n * Need to make sure that buffer isn't trying to write out of bounds.\\n */\\nfunction checkOffset (offset, ext, length) {\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\n}\\n\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\n  offset = offset >>> 0\\n  byteLength = byteLength >>> 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\n  offset = offset >>> 0\\n  byteLength = byteLength >>> 0\\n  if (!noAssert) {\\n    checkOffset(offset, byteLength, this.length)\\n  }\\n\\n  var val = this[offset + --byteLength]\\n  var mul = 1\\n  while (byteLength > 0 && (mul *= 0x100)) {\\n    val += this[offset + --byteLength] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  return this[offset]\\n}\\n\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return this[offset] | (this[offset + 1] << 8)\\n}\\n\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return (this[offset] << 8) | this[offset + 1]\\n}\\n\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return ((this[offset]) |\\n      (this[offset + 1] << 8) |\\n      (this[offset + 2] << 16)) +\\n      (this[offset + 3] * 0x1000000)\\n}\\n\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] * 0x1000000) +\\n    ((this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    this[offset + 3])\\n}\\n\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\n  offset = offset >>> 0\\n  byteLength = byteLength >>> 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\n  offset = offset >>> 0\\n  byteLength = byteLength >>> 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var i = byteLength\\n  var mul = 1\\n  var val = this[offset + --i]\\n  while (i > 0 && (mul *= 0x100)) {\\n    val += this[offset + --i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  if (!(this[offset] & 0x80)) return (this[offset])\\n  return ((0xff - this[offset] + 1) * -1)\\n}\\n\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset] | (this[offset + 1] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset + 1] | (this[offset] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset]) |\\n    (this[offset + 1] << 8) |\\n    (this[offset + 2] << 16) |\\n    (this[offset + 3] << 24)\\n}\\n\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] << 24) |\\n    (this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    (this[offset + 3])\\n}\\n\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, true, 23, 4)\\n}\\n\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, false, 23, 4)\\n}\\n\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, true, 52, 8)\\n}\\n\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\n  offset = offset >>> 0\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, false, 52, 8)\\n}\\n\\nfunction checkInt (buf, value, offset, ext, max, min) {\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance')\\n  if (value > max || value < min) throw new RangeError('\\\"value\\\" argument is out of bounds')\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\n}\\n\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  byteLength = byteLength >>> 0\\n  if (!noAssert) {\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\n  }\\n\\n  var mul = 1\\n  var i = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  byteLength = byteLength >>> 0\\n  if (!noAssert) {\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\n  this[offset] = (value & 0xff)\\n  return offset + 1\\n}\\n\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  this[offset] = (value & 0xff)\\n  this[offset + 1] = (value >>> 8)\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  this[offset] = (value >>> 8)\\n  this[offset + 1] = (value & 0xff)\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  this[offset + 3] = (value >>> 24)\\n  this[offset + 2] = (value >>> 16)\\n  this[offset + 1] = (value >>> 8)\\n  this[offset] = (value & 0xff)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  this[offset] = (value >>> 24)\\n  this[offset + 1] = (value >>> 16)\\n  this[offset + 2] = (value >>> 8)\\n  this[offset + 3] = (value & 0xff)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, (8 * byteLength) - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = 0\\n  var mul = 1\\n  var sub = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\n      sub = 1\\n    }\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, (8 * byteLength) - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  var sub = 0\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\n      sub = 1\\n    }\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\n  if (value < 0) value = 0xff + value + 1\\n  this[offset] = (value & 0xff)\\n  return offset + 1\\n}\\n\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  this[offset] = (value & 0xff)\\n  this[offset + 1] = (value >>> 8)\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  this[offset] = (value >>> 8)\\n  this[offset + 1] = (value & 0xff)\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  this[offset] = (value & 0xff)\\n  this[offset + 1] = (value >>> 8)\\n  this[offset + 2] = (value >>> 16)\\n  this[offset + 3] = (value >>> 24)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (value < 0) value = 0xffffffff + value + 1\\n  this[offset] = (value >>> 24)\\n  this[offset + 1] = (value >>> 16)\\n  this[offset + 2] = (value >>> 8)\\n  this[offset + 3] = (value & 0xff)\\n  return offset + 4\\n}\\n\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\n  if (offset < 0) throw new RangeError('Index out of range')\\n}\\n\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, false, noAssert)\\n}\\n\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\n  value = +value\\n  offset = offset >>> 0\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\n  return offset + 8\\n}\\n\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, false, noAssert)\\n}\\n\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\\n  if (!start) start = 0\\n  if (!end && end !== 0) end = this.length\\n  if (targetStart >= target.length) targetStart = target.length\\n  if (!targetStart) targetStart = 0\\n  if (end > 0 && end < start) end = start\\n\\n  // Copy 0 bytes; we're done\\n  if (end === start) return 0\\n  if (target.length === 0 || this.length === 0) return 0\\n\\n  // Fatal error conditions\\n  if (targetStart < 0) {\\n    throw new RangeError('targetStart out of bounds')\\n  }\\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\n\\n  // Are we oob?\\n  if (end > this.length) end = this.length\\n  if (target.length - targetStart < end - start) {\\n    end = target.length - targetStart + start\\n  }\\n\\n  var len = end - start\\n\\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\\n    // Use built-in when available, missing from IE11\\n    this.copyWithin(targetStart, start, end)\\n  } else if (this === target && start < targetStart && targetStart < end) {\\n    // descending copy from end\\n    for (var i = len - 1; i >= 0; --i) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else {\\n    Uint8Array.prototype.set.call(\\n      target,\\n      this.subarray(start, end),\\n      targetStart\\n    )\\n  }\\n\\n  return len\\n}\\n\\n// Usage:\\n//    buffer.fill(number[, offset[, end]])\\n//    buffer.fill(buffer[, offset[, end]])\\n//    buffer.fill(string[, offset[, end]][, encoding])\\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\\n  // Handle string cases:\\n  if (typeof val === 'string') {\\n    if (typeof start === 'string') {\\n      encoding = start\\n      start = 0\\n      end = this.length\\n    } else if (typeof end === 'string') {\\n      encoding = end\\n      end = this.length\\n    }\\n    if (encoding !== undefined && typeof encoding !== 'string') {\\n      throw new TypeError('encoding must be a string')\\n    }\\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\\n      throw new TypeError('Unknown encoding: ' + encoding)\\n    }\\n    if (val.length === 1) {\\n      var code = val.charCodeAt(0)\\n      if ((encoding === 'utf8' && code < 128) ||\\n          encoding === 'latin1') {\\n        // Fast path: If `val` fits into a single byte, use that numeric value.\\n        val = code\\n      }\\n    }\\n  } else if (typeof val === 'number') {\\n    val = val & 255\\n  }\\n\\n  // Invalid ranges are not set to a default, so can range check early.\\n  if (start < 0 || this.length < start || this.length < end) {\\n    throw new RangeError('Out of range index')\\n  }\\n\\n  if (end <= start) {\\n    return this\\n  }\\n\\n  start = start >>> 0\\n  end = end === undefined ? this.length : end >>> 0\\n\\n  if (!val) val = 0\\n\\n  var i\\n  if (typeof val === 'number') {\\n    for (i = start; i < end; ++i) {\\n      this[i] = val\\n    }\\n  } else {\\n    var bytes = Buffer.isBuffer(val)\\n      ? val\\n      : Buffer.from(val, encoding)\\n    var len = bytes.length\\n    if (len === 0) {\\n      throw new TypeError('The value \\\"' + val +\\n        '\\\" is invalid for argument \\\"value\\\"')\\n    }\\n    for (i = 0; i < end - start; ++i) {\\n      this[i + start] = bytes[i % len]\\n    }\\n  }\\n\\n  return this\\n}\\n\\n// HELPER FUNCTIONS\\n// ================\\n\\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\\n\\nfunction base64clean (str) {\\n  // Node takes equal signs as end of the Base64 encoding\\n  str = str.split('=')[0]\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\n  str = str.trim().replace(INVALID_BASE64_RE, '')\\n  // Node converts strings with length < 2 to ''\\n  if (str.length < 2) return ''\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\n  while (str.length % 4 !== 0) {\\n    str = str + '='\\n  }\\n  return str\\n}\\n\\nfunction toHex (n) {\\n  if (n < 16) return '0' + n.toString(16)\\n  return n.toString(16)\\n}\\n\\nfunction utf8ToBytes (string, units) {\\n  units = units || Infinity\\n  var codePoint\\n  var length = string.length\\n  var leadSurrogate = null\\n  var bytes = []\\n\\n  for (var i = 0; i < length; ++i) {\\n    codePoint = string.charCodeAt(i)\\n\\n    // is surrogate component\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\n      // last char was a lead\\n      if (!leadSurrogate) {\\n        // no lead yet\\n        if (codePoint > 0xDBFF) {\\n          // unexpected trail\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        } else if (i + 1 === length) {\\n          // unpaired lead\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        }\\n\\n        // valid lead\\n        leadSurrogate = codePoint\\n\\n        continue\\n      }\\n\\n      // 2 leads in a row\\n      if (codePoint < 0xDC00) {\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n        leadSurrogate = codePoint\\n        continue\\n      }\\n\\n      // valid surrogate pair\\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\\n    } else if (leadSurrogate) {\\n      // valid bmp char, but last char was a lead\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n    }\\n\\n    leadSurrogate = null\\n\\n    // encode utf8\\n    if (codePoint < 0x80) {\\n      if ((units -= 1) < 0) break\\n      bytes.push(codePoint)\\n    } else if (codePoint < 0x800) {\\n      if ((units -= 2) < 0) break\\n      bytes.push(\\n        codePoint >> 0x6 | 0xC0,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x10000) {\\n      if ((units -= 3) < 0) break\\n      bytes.push(\\n        codePoint >> 0xC | 0xE0,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x110000) {\\n      if ((units -= 4) < 0) break\\n      bytes.push(\\n        codePoint >> 0x12 | 0xF0,\\n        codePoint >> 0xC & 0x3F | 0x80,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else {\\n      throw new Error('Invalid code point')\\n    }\\n  }\\n\\n  return bytes\\n}\\n\\nfunction asciiToBytes (str) {\\n  var byteArray = []\\n  for (var i = 0; i < str.length; ++i) {\\n    // Node's code seems to be doing this and not & 0x7F..\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\n  }\\n  return byteArray\\n}\\n\\nfunction utf16leToBytes (str, units) {\\n  var c, hi, lo\\n  var byteArray = []\\n  for (var i = 0; i < str.length; ++i) {\\n    if ((units -= 2) < 0) break\\n\\n    c = str.charCodeAt(i)\\n    hi = c >> 8\\n    lo = c % 256\\n    byteArray.push(lo)\\n    byteArray.push(hi)\\n  }\\n\\n  return byteArray\\n}\\n\\nfunction base64ToBytes (str) {\\n  return base64.toByteArray(base64clean(str))\\n}\\n\\nfunction blitBuffer (src, dst, offset, length) {\\n  for (var i = 0; i < length; ++i) {\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\n    dst[i + offset] = src[i]\\n  }\\n  return i\\n}\\n\\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\\n// the `instanceof` check but they should be treated as of that type.\\n// See: https://github.com/feross/buffer/issues/166\\nfunction isInstance (obj, type) {\\n  return obj instanceof type ||\\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\\n      obj.constructor.name === type.name)\\n}\\nfunction numberIsNaN (obj) {\\n  // For IE11 support\\n  return obj !== obj // eslint-disable-line no-self-compare\\n}\\n\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"base64-js\\\":7,\\\"buffer\\\":8,\\\"ieee754\\\":22}],9:[function(require,module,exports){\\n'use strict'\\n\\nconst mh = require('multihashes')\\nconst { Buffer } = require('buffer')\\nvar CIDUtil = {\\n  /**\\n   * Test if the given input is a valid CID object.\\n   * Returns an error message if it is not.\\n   * Returns undefined if it is a valid CID.\\n   *\\n   * @param {any} other\\n   * @returns {string}\\n   */\\n  checkCIDComponents: function (other) {\\n    if (other == null) {\\n      return 'null values are not valid CIDs'\\n    }\\n\\n    if (!(other.version === 0 || other.version === 1)) {\\n      return 'Invalid version, must be a number equal to 1 or 0'\\n    }\\n\\n    if (typeof other.codec !== 'string') {\\n      return 'codec must be string'\\n    }\\n\\n    if (other.version === 0) {\\n      if (other.codec !== 'dag-pb') {\\n        return \\\"codec must be 'dag-pb' for CIDv0\\\"\\n      }\\n      if (other.multibaseName !== 'base58btc') {\\n        return \\\"multibaseName must be 'base58btc' for CIDv0\\\"\\n      }\\n    }\\n\\n    if (!Buffer.isBuffer(other.multihash)) {\\n      return 'multihash must be a Buffer'\\n    }\\n\\n    try {\\n      mh.validate(other.multihash)\\n    } catch (err) {\\n      let errorMsg = err.message\\n      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message\\n        errorMsg = 'Multihash validation failed'\\n      }\\n      return errorMsg\\n    }\\n  }\\n}\\n\\nmodule.exports = CIDUtil\\n\\n},{\\\"buffer\\\":8,\\\"multihashes\\\":51}],10:[function(require,module,exports){\\n'use strict'\\n\\nconst { Buffer } = require('buffer')\\nconst mh = require('multihashes')\\nconst multibase = require('multibase')\\nconst multicodec = require('multicodec')\\nconst codecs = require('multicodec/src/base-table.json')\\nconst CIDUtil = require('./cid-util')\\nconst withIs = require('class-is')\\n\\n/**\\n * @typedef {Object} SerializedCID\\n * @param {string} codec\\n * @param {number} version\\n * @param {Buffer} multihash\\n */\\n\\n/**\\n * Test if the given input is a CID.\\n * @function isCID\\n * @memberof CID\\n * @static\\n * @param {any} other\\n * @returns {bool}\\n */\\n\\n/**\\n * Class representing a CID `<mbase><version><mcodec><mhash>`\\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\\n * @class CID\\n */\\nclass CID {\\n  /**\\n   * Create a new CID.\\n   *\\n   * The algorithm for argument input is roughly:\\n   * ```\\n   * if (cid)\\n   *   -> create a copy\\n   * else if (str)\\n   *   if (1st char is on multibase table) -> CID String\\n   *   else -> bs58 encoded multihash\\n   * else if (Buffer)\\n   *   if (1st byte is 0 or 1) -> CID\\n   *   else -> multihash\\n   * else if (Number)\\n   *   -> construct CID by parts\\n   * ```\\n   *\\n   * @param {string|Buffer|CID} version\\n   * @param {string} [codec]\\n   * @param {Buffer} [multihash]\\n   * @param {string} [multibaseName]\\n   *\\n   * @example\\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\\n   * new CID(<cidStr>)\\n   * new CID(<cid.buffer>)\\n   * new CID(<multihash>)\\n   * new CID(<bs58 encoded multihash>)\\n   * new CID(<cid>)\\n   */\\n  constructor (version, codec, multihash, multibaseName) {\\n    if (_CID.isCID(version)) {\\n      // version is an exising CID instance\\n      const cid = version\\n      this.version = cid.version\\n      this.codec = cid.codec\\n      this.multihash = Buffer.from(cid.multihash)\\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\\n      return\\n    }\\n\\n    if (typeof version === 'string') {\\n      // e.g. 'base32' or false\\n      const baseName = multibase.isEncoded(version)\\n      if (baseName) {\\n        // version is a CID String encoded with multibase, so v1\\n        const cid = multibase.decode(version)\\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)\\n        this.codec = multicodec.getCodec(cid.slice(1))\\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\\n        this.multibaseName = baseName\\n      } else {\\n        // version is a base58btc string multihash, so v0\\n        this.version = 0\\n        this.codec = 'dag-pb'\\n        this.multihash = mh.fromB58String(version)\\n        this.multibaseName = 'base58btc'\\n      }\\n      CID.validateCID(this)\\n      Object.defineProperty(this, 'string', { value: version })\\n      return\\n    }\\n\\n    if (Buffer.isBuffer(version)) {\\n      const firstByte = version.slice(0, 1)\\n      const v = parseInt(firstByte.toString('hex'), 16)\\n      if (v === 1) {\\n        // version is a CID buffer\\n        const cid = version\\n        this.version = v\\n        this.codec = multicodec.getCodec(cid.slice(1))\\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\\n        this.multibaseName = 'base32'\\n      } else {\\n        // version is a raw multihash buffer, so v0\\n        this.version = 0\\n        this.codec = 'dag-pb'\\n        this.multihash = version\\n        this.multibaseName = 'base58btc'\\n      }\\n      CID.validateCID(this)\\n      return\\n    }\\n\\n    // otherwise, assemble the CID from the parameters\\n\\n    /**\\n     * @type {number}\\n     */\\n    this.version = version\\n\\n    /**\\n     * @type {string}\\n     */\\n    this.codec = codec\\n\\n    /**\\n     * @type {Buffer}\\n     */\\n    this.multihash = multihash\\n\\n    /**\\n     * @type {string}\\n     */\\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\\n\\n    CID.validateCID(this)\\n  }\\n\\n  /**\\n   * The CID as a `Buffer`\\n   *\\n   * @return {Buffer}\\n   * @readonly\\n   *\\n   * @memberOf CID\\n   */\\n  get buffer () {\\n    let buffer = this._buffer\\n\\n    if (!buffer) {\\n      if (this.version === 0) {\\n        buffer = this.multihash\\n      } else if (this.version === 1) {\\n        buffer = Buffer.concat([\\n          Buffer.from('01', 'hex'),\\n          multicodec.getCodeVarint(this.codec),\\n          this.multihash\\n        ])\\n      } else {\\n        throw new Error('unsupported version')\\n      }\\n\\n      // Cache this buffer so it doesn't have to be recreated\\n      Object.defineProperty(this, '_buffer', { value: buffer })\\n    }\\n\\n    return buffer\\n  }\\n\\n  /**\\n   * Get the prefix of the CID.\\n   *\\n   * @returns {Buffer}\\n   * @readonly\\n   */\\n  get prefix () {\\n    return Buffer.concat([\\n      Buffer.from(`0${this.version}`, 'hex'),\\n      multicodec.getCodeVarint(this.codec),\\n      mh.prefix(this.multihash)\\n    ])\\n  }\\n\\n  /**\\n   * Convert to a CID of version `0`.\\n   *\\n   * @returns {CID}\\n   */\\n  toV0 () {\\n    if (this.codec !== 'dag-pb') {\\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\\n    }\\n\\n    const { name, length } = mh.decode(this.multihash)\\n\\n    if (name !== 'sha2-256') {\\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\\n    }\\n\\n    if (length !== 32) {\\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\\n    }\\n\\n    return new _CID(0, this.codec, this.multihash)\\n  }\\n\\n  /**\\n   * Convert to a CID of version `1`.\\n   *\\n   * @returns {CID}\\n   */\\n  toV1 () {\\n    return new _CID(1, this.codec, this.multihash)\\n  }\\n\\n  /**\\n   * Encode the CID into a string.\\n   *\\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\\n   * @returns {string}\\n   */\\n  toBaseEncodedString (base = this.multibaseName) {\\n    if (this.string && base === this.multibaseName) {\\n      return this.string\\n    }\\n    let str = null\\n    if (this.version === 0) {\\n      if (base !== 'base58btc') {\\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\\n      }\\n      str = mh.toB58String(this.multihash)\\n    } else if (this.version === 1) {\\n      str = multibase.encode(base, this.buffer).toString()\\n    } else {\\n      throw new Error('unsupported version')\\n    }\\n    if (base === this.multibaseName) {\\n      // cache the string value\\n      Object.defineProperty(this, 'string', { value: str })\\n    }\\n    return str\\n  }\\n\\n  /**\\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\\n   *\\n   * @returns {String}\\n   */\\n  [Symbol.for('nodejs.util.inspect.custom')] () {\\n    return 'CID(' + this.toString() + ')'\\n  }\\n\\n  toString (base) {\\n    return this.toBaseEncodedString(base)\\n  }\\n\\n  /**\\n   * Serialize to a plain object.\\n   *\\n   * @returns {SerializedCID}\\n   */\\n  toJSON () {\\n    return {\\n      codec: this.codec,\\n      version: this.version,\\n      hash: this.multihash\\n    }\\n  }\\n\\n  /**\\n   * Compare equality with another CID.\\n   *\\n   * @param {CID} other\\n   * @returns {bool}\\n   */\\n  equals (other) {\\n    return this.codec === other.codec &&\\n      this.version === other.version &&\\n      this.multihash.equals(other.multihash)\\n  }\\n\\n  /**\\n   * Test if the given input is a valid CID object.\\n   * Throws if it is not.\\n   *\\n   * @param {any} other\\n   * @returns {void}\\n   */\\n  static validateCID (other) {\\n    const errorMsg = CIDUtil.checkCIDComponents(other)\\n    if (errorMsg) {\\n      throw new Error(errorMsg)\\n    }\\n  }\\n}\\n\\nconst _CID = withIs(CID, {\\n  className: 'CID',\\n  symbolName: '@ipld/js-cid/CID'\\n})\\n\\n_CID.codecs = codecs\\n\\nmodule.exports = _CID\\n\\n},{\\\"./cid-util\\\":9,\\\"buffer\\\":8,\\\"class-is\\\":11,\\\"multibase\\\":36,\\\"multicodec\\\":39,\\\"multicodec/src/base-table.json\\\":37,\\\"multihashes\\\":51}],11:[function(require,module,exports){\\n'use strict';\\n\\nfunction withIs(Class, { className, symbolName }) {\\n    const symbol = Symbol.for(symbolName);\\n\\n    const ClassIsWrapper = {\\n        // The code below assigns the class wrapper to an object to trick\\n        // JavaScript engines to show the name of the extended class when\\n        // logging an instances.\\n        // We are assigning an anonymous class (class wrapper) to the object\\n        // with key `className` to keep the correct name.\\n        // If this is not supported it falls back to logging `ClassIsWrapper`.\\n        [className]: class extends Class {\\n            constructor(...args) {\\n                super(...args);\\n                Object.defineProperty(this, symbol, { value: true });\\n            }\\n\\n            get [Symbol.toStringTag]() {\\n                return className;\\n            }\\n        },\\n    }[className];\\n\\n    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);\\n\\n    return ClassIsWrapper;\\n}\\n\\nfunction withIsProto(Class, { className, symbolName, withoutNew }) {\\n    const symbol = Symbol.for(symbolName);\\n\\n    /* eslint-disable object-shorthand */\\n    const ClassIsWrapper = {\\n        [className]: function (...args) {\\n            if (withoutNew && !(this instanceof ClassIsWrapper)) {\\n                return new ClassIsWrapper(...args);\\n            }\\n\\n            const _this = Class.call(this, ...args) || this;\\n\\n            if (_this && !_this[symbol]) {\\n                Object.defineProperty(_this, symbol, { value: true });\\n            }\\n\\n            return _this;\\n        },\\n    }[className];\\n    /* eslint-enable object-shorthand */\\n\\n    ClassIsWrapper.prototype = Object.create(Class.prototype);\\n    ClassIsWrapper.prototype.constructor = ClassIsWrapper;\\n\\n    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {\\n        get() {\\n            return className;\\n        },\\n    });\\n\\n    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);\\n\\n    return ClassIsWrapper;\\n}\\n\\nmodule.exports = withIs;\\nmodule.exports.proto = withIsProto;\\n\\n},{}],12:[function(require,module,exports){\\nmodule.exports={\\n  \\\"identity\\\": 0,\\n  \\\"ip4\\\": 4,\\n  \\\"tcp\\\": 6,\\n  \\\"sha1\\\": 17,\\n  \\\"sha2-256\\\": 18,\\n  \\\"sha2-512\\\": 19,\\n  \\\"sha3-512\\\": 20,\\n  \\\"sha3-384\\\": 21,\\n  \\\"sha3-256\\\": 22,\\n  \\\"sha3-224\\\": 23,\\n  \\\"shake-128\\\": 24,\\n  \\\"shake-256\\\": 25,\\n  \\\"keccak-224\\\": 26,\\n  \\\"keccak-256\\\": 27,\\n  \\\"keccak-384\\\": 28,\\n  \\\"keccak-512\\\": 29,\\n  \\\"dccp\\\": 33,\\n  \\\"murmur3-128\\\": 34,\\n  \\\"murmur3-32\\\": 35,\\n  \\\"ip6\\\": 41,\\n  \\\"ip6zone\\\": 42,\\n  \\\"path\\\": 47,\\n  \\\"multicodec\\\": 48,\\n  \\\"multihash\\\": 49,\\n  \\\"multiaddr\\\": 50,\\n  \\\"multibase\\\": 51,\\n  \\\"dns\\\": 53,\\n  \\\"dns4\\\": 54,\\n  \\\"dns6\\\": 55,\\n  \\\"dnsaddr\\\": 56,\\n  \\\"protobuf\\\": 80,\\n  \\\"cbor\\\": 81,\\n  \\\"raw\\\": 85,\\n  \\\"dbl-sha2-256\\\": 86,\\n  \\\"rlp\\\": 96,\\n  \\\"bencode\\\": 99,\\n  \\\"dag-pb\\\": 112,\\n  \\\"dag-cbor\\\": 113,\\n  \\\"libp2p-key\\\": 114,\\n  \\\"git-raw\\\": 120,\\n  \\\"torrent-info\\\": 123,\\n  \\\"torrent-file\\\": 124,\\n  \\\"leofcoin-block\\\": 129,\\n  \\\"leofcoin-tx\\\": 130,\\n  \\\"leofcoin-pr\\\": 131,\\n  \\\"sctp\\\": 132,\\n  \\\"eth-block\\\": 144,\\n  \\\"eth-block-list\\\": 145,\\n  \\\"eth-tx-trie\\\": 146,\\n  \\\"eth-tx\\\": 147,\\n  \\\"eth-tx-receipt-trie\\\": 148,\\n  \\\"eth-tx-receipt\\\": 149,\\n  \\\"eth-state-trie\\\": 150,\\n  \\\"eth-account-snapshot\\\": 151,\\n  \\\"eth-storage-trie\\\": 152,\\n  \\\"bitcoin-block\\\": 176,\\n  \\\"bitcoin-tx\\\": 177,\\n  \\\"zcash-block\\\": 192,\\n  \\\"zcash-tx\\\": 193,\\n  \\\"stellar-block\\\": 208,\\n  \\\"stellar-tx\\\": 209,\\n  \\\"md4\\\": 212,\\n  \\\"md5\\\": 213,\\n  \\\"bmt\\\": 214,\\n  \\\"decred-block\\\": 224,\\n  \\\"decred-tx\\\": 225,\\n  \\\"ipld-ns\\\": 226,\\n  \\\"ipfs-ns\\\": 227,\\n  \\\"swarm-ns\\\": 228,\\n  \\\"ipns-ns\\\": 229,\\n  \\\"zeronet\\\": 230,\\n  \\\"ed25519-pub\\\": 237,\\n  \\\"dash-block\\\": 240,\\n  \\\"dash-tx\\\": 241,\\n  \\\"swarm-manifest\\\": 250,\\n  \\\"swarm-feed\\\": 251,\\n  \\\"udp\\\": 273,\\n  \\\"p2p-webrtc-star\\\": 275,\\n  \\\"p2p-webrtc-direct\\\": 276,\\n  \\\"p2p-stardust\\\": 277,\\n  \\\"p2p-circuit\\\": 290,\\n  \\\"dag-json\\\": 297,\\n  \\\"udt\\\": 301,\\n  \\\"utp\\\": 302,\\n  \\\"unix\\\": 400,\\n  \\\"p2p\\\": 421,\\n  \\\"ipfs\\\": 421,\\n  \\\"https\\\": 443,\\n  \\\"onion\\\": 444,\\n  \\\"onion3\\\": 445,\\n  \\\"garlic64\\\": 446,\\n  \\\"garlic32\\\": 447,\\n  \\\"tls\\\": 448,\\n  \\\"quic\\\": 460,\\n  \\\"ws\\\": 477,\\n  \\\"wss\\\": 478,\\n  \\\"p2p-websocket-star\\\": 479,\\n  \\\"http\\\": 480,\\n  \\\"json\\\": 512,\\n  \\\"messagepack\\\": 513,\\n  \\\"x11\\\": 4352,\\n  \\\"blake2b-8\\\": 45569,\\n  \\\"blake2b-16\\\": 45570,\\n  \\\"blake2b-24\\\": 45571,\\n  \\\"blake2b-32\\\": 45572,\\n  \\\"blake2b-40\\\": 45573,\\n  \\\"blake2b-48\\\": 45574,\\n  \\\"blake2b-56\\\": 45575,\\n  \\\"blake2b-64\\\": 45576,\\n  \\\"blake2b-72\\\": 45577,\\n  \\\"blake2b-80\\\": 45578,\\n  \\\"blake2b-88\\\": 45579,\\n  \\\"blake2b-96\\\": 45580,\\n  \\\"blake2b-104\\\": 45581,\\n  \\\"blake2b-112\\\": 45582,\\n  \\\"blake2b-120\\\": 45583,\\n  \\\"blake2b-128\\\": 45584,\\n  \\\"blake2b-136\\\": 45585,\\n  \\\"blake2b-144\\\": 45586,\\n  \\\"blake2b-152\\\": 45587,\\n  \\\"blake2b-160\\\": 45588,\\n  \\\"blake2b-168\\\": 45589,\\n  \\\"blake2b-176\\\": 45590,\\n  \\\"blake2b-184\\\": 45591,\\n  \\\"blake2b-192\\\": 45592,\\n  \\\"blake2b-200\\\": 45593,\\n  \\\"blake2b-208\\\": 45594,\\n  \\\"blake2b-216\\\": 45595,\\n  \\\"blake2b-224\\\": 45596,\\n  \\\"blake2b-232\\\": 45597,\\n  \\\"blake2b-240\\\": 45598,\\n  \\\"blake2b-248\\\": 45599,\\n  \\\"blake2b-256\\\": 45600,\\n  \\\"blake2b-264\\\": 45601,\\n  \\\"blake2b-272\\\": 45602,\\n  \\\"blake2b-280\\\": 45603,\\n  \\\"blake2b-288\\\": 45604,\\n  \\\"blake2b-296\\\": 45605,\\n  \\\"blake2b-304\\\": 45606,\\n  \\\"blake2b-312\\\": 45607,\\n  \\\"blake2b-320\\\": 45608,\\n  \\\"blake2b-328\\\": 45609,\\n  \\\"blake2b-336\\\": 45610,\\n  \\\"blake2b-344\\\": 45611,\\n  \\\"blake2b-352\\\": 45612,\\n  \\\"blake2b-360\\\": 45613,\\n  \\\"blake2b-368\\\": 45614,\\n  \\\"blake2b-376\\\": 45615,\\n  \\\"blake2b-384\\\": 45616,\\n  \\\"blake2b-392\\\": 45617,\\n  \\\"blake2b-400\\\": 45618,\\n  \\\"blake2b-408\\\": 45619,\\n  \\\"blake2b-416\\\": 45620,\\n  \\\"blake2b-424\\\": 45621,\\n  \\\"blake2b-432\\\": 45622,\\n  \\\"blake2b-440\\\": 45623,\\n  \\\"blake2b-448\\\": 45624,\\n  \\\"blake2b-456\\\": 45625,\\n  \\\"blake2b-464\\\": 45626,\\n  \\\"blake2b-472\\\": 45627,\\n  \\\"blake2b-480\\\": 45628,\\n  \\\"blake2b-488\\\": 45629,\\n  \\\"blake2b-496\\\": 45630,\\n  \\\"blake2b-504\\\": 45631,\\n  \\\"blake2b-512\\\": 45632,\\n  \\\"blake2s-8\\\": 45633,\\n  \\\"blake2s-16\\\": 45634,\\n  \\\"blake2s-24\\\": 45635,\\n  \\\"blake2s-32\\\": 45636,\\n  \\\"blake2s-40\\\": 45637,\\n  \\\"blake2s-48\\\": 45638,\\n  \\\"blake2s-56\\\": 45639,\\n  \\\"blake2s-64\\\": 45640,\\n  \\\"blake2s-72\\\": 45641,\\n  \\\"blake2s-80\\\": 45642,\\n  \\\"blake2s-88\\\": 45643,\\n  \\\"blake2s-96\\\": 45644,\\n  \\\"blake2s-104\\\": 45645,\\n  \\\"blake2s-112\\\": 45646,\\n  \\\"blake2s-120\\\": 45647,\\n  \\\"blake2s-128\\\": 45648,\\n  \\\"blake2s-136\\\": 45649,\\n  \\\"blake2s-144\\\": 45650,\\n  \\\"blake2s-152\\\": 45651,\\n  \\\"blake2s-160\\\": 45652,\\n  \\\"blake2s-168\\\": 45653,\\n  \\\"blake2s-176\\\": 45654,\\n  \\\"blake2s-184\\\": 45655,\\n  \\\"blake2s-192\\\": 45656,\\n  \\\"blake2s-200\\\": 45657,\\n  \\\"blake2s-208\\\": 45658,\\n  \\\"blake2s-216\\\": 45659,\\n  \\\"blake2s-224\\\": 45660,\\n  \\\"blake2s-232\\\": 45661,\\n  \\\"blake2s-240\\\": 45662,\\n  \\\"blake2s-248\\\": 45663,\\n  \\\"blake2s-256\\\": 45664,\\n  \\\"skein256-8\\\": 45825,\\n  \\\"skein256-16\\\": 45826,\\n  \\\"skein256-24\\\": 45827,\\n  \\\"skein256-32\\\": 45828,\\n  \\\"skein256-40\\\": 45829,\\n  \\\"skein256-48\\\": 45830,\\n  \\\"skein256-56\\\": 45831,\\n  \\\"skein256-64\\\": 45832,\\n  \\\"skein256-72\\\": 45833,\\n  \\\"skein256-80\\\": 45834,\\n  \\\"skein256-88\\\": 45835,\\n  \\\"skein256-96\\\": 45836,\\n  \\\"skein256-104\\\": 45837,\\n  \\\"skein256-112\\\": 45838,\\n  \\\"skein256-120\\\": 45839,\\n  \\\"skein256-128\\\": 45840,\\n  \\\"skein256-136\\\": 45841,\\n  \\\"skein256-144\\\": 45842,\\n  \\\"skein256-152\\\": 45843,\\n  \\\"skein256-160\\\": 45844,\\n  \\\"skein256-168\\\": 45845,\\n  \\\"skein256-176\\\": 45846,\\n  \\\"skein256-184\\\": 45847,\\n  \\\"skein256-192\\\": 45848,\\n  \\\"skein256-200\\\": 45849,\\n  \\\"skein256-208\\\": 45850,\\n  \\\"skein256-216\\\": 45851,\\n  \\\"skein256-224\\\": 45852,\\n  \\\"skein256-232\\\": 45853,\\n  \\\"skein256-240\\\": 45854,\\n  \\\"skein256-248\\\": 45855,\\n  \\\"skein256-256\\\": 45856,\\n  \\\"skein512-8\\\": 45857,\\n  \\\"skein512-16\\\": 45858,\\n  \\\"skein512-24\\\": 45859,\\n  \\\"skein512-32\\\": 45860,\\n  \\\"skein512-40\\\": 45861,\\n  \\\"skein512-48\\\": 45862,\\n  \\\"skein512-56\\\": 45863,\\n  \\\"skein512-64\\\": 45864,\\n  \\\"skein512-72\\\": 45865,\\n  \\\"skein512-80\\\": 45866,\\n  \\\"skein512-88\\\": 45867,\\n  \\\"skein512-96\\\": 45868,\\n  \\\"skein512-104\\\": 45869,\\n  \\\"skein512-112\\\": 45870,\\n  \\\"skein512-120\\\": 45871,\\n  \\\"skein512-128\\\": 45872,\\n  \\\"skein512-136\\\": 45873,\\n  \\\"skein512-144\\\": 45874,\\n  \\\"skein512-152\\\": 45875,\\n  \\\"skein512-160\\\": 45876,\\n  \\\"skein512-168\\\": 45877,\\n  \\\"skein512-176\\\": 45878,\\n  \\\"skein512-184\\\": 45879,\\n  \\\"skein512-192\\\": 45880,\\n  \\\"skein512-200\\\": 45881,\\n  \\\"skein512-208\\\": 45882,\\n  \\\"skein512-216\\\": 45883,\\n  \\\"skein512-224\\\": 45884,\\n  \\\"skein512-232\\\": 45885,\\n  \\\"skein512-240\\\": 45886,\\n  \\\"skein512-248\\\": 45887,\\n  \\\"skein512-256\\\": 45888,\\n  \\\"skein512-264\\\": 45889,\\n  \\\"skein512-272\\\": 45890,\\n  \\\"skein512-280\\\": 45891,\\n  \\\"skein512-288\\\": 45892,\\n  \\\"skein512-296\\\": 45893,\\n  \\\"skein512-304\\\": 45894,\\n  \\\"skein512-312\\\": 45895,\\n  \\\"skein512-320\\\": 45896,\\n  \\\"skein512-328\\\": 45897,\\n  \\\"skein512-336\\\": 45898,\\n  \\\"skein512-344\\\": 45899,\\n  \\\"skein512-352\\\": 45900,\\n  \\\"skein512-360\\\": 45901,\\n  \\\"skein512-368\\\": 45902,\\n  \\\"skein512-376\\\": 45903,\\n  \\\"skein512-384\\\": 45904,\\n  \\\"skein512-392\\\": 45905,\\n  \\\"skein512-400\\\": 45906,\\n  \\\"skein512-408\\\": 45907,\\n  \\\"skein512-416\\\": 45908,\\n  \\\"skein512-424\\\": 45909,\\n  \\\"skein512-432\\\": 45910,\\n  \\\"skein512-440\\\": 45911,\\n  \\\"skein512-448\\\": 45912,\\n  \\\"skein512-456\\\": 45913,\\n  \\\"skein512-464\\\": 45914,\\n  \\\"skein512-472\\\": 45915,\\n  \\\"skein512-480\\\": 45916,\\n  \\\"skein512-488\\\": 45917,\\n  \\\"skein512-496\\\": 45918,\\n  \\\"skein512-504\\\": 45919,\\n  \\\"skein512-512\\\": 45920,\\n  \\\"skein1024-8\\\": 45921,\\n  \\\"skein1024-16\\\": 45922,\\n  \\\"skein1024-24\\\": 45923,\\n  \\\"skein1024-32\\\": 45924,\\n  \\\"skein1024-40\\\": 45925,\\n  \\\"skein1024-48\\\": 45926,\\n  \\\"skein1024-56\\\": 45927,\\n  \\\"skein1024-64\\\": 45928,\\n  \\\"skein1024-72\\\": 45929,\\n  \\\"skein1024-80\\\": 45930,\\n  \\\"skein1024-88\\\": 45931,\\n  \\\"skein1024-96\\\": 45932,\\n  \\\"skein1024-104\\\": 45933,\\n  \\\"skein1024-112\\\": 45934,\\n  \\\"skein1024-120\\\": 45935,\\n  \\\"skein1024-128\\\": 45936,\\n  \\\"skein1024-136\\\": 45937,\\n  \\\"skein1024-144\\\": 45938,\\n  \\\"skein1024-152\\\": 45939,\\n  \\\"skein1024-160\\\": 45940,\\n  \\\"skein1024-168\\\": 45941,\\n  \\\"skein1024-176\\\": 45942,\\n  \\\"skein1024-184\\\": 45943,\\n  \\\"skein1024-192\\\": 45944,\\n  \\\"skein1024-200\\\": 45945,\\n  \\\"skein1024-208\\\": 45946,\\n  \\\"skein1024-216\\\": 45947,\\n  \\\"skein1024-224\\\": 45948,\\n  \\\"skein1024-232\\\": 45949,\\n  \\\"skein1024-240\\\": 45950,\\n  \\\"skein1024-248\\\": 45951,\\n  \\\"skein1024-256\\\": 45952,\\n  \\\"skein1024-264\\\": 45953,\\n  \\\"skein1024-272\\\": 45954,\\n  \\\"skein1024-280\\\": 45955,\\n  \\\"skein1024-288\\\": 45956,\\n  \\\"skein1024-296\\\": 45957,\\n  \\\"skein1024-304\\\": 45958,\\n  \\\"skein1024-312\\\": 45959,\\n  \\\"skein1024-320\\\": 45960,\\n  \\\"skein1024-328\\\": 45961,\\n  \\\"skein1024-336\\\": 45962,\\n  \\\"skein1024-344\\\": 45963,\\n  \\\"skein1024-352\\\": 45964,\\n  \\\"skein1024-360\\\": 45965,\\n  \\\"skein1024-368\\\": 45966,\\n  \\\"skein1024-376\\\": 45967,\\n  \\\"skein1024-384\\\": 45968,\\n  \\\"skein1024-392\\\": 45969,\\n  \\\"skein1024-400\\\": 45970,\\n  \\\"skein1024-408\\\": 45971,\\n  \\\"skein1024-416\\\": 45972,\\n  \\\"skein1024-424\\\": 45973,\\n  \\\"skein1024-432\\\": 45974,\\n  \\\"skein1024-440\\\": 45975,\\n  \\\"skein1024-448\\\": 45976,\\n  \\\"skein1024-456\\\": 45977,\\n  \\\"skein1024-464\\\": 45978,\\n  \\\"skein1024-472\\\": 45979,\\n  \\\"skein1024-480\\\": 45980,\\n  \\\"skein1024-488\\\": 45981,\\n  \\\"skein1024-496\\\": 45982,\\n  \\\"skein1024-504\\\": 45983,\\n  \\\"skein1024-512\\\": 45984,\\n  \\\"skein1024-520\\\": 45985,\\n  \\\"skein1024-528\\\": 45986,\\n  \\\"skein1024-536\\\": 45987,\\n  \\\"skein1024-544\\\": 45988,\\n  \\\"skein1024-552\\\": 45989,\\n  \\\"skein1024-560\\\": 45990,\\n  \\\"skein1024-568\\\": 45991,\\n  \\\"skein1024-576\\\": 45992,\\n  \\\"skein1024-584\\\": 45993,\\n  \\\"skein1024-592\\\": 45994,\\n  \\\"skein1024-600\\\": 45995,\\n  \\\"skein1024-608\\\": 45996,\\n  \\\"skein1024-616\\\": 45997,\\n  \\\"skein1024-624\\\": 45998,\\n  \\\"skein1024-632\\\": 45999,\\n  \\\"skein1024-640\\\": 46000,\\n  \\\"skein1024-648\\\": 46001,\\n  \\\"skein1024-656\\\": 46002,\\n  \\\"skein1024-664\\\": 46003,\\n  \\\"skein1024-672\\\": 46004,\\n  \\\"skein1024-680\\\": 46005,\\n  \\\"skein1024-688\\\": 46006,\\n  \\\"skein1024-696\\\": 46007,\\n  \\\"skein1024-704\\\": 46008,\\n  \\\"skein1024-712\\\": 46009,\\n  \\\"skein1024-720\\\": 46010,\\n  \\\"skein1024-728\\\": 46011,\\n  \\\"skein1024-736\\\": 46012,\\n  \\\"skein1024-744\\\": 46013,\\n  \\\"skein1024-752\\\": 46014,\\n  \\\"skein1024-760\\\": 46015,\\n  \\\"skein1024-768\\\": 46016,\\n  \\\"skein1024-776\\\": 46017,\\n  \\\"skein1024-784\\\": 46018,\\n  \\\"skein1024-792\\\": 46019,\\n  \\\"skein1024-800\\\": 46020,\\n  \\\"skein1024-808\\\": 46021,\\n  \\\"skein1024-816\\\": 46022,\\n  \\\"skein1024-824\\\": 46023,\\n  \\\"skein1024-832\\\": 46024,\\n  \\\"skein1024-840\\\": 46025,\\n  \\\"skein1024-848\\\": 46026,\\n  \\\"skein1024-856\\\": 46027,\\n  \\\"skein1024-864\\\": 46028,\\n  \\\"skein1024-872\\\": 46029,\\n  \\\"skein1024-880\\\": 46030,\\n  \\\"skein1024-888\\\": 46031,\\n  \\\"skein1024-896\\\": 46032,\\n  \\\"skein1024-904\\\": 46033,\\n  \\\"skein1024-912\\\": 46034,\\n  \\\"skein1024-920\\\": 46035,\\n  \\\"skein1024-928\\\": 46036,\\n  \\\"skein1024-936\\\": 46037,\\n  \\\"skein1024-944\\\": 46038,\\n  \\\"skein1024-952\\\": 46039,\\n  \\\"skein1024-960\\\": 46040,\\n  \\\"skein1024-968\\\": 46041,\\n  \\\"skein1024-976\\\": 46042,\\n  \\\"skein1024-984\\\": 46043,\\n  \\\"skein1024-992\\\": 46044,\\n  \\\"skein1024-1000\\\": 46045,\\n  \\\"skein1024-1008\\\": 46046,\\n  \\\"skein1024-1016\\\": 46047,\\n  \\\"skein1024-1024\\\": 46048,\\n  \\\"holochain-adr-v0\\\": 8417572,\\n  \\\"holochain-adr-v1\\\": 8483108,\\n  \\\"holochain-key-v0\\\": 9728292,\\n  \\\"holochain-key-v1\\\": 9793828,\\n  \\\"holochain-sig-v0\\\": 10645796,\\n  \\\"holochain-sig-v1\\\": 10711332\\n}\\n},{}],13:[function(require,module,exports){\\n'use strict'\\n\\nconst table = require('./base-table.json')\\n\\n// map for codecConstant -> code\\nconst constants = {}\\n\\nfor (const [name, code] of Object.entries(table)) {\\n  constants[name.toUpperCase().replace(/-/g, '_')] = code\\n}\\n\\nmodule.exports = Object.freeze(constants)\\n\\n},{\\\"./base-table.json\\\":12}],14:[function(require,module,exports){\\n(function (Buffer){\\n/**\\n * Implementation of the multicodec specification.\\n *\\n * @module multicodec\\n * @example\\n * const multicodec = require('multicodec')\\n *\\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\\n * // prefixedProtobuf 0x50...\\n *\\n */\\n'use strict'\\n\\nconst varint = require('varint')\\nconst intTable = require('./int-table')\\nconst codecNameToCodeVarint = require('./varint-table')\\nconst util = require('./util')\\n\\nexports = module.exports\\n\\n/**\\n * Prefix a buffer with a multicodec-packed.\\n *\\n * @param {string|number} multicodecStrOrCode\\n * @param {Buffer} data\\n * @returns {Buffer}\\n */\\nexports.addPrefix = (multicodecStrOrCode, data) => {\\n  let prefix\\n\\n  if (Buffer.isBuffer(multicodecStrOrCode)) {\\n    prefix = util.varintBufferEncode(multicodecStrOrCode)\\n  } else {\\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\\n      prefix = codecNameToCodeVarint[multicodecStrOrCode]\\n    } else {\\n      throw new Error('multicodec not recognized')\\n    }\\n  }\\n  return Buffer.concat([prefix, data])\\n}\\n\\n/**\\n * Decapsulate the multicodec-packed prefix from the data.\\n *\\n * @param {Buffer} data\\n * @returns {Buffer}\\n */\\nexports.rmPrefix = (data) => {\\n  varint.decode(data)\\n  return data.slice(varint.decode.bytes)\\n}\\n\\n/**\\n * Get the codec of the prefixed data.\\n * @param {Buffer} prefixedData\\n * @returns {string}\\n */\\nexports.getCodec = (prefixedData) => {\\n  const code = varint.decode(prefixedData)\\n  const codecName = intTable.get(code)\\n  if (codecName === undefined) {\\n    throw new Error(`Code ${code} not found`)\\n  }\\n  return codecName\\n}\\n\\n/**\\n * Get the name of the codec.\\n * @param {number} codec\\n * @returns {string}\\n */\\nexports.getName = (codec) => {\\n  return intTable.get(codec)\\n}\\n\\n/**\\n * Get the code of the codec\\n * @param {string} name\\n * @returns {number}\\n */\\nexports.getNumber = (name) => {\\n  const code = codecNameToCodeVarint[name]\\n  if (code === undefined) {\\n    throw new Error('Codec `' + name + '` not found')\\n  }\\n  return util.varintBufferDecode(code)[0]\\n}\\n\\n/**\\n * Get the code of the prefixed data.\\n * @param {Buffer} prefixedData\\n * @returns {number}\\n */\\nexports.getCode = (prefixedData) => {\\n  return varint.decode(prefixedData)\\n}\\n\\n/**\\n * Get the code as varint of a codec name.\\n * @param {string} codecName\\n * @returns {Buffer}\\n */\\nexports.getCodeVarint = (codecName) => {\\n  const code = codecNameToCodeVarint[codecName]\\n  if (code === undefined) {\\n    throw new Error('Codec `' + codecName + '` not found')\\n  }\\n  return code\\n}\\n\\n/**\\n * Get the varint of a code.\\n * @param {Number} code\\n * @returns {Array.<number>}\\n */\\nexports.getVarint = (code) => {\\n  return varint.encode(code)\\n}\\n\\n// Make the constants top-level constants\\nconst constants = require('./constants')\\nObject.assign(exports, constants)\\n\\n// Human friendly names for printing, e.g. in error messages\\nexports.print = require('./print')\\n\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"./constants\\\":13,\\\"./int-table\\\":15,\\\"./print\\\":16,\\\"./util\\\":17,\\\"./varint-table\\\":18,\\\"buffer\\\":8,\\\"varint\\\":57}],15:[function(require,module,exports){\\n'use strict'\\nconst baseTable = require('./base-table.json')\\n\\n// map for hexString -> codecName\\nconst nameTable = new Map()\\n\\nfor (const encodingName in baseTable) {\\n  const code = baseTable[encodingName]\\n  nameTable.set(code, encodingName)\\n}\\n\\nmodule.exports = Object.freeze(nameTable)\\n\\n},{\\\"./base-table.json\\\":12}],16:[function(require,module,exports){\\n'use strict'\\n\\nconst table = require('./base-table.json')\\n\\n// map for code -> print friendly name\\nconst tableByCode = {}\\n\\nfor (const [name, code] of Object.entries(table)) {\\n  if (tableByCode[code] === undefined) tableByCode[code] = name\\n}\\n\\nmodule.exports = Object.freeze(tableByCode)\\n\\n},{\\\"./base-table.json\\\":12}],17:[function(require,module,exports){\\n(function (Buffer){\\n'use strict'\\nconst varint = require('varint')\\n\\nmodule.exports = {\\n  numberToBuffer,\\n  bufferToNumber,\\n  varintBufferEncode,\\n  varintBufferDecode,\\n  varintEncode\\n}\\n\\nfunction bufferToNumber (buf) {\\n  return parseInt(buf.toString('hex'), 16)\\n}\\n\\nfunction numberToBuffer (num) {\\n  let hexString = num.toString(16)\\n  if (hexString.length % 2 === 1) {\\n    hexString = '0' + hexString\\n  }\\n  return Buffer.from(hexString, 'hex')\\n}\\n\\nfunction varintBufferEncode (input) {\\n  return Buffer.from(varint.encode(bufferToNumber(input)))\\n}\\n\\nfunction varintBufferDecode (input) {\\n  return numberToBuffer(varint.decode(input))\\n}\\n\\nfunction varintEncode (num) {\\n  return Buffer.from(varint.encode(num))\\n}\\n\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"buffer\\\":8,\\\"varint\\\":57}],18:[function(require,module,exports){\\n'use strict'\\n\\nconst baseTable = require('./base-table.json')\\nconst varintEncode = require('./util').varintEncode\\n\\n// map for codecName -> codeVarintBuffer\\nconst varintTable = {}\\n\\nfor (const encodingName in baseTable) {\\n  const code = baseTable[encodingName]\\n  varintTable[encodingName] = varintEncode(code)\\n}\\n\\nmodule.exports = Object.freeze(varintTable)\\n\\n},{\\\"./base-table.json\\\":12,\\\"./util\\\":17}],19:[function(require,module,exports){\\n/*\\r\\n\\tISC License\\r\\n\\r\\n\\tCopyright (c) 2019, Pierre-Louis Despaigne\\r\\n\\r\\n\\tPermission to use, copy, modify, and/or distribute this software for any\\r\\n\\tpurpose with or without fee is hereby granted, provided that the above\\r\\n\\tcopyright notice and this permission notice appear in all copies.\\r\\n\\r\\n\\tTHE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n\\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n\\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n\\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n\\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n\\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n\\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n*/\\r\\n\\r\\nconst CID = require('cids');\\r\\n\\r\\n/**\\r\\n * Take any ipfsHash and convert it to a CID v1 encoded in base32.\\r\\n * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)\\r\\n * @return {string} the resulting ipfs hash as a cid v1\\r\\n */\\r\\nconst cidV0ToV1Base32 = (ipfsHash) => {\\r\\n\\tlet cid = new CID(ipfsHash);\\r\\n\\tif (cid.version === 0) {\\r\\n\\t\\tcid = cid.toV1();\\r\\n\\t}\\r\\n\\treturn cid.toString('base32');\\r\\n}\\r\\n\\r\\nexports.cidV0ToV1Base32 = cidV0ToV1Base32;\\r\\n\\n},{\\\"cids\\\":10}],20:[function(require,module,exports){\\n/*\\r\\n\\tISC License\\r\\n\\r\\n\\tCopyright (c) 2019, Pierre-Louis Despaigne\\r\\n\\r\\n\\tPermission to use, copy, modify, and/or distribute this software for any\\r\\n\\tpurpose with or without fee is hereby granted, provided that the above\\r\\n\\tcopyright notice and this permission notice appear in all copies.\\r\\n\\r\\n\\tTHE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n\\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n\\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n\\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n\\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n\\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n\\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n*/\\r\\n\\r\\nconst multiC = require('multicodec');\\r\\n\\r\\nconst { hexStringToBuffer, profiles } = require('./profiles');\\r\\nconst { cidV0ToV1Base32 } = require('./helpers');\\r\\n\\r\\nmodule.exports = {\\r\\n\\r\\n\\t//export some helpers functions\\r\\n\\thelpers: {\\r\\n\\t\\tcidV0ToV1Base32,\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t* Decode a Content Hash.\\r\\n\\t* @param {string} hash an hex string containing a content hash\\r\\n\\t* @return {string} the decoded content\\r\\n\\t*/\\r\\n\\tdecode: function (contentHash) {\\r\\n\\t\\tconst buffer = hexStringToBuffer(contentHash);\\r\\n\\t\\tconst codec = multiC.getCodec(buffer);\\r\\n\\t\\tconst value = multiC.rmPrefix(buffer);\\r\\n\\t\\tlet profile = profiles[codec];\\r\\n\\t\\tif (!profile) profile = profiles['default'];\\r\\n\\t\\treturn profile.decode(value);\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t* Encode an IPFS address into a content hash\\r\\n\\t* @param {string} ipfsHash string containing an IPFS address\\r\\n\\t* @return {string} the resulting content hash\\r\\n\\t*/\\r\\n\\tfromIpfs: function (ipfsHash) {\\r\\n\\t\\treturn this.encode('ipfs-ns', ipfsHash);\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t* Encode a Swarm address into a content hash\\r\\n\\t* @param {string} swarmHash string containing a Swarm address\\r\\n\\t* @return {string} the resulting content hash\\r\\n\\t*/\\r\\n\\tfromSwarm: function (swarmHash) {\\r\\n\\t\\treturn this.encode('swarm-ns', swarmHash);\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t* General purpose encoding function\\r\\n  * @param {string} codec \\r\\n  * @param {string} value \\r\\n  */\\r\\n\\tencode: function (codec, value) {\\r\\n\\t\\tlet profile = profiles[codec];\\r\\n\\t\\tif (!profile) profile = profiles['default'];\\r\\n\\t\\tconst encodedValue = profile.encode(value);\\r\\n\\t\\treturn multiC.addPrefix(codec, encodedValue).toString('hex');\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t* Extract the codec of a content hash\\r\\n\\t* @param {string} hash hex string containing a content hash\\r\\n\\t* @return {string} the extracted codec\\r\\n\\t*/\\r\\n\\tgetCodec: function (hash) {\\r\\n\\t\\tlet buffer = hexStringToBuffer(hash);\\r\\n\\t\\treturn multiC.getCodec(buffer);\\r\\n\\t},\\r\\n}\\r\\n\\n},{\\\"./helpers\\\":19,\\\"./profiles\\\":21,\\\"multicodec\\\":14}],21:[function(require,module,exports){\\n(function (Buffer){\\n/*\\r\\n\\tISC License\\r\\n\\r\\n\\tCopyright (c) 2019, Pierre-Louis Despaigne\\r\\n\\r\\n\\tPermission to use, copy, modify, and/or distribute this software for any\\r\\n\\tpurpose with or without fee is hereby granted, provided that the above\\r\\n\\tcopyright notice and this permission notice appear in all copies.\\r\\n\\r\\n\\tTHE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n\\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n\\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n\\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n\\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n\\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n\\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n*/\\r\\n\\r\\nconst CID = require('cids');\\r\\nconst multiH = require('multihashes');\\r\\n\\r\\n/**\\r\\n * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'\\r\\n * @param {string} hex an hexadecimal value\\r\\n * @return {Buffer} the resulting Buffer\\r\\n */\\r\\nconst hexStringToBuffer = (hex) => {\\r\\n\\tlet prefix = hex.slice(0, 2);\\r\\n\\tlet value = hex.slice(2);\\r\\n\\tlet res = '';\\r\\n\\tif (prefix === '0x') res = value;\\r\\n\\telse res = hex;\\r\\n\\treturn multiH.fromHexString(res);\\r\\n}\\r\\n\\r\\n/**\\r\\n* list of known encoding,\\r\\n* encoding should be a function that takes a `string` input,\\r\\n* and return a `Buffer` result\\r\\n*/\\r\\nconst encodes = {\\r\\n  /**\\r\\n  * @param {string} value\\r\\n  * @return {Buffer}\\r\\n  */\\r\\n  swarm: (value) => {\\r\\n    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');\\r\\n\\t\\treturn new CID(1, 'swarm-manifest', multihash).buffer;\\r\\n  },\\r\\n  /**\\r\\n  * @param {string} value\\r\\n  * @return {Buffer}\\r\\n  */\\r\\n  ipfs: (value) => {\\r\\n    const multihash = multiH.fromB58String(value);\\r\\n    return new CID(1, 'dag-pb', multihash).buffer;\\r\\n  },\\r\\n  /**\\r\\n  * @param {string} value\\r\\n  * @return {Buffer}\\r\\n  */\\r\\n  utf8: (value) => {\\r\\n    return Buffer.from(value, 'utf8');\\r\\n  },\\r\\n};\\r\\n\\r\\n/** \\r\\n* list of known decoding,\\r\\n* decoding should be a function that takes a `Buffer` input,\\r\\n* and return a `string` result\\r\\n*/\\r\\nconst decodes = {\\r\\n  /**\\r\\n  * @param {Buffer} value \\r\\n  */\\r\\n  hexMultiHash: (value) => {\\r\\n    const cid = new CID(value);\\r\\n    return multiH.decode(cid.multihash).digest.toString('hex');\\r\\n  },\\r\\n  /**\\r\\n  * @param {Buffer} value \\r\\n  */\\r\\n  b58MultiHash: (value) => {\\r\\n    const cid = new CID(value);\\r\\n    return multiH.toB58String(cid.multihash);\\r\\n  },\\r\\n  /**\\r\\n  * @param {Buffer} value \\r\\n  */\\r\\n  utf8: (value) => {\\r\\n    return value.toString('utf8');\\r\\n  },\\r\\n};\\r\\n\\r\\n/**\\r\\n* list of known encoding/decoding for a given codec,\\r\\n* `encode` should be chosen among the `encodes` functions\\r\\n* `decode` should be chosen among the `decodes` functions\\r\\n*/\\r\\nconst profiles = {\\r\\n  'swarm-ns': {\\r\\n    encode: encodes.swarm,\\r\\n    decode: decodes.hexMultiHash,\\r\\n  },\\r\\n  'ipfs-ns': {\\r\\n    encode: encodes.ipfs,\\r\\n    decode: decodes.b58MultiHash,\\r\\n  },\\r\\n  'ipns-ns': {\\r\\n    encode: encodes.ipfs,\\r\\n    decode: decodes.b58MultiHash,\\r\\n  },\\r\\n  'default': {\\r\\n    encode: encodes.utf8,\\r\\n    decode: decodes.utf8,\\r\\n  },\\r\\n};\\r\\n\\r\\nexports.hexStringToBuffer = hexStringToBuffer;\\r\\nexports.profiles = profiles;\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"buffer\\\":8,\\\"cids\\\":10,\\\"multihashes\\\":51}],22:[function(require,module,exports){\\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\\n  var e, m\\n  var eLen = (nBytes * 8) - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var nBits = -7\\n  var i = isLE ? (nBytes - 1) : 0\\n  var d = isLE ? -1 : 1\\n  var s = buffer[offset + i]\\n\\n  i += d\\n\\n  e = s & ((1 << (-nBits)) - 1)\\n  s >>= (-nBits)\\n  nBits += eLen\\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  m = e & ((1 << (-nBits)) - 1)\\n  e >>= (-nBits)\\n  nBits += mLen\\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  if (e === 0) {\\n    e = 1 - eBias\\n  } else if (e === eMax) {\\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\\n  } else {\\n    m = m + Math.pow(2, mLen)\\n    e = e - eBias\\n  }\\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\\n}\\n\\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\\n  var e, m, c\\n  var eLen = (nBytes * 8) - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\\n  var i = isLE ? 0 : (nBytes - 1)\\n  var d = isLE ? 1 : -1\\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\\n\\n  value = Math.abs(value)\\n\\n  if (isNaN(value) || value === Infinity) {\\n    m = isNaN(value) ? 1 : 0\\n    e = eMax\\n  } else {\\n    e = Math.floor(Math.log(value) / Math.LN2)\\n    if (value * (c = Math.pow(2, -e)) < 1) {\\n      e--\\n      c *= 2\\n    }\\n    if (e + eBias >= 1) {\\n      value += rt / c\\n    } else {\\n      value += rt * Math.pow(2, 1 - eBias)\\n    }\\n    if (value * c >= 2) {\\n      e++\\n      c /= 2\\n    }\\n\\n    if (e + eBias >= eMax) {\\n      m = 0\\n      e = eMax\\n    } else if (e + eBias >= 1) {\\n      m = ((value * c) - 1) * Math.pow(2, mLen)\\n      e = e + eBias\\n    } else {\\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\\n      e = 0\\n    }\\n  }\\n\\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\\n\\n  e = (e << mLen) | m\\n  eLen += mLen\\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\\n\\n  buffer[offset + i - d] |= s * 128\\n}\\n\\n},{}],23:[function(require,module,exports){\\n'use strict'\\n\\nmodule.exports = {\\n  httpClient: 'httpClient',\\n  windowIpfs: 'windowIpfs',\\n  jsIpfs: 'jsIpfs',\\n  webExt: 'webExt'\\n}\\n\\n},{}],24:[function(require,module,exports){\\n'use strict'\\n\\nconst root = require('window-or-global')\\nconst mergeOptions = require('merge-options')\\n\\nconst tryWebExt = require('./providers/webext')\\nconst tryWindow = require('./providers/window-ipfs')\\nconst tryHttpClient = require('./providers/http-client')\\nconst tryJsIpfs = require('./providers/js-ipfs')\\n\\nconst defaultGlobalOpts = {\\n  connectionTest: (ipfs) => {\\n    // ipfs connection is working if can we fetch the empty directtory.\\n    return ipfs.get('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\\n  }\\n}\\n\\nconst makeProvider = (fn, defaults = {}) => {\\n  return (options = {}) => {\\n    return (globalOpts) => {\\n      options = mergeOptions(defaultGlobalOpts, defaults, globalOpts, options)\\n      return fn(options)\\n    }\\n  }\\n}\\n\\nconst providers = {\\n  httpClient: makeProvider((options) => {\\n    const { location } = root\\n    return tryHttpClient({ httpClient, location, ...options })\\n  }, {\\n    defaultApiAddress: '/ip4/127.0.0.1/tcp/5001',\\n    apiAddress: null\\n  }),\\n  windowIpfs: makeProvider(options => {\\n    return tryWindow({ root, ...options })\\n  }),\\n  jsIpfs: makeProvider(options => {\\n    return tryJsIpfs(options)\\n  }),\\n  webExt: makeProvider(options => {\\n    return tryWebExt({ root, ...options })\\n  })\\n}\\n\\nconst defaultProviders = [\\n  providers.windowIpfs(),\\n  providers.httpClient()\\n]\\n\\nasync function getIpfs ({ providers = defaultProviders, ...options } = {}) {\\n  for (const provider of providers) {\\n    try {\\n      const res = await provider(options)\\n      if (res) return res\\n    } catch (_) {\\n      // provider failed, move to the next one\\n    }\\n  }\\n}\\n\\nmodule.exports = {\\n  getIpfs,\\n  providers,\\n  makeProvider\\n}\\n},{\\\"./providers/http-client\\\":25,\\\"./providers/js-ipfs\\\":26,\\\"./providers/webext\\\":27,\\\"./providers/window-ipfs\\\":28,\\\"merge-options\\\":30,\\\"window-or-global\\\":59}],25:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\n// 1. Try user specified API address\\n// 2. Try current origin\\n// 3. Try multiaddr from defaultApiAddress\\nasync function tryHttpClient ({ httpClient, apiAddress, defaultApiAddress, location, connectionTest }) {\\n  // Explicit custom apiAddress provided. Only try that.\\n  if (apiAddress) {\\n    return maybeApi({ apiAddress, connectionTest, httpClient })\\n  }\\n\\n  // Current origin is not localhost:5001 so try with current origin info\\n  if (location && !(location.port === '5001' && location.hostname.match(/^127.0.0.1$|^localhost$/))) {\\n    const origin = new URL(location.origin)\\n    origin.pathname = '/'\\n    const res = await maybeApi({\\n      apiAddress: origin.toString(),\\n      connectionTest,\\n      httpClient\\n    })\\n    if (res) return res\\n  }\\n\\n  // ...otherwise try /ip4/127.0.0.1/tcp/5001\\n  return maybeApi({ apiAddress: defaultApiAddress, connectionTest, httpClient })\\n}\\n\\n// Helper to construct and test an api client. Returns an js-ipfs-api instance or null\\nasync function maybeApi ({ apiAddress, connectionTest, httpClient }) {\\n  try {\\n    const ipfs = httpClient(apiAddress)\\n    await connectionTest(ipfs)\\n    return { ipfs, provider: PROVIDERS.httpClient, apiAddress }\\n  } catch (error) {\\n    // Failed to connect to ipfs-api in `apiAddress`\\n  }\\n}\\n\\nmodule.exports = tryHttpClient\\n\\n},{\\\"../constants/providers\\\":23}],26:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nfunction promiseMeJsIpfs (Ipfs, opts) {\\n  // Allow the use of `import` or `require` on `getJsIpfs` fn\\n  Ipfs = Ipfs.default || Ipfs\\n  return new Promise((resolve, reject) => {\\n    const ipfs = new Ipfs(opts)\\n    ipfs.once('ready', () => resolve(ipfs))\\n    ipfs.once('error', err => reject(err))\\n  })\\n}\\n\\nasync function tryJsIpfs ({ connectionTest, getConstructor, options, init = promiseMeJsIpfs }) {\\n  const Ipfs = await getConstructor()\\n  const ipfs = await init(Ipfs, options)\\n  await connectionTest(ipfs)\\n  return { ipfs, provider: PROVIDERS.jsIpfs }\\n}\\n\\nmodule.exports = tryJsIpfs\\n\\n},{\\\"../constants/providers\\\":23}],27:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function tryWebExt ({ root, connectionTest }) {\\n  // Opportunistic optimizations when running inside of web extension (eg. ipfs-companion)\\n  if (typeof root.chrome === 'object' && root.chrome.extension && root.chrome.extension.getBackgroundPage) {\\n    // Note: under some vendors getBackgroundPage() will return null if window is in incognito mode\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1329304\\n    let bg = null\\n    try {\\n      bg = root.chrome.extension.getBackgroundPage()\\n    } catch (err) {\\n      // not in browser extension\\n      return null\\n    }\\n    // If extension is exposing IPFS API as `ipfs` on the background page\\n    // it can be used directly for the best performance\\n    if (bg && bg.ipfs) {\\n      const { ipfs } = bg\\n      await connectionTest(ipfs)\\n      return { ipfs, provider: PROVIDERS.webExt }\\n    }\\n    /*  Other endpoints can be added here in the future.\\n        For example, Companion could provide API for other browser extensions:\\n        https://github.com/ipfs-shipyard/ipfs-companion/issues/307 */\\n  }\\n}\\n\\nmodule.exports = tryWebExt\\n\\n},{\\\"../constants/providers\\\":23}],28:[function(require,module,exports){\\n'use strict'\\n\\nconst PROVIDERS = require('../constants/providers')\\n\\nasync function tryWindow ({ root, permissions, connectionTest }) {\\n  if (root.ipfs) {\\n    // files.get is required for testing if API works, ensure we request it\\n    if (!(permissions && permissions.commands && permissions.commands.includes('files.get'))) {\\n      permissions = permissions || {}\\n      permissions = JSON.parse(JSON.stringify(permissions)) // deep copy to work with freezed objects\\n      permissions.commands = permissions.commands || []\\n      permissions.commands.push('files.get')\\n    }\\n    // try window.ipfs.enable first: https://github.com/ipfs-shipyard/ipfs-companion/issues/589\\n    const ipfs = typeof root.ipfs.enable === 'function'\\n      ? await root.ipfs.enable(permissions)\\n      : root.ipfs\\n    await connectionTest(ipfs)\\n    return { ipfs, provider: PROVIDERS.windowIpfs }\\n  }\\n}\\n\\nmodule.exports = tryWindow\\n\\n},{\\\"../constants/providers\\\":23}],29:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = value => {\\n\\tif (Object.prototype.toString.call(value) !== '[object Object]') {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tconst prototype = Object.getPrototypeOf(value);\\n\\treturn prototype === null || prototype === Object.prototype;\\n};\\n\\n},{}],30:[function(require,module,exports){\\n'use strict';\\nconst isOptionObject = require('is-plain-obj');\\n\\nconst {hasOwnProperty} = Object.prototype;\\nconst {propertyIsEnumerable} = Object;\\nconst defineProperty = (obj, name, value) => Object.defineProperty(obj, name, {\\n\\tvalue,\\n\\twritable: true,\\n\\tenumerable: true,\\n\\tconfigurable: true\\n});\\n\\nconst globalThis = this;\\nconst defaultMergeOpts = {\\n\\tconcatArrays: false,\\n\\tignoreUndefined: false\\n};\\n\\nconst getEnumerableOwnPropertyKeys = value => {\\n\\tconst keys = [];\\n\\n\\tfor (const key in value) {\\n\\t\\tif (hasOwnProperty.call(value, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\n\\t/* istanbul ignore else  */\\n\\tif (Object.getOwnPropertySymbols) {\\n\\t\\tconst symbols = Object.getOwnPropertySymbols(value);\\n\\n\\t\\tfor (const symbol of symbols) {\\n\\t\\t\\tif (propertyIsEnumerable.call(value, symbol)) {\\n\\t\\t\\t\\tkeys.push(symbol);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn keys;\\n};\\n\\nfunction clone(value) {\\n\\tif (Array.isArray(value)) {\\n\\t\\treturn cloneArray(value);\\n\\t}\\n\\n\\tif (isOptionObject(value)) {\\n\\t\\treturn cloneOptionObject(value);\\n\\t}\\n\\n\\treturn value;\\n}\\n\\nfunction cloneArray(array) {\\n\\tconst result = array.slice(0, 0);\\n\\n\\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\\n\\t\\tdefineProperty(result, key, clone(array[key]));\\n\\t});\\n\\n\\treturn result;\\n}\\n\\nfunction cloneOptionObject(obj) {\\n\\tconst result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};\\n\\n\\tgetEnumerableOwnPropertyKeys(obj).forEach(key => {\\n\\t\\tdefineProperty(result, key, clone(obj[key]));\\n\\t});\\n\\n\\treturn result;\\n}\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {string[]} keys keys to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n */\\nconst mergeKeys = (merged, source, keys, config) => {\\n\\tkeys.forEach(key => {\\n\\t\\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Do not recurse into prototype chain of merged\\n\\t\\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\\n\\t\\t\\tdefineProperty(merged, key, merge(merged[key], source[key], config));\\n\\t\\t} else {\\n\\t\\t\\tdefineProperty(merged, key, clone(source[key]));\\n\\t\\t}\\n\\t});\\n\\n\\treturn merged;\\n};\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n *\\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\\n */\\nconst concatArrays = (merged, source, config) => {\\n\\tlet result = merged.slice(0, 0);\\n\\tlet resultIndex = 0;\\n\\n\\t[merged, source].forEach(array => {\\n\\t\\tconst indices = [];\\n\\n\\t\\t// `result.concat(array)` with cloning\\n\\t\\tfor (let k = 0; k < array.length; k++) {\\n\\t\\t\\tif (!hasOwnProperty.call(array, k)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tindices.push(String(k));\\n\\n\\t\\t\\tif (array === merged) {\\n\\t\\t\\t\\t// Already cloned\\n\\t\\t\\t\\tdefineProperty(result, resultIndex++, array[k]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdefineProperty(result, resultIndex++, clone(array[k]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Merge non-index keys\\n\\t\\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\\n\\t});\\n\\n\\treturn result;\\n};\\n\\n/**\\n * @param {*} merged already cloned\\n * @param {*} source something to merge\\n * @param {Object} config Config Object\\n * @returns {*} cloned Object\\n */\\nfunction merge(merged, source, config) {\\n\\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\\n\\t\\treturn concatArrays(merged, source, config);\\n\\t}\\n\\n\\tif (!isOptionObject(source) || !isOptionObject(merged)) {\\n\\t\\treturn clone(source);\\n\\t}\\n\\n\\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\\n}\\n\\nmodule.exports = function (...options) {\\n\\tconst config = merge(clone(defaultMergeOpts), (this !== globalThis && this) || {}, defaultMergeOpts);\\n\\tlet merged = {_: {}};\\n\\n\\tfor (const option of options) {\\n\\t\\tif (option === undefined) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!isOptionObject(option)) {\\n\\t\\t\\tthrow new TypeError('`' + option + '` is not an Option Object');\\n\\t\\t}\\n\\n\\t\\tmerged = merge(merged, {_: option}, config);\\n\\t}\\n\\n\\treturn merged._;\\n};\\n\\n},{\\\"is-plain-obj\\\":29}],31:[function(require,module,exports){\\n'use strict'\\n\\nclass Base {\\n  constructor (name, code, implementation, alphabet) {\\n    this.name = name\\n    this.code = code\\n    this.alphabet = alphabet\\n    if (implementation && alphabet) {\\n      this.engine = implementation(alphabet)\\n    }\\n  }\\n\\n  encode (stringOrBuffer) {\\n    return this.engine.encode(stringOrBuffer)\\n  }\\n\\n  decode (stringOrBuffer) {\\n    return this.engine.decode(stringOrBuffer)\\n  }\\n\\n  isImplemented () {\\n    return this.engine\\n  }\\n}\\n\\nmodule.exports = Base\\n\\n},{}],32:[function(require,module,exports){\\n'use strict'\\nconst { Buffer } = require('buffer')\\n\\nmodule.exports = function base16 (alphabet) {\\n  return {\\n    encode (input) {\\n      if (typeof input === 'string') {\\n        return Buffer.from(input).toString('hex')\\n      }\\n      return input.toString('hex')\\n    },\\n    decode (input) {\\n      for (const char of input) {\\n        if (alphabet.indexOf(char) < 0) {\\n          throw new Error('invalid base16 character')\\n        }\\n      }\\n      return Buffer.from(input, 'hex')\\n    }\\n  }\\n}\\n\\n},{\\\"buffer\\\":8}],33:[function(require,module,exports){\\n'use strict'\\n\\nfunction decode (input, alphabet) {\\n  input = input.replace(new RegExp('=', 'g'), '')\\n  const length = input.length\\n\\n  let bits = 0\\n  let value = 0\\n\\n  let index = 0\\n  const output = new Uint8Array((length * 5 / 8) | 0)\\n\\n  for (let i = 0; i < length; i++) {\\n    value = (value << 5) | alphabet.indexOf(input[i])\\n    bits += 5\\n\\n    if (bits >= 8) {\\n      output[index++] = (value >>> (bits - 8)) & 255\\n      bits -= 8\\n    }\\n  }\\n\\n  return output.buffer\\n}\\n\\nfunction encode (buffer, alphabet) {\\n  const length = buffer.byteLength\\n  const view = new Uint8Array(buffer)\\n  const padding = alphabet.indexOf('=') === alphabet.length - 1\\n\\n  if (padding) {\\n    alphabet = alphabet.substring(0, alphabet.length - 1)\\n  }\\n\\n  let bits = 0\\n  let value = 0\\n  let output = ''\\n\\n  for (let i = 0; i < length; i++) {\\n    value = (value << 8) | view[i]\\n    bits += 8\\n\\n    while (bits >= 5) {\\n      output += alphabet[(value >>> (bits - 5)) & 31]\\n      bits -= 5\\n    }\\n  }\\n\\n  if (bits > 0) {\\n    output += alphabet[(value << (5 - bits)) & 31]\\n  }\\n\\n  if (padding) {\\n    while ((output.length % 8) !== 0) {\\n      output += '='\\n    }\\n  }\\n\\n  return output\\n}\\n\\nmodule.exports = function base32 (alphabet) {\\n  return {\\n    encode (input) {\\n      if (typeof input === 'string') {\\n        return encode(Uint8Array.from(input), alphabet)\\n      }\\n\\n      return encode(input, alphabet)\\n    },\\n    decode (input) {\\n      for (const char of input) {\\n        if (alphabet.indexOf(char) < 0) {\\n          throw new Error('invalid base32 character')\\n        }\\n      }\\n\\n      return decode(input, alphabet)\\n    }\\n  }\\n}\\n\\n},{}],34:[function(require,module,exports){\\n'use strict'\\nconst { Buffer } = require('buffer')\\n\\nmodule.exports = function base64 (alphabet) {\\n  // The alphabet is only used to know:\\n  //   1. If padding is enabled (must contain '=')\\n  //   2. If the output must be url-safe (must contain '-' and '_')\\n  //   3. If the input of the output function is valid\\n  // The alphabets from RFC 4648 are always used.\\n  const padding = alphabet.indexOf('=') > -1\\n  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1\\n\\n  return {\\n    encode (input) {\\n      let output = ''\\n\\n      if (typeof input === 'string') {\\n        output = Buffer.from(input).toString('base64')\\n      } else {\\n        output = input.toString('base64')\\n      }\\n\\n      if (url) {\\n        output = output.replace(/\\\\+/g, '-').replace(/\\\\//g, '_')\\n      }\\n\\n      const pad = output.indexOf('=')\\n      if (pad > 0 && !padding) {\\n        output = output.substring(0, pad)\\n      }\\n\\n      return output\\n    },\\n    decode (input) {\\n      for (const char of input) {\\n        if (alphabet.indexOf(char) < 0) {\\n          throw new Error('invalid base64 character')\\n        }\\n      }\\n\\n      return Buffer.from(input, 'base64')\\n    }\\n  }\\n}\\n\\n},{\\\"buffer\\\":8}],35:[function(require,module,exports){\\n'use strict'\\n\\nconst Base = require('./base.js')\\nconst baseX = require('base-x')\\nconst base16 = require('./base16')\\nconst base32 = require('./base32')\\nconst base64 = require('./base64')\\n\\n// name, code, implementation, alphabet\\nconst constants = [\\n  ['base1', '1', '', '1'],\\n  ['base2', '0', baseX, '01'],\\n  ['base8', '7', baseX, '01234567'],\\n  ['base10', '9', baseX, '0123456789'],\\n  ['base16', 'f', base16, '0123456789abcdef'],\\n  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],\\n  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],\\n  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],\\n  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],\\n  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],\\n  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],\\n  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],\\n  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],\\n  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],\\n  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],\\n  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']\\n]\\n\\nconst names = constants.reduce((prev, tupple) => {\\n  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])\\n  return prev\\n}, {})\\n\\nconst codes = constants.reduce((prev, tupple) => {\\n  prev[tupple[1]] = names[tupple[0]]\\n  return prev\\n}, {})\\n\\nmodule.exports = {\\n  names: names,\\n  codes: codes\\n}\\n\\n},{\\\"./base.js\\\":31,\\\"./base16\\\":32,\\\"./base32\\\":33,\\\"./base64\\\":34,\\\"base-x\\\":6}],36:[function(require,module,exports){\\n/**\\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\\n * @module Multibase\\n */\\n'use strict'\\n\\nconst { Buffer } = require('buffer')\\nconst constants = require('./constants')\\n\\nexports = module.exports = multibase\\nexports.encode = encode\\nexports.decode = decode\\nexports.isEncoded = isEncoded\\nexports.names = Object.freeze(Object.keys(constants.names))\\nexports.codes = Object.freeze(Object.keys(constants.codes))\\n\\nconst errNotSupported = new Error('Unsupported encoding')\\n\\n/**\\n * Create a new buffer with the multibase varint+code.\\n *\\n * @param {string|number} nameOrCode - The multibase name or code number.\\n * @param {Buffer} buf - The data to be prefixed with multibase.\\n * @memberof Multibase\\n * @returns {Buffer}\\n */\\nfunction multibase (nameOrCode, buf) {\\n  if (!buf) {\\n    throw new Error('requires an encoded buffer')\\n  }\\n  const base = getBase(nameOrCode)\\n  const codeBuf = Buffer.from(base.code)\\n\\n  const name = base.name\\n  validEncode(name, buf)\\n  return Buffer.concat([codeBuf, buf])\\n}\\n\\n/**\\n * Encode data with the specified base and add the multibase prefix.\\n *\\n * @param {string|number} nameOrCode - The multibase name or code number.\\n * @param {Buffer} buf - The data to be encoded.\\n * @returns {Buffer}\\n * @memberof Multibase\\n */\\nfunction encode (nameOrCode, buf) {\\n  const base = getBase(nameOrCode)\\n  const name = base.name\\n\\n  return multibase(name, Buffer.from(base.encode(buf)))\\n}\\n\\n/**\\n * Takes a buffer or string encoded with multibase header, decodes it and\\n * returns the decoded buffer\\n *\\n * @param {Buffer|string} bufOrString\\n * @returns {Buffer}\\n * @memberof Multibase\\n *\\n */\\nfunction decode (bufOrString) {\\n  if (Buffer.isBuffer(bufOrString)) {\\n    bufOrString = bufOrString.toString()\\n  }\\n\\n  const code = bufOrString.substring(0, 1)\\n  bufOrString = bufOrString.substring(1, bufOrString.length)\\n\\n  if (typeof bufOrString === 'string') {\\n    bufOrString = Buffer.from(bufOrString)\\n  }\\n\\n  const base = getBase(code)\\n  return Buffer.from(base.decode(bufOrString.toString()))\\n}\\n\\n/**\\n * Is the given data multibase encoded?\\n *\\n * @param {Buffer|string} bufOrString\\n * @returns {boolean}\\n * @memberof Multibase\\n */\\nfunction isEncoded (bufOrString) {\\n  if (Buffer.isBuffer(bufOrString)) {\\n    bufOrString = bufOrString.toString()\\n  }\\n\\n  // Ensure bufOrString is a string\\n  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {\\n    return false\\n  }\\n\\n  const code = bufOrString.substring(0, 1)\\n  try {\\n    const base = getBase(code)\\n    return base.name\\n  } catch (err) {\\n    return false\\n  }\\n}\\n\\n/**\\n * @param {string} name\\n * @param {Buffer} buf\\n * @private\\n * @returns {undefined}\\n */\\nfunction validEncode (name, buf) {\\n  const base = getBase(name)\\n  base.decode(buf.toString())\\n}\\n\\nfunction getBase (nameOrCode) {\\n  let base\\n\\n  if (constants.names[nameOrCode]) {\\n    base = constants.names[nameOrCode]\\n  } else if (constants.codes[nameOrCode]) {\\n    base = constants.codes[nameOrCode]\\n  } else {\\n    throw errNotSupported\\n  }\\n\\n  if (!base.isImplemented()) {\\n    throw new Error('Base ' + nameOrCode + ' is not implemented yet')\\n  }\\n\\n  return base\\n}\\n\\n},{\\\"./constants\\\":35,\\\"buffer\\\":8}],37:[function(require,module,exports){\\narguments[4][12][0].apply(exports,arguments)\\n},{\\\"dup\\\":12}],38:[function(require,module,exports){\\narguments[4][13][0].apply(exports,arguments)\\n},{\\\"./base-table.json\\\":37,\\\"dup\\\":13}],39:[function(require,module,exports){\\n/**\\n * Implementation of the multicodec specification.\\n *\\n * @module multicodec\\n * @example\\n * const multicodec = require('multicodec')\\n *\\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\\n * // prefixedProtobuf 0x50...\\n *\\n */\\n'use strict'\\n\\nconst { Buffer } = require('buffer')\\nconst varint = require('varint')\\nconst intTable = require('./int-table')\\nconst codecNameToCodeVarint = require('./varint-table')\\nconst util = require('./util')\\n\\nexports = module.exports\\n\\n/**\\n * Prefix a buffer with a multicodec-packed.\\n *\\n * @param {string|number} multicodecStrOrCode\\n * @param {Buffer} data\\n * @returns {Buffer}\\n */\\nexports.addPrefix = (multicodecStrOrCode, data) => {\\n  let prefix\\n\\n  if (Buffer.isBuffer(multicodecStrOrCode)) {\\n    prefix = util.varintBufferEncode(multicodecStrOrCode)\\n  } else {\\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\\n      prefix = codecNameToCodeVarint[multicodecStrOrCode]\\n    } else {\\n      throw new Error('multicodec not recognized')\\n    }\\n  }\\n  return Buffer.concat([prefix, data])\\n}\\n\\n/**\\n * Decapsulate the multicodec-packed prefix from the data.\\n *\\n * @param {Buffer} data\\n * @returns {Buffer}\\n */\\nexports.rmPrefix = (data) => {\\n  varint.decode(data)\\n  return data.slice(varint.decode.bytes)\\n}\\n\\n/**\\n * Get the codec of the prefixed data.\\n * @param {Buffer} prefixedData\\n * @returns {string}\\n */\\nexports.getCodec = (prefixedData) => {\\n  const code = varint.decode(prefixedData)\\n  const codecName = intTable.get(code)\\n  if (codecName === undefined) {\\n    throw new Error(`Code ${code} not found`)\\n  }\\n  return codecName\\n}\\n\\n/**\\n * Get the name of the codec.\\n * @param {number} codec\\n * @returns {string}\\n */\\nexports.getName = (codec) => {\\n  return intTable.get(codec)\\n}\\n\\n/**\\n * Get the code of the codec\\n * @param {string} name\\n * @returns {number}\\n */\\nexports.getNumber = (name) => {\\n  const code = codecNameToCodeVarint[name]\\n  if (code === undefined) {\\n    throw new Error('Codec `' + name + '` not found')\\n  }\\n  return util.varintBufferDecode(code)[0]\\n}\\n\\n/**\\n * Get the code of the prefixed data.\\n * @param {Buffer} prefixedData\\n * @returns {number}\\n */\\nexports.getCode = (prefixedData) => {\\n  return varint.decode(prefixedData)\\n}\\n\\n/**\\n * Get the code as varint of a codec name.\\n * @param {string} codecName\\n * @returns {Buffer}\\n */\\nexports.getCodeVarint = (codecName) => {\\n  const code = codecNameToCodeVarint[codecName]\\n  if (code === undefined) {\\n    throw new Error('Codec `' + codecName + '` not found')\\n  }\\n  return code\\n}\\n\\n/**\\n * Get the varint of a code.\\n * @param {Number} code\\n * @returns {Array.<number>}\\n */\\nexports.getVarint = (code) => {\\n  return varint.encode(code)\\n}\\n\\n// Make the constants top-level constants\\nconst constants = require('./constants')\\nObject.assign(exports, constants)\\n\\n// Human friendly names for printing, e.g. in error messages\\nexports.print = require('./print')\\n\\n},{\\\"./constants\\\":38,\\\"./int-table\\\":40,\\\"./print\\\":41,\\\"./util\\\":42,\\\"./varint-table\\\":43,\\\"buffer\\\":8,\\\"varint\\\":57}],40:[function(require,module,exports){\\narguments[4][15][0].apply(exports,arguments)\\n},{\\\"./base-table.json\\\":37,\\\"dup\\\":15}],41:[function(require,module,exports){\\narguments[4][16][0].apply(exports,arguments)\\n},{\\\"./base-table.json\\\":37,\\\"dup\\\":16}],42:[function(require,module,exports){\\n'use strict'\\nconst varint = require('varint')\\nconst { Buffer } = require('buffer')\\n\\nmodule.exports = {\\n  numberToBuffer,\\n  bufferToNumber,\\n  varintBufferEncode,\\n  varintBufferDecode,\\n  varintEncode\\n}\\n\\nfunction bufferToNumber (buf) {\\n  return parseInt(buf.toString('hex'), 16)\\n}\\n\\nfunction numberToBuffer (num) {\\n  let hexString = num.toString(16)\\n  if (hexString.length % 2 === 1) {\\n    hexString = '0' + hexString\\n  }\\n  return Buffer.from(hexString, 'hex')\\n}\\n\\nfunction varintBufferEncode (input) {\\n  return Buffer.from(varint.encode(bufferToNumber(input)))\\n}\\n\\nfunction varintBufferDecode (input) {\\n  return numberToBuffer(varint.decode(input))\\n}\\n\\nfunction varintEncode (num) {\\n  return Buffer.from(varint.encode(num))\\n}\\n\\n},{\\\"buffer\\\":8,\\\"varint\\\":57}],43:[function(require,module,exports){\\narguments[4][18][0].apply(exports,arguments)\\n},{\\\"./base-table.json\\\":37,\\\"./util\\\":42,\\\"dup\\\":18}],44:[function(require,module,exports){\\narguments[4][31][0].apply(exports,arguments)\\n},{\\\"dup\\\":31}],45:[function(require,module,exports){\\narguments[4][32][0].apply(exports,arguments)\\n},{\\\"buffer\\\":8,\\\"dup\\\":32}],46:[function(require,module,exports){\\narguments[4][33][0].apply(exports,arguments)\\n},{\\\"dup\\\":33}],47:[function(require,module,exports){\\narguments[4][34][0].apply(exports,arguments)\\n},{\\\"buffer\\\":8,\\\"dup\\\":34}],48:[function(require,module,exports){\\narguments[4][35][0].apply(exports,arguments)\\n},{\\\"./base.js\\\":44,\\\"./base16\\\":45,\\\"./base32\\\":46,\\\"./base64\\\":47,\\\"base-x\\\":6,\\\"dup\\\":35}],49:[function(require,module,exports){\\n/**\\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\\n * @module Multibase\\n */\\n'use strict'\\n\\nconst { Buffer } = require('buffer')\\nconst constants = require('./constants')\\n\\nexports = module.exports = multibase\\nexports.encode = encode\\nexports.decode = decode\\nexports.isEncoded = isEncoded\\nexports.names = Object.freeze(Object.keys(constants.names))\\nexports.codes = Object.freeze(Object.keys(constants.codes))\\n\\n/**\\n * Create a new buffer with the multibase varint+code.\\n *\\n * @param {string|number} nameOrCode - The multibase name or code number.\\n * @param {Buffer} buf - The data to be prefixed with multibase.\\n * @memberof Multibase\\n * @returns {Buffer}\\n */\\nfunction multibase (nameOrCode, buf) {\\n  if (!buf) {\\n    throw new Error('requires an encoded buffer')\\n  }\\n  const base = getBase(nameOrCode)\\n  const codeBuf = Buffer.from(base.code)\\n\\n  const name = base.name\\n  validEncode(name, buf)\\n  return Buffer.concat([codeBuf, buf])\\n}\\n\\n/**\\n * Encode data with the specified base and add the multibase prefix.\\n *\\n * @param {string|number} nameOrCode - The multibase name or code number.\\n * @param {Buffer} buf - The data to be encoded.\\n * @returns {Buffer}\\n * @memberof Multibase\\n */\\nfunction encode (nameOrCode, buf) {\\n  const base = getBase(nameOrCode)\\n  const name = base.name\\n\\n  return multibase(name, Buffer.from(base.encode(buf)))\\n}\\n\\n/**\\n * Takes a buffer or string encoded with multibase header, decodes it and\\n * returns the decoded buffer\\n *\\n * @param {Buffer|string} bufOrString\\n * @returns {Buffer}\\n * @memberof Multibase\\n *\\n */\\nfunction decode (bufOrString) {\\n  if (Buffer.isBuffer(bufOrString)) {\\n    bufOrString = bufOrString.toString()\\n  }\\n\\n  const code = bufOrString.substring(0, 1)\\n  bufOrString = bufOrString.substring(1, bufOrString.length)\\n\\n  if (typeof bufOrString === 'string') {\\n    bufOrString = Buffer.from(bufOrString)\\n  }\\n\\n  const base = getBase(code)\\n  return Buffer.from(base.decode(bufOrString.toString()))\\n}\\n\\n/**\\n * Is the given data multibase encoded?\\n *\\n * @param {Buffer|string} bufOrString\\n * @returns {boolean}\\n * @memberof Multibase\\n */\\nfunction isEncoded (bufOrString) {\\n  if (Buffer.isBuffer(bufOrString)) {\\n    bufOrString = bufOrString.toString()\\n  }\\n\\n  // Ensure bufOrString is a string\\n  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {\\n    return false\\n  }\\n\\n  const code = bufOrString.substring(0, 1)\\n  try {\\n    const base = getBase(code)\\n    return base.name\\n  } catch (err) {\\n    return false\\n  }\\n}\\n\\n/**\\n * @param {string} name\\n * @param {Buffer} buf\\n * @private\\n * @returns {undefined}\\n */\\nfunction validEncode (name, buf) {\\n  const base = getBase(name)\\n  base.decode(buf.toString())\\n}\\n\\nfunction getBase (nameOrCode) {\\n  let base\\n\\n  if (constants.names[nameOrCode]) {\\n    base = constants.names[nameOrCode]\\n  } else if (constants.codes[nameOrCode]) {\\n    base = constants.codes[nameOrCode]\\n  } else {\\n    throw new Error('Unsupported encoding')\\n  }\\n\\n  if (!base.isImplemented()) {\\n    throw new Error('Base ' + nameOrCode + ' is not implemented yet')\\n  }\\n\\n  return base\\n}\\n\\n},{\\\"./constants\\\":48,\\\"buffer\\\":8}],50:[function(require,module,exports){\\n/* eslint quote-props: off */\\n/* eslint key-spacing: off */\\n'use strict'\\n\\nexports.names = Object.freeze({\\n  'identity':   0x0,\\n  'sha1':       0x11,\\n  'sha2-256':   0x12,\\n  'sha2-512':   0x13,\\n  'dbl-sha2-256': 0x56,\\n  'sha3-224':   0x17,\\n  'sha3-256':   0x16,\\n  'sha3-384':   0x15,\\n  'sha3-512':   0x14,\\n  'shake-128':  0x18,\\n  'shake-256':  0x19,\\n  'keccak-224': 0x1A,\\n  'keccak-256': 0x1B,\\n  'keccak-384': 0x1C,\\n  'keccak-512': 0x1D,\\n  'murmur3-128': 0x22,\\n  'murmur3-32':  0x23,\\n  'md4':         0xd4,\\n  'md5':         0xd5,\\n  'blake2b-8':   0xb201,\\n  'blake2b-16':  0xb202,\\n  'blake2b-24':  0xb203,\\n  'blake2b-32':  0xb204,\\n  'blake2b-40':  0xb205,\\n  'blake2b-48':  0xb206,\\n  'blake2b-56':  0xb207,\\n  'blake2b-64':  0xb208,\\n  'blake2b-72':  0xb209,\\n  'blake2b-80':  0xb20a,\\n  'blake2b-88':  0xb20b,\\n  'blake2b-96':  0xb20c,\\n  'blake2b-104': 0xb20d,\\n  'blake2b-112': 0xb20e,\\n  'blake2b-120': 0xb20f,\\n  'blake2b-128': 0xb210,\\n  'blake2b-136': 0xb211,\\n  'blake2b-144': 0xb212,\\n  'blake2b-152': 0xb213,\\n  'blake2b-160': 0xb214,\\n  'blake2b-168': 0xb215,\\n  'blake2b-176': 0xb216,\\n  'blake2b-184': 0xb217,\\n  'blake2b-192': 0xb218,\\n  'blake2b-200': 0xb219,\\n  'blake2b-208': 0xb21a,\\n  'blake2b-216': 0xb21b,\\n  'blake2b-224': 0xb21c,\\n  'blake2b-232': 0xb21d,\\n  'blake2b-240': 0xb21e,\\n  'blake2b-248': 0xb21f,\\n  'blake2b-256': 0xb220,\\n  'blake2b-264': 0xb221,\\n  'blake2b-272': 0xb222,\\n  'blake2b-280': 0xb223,\\n  'blake2b-288': 0xb224,\\n  'blake2b-296': 0xb225,\\n  'blake2b-304': 0xb226,\\n  'blake2b-312': 0xb227,\\n  'blake2b-320': 0xb228,\\n  'blake2b-328': 0xb229,\\n  'blake2b-336': 0xb22a,\\n  'blake2b-344': 0xb22b,\\n  'blake2b-352': 0xb22c,\\n  'blake2b-360': 0xb22d,\\n  'blake2b-368': 0xb22e,\\n  'blake2b-376': 0xb22f,\\n  'blake2b-384': 0xb230,\\n  'blake2b-392': 0xb231,\\n  'blake2b-400': 0xb232,\\n  'blake2b-408': 0xb233,\\n  'blake2b-416': 0xb234,\\n  'blake2b-424': 0xb235,\\n  'blake2b-432': 0xb236,\\n  'blake2b-440': 0xb237,\\n  'blake2b-448': 0xb238,\\n  'blake2b-456': 0xb239,\\n  'blake2b-464': 0xb23a,\\n  'blake2b-472': 0xb23b,\\n  'blake2b-480': 0xb23c,\\n  'blake2b-488': 0xb23d,\\n  'blake2b-496': 0xb23e,\\n  'blake2b-504': 0xb23f,\\n  'blake2b-512': 0xb240,\\n  'blake2s-8':   0xb241,\\n  'blake2s-16':  0xb242,\\n  'blake2s-24':  0xb243,\\n  'blake2s-32':  0xb244,\\n  'blake2s-40':  0xb245,\\n  'blake2s-48':  0xb246,\\n  'blake2s-56':  0xb247,\\n  'blake2s-64':  0xb248,\\n  'blake2s-72':  0xb249,\\n  'blake2s-80':  0xb24a,\\n  'blake2s-88':  0xb24b,\\n  'blake2s-96':  0xb24c,\\n  'blake2s-104': 0xb24d,\\n  'blake2s-112': 0xb24e,\\n  'blake2s-120': 0xb24f,\\n  'blake2s-128': 0xb250,\\n  'blake2s-136': 0xb251,\\n  'blake2s-144': 0xb252,\\n  'blake2s-152': 0xb253,\\n  'blake2s-160': 0xb254,\\n  'blake2s-168': 0xb255,\\n  'blake2s-176': 0xb256,\\n  'blake2s-184': 0xb257,\\n  'blake2s-192': 0xb258,\\n  'blake2s-200': 0xb259,\\n  'blake2s-208': 0xb25a,\\n  'blake2s-216': 0xb25b,\\n  'blake2s-224': 0xb25c,\\n  'blake2s-232': 0xb25d,\\n  'blake2s-240': 0xb25e,\\n  'blake2s-248': 0xb25f,\\n  'blake2s-256': 0xb260,\\n  'Skein256-8': 0xb301,\\n  'Skein256-16': 0xb302,\\n  'Skein256-24': 0xb303,\\n  'Skein256-32': 0xb304,\\n  'Skein256-40': 0xb305,\\n  'Skein256-48': 0xb306,\\n  'Skein256-56': 0xb307,\\n  'Skein256-64': 0xb308,\\n  'Skein256-72': 0xb309,\\n  'Skein256-80': 0xb30a,\\n  'Skein256-88': 0xb30b,\\n  'Skein256-96': 0xb30c,\\n  'Skein256-104': 0xb30d,\\n  'Skein256-112': 0xb30e,\\n  'Skein256-120': 0xb30f,\\n  'Skein256-128': 0xb310,\\n  'Skein256-136': 0xb311,\\n  'Skein256-144': 0xb312,\\n  'Skein256-152': 0xb313,\\n  'Skein256-160': 0xb314,\\n  'Skein256-168': 0xb315,\\n  'Skein256-176': 0xb316,\\n  'Skein256-184': 0xb317,\\n  'Skein256-192': 0xb318,\\n  'Skein256-200': 0xb319,\\n  'Skein256-208': 0xb31a,\\n  'Skein256-216': 0xb31b,\\n  'Skein256-224': 0xb31c,\\n  'Skein256-232': 0xb31d,\\n  'Skein256-240': 0xb31e,\\n  'Skein256-248': 0xb31f,\\n  'Skein256-256': 0xb320,\\n  'Skein512-8': 0xb321,\\n  'Skein512-16': 0xb322,\\n  'Skein512-24': 0xb323,\\n  'Skein512-32': 0xb324,\\n  'Skein512-40': 0xb325,\\n  'Skein512-48': 0xb326,\\n  'Skein512-56': 0xb327,\\n  'Skein512-64': 0xb328,\\n  'Skein512-72': 0xb329,\\n  'Skein512-80': 0xb32a,\\n  'Skein512-88': 0xb32b,\\n  'Skein512-96': 0xb32c,\\n  'Skein512-104': 0xb32d,\\n  'Skein512-112': 0xb32e,\\n  'Skein512-120': 0xb32f,\\n  'Skein512-128': 0xb330,\\n  'Skein512-136': 0xb331,\\n  'Skein512-144': 0xb332,\\n  'Skein512-152': 0xb333,\\n  'Skein512-160': 0xb334,\\n  'Skein512-168': 0xb335,\\n  'Skein512-176': 0xb336,\\n  'Skein512-184': 0xb337,\\n  'Skein512-192': 0xb338,\\n  'Skein512-200': 0xb339,\\n  'Skein512-208': 0xb33a,\\n  'Skein512-216': 0xb33b,\\n  'Skein512-224': 0xb33c,\\n  'Skein512-232': 0xb33d,\\n  'Skein512-240': 0xb33e,\\n  'Skein512-248': 0xb33f,\\n  'Skein512-256': 0xb340,\\n  'Skein512-264': 0xb341,\\n  'Skein512-272': 0xb342,\\n  'Skein512-280': 0xb343,\\n  'Skein512-288': 0xb344,\\n  'Skein512-296': 0xb345,\\n  'Skein512-304': 0xb346,\\n  'Skein512-312': 0xb347,\\n  'Skein512-320': 0xb348,\\n  'Skein512-328': 0xb349,\\n  'Skein512-336': 0xb34a,\\n  'Skein512-344': 0xb34b,\\n  'Skein512-352': 0xb34c,\\n  'Skein512-360': 0xb34d,\\n  'Skein512-368': 0xb34e,\\n  'Skein512-376': 0xb34f,\\n  'Skein512-384': 0xb350,\\n  'Skein512-392': 0xb351,\\n  'Skein512-400': 0xb352,\\n  'Skein512-408': 0xb353,\\n  'Skein512-416': 0xb354,\\n  'Skein512-424': 0xb355,\\n  'Skein512-432': 0xb356,\\n  'Skein512-440': 0xb357,\\n  'Skein512-448': 0xb358,\\n  'Skein512-456': 0xb359,\\n  'Skein512-464': 0xb35a,\\n  'Skein512-472': 0xb35b,\\n  'Skein512-480': 0xb35c,\\n  'Skein512-488': 0xb35d,\\n  'Skein512-496': 0xb35e,\\n  'Skein512-504': 0xb35f,\\n  'Skein512-512': 0xb360,\\n  'Skein1024-8': 0xb361,\\n  'Skein1024-16': 0xb362,\\n  'Skein1024-24': 0xb363,\\n  'Skein1024-32': 0xb364,\\n  'Skein1024-40': 0xb365,\\n  'Skein1024-48': 0xb366,\\n  'Skein1024-56': 0xb367,\\n  'Skein1024-64': 0xb368,\\n  'Skein1024-72': 0xb369,\\n  'Skein1024-80': 0xb36a,\\n  'Skein1024-88': 0xb36b,\\n  'Skein1024-96': 0xb36c,\\n  'Skein1024-104': 0xb36d,\\n  'Skein1024-112': 0xb36e,\\n  'Skein1024-120': 0xb36f,\\n  'Skein1024-128': 0xb370,\\n  'Skein1024-136': 0xb371,\\n  'Skein1024-144': 0xb372,\\n  'Skein1024-152': 0xb373,\\n  'Skein1024-160': 0xb374,\\n  'Skein1024-168': 0xb375,\\n  'Skein1024-176': 0xb376,\\n  'Skein1024-184': 0xb377,\\n  'Skein1024-192': 0xb378,\\n  'Skein1024-200': 0xb379,\\n  'Skein1024-208': 0xb37a,\\n  'Skein1024-216': 0xb37b,\\n  'Skein1024-224': 0xb37c,\\n  'Skein1024-232': 0xb37d,\\n  'Skein1024-240': 0xb37e,\\n  'Skein1024-248': 0xb37f,\\n  'Skein1024-256': 0xb380,\\n  'Skein1024-264': 0xb381,\\n  'Skein1024-272': 0xb382,\\n  'Skein1024-280': 0xb383,\\n  'Skein1024-288': 0xb384,\\n  'Skein1024-296': 0xb385,\\n  'Skein1024-304': 0xb386,\\n  'Skein1024-312': 0xb387,\\n  'Skein1024-320': 0xb388,\\n  'Skein1024-328': 0xb389,\\n  'Skein1024-336': 0xb38a,\\n  'Skein1024-344': 0xb38b,\\n  'Skein1024-352': 0xb38c,\\n  'Skein1024-360': 0xb38d,\\n  'Skein1024-368': 0xb38e,\\n  'Skein1024-376': 0xb38f,\\n  'Skein1024-384': 0xb390,\\n  'Skein1024-392': 0xb391,\\n  'Skein1024-400': 0xb392,\\n  'Skein1024-408': 0xb393,\\n  'Skein1024-416': 0xb394,\\n  'Skein1024-424': 0xb395,\\n  'Skein1024-432': 0xb396,\\n  'Skein1024-440': 0xb397,\\n  'Skein1024-448': 0xb398,\\n  'Skein1024-456': 0xb399,\\n  'Skein1024-464': 0xb39a,\\n  'Skein1024-472': 0xb39b,\\n  'Skein1024-480': 0xb39c,\\n  'Skein1024-488': 0xb39d,\\n  'Skein1024-496': 0xb39e,\\n  'Skein1024-504': 0xb39f,\\n  'Skein1024-512': 0xb3a0,\\n  'Skein1024-520': 0xb3a1,\\n  'Skein1024-528': 0xb3a2,\\n  'Skein1024-536': 0xb3a3,\\n  'Skein1024-544': 0xb3a4,\\n  'Skein1024-552': 0xb3a5,\\n  'Skein1024-560': 0xb3a6,\\n  'Skein1024-568': 0xb3a7,\\n  'Skein1024-576': 0xb3a8,\\n  'Skein1024-584': 0xb3a9,\\n  'Skein1024-592': 0xb3aa,\\n  'Skein1024-600': 0xb3ab,\\n  'Skein1024-608': 0xb3ac,\\n  'Skein1024-616': 0xb3ad,\\n  'Skein1024-624': 0xb3ae,\\n  'Skein1024-632': 0xb3af,\\n  'Skein1024-640': 0xb3b0,\\n  'Skein1024-648': 0xb3b1,\\n  'Skein1024-656': 0xb3b2,\\n  'Skein1024-664': 0xb3b3,\\n  'Skein1024-672': 0xb3b4,\\n  'Skein1024-680': 0xb3b5,\\n  'Skein1024-688': 0xb3b6,\\n  'Skein1024-696': 0xb3b7,\\n  'Skein1024-704': 0xb3b8,\\n  'Skein1024-712': 0xb3b9,\\n  'Skein1024-720': 0xb3ba,\\n  'Skein1024-728': 0xb3bb,\\n  'Skein1024-736': 0xb3bc,\\n  'Skein1024-744': 0xb3bd,\\n  'Skein1024-752': 0xb3be,\\n  'Skein1024-760': 0xb3bf,\\n  'Skein1024-768': 0xb3c0,\\n  'Skein1024-776': 0xb3c1,\\n  'Skein1024-784': 0xb3c2,\\n  'Skein1024-792': 0xb3c3,\\n  'Skein1024-800': 0xb3c4,\\n  'Skein1024-808': 0xb3c5,\\n  'Skein1024-816': 0xb3c6,\\n  'Skein1024-824': 0xb3c7,\\n  'Skein1024-832': 0xb3c8,\\n  'Skein1024-840': 0xb3c9,\\n  'Skein1024-848': 0xb3ca,\\n  'Skein1024-856': 0xb3cb,\\n  'Skein1024-864': 0xb3cc,\\n  'Skein1024-872': 0xb3cd,\\n  'Skein1024-880': 0xb3ce,\\n  'Skein1024-888': 0xb3cf,\\n  'Skein1024-896': 0xb3d0,\\n  'Skein1024-904': 0xb3d1,\\n  'Skein1024-912': 0xb3d2,\\n  'Skein1024-920': 0xb3d3,\\n  'Skein1024-928': 0xb3d4,\\n  'Skein1024-936': 0xb3d5,\\n  'Skein1024-944': 0xb3d6,\\n  'Skein1024-952': 0xb3d7,\\n  'Skein1024-960': 0xb3d8,\\n  'Skein1024-968': 0xb3d9,\\n  'Skein1024-976': 0xb3da,\\n  'Skein1024-984': 0xb3db,\\n  'Skein1024-992': 0xb3dc,\\n  'Skein1024-1000': 0xb3dd,\\n  'Skein1024-1008': 0xb3de,\\n  'Skein1024-1016': 0xb3df,\\n  'Skein1024-1024': 0xb3e0\\n})\\n\\nexports.codes = Object.freeze({\\n  0x0: 'identity',\\n\\n  // sha family\\n  0x11: 'sha1',\\n  0x12: 'sha2-256',\\n  0x13: 'sha2-512',\\n  0x56: 'dbl-sha2-256',\\n  0x17: 'sha3-224',\\n  0x16: 'sha3-256',\\n  0x15: 'sha3-384',\\n  0x14: 'sha3-512',\\n  0x18: 'shake-128',\\n  0x19: 'shake-256',\\n  0x1A: 'keccak-224',\\n  0x1B: 'keccak-256',\\n  0x1C: 'keccak-384',\\n  0x1D: 'keccak-512',\\n\\n  0x22: 'murmur3-128',\\n  0x23: 'murmur3-32',\\n\\n  0xd4: 'md4',\\n  0xd5: 'md5',\\n\\n  // blake2\\n  0xb201: 'blake2b-8',\\n  0xb202: 'blake2b-16',\\n  0xb203: 'blake2b-24',\\n  0xb204: 'blake2b-32',\\n  0xb205: 'blake2b-40',\\n  0xb206: 'blake2b-48',\\n  0xb207: 'blake2b-56',\\n  0xb208: 'blake2b-64',\\n  0xb209: 'blake2b-72',\\n  0xb20a: 'blake2b-80',\\n  0xb20b: 'blake2b-88',\\n  0xb20c: 'blake2b-96',\\n  0xb20d: 'blake2b-104',\\n  0xb20e: 'blake2b-112',\\n  0xb20f: 'blake2b-120',\\n  0xb210: 'blake2b-128',\\n  0xb211: 'blake2b-136',\\n  0xb212: 'blake2b-144',\\n  0xb213: 'blake2b-152',\\n  0xb214: 'blake2b-160',\\n  0xb215: 'blake2b-168',\\n  0xb216: 'blake2b-176',\\n  0xb217: 'blake2b-184',\\n  0xb218: 'blake2b-192',\\n  0xb219: 'blake2b-200',\\n  0xb21a: 'blake2b-208',\\n  0xb21b: 'blake2b-216',\\n  0xb21c: 'blake2b-224',\\n  0xb21d: 'blake2b-232',\\n  0xb21e: 'blake2b-240',\\n  0xb21f: 'blake2b-248',\\n  0xb220: 'blake2b-256',\\n  0xb221: 'blake2b-264',\\n  0xb222: 'blake2b-272',\\n  0xb223: 'blake2b-280',\\n  0xb224: 'blake2b-288',\\n  0xb225: 'blake2b-296',\\n  0xb226: 'blake2b-304',\\n  0xb227: 'blake2b-312',\\n  0xb228: 'blake2b-320',\\n  0xb229: 'blake2b-328',\\n  0xb22a: 'blake2b-336',\\n  0xb22b: 'blake2b-344',\\n  0xb22c: 'blake2b-352',\\n  0xb22d: 'blake2b-360',\\n  0xb22e: 'blake2b-368',\\n  0xb22f: 'blake2b-376',\\n  0xb230: 'blake2b-384',\\n  0xb231: 'blake2b-392',\\n  0xb232: 'blake2b-400',\\n  0xb233: 'blake2b-408',\\n  0xb234: 'blake2b-416',\\n  0xb235: 'blake2b-424',\\n  0xb236: 'blake2b-432',\\n  0xb237: 'blake2b-440',\\n  0xb238: 'blake2b-448',\\n  0xb239: 'blake2b-456',\\n  0xb23a: 'blake2b-464',\\n  0xb23b: 'blake2b-472',\\n  0xb23c: 'blake2b-480',\\n  0xb23d: 'blake2b-488',\\n  0xb23e: 'blake2b-496',\\n  0xb23f: 'blake2b-504',\\n  0xb240: 'blake2b-512',\\n  0xb241: 'blake2s-8',\\n  0xb242: 'blake2s-16',\\n  0xb243: 'blake2s-24',\\n  0xb244: 'blake2s-32',\\n  0xb245: 'blake2s-40',\\n  0xb246: 'blake2s-48',\\n  0xb247: 'blake2s-56',\\n  0xb248: 'blake2s-64',\\n  0xb249: 'blake2s-72',\\n  0xb24a: 'blake2s-80',\\n  0xb24b: 'blake2s-88',\\n  0xb24c: 'blake2s-96',\\n  0xb24d: 'blake2s-104',\\n  0xb24e: 'blake2s-112',\\n  0xb24f: 'blake2s-120',\\n  0xb250: 'blake2s-128',\\n  0xb251: 'blake2s-136',\\n  0xb252: 'blake2s-144',\\n  0xb253: 'blake2s-152',\\n  0xb254: 'blake2s-160',\\n  0xb255: 'blake2s-168',\\n  0xb256: 'blake2s-176',\\n  0xb257: 'blake2s-184',\\n  0xb258: 'blake2s-192',\\n  0xb259: 'blake2s-200',\\n  0xb25a: 'blake2s-208',\\n  0xb25b: 'blake2s-216',\\n  0xb25c: 'blake2s-224',\\n  0xb25d: 'blake2s-232',\\n  0xb25e: 'blake2s-240',\\n  0xb25f: 'blake2s-248',\\n  0xb260: 'blake2s-256',\\n\\n  // skein\\n  0xb301: 'Skein256-8',\\n  0xb302: 'Skein256-16',\\n  0xb303: 'Skein256-24',\\n  0xb304: 'Skein256-32',\\n  0xb305: 'Skein256-40',\\n  0xb306: 'Skein256-48',\\n  0xb307: 'Skein256-56',\\n  0xb308: 'Skein256-64',\\n  0xb309: 'Skein256-72',\\n  0xb30a: 'Skein256-80',\\n  0xb30b: 'Skein256-88',\\n  0xb30c: 'Skein256-96',\\n  0xb30d: 'Skein256-104',\\n  0xb30e: 'Skein256-112',\\n  0xb30f: 'Skein256-120',\\n  0xb310: 'Skein256-128',\\n  0xb311: 'Skein256-136',\\n  0xb312: 'Skein256-144',\\n  0xb313: 'Skein256-152',\\n  0xb314: 'Skein256-160',\\n  0xb315: 'Skein256-168',\\n  0xb316: 'Skein256-176',\\n  0xb317: 'Skein256-184',\\n  0xb318: 'Skein256-192',\\n  0xb319: 'Skein256-200',\\n  0xb31a: 'Skein256-208',\\n  0xb31b: 'Skein256-216',\\n  0xb31c: 'Skein256-224',\\n  0xb31d: 'Skein256-232',\\n  0xb31e: 'Skein256-240',\\n  0xb31f: 'Skein256-248',\\n  0xb320: 'Skein256-256',\\n  0xb321: 'Skein512-8',\\n  0xb322: 'Skein512-16',\\n  0xb323: 'Skein512-24',\\n  0xb324: 'Skein512-32',\\n  0xb325: 'Skein512-40',\\n  0xb326: 'Skein512-48',\\n  0xb327: 'Skein512-56',\\n  0xb328: 'Skein512-64',\\n  0xb329: 'Skein512-72',\\n  0xb32a: 'Skein512-80',\\n  0xb32b: 'Skein512-88',\\n  0xb32c: 'Skein512-96',\\n  0xb32d: 'Skein512-104',\\n  0xb32e: 'Skein512-112',\\n  0xb32f: 'Skein512-120',\\n  0xb330: 'Skein512-128',\\n  0xb331: 'Skein512-136',\\n  0xb332: 'Skein512-144',\\n  0xb333: 'Skein512-152',\\n  0xb334: 'Skein512-160',\\n  0xb335: 'Skein512-168',\\n  0xb336: 'Skein512-176',\\n  0xb337: 'Skein512-184',\\n  0xb338: 'Skein512-192',\\n  0xb339: 'Skein512-200',\\n  0xb33a: 'Skein512-208',\\n  0xb33b: 'Skein512-216',\\n  0xb33c: 'Skein512-224',\\n  0xb33d: 'Skein512-232',\\n  0xb33e: 'Skein512-240',\\n  0xb33f: 'Skein512-248',\\n  0xb340: 'Skein512-256',\\n  0xb341: 'Skein512-264',\\n  0xb342: 'Skein512-272',\\n  0xb343: 'Skein512-280',\\n  0xb344: 'Skein512-288',\\n  0xb345: 'Skein512-296',\\n  0xb346: 'Skein512-304',\\n  0xb347: 'Skein512-312',\\n  0xb348: 'Skein512-320',\\n  0xb349: 'Skein512-328',\\n  0xb34a: 'Skein512-336',\\n  0xb34b: 'Skein512-344',\\n  0xb34c: 'Skein512-352',\\n  0xb34d: 'Skein512-360',\\n  0xb34e: 'Skein512-368',\\n  0xb34f: 'Skein512-376',\\n  0xb350: 'Skein512-384',\\n  0xb351: 'Skein512-392',\\n  0xb352: 'Skein512-400',\\n  0xb353: 'Skein512-408',\\n  0xb354: 'Skein512-416',\\n  0xb355: 'Skein512-424',\\n  0xb356: 'Skein512-432',\\n  0xb357: 'Skein512-440',\\n  0xb358: 'Skein512-448',\\n  0xb359: 'Skein512-456',\\n  0xb35a: 'Skein512-464',\\n  0xb35b: 'Skein512-472',\\n  0xb35c: 'Skein512-480',\\n  0xb35d: 'Skein512-488',\\n  0xb35e: 'Skein512-496',\\n  0xb35f: 'Skein512-504',\\n  0xb360: 'Skein512-512',\\n  0xb361: 'Skein1024-8',\\n  0xb362: 'Skein1024-16',\\n  0xb363: 'Skein1024-24',\\n  0xb364: 'Skein1024-32',\\n  0xb365: 'Skein1024-40',\\n  0xb366: 'Skein1024-48',\\n  0xb367: 'Skein1024-56',\\n  0xb368: 'Skein1024-64',\\n  0xb369: 'Skein1024-72',\\n  0xb36a: 'Skein1024-80',\\n  0xb36b: 'Skein1024-88',\\n  0xb36c: 'Skein1024-96',\\n  0xb36d: 'Skein1024-104',\\n  0xb36e: 'Skein1024-112',\\n  0xb36f: 'Skein1024-120',\\n  0xb370: 'Skein1024-128',\\n  0xb371: 'Skein1024-136',\\n  0xb372: 'Skein1024-144',\\n  0xb373: 'Skein1024-152',\\n  0xb374: 'Skein1024-160',\\n  0xb375: 'Skein1024-168',\\n  0xb376: 'Skein1024-176',\\n  0xb377: 'Skein1024-184',\\n  0xb378: 'Skein1024-192',\\n  0xb379: 'Skein1024-200',\\n  0xb37a: 'Skein1024-208',\\n  0xb37b: 'Skein1024-216',\\n  0xb37c: 'Skein1024-224',\\n  0xb37d: 'Skein1024-232',\\n  0xb37e: 'Skein1024-240',\\n  0xb37f: 'Skein1024-248',\\n  0xb380: 'Skein1024-256',\\n  0xb381: 'Skein1024-264',\\n  0xb382: 'Skein1024-272',\\n  0xb383: 'Skein1024-280',\\n  0xb384: 'Skein1024-288',\\n  0xb385: 'Skein1024-296',\\n  0xb386: 'Skein1024-304',\\n  0xb387: 'Skein1024-312',\\n  0xb388: 'Skein1024-320',\\n  0xb389: 'Skein1024-328',\\n  0xb38a: 'Skein1024-336',\\n  0xb38b: 'Skein1024-344',\\n  0xb38c: 'Skein1024-352',\\n  0xb38d: 'Skein1024-360',\\n  0xb38e: 'Skein1024-368',\\n  0xb38f: 'Skein1024-376',\\n  0xb390: 'Skein1024-384',\\n  0xb391: 'Skein1024-392',\\n  0xb392: 'Skein1024-400',\\n  0xb393: 'Skein1024-408',\\n  0xb394: 'Skein1024-416',\\n  0xb395: 'Skein1024-424',\\n  0xb396: 'Skein1024-432',\\n  0xb397: 'Skein1024-440',\\n  0xb398: 'Skein1024-448',\\n  0xb399: 'Skein1024-456',\\n  0xb39a: 'Skein1024-464',\\n  0xb39b: 'Skein1024-472',\\n  0xb39c: 'Skein1024-480',\\n  0xb39d: 'Skein1024-488',\\n  0xb39e: 'Skein1024-496',\\n  0xb39f: 'Skein1024-504',\\n  0xb3a0: 'Skein1024-512',\\n  0xb3a1: 'Skein1024-520',\\n  0xb3a2: 'Skein1024-528',\\n  0xb3a3: 'Skein1024-536',\\n  0xb3a4: 'Skein1024-544',\\n  0xb3a5: 'Skein1024-552',\\n  0xb3a6: 'Skein1024-560',\\n  0xb3a7: 'Skein1024-568',\\n  0xb3a8: 'Skein1024-576',\\n  0xb3a9: 'Skein1024-584',\\n  0xb3aa: 'Skein1024-592',\\n  0xb3ab: 'Skein1024-600',\\n  0xb3ac: 'Skein1024-608',\\n  0xb3ad: 'Skein1024-616',\\n  0xb3ae: 'Skein1024-624',\\n  0xb3af: 'Skein1024-632',\\n  0xb3b0: 'Skein1024-640',\\n  0xb3b1: 'Skein1024-648',\\n  0xb3b2: 'Skein1024-656',\\n  0xb3b3: 'Skein1024-664',\\n  0xb3b4: 'Skein1024-672',\\n  0xb3b5: 'Skein1024-680',\\n  0xb3b6: 'Skein1024-688',\\n  0xb3b7: 'Skein1024-696',\\n  0xb3b8: 'Skein1024-704',\\n  0xb3b9: 'Skein1024-712',\\n  0xb3ba: 'Skein1024-720',\\n  0xb3bb: 'Skein1024-728',\\n  0xb3bc: 'Skein1024-736',\\n  0xb3bd: 'Skein1024-744',\\n  0xb3be: 'Skein1024-752',\\n  0xb3bf: 'Skein1024-760',\\n  0xb3c0: 'Skein1024-768',\\n  0xb3c1: 'Skein1024-776',\\n  0xb3c2: 'Skein1024-784',\\n  0xb3c3: 'Skein1024-792',\\n  0xb3c4: 'Skein1024-800',\\n  0xb3c5: 'Skein1024-808',\\n  0xb3c6: 'Skein1024-816',\\n  0xb3c7: 'Skein1024-824',\\n  0xb3c8: 'Skein1024-832',\\n  0xb3c9: 'Skein1024-840',\\n  0xb3ca: 'Skein1024-848',\\n  0xb3cb: 'Skein1024-856',\\n  0xb3cc: 'Skein1024-864',\\n  0xb3cd: 'Skein1024-872',\\n  0xb3ce: 'Skein1024-880',\\n  0xb3cf: 'Skein1024-888',\\n  0xb3d0: 'Skein1024-896',\\n  0xb3d1: 'Skein1024-904',\\n  0xb3d2: 'Skein1024-912',\\n  0xb3d3: 'Skein1024-920',\\n  0xb3d4: 'Skein1024-928',\\n  0xb3d5: 'Skein1024-936',\\n  0xb3d6: 'Skein1024-944',\\n  0xb3d7: 'Skein1024-952',\\n  0xb3d8: 'Skein1024-960',\\n  0xb3d9: 'Skein1024-968',\\n  0xb3da: 'Skein1024-976',\\n  0xb3db: 'Skein1024-984',\\n  0xb3dc: 'Skein1024-992',\\n  0xb3dd: 'Skein1024-1000',\\n  0xb3de: 'Skein1024-1008',\\n  0xb3df: 'Skein1024-1016',\\n  0xb3e0: 'Skein1024-1024'\\n})\\n\\nexports.defaultLengths = Object.freeze({\\n  0x11: 20,\\n  0x12: 32,\\n  0x13: 64,\\n  0x56: 32,\\n  0x17: 28,\\n  0x16: 32,\\n  0x15: 48,\\n  0x14: 64,\\n  0x18: 32,\\n  0x19: 64,\\n  0x1A: 28,\\n  0x1B: 32,\\n  0x1C: 48,\\n  0x1D: 64,\\n  0x22: 32,\\n\\n  0xb201: 0x01,\\n  0xb202: 0x02,\\n  0xb203: 0x03,\\n  0xb204: 0x04,\\n  0xb205: 0x05,\\n  0xb206: 0x06,\\n  0xb207: 0x07,\\n  0xb208: 0x08,\\n  0xb209: 0x09,\\n  0xb20a: 0x0a,\\n  0xb20b: 0x0b,\\n  0xb20c: 0x0c,\\n  0xb20d: 0x0d,\\n  0xb20e: 0x0e,\\n  0xb20f: 0x0f,\\n  0xb210: 0x10,\\n  0xb211: 0x11,\\n  0xb212: 0x12,\\n  0xb213: 0x13,\\n  0xb214: 0x14,\\n  0xb215: 0x15,\\n  0xb216: 0x16,\\n  0xb217: 0x17,\\n  0xb218: 0x18,\\n  0xb219: 0x19,\\n  0xb21a: 0x1a,\\n  0xb21b: 0x1b,\\n  0xb21c: 0x1c,\\n  0xb21d: 0x1d,\\n  0xb21e: 0x1e,\\n  0xb21f: 0x1f,\\n  0xb220: 0x20,\\n  0xb221: 0x21,\\n  0xb222: 0x22,\\n  0xb223: 0x23,\\n  0xb224: 0x24,\\n  0xb225: 0x25,\\n  0xb226: 0x26,\\n  0xb227: 0x27,\\n  0xb228: 0x28,\\n  0xb229: 0x29,\\n  0xb22a: 0x2a,\\n  0xb22b: 0x2b,\\n  0xb22c: 0x2c,\\n  0xb22d: 0x2d,\\n  0xb22e: 0x2e,\\n  0xb22f: 0x2f,\\n  0xb230: 0x30,\\n  0xb231: 0x31,\\n  0xb232: 0x32,\\n  0xb233: 0x33,\\n  0xb234: 0x34,\\n  0xb235: 0x35,\\n  0xb236: 0x36,\\n  0xb237: 0x37,\\n  0xb238: 0x38,\\n  0xb239: 0x39,\\n  0xb23a: 0x3a,\\n  0xb23b: 0x3b,\\n  0xb23c: 0x3c,\\n  0xb23d: 0x3d,\\n  0xb23e: 0x3e,\\n  0xb23f: 0x3f,\\n  0xb240: 0x40,\\n  0xb241: 0x01,\\n  0xb242: 0x02,\\n  0xb243: 0x03,\\n  0xb244: 0x04,\\n  0xb245: 0x05,\\n  0xb246: 0x06,\\n  0xb247: 0x07,\\n  0xb248: 0x08,\\n  0xb249: 0x09,\\n  0xb24a: 0x0a,\\n  0xb24b: 0x0b,\\n  0xb24c: 0x0c,\\n  0xb24d: 0x0d,\\n  0xb24e: 0x0e,\\n  0xb24f: 0x0f,\\n  0xb250: 0x10,\\n  0xb251: 0x11,\\n  0xb252: 0x12,\\n  0xb253: 0x13,\\n  0xb254: 0x14,\\n  0xb255: 0x15,\\n  0xb256: 0x16,\\n  0xb257: 0x17,\\n  0xb258: 0x18,\\n  0xb259: 0x19,\\n  0xb25a: 0x1a,\\n  0xb25b: 0x1b,\\n  0xb25c: 0x1c,\\n  0xb25d: 0x1d,\\n  0xb25e: 0x1e,\\n  0xb25f: 0x1f,\\n  0xb260: 0x20,\\n  0xb301: 0x01,\\n  0xb302: 0x02,\\n  0xb303: 0x03,\\n  0xb304: 0x04,\\n  0xb305: 0x05,\\n  0xb306: 0x06,\\n  0xb307: 0x07,\\n  0xb308: 0x08,\\n  0xb309: 0x09,\\n  0xb30a: 0x0a,\\n  0xb30b: 0x0b,\\n  0xb30c: 0x0c,\\n  0xb30d: 0x0d,\\n  0xb30e: 0x0e,\\n  0xb30f: 0x0f,\\n  0xb310: 0x10,\\n  0xb311: 0x11,\\n  0xb312: 0x12,\\n  0xb313: 0x13,\\n  0xb314: 0x14,\\n  0xb315: 0x15,\\n  0xb316: 0x16,\\n  0xb317: 0x17,\\n  0xb318: 0x18,\\n  0xb319: 0x19,\\n  0xb31a: 0x1a,\\n  0xb31b: 0x1b,\\n  0xb31c: 0x1c,\\n  0xb31d: 0x1d,\\n  0xb31e: 0x1e,\\n  0xb31f: 0x1f,\\n  0xb320: 0x20,\\n  0xb321: 0x01,\\n  0xb322: 0x02,\\n  0xb323: 0x03,\\n  0xb324: 0x04,\\n  0xb325: 0x05,\\n  0xb326: 0x06,\\n  0xb327: 0x07,\\n  0xb328: 0x08,\\n  0xb329: 0x09,\\n  0xb32a: 0x0a,\\n  0xb32b: 0x0b,\\n  0xb32c: 0x0c,\\n  0xb32d: 0x0d,\\n  0xb32e: 0x0e,\\n  0xb32f: 0x0f,\\n  0xb330: 0x10,\\n  0xb331: 0x11,\\n  0xb332: 0x12,\\n  0xb333: 0x13,\\n  0xb334: 0x14,\\n  0xb335: 0x15,\\n  0xb336: 0x16,\\n  0xb337: 0x17,\\n  0xb338: 0x18,\\n  0xb339: 0x19,\\n  0xb33a: 0x1a,\\n  0xb33b: 0x1b,\\n  0xb33c: 0x1c,\\n  0xb33d: 0x1d,\\n  0xb33e: 0x1e,\\n  0xb33f: 0x1f,\\n  0xb340: 0x20,\\n  0xb341: 0x21,\\n  0xb342: 0x22,\\n  0xb343: 0x23,\\n  0xb344: 0x24,\\n  0xb345: 0x25,\\n  0xb346: 0x26,\\n  0xb347: 0x27,\\n  0xb348: 0x28,\\n  0xb349: 0x29,\\n  0xb34a: 0x2a,\\n  0xb34b: 0x2b,\\n  0xb34c: 0x2c,\\n  0xb34d: 0x2d,\\n  0xb34e: 0x2e,\\n  0xb34f: 0x2f,\\n  0xb350: 0x30,\\n  0xb351: 0x31,\\n  0xb352: 0x32,\\n  0xb353: 0x33,\\n  0xb354: 0x34,\\n  0xb355: 0x35,\\n  0xb356: 0x36,\\n  0xb357: 0x37,\\n  0xb358: 0x38,\\n  0xb359: 0x39,\\n  0xb35a: 0x3a,\\n  0xb35b: 0x3b,\\n  0xb35c: 0x3c,\\n  0xb35d: 0x3d,\\n  0xb35e: 0x3e,\\n  0xb35f: 0x3f,\\n  0xb360: 0x40,\\n  0xb361: 0x01,\\n  0xb362: 0x02,\\n  0xb363: 0x03,\\n  0xb364: 0x04,\\n  0xb365: 0x05,\\n  0xb366: 0x06,\\n  0xb367: 0x07,\\n  0xb368: 0x08,\\n  0xb369: 0x09,\\n  0xb36a: 0x0a,\\n  0xb36b: 0x0b,\\n  0xb36c: 0x0c,\\n  0xb36d: 0x0d,\\n  0xb36e: 0x0e,\\n  0xb36f: 0x0f,\\n  0xb370: 0x10,\\n  0xb371: 0x11,\\n  0xb372: 0x12,\\n  0xb373: 0x13,\\n  0xb374: 0x14,\\n  0xb375: 0x15,\\n  0xb376: 0x16,\\n  0xb377: 0x17,\\n  0xb378: 0x18,\\n  0xb379: 0x19,\\n  0xb37a: 0x1a,\\n  0xb37b: 0x1b,\\n  0xb37c: 0x1c,\\n  0xb37d: 0x1d,\\n  0xb37e: 0x1e,\\n  0xb37f: 0x1f,\\n  0xb380: 0x20,\\n  0xb381: 0x21,\\n  0xb382: 0x22,\\n  0xb383: 0x23,\\n  0xb384: 0x24,\\n  0xb385: 0x25,\\n  0xb386: 0x26,\\n  0xb387: 0x27,\\n  0xb388: 0x28,\\n  0xb389: 0x29,\\n  0xb38a: 0x2a,\\n  0xb38b: 0x2b,\\n  0xb38c: 0x2c,\\n  0xb38d: 0x2d,\\n  0xb38e: 0x2e,\\n  0xb38f: 0x2f,\\n  0xb390: 0x30,\\n  0xb391: 0x31,\\n  0xb392: 0x32,\\n  0xb393: 0x33,\\n  0xb394: 0x34,\\n  0xb395: 0x35,\\n  0xb396: 0x36,\\n  0xb397: 0x37,\\n  0xb398: 0x38,\\n  0xb399: 0x39,\\n  0xb39a: 0x3a,\\n  0xb39b: 0x3b,\\n  0xb39c: 0x3c,\\n  0xb39d: 0x3d,\\n  0xb39e: 0x3e,\\n  0xb39f: 0x3f,\\n  0xb3a0: 0x40,\\n  0xb3a1: 0x41,\\n  0xb3a2: 0x42,\\n  0xb3a3: 0x43,\\n  0xb3a4: 0x44,\\n  0xb3a5: 0x45,\\n  0xb3a6: 0x46,\\n  0xb3a7: 0x47,\\n  0xb3a8: 0x48,\\n  0xb3a9: 0x49,\\n  0xb3aa: 0x4a,\\n  0xb3ab: 0x4b,\\n  0xb3ac: 0x4c,\\n  0xb3ad: 0x4d,\\n  0xb3ae: 0x4e,\\n  0xb3af: 0x4f,\\n  0xb3b0: 0x50,\\n  0xb3b1: 0x51,\\n  0xb3b2: 0x52,\\n  0xb3b3: 0x53,\\n  0xb3b4: 0x54,\\n  0xb3b5: 0x55,\\n  0xb3b6: 0x56,\\n  0xb3b7: 0x57,\\n  0xb3b8: 0x58,\\n  0xb3b9: 0x59,\\n  0xb3ba: 0x5a,\\n  0xb3bb: 0x5b,\\n  0xb3bc: 0x5c,\\n  0xb3bd: 0x5d,\\n  0xb3be: 0x5e,\\n  0xb3bf: 0x5f,\\n  0xb3c0: 0x60,\\n  0xb3c1: 0x61,\\n  0xb3c2: 0x62,\\n  0xb3c3: 0x63,\\n  0xb3c4: 0x64,\\n  0xb3c5: 0x65,\\n  0xb3c6: 0x66,\\n  0xb3c7: 0x67,\\n  0xb3c8: 0x68,\\n  0xb3c9: 0x69,\\n  0xb3ca: 0x6a,\\n  0xb3cb: 0x6b,\\n  0xb3cc: 0x6c,\\n  0xb3cd: 0x6d,\\n  0xb3ce: 0x6e,\\n  0xb3cf: 0x6f,\\n  0xb3d0: 0x70,\\n  0xb3d1: 0x71,\\n  0xb3d2: 0x72,\\n  0xb3d3: 0x73,\\n  0xb3d4: 0x74,\\n  0xb3d5: 0x75,\\n  0xb3d6: 0x76,\\n  0xb3d7: 0x77,\\n  0xb3d8: 0x78,\\n  0xb3d9: 0x79,\\n  0xb3da: 0x7a,\\n  0xb3db: 0x7b,\\n  0xb3dc: 0x7c,\\n  0xb3dd: 0x7d,\\n  0xb3de: 0x7e,\\n  0xb3df: 0x7f,\\n  0xb3e0: 0x80\\n})\\n\\n},{}],51:[function(require,module,exports){\\n/**\\n * Multihash implementation in JavaScript.\\n *\\n * @module multihash\\n */\\n'use strict'\\n\\nconst { Buffer } = require('buffer')\\nconst multibase = require('multibase')\\nconst varint = require('varint')\\nconst cs = require('./constants')\\n\\nexports.names = cs.names\\nexports.codes = cs.codes\\nexports.defaultLengths = cs.defaultLengths\\n\\n/**\\n * Convert the given multihash to a hex encoded string.\\n *\\n * @param {Buffer} hash\\n * @returns {string}\\n */\\nexports.toHexString = function toHexString (hash) {\\n  if (!Buffer.isBuffer(hash)) {\\n    throw new Error('must be passed a buffer')\\n  }\\n\\n  return hash.toString('hex')\\n}\\n\\n/**\\n * Convert the given hex encoded string to a multihash.\\n *\\n * @param {string} hash\\n * @returns {Buffer}\\n */\\nexports.fromHexString = function fromHexString (hash) {\\n  return Buffer.from(hash, 'hex')\\n}\\n\\n/**\\n * Convert the given multihash to a base58 encoded string.\\n *\\n * @param {Buffer} hash\\n * @returns {string}\\n */\\nexports.toB58String = function toB58String (hash) {\\n  if (!Buffer.isBuffer(hash)) {\\n    throw new Error('must be passed a buffer')\\n  }\\n\\n  return multibase.encode('base58btc', hash).toString().slice(1)\\n}\\n\\n/**\\n * Convert the given base58 encoded string to a multihash.\\n *\\n * @param {string|Buffer} hash\\n * @returns {Buffer}\\n */\\nexports.fromB58String = function fromB58String (hash) {\\n  let encoded = hash\\n  if (Buffer.isBuffer(hash)) {\\n    encoded = hash.toString()\\n  }\\n\\n  return multibase.decode('z' + encoded)\\n}\\n\\n/**\\n * Decode a hash from the given multihash.\\n *\\n * @param {Buffer} buf\\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\\n */\\nexports.decode = function decode (buf) {\\n  if (!(Buffer.isBuffer(buf))) {\\n    throw new Error('multihash must be a Buffer')\\n  }\\n\\n  if (buf.length < 2) {\\n    throw new Error('multihash too short. must be > 2 bytes.')\\n  }\\n\\n  const code = varint.decode(buf)\\n  if (!exports.isValidCode(code)) {\\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\\n  }\\n  buf = buf.slice(varint.decode.bytes)\\n\\n  const len = varint.decode(buf)\\n  if (len < 0) {\\n    throw new Error(`multihash invalid length: ${len}`)\\n  }\\n  buf = buf.slice(varint.decode.bytes)\\n\\n  if (buf.length !== len) {\\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\\n  }\\n\\n  return {\\n    code: code,\\n    name: cs.codes[code],\\n    length: len,\\n    digest: buf\\n  }\\n}\\n\\n/**\\n *  Encode a hash digest along with the specified function code.\\n *\\n * > **Note:** the length is derived from the length of the digest itself.\\n *\\n * @param {Buffer} digest\\n * @param {string|number} code\\n * @param {number} [length]\\n * @returns {Buffer}\\n */\\nexports.encode = function encode (digest, code, length) {\\n  if (!digest || code === undefined) {\\n    throw new Error('multihash encode requires at least two args: digest, code')\\n  }\\n\\n  // ensure it's a hashfunction code.\\n  const hashfn = exports.coerceCode(code)\\n\\n  if (!(Buffer.isBuffer(digest))) {\\n    throw new Error('digest should be a Buffer')\\n  }\\n\\n  if (length == null) {\\n    length = digest.length\\n  }\\n\\n  if (length && digest.length !== length) {\\n    throw new Error('digest length should be equal to specified length.')\\n  }\\n\\n  return Buffer.concat([\\n    Buffer.from(varint.encode(hashfn)),\\n    Buffer.from(varint.encode(length)),\\n    digest\\n  ])\\n}\\n\\n/**\\n * Converts a hash function name into the matching code.\\n * If passed a number it will return the number if it's a valid code.\\n * @param {string|number} name\\n * @returns {number}\\n */\\nexports.coerceCode = function coerceCode (name) {\\n  let code = name\\n\\n  if (typeof name === 'string') {\\n    if (cs.names[name] === undefined) {\\n      throw new Error(`Unrecognized hash function named: ${name}`)\\n    }\\n    code = cs.names[name]\\n  }\\n\\n  if (typeof code !== 'number') {\\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\\n  }\\n\\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\\n    throw new Error(`Unrecognized function code: ${code}`)\\n  }\\n\\n  return code\\n}\\n\\n/**\\n * Checks wether a code is part of the app range\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\nexports.isAppCode = function appCode (code) {\\n  return code > 0 && code < 0x10\\n}\\n\\n/**\\n * Checks whether a multihash code is valid.\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\nexports.isValidCode = function validCode (code) {\\n  if (exports.isAppCode(code)) {\\n    return true\\n  }\\n\\n  if (cs.codes[code]) {\\n    return true\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Buffer} multihash\\n * @returns {undefined}\\n * @throws {Error}\\n */\\nfunction validate (multihash) {\\n  exports.decode(multihash) // throws if bad.\\n}\\nexports.validate = validate\\n\\n/**\\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Buffer} multihash\\n * @returns {undefined}\\n * @throws {Error}\\n */\\nexports.prefix = function prefix (multihash) {\\n  validate(multihash)\\n\\n  return multihash.slice(0, 2)\\n}\\n\\n},{\\\"./constants\\\":50,\\\"buffer\\\":8,\\\"multibase\\\":49,\\\"varint\\\":57}],52:[function(require,module,exports){\\n/**\\n * Copyright (c) 2014-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nvar runtime = (function (exports) {\\n  \\\"use strict\\\";\\n\\n  var Op = Object.prototype;\\n  var hasOwn = Op.hasOwnProperty;\\n  var undefined; // More compressible than void 0.\\n  var $Symbol = typeof Symbol === \\\"function\\\" ? Symbol : {};\\n  var iteratorSymbol = $Symbol.iterator || \\\"@@iterator\\\";\\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \\\"@@asyncIterator\\\";\\n  var toStringTagSymbol = $Symbol.toStringTag || \\\"@@toStringTag\\\";\\n\\n  function wrap(innerFn, outerFn, self, tryLocsList) {\\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\\n    var generator = Object.create(protoGenerator.prototype);\\n    var context = new Context(tryLocsList || []);\\n\\n    // The ._invoke method unifies the implementations of the .next,\\n    // .throw, and .return methods.\\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\\n\\n    return generator;\\n  }\\n  exports.wrap = wrap;\\n\\n  // Try/catch helper to minimize deoptimizations. Returns a completion\\n  // record like context.tryEntries[i].completion. This interface could\\n  // have been (and was previously) designed to take a closure to be\\n  // invoked without arguments, but in all the cases we care about we\\n  // already have an existing method we want to call, so there's no need\\n  // to create a new function object. We can even get away with assuming\\n  // the method takes exactly one argument, since that happens to be true\\n  // in every case, so we don't have to touch the arguments object. The\\n  // only additional allocation required is the completion record, which\\n  // has a stable shape and so hopefully should be cheap to allocate.\\n  function tryCatch(fn, obj, arg) {\\n    try {\\n      return { type: \\\"normal\\\", arg: fn.call(obj, arg) };\\n    } catch (err) {\\n      return { type: \\\"throw\\\", arg: err };\\n    }\\n  }\\n\\n  var GenStateSuspendedStart = \\\"suspendedStart\\\";\\n  var GenStateSuspendedYield = \\\"suspendedYield\\\";\\n  var GenStateExecuting = \\\"executing\\\";\\n  var GenStateCompleted = \\\"completed\\\";\\n\\n  // Returning this object from the innerFn has the same effect as\\n  // breaking out of the dispatch switch statement.\\n  var ContinueSentinel = {};\\n\\n  // Dummy constructor functions that we use as the .constructor and\\n  // .constructor.prototype properties for functions that return Generator\\n  // objects. For full spec compliance, you may wish to configure your\\n  // minifier not to mangle the names of these two functions.\\n  function Generator() {}\\n  function GeneratorFunction() {}\\n  function GeneratorFunctionPrototype() {}\\n\\n  // This is a polyfill for %IteratorPrototype% for environments that\\n  // don't natively support it.\\n  var IteratorPrototype = {};\\n  IteratorPrototype[iteratorSymbol] = function () {\\n    return this;\\n  };\\n\\n  var getProto = Object.getPrototypeOf;\\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\\n  if (NativeIteratorPrototype &&\\n      NativeIteratorPrototype !== Op &&\\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\\n    // This environment has a native %IteratorPrototype%; use it instead\\n    // of the polyfill.\\n    IteratorPrototype = NativeIteratorPrototype;\\n  }\\n\\n  var Gp = GeneratorFunctionPrototype.prototype =\\n    Generator.prototype = Object.create(IteratorPrototype);\\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\\n  GeneratorFunctionPrototype[toStringTagSymbol] =\\n    GeneratorFunction.displayName = \\\"GeneratorFunction\\\";\\n\\n  // Helper for defining the .next, .throw, and .return methods of the\\n  // Iterator interface in terms of a single ._invoke method.\\n  function defineIteratorMethods(prototype) {\\n    [\\\"next\\\", \\\"throw\\\", \\\"return\\\"].forEach(function(method) {\\n      prototype[method] = function(arg) {\\n        return this._invoke(method, arg);\\n      };\\n    });\\n  }\\n\\n  exports.isGeneratorFunction = function(genFun) {\\n    var ctor = typeof genFun === \\\"function\\\" && genFun.constructor;\\n    return ctor\\n      ? ctor === GeneratorFunction ||\\n        // For the native GeneratorFunction constructor, the best we can\\n        // do is to check its .name property.\\n        (ctor.displayName || ctor.name) === \\\"GeneratorFunction\\\"\\n      : false;\\n  };\\n\\n  exports.mark = function(genFun) {\\n    if (Object.setPrototypeOf) {\\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\\n    } else {\\n      genFun.__proto__ = GeneratorFunctionPrototype;\\n      if (!(toStringTagSymbol in genFun)) {\\n        genFun[toStringTagSymbol] = \\\"GeneratorFunction\\\";\\n      }\\n    }\\n    genFun.prototype = Object.create(Gp);\\n    return genFun;\\n  };\\n\\n  // Within the body of any async function, `await x` is transformed to\\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\\n  // `hasOwn.call(value, \\\"__await\\\")` to determine if the yielded value is\\n  // meant to be awaited.\\n  exports.awrap = function(arg) {\\n    return { __await: arg };\\n  };\\n\\n  function AsyncIterator(generator, PromiseImpl) {\\n    function invoke(method, arg, resolve, reject) {\\n      var record = tryCatch(generator[method], generator, arg);\\n      if (record.type === \\\"throw\\\") {\\n        reject(record.arg);\\n      } else {\\n        var result = record.arg;\\n        var value = result.value;\\n        if (value &&\\n            typeof value === \\\"object\\\" &&\\n            hasOwn.call(value, \\\"__await\\\")) {\\n          return PromiseImpl.resolve(value.__await).then(function(value) {\\n            invoke(\\\"next\\\", value, resolve, reject);\\n          }, function(err) {\\n            invoke(\\\"throw\\\", err, resolve, reject);\\n          });\\n        }\\n\\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\\n          // When a yielded Promise is resolved, its final value becomes\\n          // the .value of the Promise<{value,done}> result for the\\n          // current iteration.\\n          result.value = unwrapped;\\n          resolve(result);\\n        }, function(error) {\\n          // If a rejected Promise was yielded, throw the rejection back\\n          // into the async generator function so it can be handled there.\\n          return invoke(\\\"throw\\\", error, resolve, reject);\\n        });\\n      }\\n    }\\n\\n    var previousPromise;\\n\\n    function enqueue(method, arg) {\\n      function callInvokeWithMethodAndArg() {\\n        return new PromiseImpl(function(resolve, reject) {\\n          invoke(method, arg, resolve, reject);\\n        });\\n      }\\n\\n      return previousPromise =\\n        // If enqueue has been called before, then we want to wait until\\n        // all previous Promises have been resolved before calling invoke,\\n        // so that results are always delivered in the correct order. If\\n        // enqueue has not been called before, then it is important to\\n        // call invoke immediately, without waiting on a callback to fire,\\n        // so that the async generator function has the opportunity to do\\n        // any necessary setup in a predictable way. This predictability\\n        // is why the Promise constructor synchronously invokes its\\n        // executor callback, and why async functions synchronously\\n        // execute code before the first await. Since we implement simple\\n        // async functions in terms of async generators, it is especially\\n        // important to get this right, even though it requires care.\\n        previousPromise ? previousPromise.then(\\n          callInvokeWithMethodAndArg,\\n          // Avoid propagating failures to Promises returned by later\\n          // invocations of the iterator.\\n          callInvokeWithMethodAndArg\\n        ) : callInvokeWithMethodAndArg();\\n    }\\n\\n    // Define the unified helper method that is used to implement .next,\\n    // .throw, and .return (see defineIteratorMethods).\\n    this._invoke = enqueue;\\n  }\\n\\n  defineIteratorMethods(AsyncIterator.prototype);\\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\\n    return this;\\n  };\\n  exports.AsyncIterator = AsyncIterator;\\n\\n  // Note that simple async functions are implemented on top of\\n  // AsyncIterator objects; they just return a Promise for the value of\\n  // the final result produced by the iterator.\\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\\n\\n    var iter = new AsyncIterator(\\n      wrap(innerFn, outerFn, self, tryLocsList),\\n      PromiseImpl\\n    );\\n\\n    return exports.isGeneratorFunction(outerFn)\\n      ? iter // If outerFn is a generator, return the full iterator.\\n      : iter.next().then(function(result) {\\n          return result.done ? result.value : iter.next();\\n        });\\n  };\\n\\n  function makeInvokeMethod(innerFn, self, context) {\\n    var state = GenStateSuspendedStart;\\n\\n    return function invoke(method, arg) {\\n      if (state === GenStateExecuting) {\\n        throw new Error(\\\"Generator is already running\\\");\\n      }\\n\\n      if (state === GenStateCompleted) {\\n        if (method === \\\"throw\\\") {\\n          throw arg;\\n        }\\n\\n        // Be forgiving, per 25.3.3.3.3 of the spec:\\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\\n        return doneResult();\\n      }\\n\\n      context.method = method;\\n      context.arg = arg;\\n\\n      while (true) {\\n        var delegate = context.delegate;\\n        if (delegate) {\\n          var delegateResult = maybeInvokeDelegate(delegate, context);\\n          if (delegateResult) {\\n            if (delegateResult === ContinueSentinel) continue;\\n            return delegateResult;\\n          }\\n        }\\n\\n        if (context.method === \\\"next\\\") {\\n          // Setting context._sent for legacy support of Babel's\\n          // function.sent implementation.\\n          context.sent = context._sent = context.arg;\\n\\n        } else if (context.method === \\\"throw\\\") {\\n          if (state === GenStateSuspendedStart) {\\n            state = GenStateCompleted;\\n            throw context.arg;\\n          }\\n\\n          context.dispatchException(context.arg);\\n\\n        } else if (context.method === \\\"return\\\") {\\n          context.abrupt(\\\"return\\\", context.arg);\\n        }\\n\\n        state = GenStateExecuting;\\n\\n        var record = tryCatch(innerFn, self, context);\\n        if (record.type === \\\"normal\\\") {\\n          // If an exception is thrown from innerFn, we leave state ===\\n          // GenStateExecuting and loop back for another invocation.\\n          state = context.done\\n            ? GenStateCompleted\\n            : GenStateSuspendedYield;\\n\\n          if (record.arg === ContinueSentinel) {\\n            continue;\\n          }\\n\\n          return {\\n            value: record.arg,\\n            done: context.done\\n          };\\n\\n        } else if (record.type === \\\"throw\\\") {\\n          state = GenStateCompleted;\\n          // Dispatch the exception by looping back around to the\\n          // context.dispatchException(context.arg) call above.\\n          context.method = \\\"throw\\\";\\n          context.arg = record.arg;\\n        }\\n      }\\n    };\\n  }\\n\\n  // Call delegate.iterator[context.method](context.arg) and handle the\\n  // result, either by returning a { value, done } result from the\\n  // delegate iterator, or by modifying context.method and context.arg,\\n  // setting context.delegate to null, and returning the ContinueSentinel.\\n  function maybeInvokeDelegate(delegate, context) {\\n    var method = delegate.iterator[context.method];\\n    if (method === undefined) {\\n      // A .throw or .return when the delegate iterator has no .throw\\n      // method always terminates the yield* loop.\\n      context.delegate = null;\\n\\n      if (context.method === \\\"throw\\\") {\\n        // Note: [\\\"return\\\"] must be used for ES3 parsing compatibility.\\n        if (delegate.iterator[\\\"return\\\"]) {\\n          // If the delegate iterator has a return method, give it a\\n          // chance to clean up.\\n          context.method = \\\"return\\\";\\n          context.arg = undefined;\\n          maybeInvokeDelegate(delegate, context);\\n\\n          if (context.method === \\\"throw\\\") {\\n            // If maybeInvokeDelegate(context) changed context.method from\\n            // \\\"return\\\" to \\\"throw\\\", let that override the TypeError below.\\n            return ContinueSentinel;\\n          }\\n        }\\n\\n        context.method = \\\"throw\\\";\\n        context.arg = new TypeError(\\n          \\\"The iterator does not provide a 'throw' method\\\");\\n      }\\n\\n      return ContinueSentinel;\\n    }\\n\\n    var record = tryCatch(method, delegate.iterator, context.arg);\\n\\n    if (record.type === \\\"throw\\\") {\\n      context.method = \\\"throw\\\";\\n      context.arg = record.arg;\\n      context.delegate = null;\\n      return ContinueSentinel;\\n    }\\n\\n    var info = record.arg;\\n\\n    if (! info) {\\n      context.method = \\\"throw\\\";\\n      context.arg = new TypeError(\\\"iterator result is not an object\\\");\\n      context.delegate = null;\\n      return ContinueSentinel;\\n    }\\n\\n    if (info.done) {\\n      // Assign the result of the finished delegate to the temporary\\n      // variable specified by delegate.resultName (see delegateYield).\\n      context[delegate.resultName] = info.value;\\n\\n      // Resume execution at the desired location (see delegateYield).\\n      context.next = delegate.nextLoc;\\n\\n      // If context.method was \\\"throw\\\" but the delegate handled the\\n      // exception, let the outer generator proceed normally. If\\n      // context.method was \\\"next\\\", forget context.arg since it has been\\n      // \\\"consumed\\\" by the delegate iterator. If context.method was\\n      // \\\"return\\\", allow the original .return call to continue in the\\n      // outer generator.\\n      if (context.method !== \\\"return\\\") {\\n        context.method = \\\"next\\\";\\n        context.arg = undefined;\\n      }\\n\\n    } else {\\n      // Re-yield the result returned by the delegate method.\\n      return info;\\n    }\\n\\n    // The delegate iterator is finished, so forget it and continue with\\n    // the outer generator.\\n    context.delegate = null;\\n    return ContinueSentinel;\\n  }\\n\\n  // Define Generator.prototype.{next,throw,return} in terms of the\\n  // unified ._invoke helper method.\\n  defineIteratorMethods(Gp);\\n\\n  Gp[toStringTagSymbol] = \\\"Generator\\\";\\n\\n  // A Generator should always return itself as the iterator object when the\\n  // @@iterator function is called on it. Some browsers' implementations of the\\n  // iterator prototype chain incorrectly implement this, causing the Generator\\n  // object to not be returned from this call. This ensures that doesn't happen.\\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\\n  Gp[iteratorSymbol] = function() {\\n    return this;\\n  };\\n\\n  Gp.toString = function() {\\n    return \\\"[object Generator]\\\";\\n  };\\n\\n  function pushTryEntry(locs) {\\n    var entry = { tryLoc: locs[0] };\\n\\n    if (1 in locs) {\\n      entry.catchLoc = locs[1];\\n    }\\n\\n    if (2 in locs) {\\n      entry.finallyLoc = locs[2];\\n      entry.afterLoc = locs[3];\\n    }\\n\\n    this.tryEntries.push(entry);\\n  }\\n\\n  function resetTryEntry(entry) {\\n    var record = entry.completion || {};\\n    record.type = \\\"normal\\\";\\n    delete record.arg;\\n    entry.completion = record;\\n  }\\n\\n  function Context(tryLocsList) {\\n    // The root entry object (effectively a try statement without a catch\\n    // or a finally block) gives us a place to store values thrown from\\n    // locations where there is no enclosing try statement.\\n    this.tryEntries = [{ tryLoc: \\\"root\\\" }];\\n    tryLocsList.forEach(pushTryEntry, this);\\n    this.reset(true);\\n  }\\n\\n  exports.keys = function(object) {\\n    var keys = [];\\n    for (var key in object) {\\n      keys.push(key);\\n    }\\n    keys.reverse();\\n\\n    // Rather than returning an object with a next method, we keep\\n    // things simple and return the next function itself.\\n    return function next() {\\n      while (keys.length) {\\n        var key = keys.pop();\\n        if (key in object) {\\n          next.value = key;\\n          next.done = false;\\n          return next;\\n        }\\n      }\\n\\n      // To avoid creating an additional object, we just hang the .value\\n      // and .done properties off the next function object itself. This\\n      // also ensures that the minifier will not anonymize the function.\\n      next.done = true;\\n      return next;\\n    };\\n  };\\n\\n  function values(iterable) {\\n    if (iterable) {\\n      var iteratorMethod = iterable[iteratorSymbol];\\n      if (iteratorMethod) {\\n        return iteratorMethod.call(iterable);\\n      }\\n\\n      if (typeof iterable.next === \\\"function\\\") {\\n        return iterable;\\n      }\\n\\n      if (!isNaN(iterable.length)) {\\n        var i = -1, next = function next() {\\n          while (++i < iterable.length) {\\n            if (hasOwn.call(iterable, i)) {\\n              next.value = iterable[i];\\n              next.done = false;\\n              return next;\\n            }\\n          }\\n\\n          next.value = undefined;\\n          next.done = true;\\n\\n          return next;\\n        };\\n\\n        return next.next = next;\\n      }\\n    }\\n\\n    // Return an iterator with no values.\\n    return { next: doneResult };\\n  }\\n  exports.values = values;\\n\\n  function doneResult() {\\n    return { value: undefined, done: true };\\n  }\\n\\n  Context.prototype = {\\n    constructor: Context,\\n\\n    reset: function(skipTempReset) {\\n      this.prev = 0;\\n      this.next = 0;\\n      // Resetting context._sent for legacy support of Babel's\\n      // function.sent implementation.\\n      this.sent = this._sent = undefined;\\n      this.done = false;\\n      this.delegate = null;\\n\\n      this.method = \\\"next\\\";\\n      this.arg = undefined;\\n\\n      this.tryEntries.forEach(resetTryEntry);\\n\\n      if (!skipTempReset) {\\n        for (var name in this) {\\n          // Not sure about the optimal order of these conditions:\\n          if (name.charAt(0) === \\\"t\\\" &&\\n              hasOwn.call(this, name) &&\\n              !isNaN(+name.slice(1))) {\\n            this[name] = undefined;\\n          }\\n        }\\n      }\\n    },\\n\\n    stop: function() {\\n      this.done = true;\\n\\n      var rootEntry = this.tryEntries[0];\\n      var rootRecord = rootEntry.completion;\\n      if (rootRecord.type === \\\"throw\\\") {\\n        throw rootRecord.arg;\\n      }\\n\\n      return this.rval;\\n    },\\n\\n    dispatchException: function(exception) {\\n      if (this.done) {\\n        throw exception;\\n      }\\n\\n      var context = this;\\n      function handle(loc, caught) {\\n        record.type = \\\"throw\\\";\\n        record.arg = exception;\\n        context.next = loc;\\n\\n        if (caught) {\\n          // If the dispatched exception was caught by a catch block,\\n          // then let that catch block handle the exception normally.\\n          context.method = \\\"next\\\";\\n          context.arg = undefined;\\n        }\\n\\n        return !! caught;\\n      }\\n\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        var record = entry.completion;\\n\\n        if (entry.tryLoc === \\\"root\\\") {\\n          // Exception thrown outside of any try block that could handle\\n          // it, so set the completion value of the entire function to\\n          // throw the exception.\\n          return handle(\\\"end\\\");\\n        }\\n\\n        if (entry.tryLoc <= this.prev) {\\n          var hasCatch = hasOwn.call(entry, \\\"catchLoc\\\");\\n          var hasFinally = hasOwn.call(entry, \\\"finallyLoc\\\");\\n\\n          if (hasCatch && hasFinally) {\\n            if (this.prev < entry.catchLoc) {\\n              return handle(entry.catchLoc, true);\\n            } else if (this.prev < entry.finallyLoc) {\\n              return handle(entry.finallyLoc);\\n            }\\n\\n          } else if (hasCatch) {\\n            if (this.prev < entry.catchLoc) {\\n              return handle(entry.catchLoc, true);\\n            }\\n\\n          } else if (hasFinally) {\\n            if (this.prev < entry.finallyLoc) {\\n              return handle(entry.finallyLoc);\\n            }\\n\\n          } else {\\n            throw new Error(\\\"try statement without catch or finally\\\");\\n          }\\n        }\\n      }\\n    },\\n\\n    abrupt: function(type, arg) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.tryLoc <= this.prev &&\\n            hasOwn.call(entry, \\\"finallyLoc\\\") &&\\n            this.prev < entry.finallyLoc) {\\n          var finallyEntry = entry;\\n          break;\\n        }\\n      }\\n\\n      if (finallyEntry &&\\n          (type === \\\"break\\\" ||\\n           type === \\\"continue\\\") &&\\n          finallyEntry.tryLoc <= arg &&\\n          arg <= finallyEntry.finallyLoc) {\\n        // Ignore the finally entry if control is not jumping to a\\n        // location outside the try/catch block.\\n        finallyEntry = null;\\n      }\\n\\n      var record = finallyEntry ? finallyEntry.completion : {};\\n      record.type = type;\\n      record.arg = arg;\\n\\n      if (finallyEntry) {\\n        this.method = \\\"next\\\";\\n        this.next = finallyEntry.finallyLoc;\\n        return ContinueSentinel;\\n      }\\n\\n      return this.complete(record);\\n    },\\n\\n    complete: function(record, afterLoc) {\\n      if (record.type === \\\"throw\\\") {\\n        throw record.arg;\\n      }\\n\\n      if (record.type === \\\"break\\\" ||\\n          record.type === \\\"continue\\\") {\\n        this.next = record.arg;\\n      } else if (record.type === \\\"return\\\") {\\n        this.rval = this.arg = record.arg;\\n        this.method = \\\"return\\\";\\n        this.next = \\\"end\\\";\\n      } else if (record.type === \\\"normal\\\" && afterLoc) {\\n        this.next = afterLoc;\\n      }\\n\\n      return ContinueSentinel;\\n    },\\n\\n    finish: function(finallyLoc) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.finallyLoc === finallyLoc) {\\n          this.complete(entry.completion, entry.afterLoc);\\n          resetTryEntry(entry);\\n          return ContinueSentinel;\\n        }\\n      }\\n    },\\n\\n    \\\"catch\\\": function(tryLoc) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.tryLoc === tryLoc) {\\n          var record = entry.completion;\\n          if (record.type === \\\"throw\\\") {\\n            var thrown = record.arg;\\n            resetTryEntry(entry);\\n          }\\n          return thrown;\\n        }\\n      }\\n\\n      // The context.catch method must only be called with a location\\n      // argument that corresponds to a known catch block.\\n      throw new Error(\\\"illegal catch attempt\\\");\\n    },\\n\\n    delegateYield: function(iterable, resultName, nextLoc) {\\n      this.delegate = {\\n        iterator: values(iterable),\\n        resultName: resultName,\\n        nextLoc: nextLoc\\n      };\\n\\n      if (this.method === \\\"next\\\") {\\n        // Deliberately forget the last sent value so that we don't\\n        // accidentally pass it on to the delegate.\\n        this.arg = undefined;\\n      }\\n\\n      return ContinueSentinel;\\n    }\\n  };\\n\\n  // Regardless of whether this script is executing as a CommonJS module\\n  // or not, return the runtime object so that we can declare the variable\\n  // regeneratorRuntime in the outer scope, which allows this module to be\\n  // injected easily by `bin/regenerator --include-runtime script.js`.\\n  return exports;\\n\\n}(\\n  // If this script is executing as a CommonJS module, use module.exports\\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\\n  // object. Either way, the resulting object will be used to initialize\\n  // the regeneratorRuntime variable at the top of this file.\\n  typeof module === \\\"object\\\" ? module.exports : {}\\n));\\n\\ntry {\\n  regeneratorRuntime = runtime;\\n} catch (accidentalStrictMode) {\\n  // This module should not be running in strict mode, so the above\\n  // assignment should always work unless something is misconfigured. Just\\n  // in case runtime.js accidentally runs in strict mode, we can escape\\n  // strict mode using a global Function call. This could conceivably fail\\n  // if a Content Security Policy forbids using Function, but in that case\\n  // the proper solution is to fix the accidental strict mode problem. If\\n  // you've misconfigured your bundler to force strict mode and applied a\\n  // CSP to forbid Function, and you're not willing to fix either of those\\n  // problems, please detail your unique predicament in a GitHub issue.\\n  Function(\\\"r\\\", \\\"regeneratorRuntime = r\\\")(runtime);\\n}\\n\\n},{}],53:[function(require,module,exports){\\n/* eslint-disable node/no-deprecated-api */\\nvar buffer = require('buffer')\\nvar Buffer = buffer.Buffer\\n\\n// alternative to using Object.keys for old browsers\\nfunction copyProps (src, dst) {\\n  for (var key in src) {\\n    dst[key] = src[key]\\n  }\\n}\\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\\n  module.exports = buffer\\n} else {\\n  // Copy properties from require('buffer')\\n  copyProps(buffer, exports)\\n  exports.Buffer = SafeBuffer\\n}\\n\\nfunction SafeBuffer (arg, encodingOrOffset, length) {\\n  return Buffer(arg, encodingOrOffset, length)\\n}\\n\\nSafeBuffer.prototype = Object.create(Buffer.prototype)\\n\\n// Copy static methods from Buffer\\ncopyProps(Buffer, SafeBuffer)\\n\\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\\n  if (typeof arg === 'number') {\\n    throw new TypeError('Argument must not be a number')\\n  }\\n  return Buffer(arg, encodingOrOffset, length)\\n}\\n\\nSafeBuffer.alloc = function (size, fill, encoding) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('Argument must be a number')\\n  }\\n  var buf = Buffer(size)\\n  if (fill !== undefined) {\\n    if (typeof encoding === 'string') {\\n      buf.fill(fill, encoding)\\n    } else {\\n      buf.fill(fill)\\n    }\\n  } else {\\n    buf.fill(0)\\n  }\\n  return buf\\n}\\n\\nSafeBuffer.allocUnsafe = function (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('Argument must be a number')\\n  }\\n  return Buffer(size)\\n}\\n\\nSafeBuffer.allocUnsafeSlow = function (size) {\\n  if (typeof size !== 'number') {\\n    throw new TypeError('Argument must be a number')\\n  }\\n  return buffer.SlowBuffer(size)\\n}\\n\\n},{\\\"buffer\\\":8}],54:[function(require,module,exports){\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.UniversalURL = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\\\"function\\\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\\\"Cannot find module '\\\"+i+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\\\"function\\\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\\n(function (global){\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/*! https://mths.be/punycode v1.4.1 by @mathias */\\n;\\n\\n(function (root) {\\n  /** Detect free variables */\\n  var freeExports = (typeof exports === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\\n  var freeModule = (typeof module === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(module)) == 'object' && module && !module.nodeType && module;\\n  var freeGlobal = (typeof global === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(global)) == 'object' && global;\\n\\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\\n    root = freeGlobal;\\n  }\\n  /**\\n   * The `punycode` object.\\n   * @name punycode\\n   * @type Object\\n   */\\n\\n\\n  var punycode,\\n\\n  /** Highest positive signed 32-bit float value */\\n  maxInt = 2147483647,\\n      // aka. 0x7FFFFFFF or 2^31-1\\n\\n  /** Bootstring parameters */\\n  base = 36,\\n      tMin = 1,\\n      tMax = 26,\\n      skew = 38,\\n      damp = 700,\\n      initialBias = 72,\\n      initialN = 128,\\n      // 0x80\\n  delimiter = '-',\\n      // '\\\\x2D'\\n\\n  /** Regular expressions */\\n  regexPunycode = /^xn--/,\\n      regexNonASCII = /[^\\\\x20-\\\\x7E]/,\\n      // unprintable ASCII chars + non-ASCII chars\\n  regexSeparators = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g,\\n      // RFC 3490 separators\\n\\n  /** Error messages */\\n  errors = {\\n    'overflow': 'Overflow: input needs wider integers to process',\\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\\n    'invalid-input': 'Invalid input'\\n  },\\n\\n  /** Convenience shortcuts */\\n  baseMinusTMin = base - tMin,\\n      floor = Math.floor,\\n      stringFromCharCode = String.fromCharCode,\\n\\n  /** Temporary variable */\\n  key;\\n  /*--------------------------------------------------------------------------*/\\n\\n  /**\\n   * A generic error utility function.\\n   * @private\\n   * @param {String} type The error type.\\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\\n   */\\n\\n  function error(type) {\\n    throw new RangeError(errors[type]);\\n  }\\n  /**\\n   * A generic `Array#map` utility function.\\n   * @private\\n   * @param {Array} array The array to iterate over.\\n   * @param {Function} callback The function that gets called for every array\\n   * item.\\n   * @returns {Array} A new array of values returned by the callback function.\\n   */\\n\\n\\n  function map(array, fn) {\\n    var length = array.length;\\n    var result = [];\\n\\n    while (length--) {\\n      result[length] = fn(array[length]);\\n    }\\n\\n    return result;\\n  }\\n  /**\\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\\n   * addresses.\\n   * @private\\n   * @param {String} domain The domain name or email address.\\n   * @param {Function} callback The function that gets called for every\\n   * character.\\n   * @returns {Array} A new string of characters returned by the callback\\n   * function.\\n   */\\n\\n\\n  function mapDomain(string, fn) {\\n    var parts = string.split('@');\\n    var result = '';\\n\\n    if (parts.length > 1) {\\n      // In email addresses, only the domain name should be punycoded. Leave\\n      // the local part (i.e. everything up to `@`) intact.\\n      result = parts[0] + '@';\\n      string = parts[1];\\n    } // Avoid `split(regex)` for IE8 compatibility. See #17.\\n\\n\\n    string = string.replace(regexSeparators, '\\\\x2E');\\n    var labels = string.split('.');\\n    var encoded = map(labels, fn).join('.');\\n    return result + encoded;\\n  }\\n  /**\\n   * Creates an array containing the numeric code points of each Unicode\\n   * character in the string. While JavaScript uses UCS-2 internally,\\n   * this function will convert a pair of surrogate halves (each of which\\n   * UCS-2 exposes as separate characters) into a single code point,\\n   * matching UTF-16.\\n   * @see `punycode.ucs2.encode`\\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n   * @memberOf punycode.ucs2\\n   * @name decode\\n   * @param {String} string The Unicode input string (UCS-2).\\n   * @returns {Array} The new array of code points.\\n   */\\n\\n\\n  function ucs2decode(string) {\\n    var output = [],\\n        counter = 0,\\n        length = string.length,\\n        value,\\n        extra;\\n\\n    while (counter < length) {\\n      value = string.charCodeAt(counter++);\\n\\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n        // high surrogate, and there is a next character\\n        extra = string.charCodeAt(counter++);\\n\\n        if ((extra & 0xFC00) == 0xDC00) {\\n          // low surrogate\\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n        } else {\\n          // unmatched surrogate; only append this code unit, in case the next\\n          // code unit is the high surrogate of a surrogate pair\\n          output.push(value);\\n          counter--;\\n        }\\n      } else {\\n        output.push(value);\\n      }\\n    }\\n\\n    return output;\\n  }\\n  /**\\n   * Creates a string based on an array of numeric code points.\\n   * @see `punycode.ucs2.decode`\\n   * @memberOf punycode.ucs2\\n   * @name encode\\n   * @param {Array} codePoints The array of numeric code points.\\n   * @returns {String} The new Unicode string (UCS-2).\\n   */\\n\\n\\n  function ucs2encode(array) {\\n    return map(array, function (value) {\\n      var output = '';\\n\\n      if (value > 0xFFFF) {\\n        value -= 0x10000;\\n        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\\n        value = 0xDC00 | value & 0x3FF;\\n      }\\n\\n      output += stringFromCharCode(value);\\n      return output;\\n    }).join('');\\n  }\\n  /**\\n   * Converts a basic code point into a digit/integer.\\n   * @see `digitToBasic()`\\n   * @private\\n   * @param {Number} codePoint The basic numeric code point value.\\n   * @returns {Number} The numeric value of a basic code point (for use in\\n   * representing integers) in the range `0` to `base - 1`, or `base` if\\n   * the code point does not represent a value.\\n   */\\n\\n\\n  function basicToDigit(codePoint) {\\n    if (codePoint - 48 < 10) {\\n      return codePoint - 22;\\n    }\\n\\n    if (codePoint - 65 < 26) {\\n      return codePoint - 65;\\n    }\\n\\n    if (codePoint - 97 < 26) {\\n      return codePoint - 97;\\n    }\\n\\n    return base;\\n  }\\n  /**\\n   * Converts a digit/integer into a basic code point.\\n   * @see `basicToDigit()`\\n   * @private\\n   * @param {Number} digit The numeric value of a basic code point.\\n   * @returns {Number} The basic code point whose value (when used for\\n   * representing integers) is `digit`, which needs to be in the range\\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\\n   * used; else, the lowercase form is used. The behavior is undefined\\n   * if `flag` is non-zero and `digit` has no uppercase form.\\n   */\\n\\n\\n  function digitToBasic(digit, flag) {\\n    //  0..25 map to ASCII a..z or A..Z\\n    // 26..35 map to ASCII 0..9\\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\\n  }\\n  /**\\n   * Bias adaptation function as per section 3.4 of RFC 3492.\\n   * https://tools.ietf.org/html/rfc3492#section-3.4\\n   * @private\\n   */\\n\\n\\n  function adapt(delta, numPoints, firstTime) {\\n    var k = 0;\\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\\n    delta += floor(delta / numPoints);\\n\\n    for (;\\n    /* no initialization */\\n    delta > baseMinusTMin * tMax >> 1; k += base) {\\n      delta = floor(delta / baseMinusTMin);\\n    }\\n\\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\n  }\\n  /**\\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\\n   * symbols.\\n   * @memberOf punycode\\n   * @param {String} input The Punycode string of ASCII-only symbols.\\n   * @returns {String} The resulting string of Unicode symbols.\\n   */\\n\\n\\n  function decode(input) {\\n    // Don't use UCS-2\\n    var output = [],\\n        inputLength = input.length,\\n        out,\\n        i = 0,\\n        n = initialN,\\n        bias = initialBias,\\n        basic,\\n        j,\\n        index,\\n        oldi,\\n        w,\\n        k,\\n        digit,\\n        t,\\n\\n    /** Cached calculation results */\\n    baseMinusT; // Handle the basic code points: let `basic` be the number of input code\\n    // points before the last delimiter, or `0` if there is none, then copy\\n    // the first basic code points to the output.\\n\\n    basic = input.lastIndexOf(delimiter);\\n\\n    if (basic < 0) {\\n      basic = 0;\\n    }\\n\\n    for (j = 0; j < basic; ++j) {\\n      // if it's not a basic code point\\n      if (input.charCodeAt(j) >= 0x80) {\\n        error('not-basic');\\n      }\\n\\n      output.push(input.charCodeAt(j));\\n    } // Main decoding loop: start just after the last delimiter if any basic code\\n    // points were copied; start at the beginning otherwise.\\n\\n\\n    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)\\n    /* no final expression */\\n    {\\n      // `index` is the index of the next character to be consumed.\\n      // Decode a generalized variable-length integer into `delta`,\\n      // which gets added to `i`. The overflow checking is easier\\n      // if we increase `i` as we go, then subtract off its starting\\n      // value at the end to obtain `delta`.\\n      for (oldi = i, w = 1, k = base;;\\n      /* no condition */\\n      k += base) {\\n        if (index >= inputLength) {\\n          error('invalid-input');\\n        }\\n\\n        digit = basicToDigit(input.charCodeAt(index++));\\n\\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\\n          error('overflow');\\n        }\\n\\n        i += digit * w;\\n        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\\n\\n        if (digit < t) {\\n          break;\\n        }\\n\\n        baseMinusT = base - t;\\n\\n        if (w > floor(maxInt / baseMinusT)) {\\n          error('overflow');\\n        }\\n\\n        w *= baseMinusT;\\n      }\\n\\n      out = output.length + 1;\\n      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\\n      // incrementing `n` each time, so we'll fix that now:\\n\\n      if (floor(i / out) > maxInt - n) {\\n        error('overflow');\\n      }\\n\\n      n += floor(i / out);\\n      i %= out; // Insert `n` at position `i` of the output\\n\\n      output.splice(i++, 0, n);\\n    }\\n\\n    return ucs2encode(output);\\n  }\\n  /**\\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\\n   * Punycode string of ASCII-only symbols.\\n   * @memberOf punycode\\n   * @param {String} input The string of Unicode symbols.\\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\\n   */\\n\\n\\n  function encode(input) {\\n    var n,\\n        delta,\\n        handledCPCount,\\n        basicLength,\\n        bias,\\n        j,\\n        m,\\n        q,\\n        k,\\n        t,\\n        currentValue,\\n        output = [],\\n\\n    /** `inputLength` will hold the number of code points in `input`. */\\n    inputLength,\\n\\n    /** Cached calculation results */\\n    handledCPCountPlusOne,\\n        baseMinusT,\\n        qMinusT; // Convert the input in UCS-2 to Unicode\\n\\n    input = ucs2decode(input); // Cache the length\\n\\n    inputLength = input.length; // Initialize the state\\n\\n    n = initialN;\\n    delta = 0;\\n    bias = initialBias; // Handle the basic code points\\n\\n    for (j = 0; j < inputLength; ++j) {\\n      currentValue = input[j];\\n\\n      if (currentValue < 0x80) {\\n        output.push(stringFromCharCode(currentValue));\\n      }\\n    }\\n\\n    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\\n    // `basicLength` is the number of basic code points.\\n    // Finish the basic string - if it is not empty - with a delimiter\\n\\n    if (basicLength) {\\n      output.push(delimiter);\\n    } // Main encoding loop:\\n\\n\\n    while (handledCPCount < inputLength) {\\n      // All non-basic code points < n have been handled already. Find the next\\n      // larger one:\\n      for (m = maxInt, j = 0; j < inputLength; ++j) {\\n        currentValue = input[j];\\n\\n        if (currentValue >= n && currentValue < m) {\\n          m = currentValue;\\n        }\\n      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\\n      // but guard against overflow\\n\\n\\n      handledCPCountPlusOne = handledCPCount + 1;\\n\\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\n        error('overflow');\\n      }\\n\\n      delta += (m - n) * handledCPCountPlusOne;\\n      n = m;\\n\\n      for (j = 0; j < inputLength; ++j) {\\n        currentValue = input[j];\\n\\n        if (currentValue < n && ++delta > maxInt) {\\n          error('overflow');\\n        }\\n\\n        if (currentValue == n) {\\n          // Represent delta as a generalized variable-length integer\\n          for (q = delta, k = base;;\\n          /* no condition */\\n          k += base) {\\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\\n\\n            if (q < t) {\\n              break;\\n            }\\n\\n            qMinusT = q - t;\\n            baseMinusT = base - t;\\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\\n            q = floor(qMinusT / baseMinusT);\\n          }\\n\\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\n          delta = 0;\\n          ++handledCPCount;\\n        }\\n      }\\n\\n      ++delta;\\n      ++n;\\n    }\\n\\n    return output.join('');\\n  }\\n  /**\\n   * Converts a Punycode string representing a domain name or an email address\\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\\n   * it doesn't matter if you call it on a string that has already been\\n   * converted to Unicode.\\n   * @memberOf punycode\\n   * @param {String} input The Punycoded domain name or email address to\\n   * convert to Unicode.\\n   * @returns {String} The Unicode representation of the given Punycode\\n   * string.\\n   */\\n\\n\\n  function toUnicode(input) {\\n    return mapDomain(input, function (string) {\\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\\n    });\\n  }\\n  /**\\n   * Converts a Unicode string representing a domain name or an email address to\\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\\n   * i.e. it doesn't matter if you call it with a domain that's already in\\n   * ASCII.\\n   * @memberOf punycode\\n   * @param {String} input The domain name or email address to convert, as a\\n   * Unicode string.\\n   * @returns {String} The Punycode representation of the given domain name or\\n   * email address.\\n   */\\n\\n\\n  function toASCII(input) {\\n    return mapDomain(input, function (string) {\\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\\n    });\\n  }\\n  /*--------------------------------------------------------------------------*/\\n\\n  /** Define the public API */\\n\\n\\n  punycode = {\\n    /**\\n     * A string representing the current Punycode.js version number.\\n     * @memberOf punycode\\n     * @type String\\n     */\\n    'version': '1.4.1',\\n\\n    /**\\n     * An object of methods to convert from JavaScript's internal character\\n     * representation (UCS-2) to Unicode code points, and back.\\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n     * @memberOf punycode\\n     * @type Object\\n     */\\n    'ucs2': {\\n      'decode': ucs2decode,\\n      'encode': ucs2encode\\n    },\\n    'decode': decode,\\n    'encode': encode,\\n    'toASCII': toASCII,\\n    'toUnicode': toUnicode\\n  };\\n  /** Expose `punycode` */\\n  // Some AMD build optimizers, like r.js, check for specific condition patterns\\n  // like the following:\\n\\n  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\\n    define('punycode', function () {\\n      return punycode;\\n    });\\n  } else if (freeExports && freeModule) {\\n    if (module.exports == freeExports) {\\n      // in Node.js, io.js, or RingoJS v0.8.0+\\n      freeModule.exports = punycode;\\n    } else {\\n      // in Narwhal or RingoJS v0.7.0-\\n      for (key in punycode) {\\n        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\\n      }\\n    }\\n  } else {\\n    // in Rhino or a web browser\\n    root.punycode = punycode;\\n  }\\n})(void 0);\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],2:[function(require,module,exports){\\n'use strict';\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nvar strValue = String.prototype.valueOf;\\n\\nvar tryStringObject = function tryStringObject(value) {\\n  try {\\n    strValue.call(value);\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\nvar toStr = Object.prototype.toString;\\nvar strClass = '[object String]';\\nvar hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';\\n\\nmodule.exports = function isString(value) {\\n  if (typeof value === 'string') {\\n    return true;\\n  }\\n\\n  if (_typeof(value) !== 'object') {\\n    return false;\\n  }\\n\\n  return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;\\n};\\n\\n},{}],3:[function(require,module,exports){\\n(function (global){\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n * lodash (Custom Build) <https://lodash.com/>\\n * Build: `lodash modularize exports=\\\"npm\\\" -o ./`\\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\\n * Released under MIT license <https://lodash.com/license>\\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\\n */\\n\\n/** Used as the size to enable large array optimizations. */\\nvar LARGE_ARRAY_SIZE = 200;\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\n\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n/** Used to stand-in for `undefined` hash values. */\\n\\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\\n/** Used to compose bitmasks for comparison styles. */\\n\\nvar UNORDERED_COMPARE_FLAG = 1,\\n    PARTIAL_COMPARE_FLAG = 2;\\n/** Used as references for various `Number` constants. */\\n\\nvar INFINITY = 1 / 0,\\n    MAX_SAFE_INTEGER = 9007199254740991;\\n/** `Object#toString` result references. */\\n\\nvar argsTag = '[object Arguments]',\\n    arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    genTag = '[object GeneratorFunction]',\\n    mapTag = '[object Map]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    promiseTag = '[object Promise]',\\n    regexpTag = '[object RegExp]',\\n    setTag = '[object Set]',\\n    stringTag = '[object String]',\\n    symbolTag = '[object Symbol]',\\n    weakMapTag = '[object WeakMap]';\\nvar arrayBufferTag = '[object ArrayBuffer]',\\n    dataViewTag = '[object DataView]',\\n    float32Tag = '[object Float32Array]',\\n    float64Tag = '[object Float64Array]',\\n    int8Tag = '[object Int8Array]',\\n    int16Tag = '[object Int16Array]',\\n    int32Tag = '[object Int32Array]',\\n    uint8Tag = '[object Uint8Array]',\\n    uint8ClampedTag = '[object Uint8ClampedArray]',\\n    uint16Tag = '[object Uint16Array]',\\n    uint32Tag = '[object Uint32Array]';\\n/** Used to match property names within property paths. */\\n\\nvar reIsDeepProp = /\\\\.|\\\\[(?:[^[\\\\]]*|([\\\"'])(?:(?!\\\\1)[^\\\\\\\\]|\\\\\\\\.)*?\\\\1)\\\\]/,\\n    reIsPlainProp = /^\\\\w*$/,\\n    reLeadingDot = /^\\\\./,\\n    rePropName = /[^.[\\\\]]+|\\\\[(?:(-?\\\\d+(?:\\\\.\\\\d+)?)|([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2)\\\\]|(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))/g;\\n/**\\n * Used to match `RegExp`\\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\\n */\\n\\nvar reRegExpChar = /[\\\\\\\\^$.*+?()[\\\\]{}|]/g;\\n/** Used to match backslashes in property paths. */\\n\\nvar reEscapeChar = /\\\\\\\\(\\\\\\\\)?/g;\\n/** Used to detect host constructors (Safari). */\\n\\nvar reIsHostCtor = /^\\\\[object .+?Constructor\\\\]$/;\\n/** Used to detect unsigned integer values. */\\n\\nvar reIsUint = /^(?:0|[1-9]\\\\d*)$/;\\n/** Used to identify `toStringTag` values of typed arrays. */\\n\\nvar typedArrayTags = {};\\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\\n/** Detect free variable `global` from Node.js. */\\n\\nvar freeGlobal = (typeof global === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\\n/** Detect free variable `self`. */\\n\\nvar freeSelf = (typeof self === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\\n/** Used as a reference to the global object. */\\n\\nvar root = freeGlobal || freeSelf || Function('return this')();\\n/** Detect free variable `exports`. */\\n\\nvar freeExports = (typeof exports === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\\n/** Detect free variable `module`. */\\n\\nvar freeModule = freeExports && (typeof module === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(module)) == 'object' && module && !module.nodeType && module;\\n/** Detect the popular CommonJS extension `module.exports`. */\\n\\nvar moduleExports = freeModule && freeModule.exports === freeExports;\\n/** Detect free variable `process` from Node.js. */\\n\\nvar freeProcess = moduleExports && freeGlobal.process;\\n/** Used to access faster Node.js helpers. */\\n\\nvar nodeUtil = function () {\\n  try {\\n    return freeProcess && freeProcess.binding('util');\\n  } catch (e) {}\\n}();\\n/* Node.js helper references. */\\n\\n\\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\\n/**\\n * A faster alternative to `Function#apply`, this function invokes `func`\\n * with the `this` binding of `thisArg` and the arguments of `args`.\\n *\\n * @private\\n * @param {Function} func The function to invoke.\\n * @param {*} thisArg The `this` binding of `func`.\\n * @param {Array} args The arguments to invoke `func` with.\\n * @returns {*} Returns the result of `func`.\\n */\\n\\nfunction apply(func, thisArg, args) {\\n  switch (args.length) {\\n    case 0:\\n      return func.call(thisArg);\\n\\n    case 1:\\n      return func.call(thisArg, args[0]);\\n\\n    case 2:\\n      return func.call(thisArg, args[0], args[1]);\\n\\n    case 3:\\n      return func.call(thisArg, args[0], args[1], args[2]);\\n  }\\n\\n  return func.apply(thisArg, args);\\n}\\n/**\\n * A specialized version of `_.map` for arrays without support for iteratee\\n * shorthands.\\n *\\n * @private\\n * @param {Array} [array] The array to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns the new mapped array.\\n */\\n\\n\\nfunction arrayMap(array, iteratee) {\\n  var index = -1,\\n      length = array ? array.length : 0,\\n      result = Array(length);\\n\\n  while (++index < length) {\\n    result[index] = iteratee(array[index], index, array);\\n  }\\n\\n  return result;\\n}\\n/**\\n * Appends the elements of `values` to `array`.\\n *\\n * @private\\n * @param {Array} array The array to modify.\\n * @param {Array} values The values to append.\\n * @returns {Array} Returns `array`.\\n */\\n\\n\\nfunction arrayPush(array, values) {\\n  var index = -1,\\n      length = values.length,\\n      offset = array.length;\\n\\n  while (++index < length) {\\n    array[offset + index] = values[index];\\n  }\\n\\n  return array;\\n}\\n/**\\n * A specialized version of `_.some` for arrays without support for iteratee\\n * shorthands.\\n *\\n * @private\\n * @param {Array} [array] The array to iterate over.\\n * @param {Function} predicate The function invoked per iteration.\\n * @returns {boolean} Returns `true` if any element passes the predicate check,\\n *  else `false`.\\n */\\n\\n\\nfunction arraySome(array, predicate) {\\n  var index = -1,\\n      length = array ? array.length : 0;\\n\\n  while (++index < length) {\\n    if (predicate(array[index], index, array)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n/**\\n * The base implementation of `_.property` without support for deep paths.\\n *\\n * @private\\n * @param {string} key The key of the property to get.\\n * @returns {Function} Returns the new accessor function.\\n */\\n\\n\\nfunction baseProperty(key) {\\n  return function (object) {\\n    return object == null ? undefined : object[key];\\n  };\\n}\\n/**\\n * The base implementation of `_.sortBy` which uses `comparer` to define the\\n * sort order of `array` and replaces criteria objects with their corresponding\\n * values.\\n *\\n * @private\\n * @param {Array} array The array to sort.\\n * @param {Function} comparer The function to define sort order.\\n * @returns {Array} Returns `array`.\\n */\\n\\n\\nfunction baseSortBy(array, comparer) {\\n  var length = array.length;\\n  array.sort(comparer);\\n\\n  while (length--) {\\n    array[length] = array[length].value;\\n  }\\n\\n  return array;\\n}\\n/**\\n * The base implementation of `_.times` without support for iteratee shorthands\\n * or max array length checks.\\n *\\n * @private\\n * @param {number} n The number of times to invoke `iteratee`.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns the array of results.\\n */\\n\\n\\nfunction baseTimes(n, iteratee) {\\n  var index = -1,\\n      result = Array(n);\\n\\n  while (++index < n) {\\n    result[index] = iteratee(index);\\n  }\\n\\n  return result;\\n}\\n/**\\n * The base implementation of `_.unary` without support for storing metadata.\\n *\\n * @private\\n * @param {Function} func The function to cap arguments for.\\n * @returns {Function} Returns the new capped function.\\n */\\n\\n\\nfunction baseUnary(func) {\\n  return function (value) {\\n    return func(value);\\n  };\\n}\\n/**\\n * Gets the value at `key` of `object`.\\n *\\n * @private\\n * @param {Object} [object] The object to query.\\n * @param {string} key The key of the property to get.\\n * @returns {*} Returns the property value.\\n */\\n\\n\\nfunction getValue(object, key) {\\n  return object == null ? undefined : object[key];\\n}\\n/**\\n * Checks if `value` is a host object in IE < 9.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\\n */\\n\\n\\nfunction isHostObject(value) {\\n  // Many host objects are `Object` objects that can coerce to strings\\n  // despite having improperly defined `toString` methods.\\n  var result = false;\\n\\n  if (value != null && typeof value.toString != 'function') {\\n    try {\\n      result = !!(value + '');\\n    } catch (e) {}\\n  }\\n\\n  return result;\\n}\\n/**\\n * Converts `map` to its key-value pairs.\\n *\\n * @private\\n * @param {Object} map The map to convert.\\n * @returns {Array} Returns the key-value pairs.\\n */\\n\\n\\nfunction mapToArray(map) {\\n  var index = -1,\\n      result = Array(map.size);\\n  map.forEach(function (value, key) {\\n    result[++index] = [key, value];\\n  });\\n  return result;\\n}\\n/**\\n * Creates a unary function that invokes `func` with its argument transformed.\\n *\\n * @private\\n * @param {Function} func The function to wrap.\\n * @param {Function} transform The argument transform.\\n * @returns {Function} Returns the new function.\\n */\\n\\n\\nfunction overArg(func, transform) {\\n  return function (arg) {\\n    return func(transform(arg));\\n  };\\n}\\n/**\\n * Converts `set` to an array of its values.\\n *\\n * @private\\n * @param {Object} set The set to convert.\\n * @returns {Array} Returns the values.\\n */\\n\\n\\nfunction setToArray(set) {\\n  var index = -1,\\n      result = Array(set.size);\\n  set.forEach(function (value) {\\n    result[++index] = value;\\n  });\\n  return result;\\n}\\n/** Used for built-in method references. */\\n\\n\\nvar arrayProto = Array.prototype,\\n    funcProto = Function.prototype,\\n    objectProto = Object.prototype;\\n/** Used to detect overreaching core-js shims. */\\n\\nvar coreJsData = root['__core-js_shared__'];\\n/** Used to detect methods masquerading as native. */\\n\\nvar maskSrcKey = function () {\\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\\n  return uid ? 'Symbol(src)_1.' + uid : '';\\n}();\\n/** Used to resolve the decompiled source of functions. */\\n\\n\\nvar funcToString = funcProto.toString;\\n/** Used to check objects for own properties. */\\n\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n/**\\n * Used to resolve the\\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\n\\nvar objectToString = objectProto.toString;\\n/** Used to detect if a method is native. */\\n\\nvar reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?') + '$');\\n/** Built-in value references. */\\n\\nvar _Symbol = root.Symbol,\\n    Uint8Array = root.Uint8Array,\\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\\n    splice = arrayProto.splice,\\n    spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;\\n/* Built-in method references for those with the same name as other `lodash` methods. */\\n\\nvar nativeKeys = overArg(Object.keys, Object),\\n    nativeMax = Math.max;\\n/* Built-in method references that are verified to be native. */\\n\\nvar DataView = getNative(root, 'DataView'),\\n    Map = getNative(root, 'Map'),\\n    Promise = getNative(root, 'Promise'),\\n    Set = getNative(root, 'Set'),\\n    WeakMap = getNative(root, 'WeakMap'),\\n    nativeCreate = getNative(Object, 'create');\\n/** Used to detect maps, sets, and weakmaps. */\\n\\nvar dataViewCtorString = toSource(DataView),\\n    mapCtorString = toSource(Map),\\n    promiseCtorString = toSource(Promise),\\n    setCtorString = toSource(Set),\\n    weakMapCtorString = toSource(WeakMap);\\n/** Used to convert symbols to primitives and strings. */\\n\\nvar symbolProto = _Symbol ? _Symbol.prototype : undefined,\\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\\n/**\\n * Creates a hash object.\\n *\\n * @private\\n * @constructor\\n * @param {Array} [entries] The key-value pairs to cache.\\n */\\n\\nfunction Hash(entries) {\\n  var index = -1,\\n      length = entries ? entries.length : 0;\\n  this.clear();\\n\\n  while (++index < length) {\\n    var entry = entries[index];\\n    this.set(entry[0], entry[1]);\\n  }\\n}\\n/**\\n * Removes all key-value entries from the hash.\\n *\\n * @private\\n * @name clear\\n * @memberOf Hash\\n */\\n\\n\\nfunction hashClear() {\\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\\n}\\n/**\\n * Removes `key` and its value from the hash.\\n *\\n * @private\\n * @name delete\\n * @memberOf Hash\\n * @param {Object} hash The hash to modify.\\n * @param {string} key The key of the value to remove.\\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\\n */\\n\\n\\nfunction hashDelete(key) {\\n  return this.has(key) && delete this.__data__[key];\\n}\\n/**\\n * Gets the hash value for `key`.\\n *\\n * @private\\n * @name get\\n * @memberOf Hash\\n * @param {string} key The key of the value to get.\\n * @returns {*} Returns the entry value.\\n */\\n\\n\\nfunction hashGet(key) {\\n  var data = this.__data__;\\n\\n  if (nativeCreate) {\\n    var result = data[key];\\n    return result === HASH_UNDEFINED ? undefined : result;\\n  }\\n\\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\\n}\\n/**\\n * Checks if a hash value for `key` exists.\\n *\\n * @private\\n * @name has\\n * @memberOf Hash\\n * @param {string} key The key of the entry to check.\\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\\n */\\n\\n\\nfunction hashHas(key) {\\n  var data = this.__data__;\\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\\n}\\n/**\\n * Sets the hash `key` to `value`.\\n *\\n * @private\\n * @name set\\n * @memberOf Hash\\n * @param {string} key The key of the value to set.\\n * @param {*} value The value to set.\\n * @returns {Object} Returns the hash instance.\\n */\\n\\n\\nfunction hashSet(key, value) {\\n  var data = this.__data__;\\n  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\\n  return this;\\n} // Add methods to `Hash`.\\n\\n\\nHash.prototype.clear = hashClear;\\nHash.prototype['delete'] = hashDelete;\\nHash.prototype.get = hashGet;\\nHash.prototype.has = hashHas;\\nHash.prototype.set = hashSet;\\n/**\\n * Creates an list cache object.\\n *\\n * @private\\n * @constructor\\n * @param {Array} [entries] The key-value pairs to cache.\\n */\\n\\nfunction ListCache(entries) {\\n  var index = -1,\\n      length = entries ? entries.length : 0;\\n  this.clear();\\n\\n  while (++index < length) {\\n    var entry = entries[index];\\n    this.set(entry[0], entry[1]);\\n  }\\n}\\n/**\\n * Removes all key-value entries from the list cache.\\n *\\n * @private\\n * @name clear\\n * @memberOf ListCache\\n */\\n\\n\\nfunction listCacheClear() {\\n  this.__data__ = [];\\n}\\n/**\\n * Removes `key` and its value from the list cache.\\n *\\n * @private\\n * @name delete\\n * @memberOf ListCache\\n * @param {string} key The key of the value to remove.\\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\\n */\\n\\n\\nfunction listCacheDelete(key) {\\n  var data = this.__data__,\\n      index = assocIndexOf(data, key);\\n\\n  if (index < 0) {\\n    return false;\\n  }\\n\\n  var lastIndex = data.length - 1;\\n\\n  if (index == lastIndex) {\\n    data.pop();\\n  } else {\\n    splice.call(data, index, 1);\\n  }\\n\\n  return true;\\n}\\n/**\\n * Gets the list cache value for `key`.\\n *\\n * @private\\n * @name get\\n * @memberOf ListCache\\n * @param {string} key The key of the value to get.\\n * @returns {*} Returns the entry value.\\n */\\n\\n\\nfunction listCacheGet(key) {\\n  var data = this.__data__,\\n      index = assocIndexOf(data, key);\\n  return index < 0 ? undefined : data[index][1];\\n}\\n/**\\n * Checks if a list cache value for `key` exists.\\n *\\n * @private\\n * @name has\\n * @memberOf ListCache\\n * @param {string} key The key of the entry to check.\\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\\n */\\n\\n\\nfunction listCacheHas(key) {\\n  return assocIndexOf(this.__data__, key) > -1;\\n}\\n/**\\n * Sets the list cache `key` to `value`.\\n *\\n * @private\\n * @name set\\n * @memberOf ListCache\\n * @param {string} key The key of the value to set.\\n * @param {*} value The value to set.\\n * @returns {Object} Returns the list cache instance.\\n */\\n\\n\\nfunction listCacheSet(key, value) {\\n  var data = this.__data__,\\n      index = assocIndexOf(data, key);\\n\\n  if (index < 0) {\\n    data.push([key, value]);\\n  } else {\\n    data[index][1] = value;\\n  }\\n\\n  return this;\\n} // Add methods to `ListCache`.\\n\\n\\nListCache.prototype.clear = listCacheClear;\\nListCache.prototype['delete'] = listCacheDelete;\\nListCache.prototype.get = listCacheGet;\\nListCache.prototype.has = listCacheHas;\\nListCache.prototype.set = listCacheSet;\\n/**\\n * Creates a map cache object to store key-value pairs.\\n *\\n * @private\\n * @constructor\\n * @param {Array} [entries] The key-value pairs to cache.\\n */\\n\\nfunction MapCache(entries) {\\n  var index = -1,\\n      length = entries ? entries.length : 0;\\n  this.clear();\\n\\n  while (++index < length) {\\n    var entry = entries[index];\\n    this.set(entry[0], entry[1]);\\n  }\\n}\\n/**\\n * Removes all key-value entries from the map.\\n *\\n * @private\\n * @name clear\\n * @memberOf MapCache\\n */\\n\\n\\nfunction mapCacheClear() {\\n  this.__data__ = {\\n    'hash': new Hash(),\\n    'map': new (Map || ListCache)(),\\n    'string': new Hash()\\n  };\\n}\\n/**\\n * Removes `key` and its value from the map.\\n *\\n * @private\\n * @name delete\\n * @memberOf MapCache\\n * @param {string} key The key of the value to remove.\\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\\n */\\n\\n\\nfunction mapCacheDelete(key) {\\n  return getMapData(this, key)['delete'](key);\\n}\\n/**\\n * Gets the map value for `key`.\\n *\\n * @private\\n * @name get\\n * @memberOf MapCache\\n * @param {string} key The key of the value to get.\\n * @returns {*} Returns the entry value.\\n */\\n\\n\\nfunction mapCacheGet(key) {\\n  return getMapData(this, key).get(key);\\n}\\n/**\\n * Checks if a map value for `key` exists.\\n *\\n * @private\\n * @name has\\n * @memberOf MapCache\\n * @param {string} key The key of the entry to check.\\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\\n */\\n\\n\\nfunction mapCacheHas(key) {\\n  return getMapData(this, key).has(key);\\n}\\n/**\\n * Sets the map `key` to `value`.\\n *\\n * @private\\n * @name set\\n * @memberOf MapCache\\n * @param {string} key The key of the value to set.\\n * @param {*} value The value to set.\\n * @returns {Object} Returns the map cache instance.\\n */\\n\\n\\nfunction mapCacheSet(key, value) {\\n  getMapData(this, key).set(key, value);\\n  return this;\\n} // Add methods to `MapCache`.\\n\\n\\nMapCache.prototype.clear = mapCacheClear;\\nMapCache.prototype['delete'] = mapCacheDelete;\\nMapCache.prototype.get = mapCacheGet;\\nMapCache.prototype.has = mapCacheHas;\\nMapCache.prototype.set = mapCacheSet;\\n/**\\n *\\n * Creates an array cache object to store unique values.\\n *\\n * @private\\n * @constructor\\n * @param {Array} [values] The values to cache.\\n */\\n\\nfunction SetCache(values) {\\n  var index = -1,\\n      length = values ? values.length : 0;\\n  this.__data__ = new MapCache();\\n\\n  while (++index < length) {\\n    this.add(values[index]);\\n  }\\n}\\n/**\\n * Adds `value` to the array cache.\\n *\\n * @private\\n * @name add\\n * @memberOf SetCache\\n * @alias push\\n * @param {*} value The value to cache.\\n * @returns {Object} Returns the cache instance.\\n */\\n\\n\\nfunction setCacheAdd(value) {\\n  this.__data__.set(value, HASH_UNDEFINED);\\n\\n  return this;\\n}\\n/**\\n * Checks if `value` is in the array cache.\\n *\\n * @private\\n * @name has\\n * @memberOf SetCache\\n * @param {*} value The value to search for.\\n * @returns {number} Returns `true` if `value` is found, else `false`.\\n */\\n\\n\\nfunction setCacheHas(value) {\\n  return this.__data__.has(value);\\n} // Add methods to `SetCache`.\\n\\n\\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\\nSetCache.prototype.has = setCacheHas;\\n/**\\n * Creates a stack cache object to store key-value pairs.\\n *\\n * @private\\n * @constructor\\n * @param {Array} [entries] The key-value pairs to cache.\\n */\\n\\nfunction Stack(entries) {\\n  this.__data__ = new ListCache(entries);\\n}\\n/**\\n * Removes all key-value entries from the stack.\\n *\\n * @private\\n * @name clear\\n * @memberOf Stack\\n */\\n\\n\\nfunction stackClear() {\\n  this.__data__ = new ListCache();\\n}\\n/**\\n * Removes `key` and its value from the stack.\\n *\\n * @private\\n * @name delete\\n * @memberOf Stack\\n * @param {string} key The key of the value to remove.\\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\\n */\\n\\n\\nfunction stackDelete(key) {\\n  return this.__data__['delete'](key);\\n}\\n/**\\n * Gets the stack value for `key`.\\n *\\n * @private\\n * @name get\\n * @memberOf Stack\\n * @param {string} key The key of the value to get.\\n * @returns {*} Returns the entry value.\\n */\\n\\n\\nfunction stackGet(key) {\\n  return this.__data__.get(key);\\n}\\n/**\\n * Checks if a stack value for `key` exists.\\n *\\n * @private\\n * @name has\\n * @memberOf Stack\\n * @param {string} key The key of the entry to check.\\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\\n */\\n\\n\\nfunction stackHas(key) {\\n  return this.__data__.has(key);\\n}\\n/**\\n * Sets the stack `key` to `value`.\\n *\\n * @private\\n * @name set\\n * @memberOf Stack\\n * @param {string} key The key of the value to set.\\n * @param {*} value The value to set.\\n * @returns {Object} Returns the stack cache instance.\\n */\\n\\n\\nfunction stackSet(key, value) {\\n  var cache = this.__data__;\\n\\n  if (cache instanceof ListCache) {\\n    var pairs = cache.__data__;\\n\\n    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\\n      pairs.push([key, value]);\\n      return this;\\n    }\\n\\n    cache = this.__data__ = new MapCache(pairs);\\n  }\\n\\n  cache.set(key, value);\\n  return this;\\n} // Add methods to `Stack`.\\n\\n\\nStack.prototype.clear = stackClear;\\nStack.prototype['delete'] = stackDelete;\\nStack.prototype.get = stackGet;\\nStack.prototype.has = stackHas;\\nStack.prototype.set = stackSet;\\n/**\\n * Creates an array of the enumerable property names of the array-like `value`.\\n *\\n * @private\\n * @param {*} value The value to query.\\n * @param {boolean} inherited Specify returning inherited property names.\\n * @returns {Array} Returns the array of property names.\\n */\\n\\nfunction arrayLikeKeys(value, inherited) {\\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\\n  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];\\n  var length = result.length,\\n      skipIndexes = !!length;\\n\\n  for (var key in value) {\\n    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\\n      result.push(key);\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Gets the index at which the `key` is found in `array` of key-value pairs.\\n *\\n * @private\\n * @param {Array} array The array to inspect.\\n * @param {*} key The key to search for.\\n * @returns {number} Returns the index of the matched value, else `-1`.\\n */\\n\\n\\nfunction assocIndexOf(array, key) {\\n  var length = array.length;\\n\\n  while (length--) {\\n    if (eq(array[length][0], key)) {\\n      return length;\\n    }\\n  }\\n\\n  return -1;\\n}\\n/**\\n * The base implementation of `_.forEach` without support for iteratee shorthands.\\n *\\n * @private\\n * @param {Array|Object} collection The collection to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array|Object} Returns `collection`.\\n */\\n\\n\\nvar baseEach = createBaseEach(baseForOwn);\\n/**\\n * The base implementation of `_.flatten` with support for restricting flattening.\\n *\\n * @private\\n * @param {Array} array The array to flatten.\\n * @param {number} depth The maximum recursion depth.\\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\\n * @param {Array} [result=[]] The initial result value.\\n * @returns {Array} Returns the new flattened array.\\n */\\n\\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\\n  var index = -1,\\n      length = array.length;\\n  predicate || (predicate = isFlattenable);\\n  result || (result = []);\\n\\n  while (++index < length) {\\n    var value = array[index];\\n\\n    if (depth > 0 && predicate(value)) {\\n      if (depth > 1) {\\n        // Recursively flatten arrays (susceptible to call stack limits).\\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\\n      } else {\\n        arrayPush(result, value);\\n      }\\n    } else if (!isStrict) {\\n      result[result.length] = value;\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * The base implementation of `baseForOwn` which iterates over `object`\\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\\n * Iteratee functions may exit iteration early by explicitly returning `false`.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @param {Function} keysFunc The function to get the keys of `object`.\\n * @returns {Object} Returns `object`.\\n */\\n\\n\\nvar baseFor = createBaseFor();\\n/**\\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Object} Returns `object`.\\n */\\n\\nfunction baseForOwn(object, iteratee) {\\n  return object && baseFor(object, iteratee, keys);\\n}\\n/**\\n * The base implementation of `_.get` without support for default values.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {Array|string} path The path of the property to get.\\n * @returns {*} Returns the resolved value.\\n */\\n\\n\\nfunction baseGet(object, path) {\\n  path = isKey(path, object) ? [path] : castPath(path);\\n  var index = 0,\\n      length = path.length;\\n\\n  while (object != null && index < length) {\\n    object = object[toKey(path[index++])];\\n  }\\n\\n  return index && index == length ? object : undefined;\\n}\\n/**\\n * The base implementation of `getTag`.\\n *\\n * @private\\n * @param {*} value The value to query.\\n * @returns {string} Returns the `toStringTag`.\\n */\\n\\n\\nfunction baseGetTag(value) {\\n  return objectToString.call(value);\\n}\\n/**\\n * The base implementation of `_.hasIn` without support for deep paths.\\n *\\n * @private\\n * @param {Object} [object] The object to query.\\n * @param {Array|string} key The key to check.\\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\\n */\\n\\n\\nfunction baseHasIn(object, key) {\\n  return object != null && key in Object(object);\\n}\\n/**\\n * The base implementation of `_.isEqual` which supports partial comparisons\\n * and tracks traversed objects.\\n *\\n * @private\\n * @param {*} value The value to compare.\\n * @param {*} other The other value to compare.\\n * @param {Function} [customizer] The function to customize comparisons.\\n * @param {boolean} [bitmask] The bitmask of comparison flags.\\n *  The bitmask may be composed of the following flags:\\n *     1 - Unordered comparison\\n *     2 - Partial comparison\\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\\n */\\n\\n\\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\\n  if (value === other) {\\n    return true;\\n  }\\n\\n  if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {\\n    return value !== value && other !== other;\\n  }\\n\\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\\n}\\n/**\\n * A specialized version of `baseIsEqual` for arrays and objects which performs\\n * deep comparisons and tracks traversed objects enabling objects with circular\\n * references to be compared.\\n *\\n * @private\\n * @param {Object} object The object to compare.\\n * @param {Object} other The other object to compare.\\n * @param {Function} equalFunc The function to determine equivalents of values.\\n * @param {Function} [customizer] The function to customize comparisons.\\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\\n *  for more details.\\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\n\\n\\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\\n  var objIsArr = isArray(object),\\n      othIsArr = isArray(other),\\n      objTag = arrayTag,\\n      othTag = arrayTag;\\n\\n  if (!objIsArr) {\\n    objTag = getTag(object);\\n    objTag = objTag == argsTag ? objectTag : objTag;\\n  }\\n\\n  if (!othIsArr) {\\n    othTag = getTag(other);\\n    othTag = othTag == argsTag ? objectTag : othTag;\\n  }\\n\\n  var objIsObj = objTag == objectTag && !isHostObject(object),\\n      othIsObj = othTag == objectTag && !isHostObject(other),\\n      isSameTag = objTag == othTag;\\n\\n  if (isSameTag && !objIsObj) {\\n    stack || (stack = new Stack());\\n    return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\\n  }\\n\\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\\n\\n    if (objIsWrapped || othIsWrapped) {\\n      var objUnwrapped = objIsWrapped ? object.value() : object,\\n          othUnwrapped = othIsWrapped ? other.value() : other;\\n      stack || (stack = new Stack());\\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\\n    }\\n  }\\n\\n  if (!isSameTag) {\\n    return false;\\n  }\\n\\n  stack || (stack = new Stack());\\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\\n}\\n/**\\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\\n *\\n * @private\\n * @param {Object} object The object to inspect.\\n * @param {Object} source The object of property values to match.\\n * @param {Array} matchData The property names, values, and compare flags to match.\\n * @param {Function} [customizer] The function to customize comparisons.\\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\\n */\\n\\n\\nfunction baseIsMatch(object, source, matchData, customizer) {\\n  var index = matchData.length,\\n      length = index,\\n      noCustomizer = !customizer;\\n\\n  if (object == null) {\\n    return !length;\\n  }\\n\\n  object = Object(object);\\n\\n  while (index--) {\\n    var data = matchData[index];\\n\\n    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\\n      return false;\\n    }\\n  }\\n\\n  while (++index < length) {\\n    data = matchData[index];\\n    var key = data[0],\\n        objValue = object[key],\\n        srcValue = data[1];\\n\\n    if (noCustomizer && data[2]) {\\n      if (objValue === undefined && !(key in object)) {\\n        return false;\\n      }\\n    } else {\\n      var stack = new Stack();\\n\\n      if (customizer) {\\n        var result = customizer(objValue, srcValue, key, object, source, stack);\\n      }\\n\\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return true;\\n}\\n/**\\n * The base implementation of `_.isNative` without bad shim checks.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a native function,\\n *  else `false`.\\n */\\n\\n\\nfunction baseIsNative(value) {\\n  if (!isObject(value) || isMasked(value)) {\\n    return false;\\n  }\\n\\n  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\\n  return pattern.test(toSource(value));\\n}\\n/**\\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\\n */\\n\\n\\nfunction baseIsTypedArray(value) {\\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\\n}\\n/**\\n * The base implementation of `_.iteratee`.\\n *\\n * @private\\n * @param {*} [value=_.identity] The value to convert to an iteratee.\\n * @returns {Function} Returns the iteratee.\\n */\\n\\n\\nfunction baseIteratee(value) {\\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\\n  if (typeof value == 'function') {\\n    return value;\\n  }\\n\\n  if (value == null) {\\n    return identity;\\n  }\\n\\n  if (_typeof(value) == 'object') {\\n    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\\n  }\\n\\n  return property(value);\\n}\\n/**\\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n */\\n\\n\\nfunction baseKeys(object) {\\n  if (!isPrototype(object)) {\\n    return nativeKeys(object);\\n  }\\n\\n  var result = [];\\n\\n  for (var key in Object(object)) {\\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\\n      result.push(key);\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * The base implementation of `_.map` without support for iteratee shorthands.\\n *\\n * @private\\n * @param {Array|Object} collection The collection to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns the new mapped array.\\n */\\n\\n\\nfunction baseMap(collection, iteratee) {\\n  var index = -1,\\n      result = isArrayLike(collection) ? Array(collection.length) : [];\\n  baseEach(collection, function (value, key, collection) {\\n    result[++index] = iteratee(value, key, collection);\\n  });\\n  return result;\\n}\\n/**\\n * The base implementation of `_.matches` which doesn't clone `source`.\\n *\\n * @private\\n * @param {Object} source The object of property values to match.\\n * @returns {Function} Returns the new spec function.\\n */\\n\\n\\nfunction baseMatches(source) {\\n  var matchData = getMatchData(source);\\n\\n  if (matchData.length == 1 && matchData[0][2]) {\\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\\n  }\\n\\n  return function (object) {\\n    return object === source || baseIsMatch(object, source, matchData);\\n  };\\n}\\n/**\\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\\n *\\n * @private\\n * @param {string} path The path of the property to get.\\n * @param {*} srcValue The value to match.\\n * @returns {Function} Returns the new spec function.\\n */\\n\\n\\nfunction baseMatchesProperty(path, srcValue) {\\n  if (isKey(path) && isStrictComparable(srcValue)) {\\n    return matchesStrictComparable(toKey(path), srcValue);\\n  }\\n\\n  return function (object) {\\n    var objValue = get(object, path);\\n    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\\n  };\\n}\\n/**\\n * The base implementation of `_.orderBy` without param guards.\\n *\\n * @private\\n * @param {Array|Object} collection The collection to iterate over.\\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\\n * @param {string[]} orders The sort orders of `iteratees`.\\n * @returns {Array} Returns the new sorted array.\\n */\\n\\n\\nfunction baseOrderBy(collection, iteratees, orders) {\\n  var index = -1;\\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\\n  var result = baseMap(collection, function (value, key, collection) {\\n    var criteria = arrayMap(iteratees, function (iteratee) {\\n      return iteratee(value);\\n    });\\n    return {\\n      'criteria': criteria,\\n      'index': ++index,\\n      'value': value\\n    };\\n  });\\n  return baseSortBy(result, function (object, other) {\\n    return compareMultiple(object, other, orders);\\n  });\\n}\\n/**\\n * A specialized version of `baseProperty` which supports deep paths.\\n *\\n * @private\\n * @param {Array|string} path The path of the property to get.\\n * @returns {Function} Returns the new accessor function.\\n */\\n\\n\\nfunction basePropertyDeep(path) {\\n  return function (object) {\\n    return baseGet(object, path);\\n  };\\n}\\n/**\\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\\n *\\n * @private\\n * @param {Function} func The function to apply a rest parameter to.\\n * @param {number} [start=func.length-1] The start position of the rest parameter.\\n * @returns {Function} Returns the new function.\\n */\\n\\n\\nfunction baseRest(func, start) {\\n  start = nativeMax(start === undefined ? func.length - 1 : start, 0);\\n  return function () {\\n    var args = arguments,\\n        index = -1,\\n        length = nativeMax(args.length - start, 0),\\n        array = Array(length);\\n\\n    while (++index < length) {\\n      array[index] = args[start + index];\\n    }\\n\\n    index = -1;\\n    var otherArgs = Array(start + 1);\\n\\n    while (++index < start) {\\n      otherArgs[index] = args[index];\\n    }\\n\\n    otherArgs[start] = array;\\n    return apply(func, this, otherArgs);\\n  };\\n}\\n/**\\n * The base implementation of `_.toString` which doesn't convert nullish\\n * values to empty strings.\\n *\\n * @private\\n * @param {*} value The value to process.\\n * @returns {string} Returns the string.\\n */\\n\\n\\nfunction baseToString(value) {\\n  // Exit early for strings to avoid a performance hit in some environments.\\n  if (typeof value == 'string') {\\n    return value;\\n  }\\n\\n  if (isSymbol(value)) {\\n    return symbolToString ? symbolToString.call(value) : '';\\n  }\\n\\n  var result = value + '';\\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\\n}\\n/**\\n * Casts `value` to a path array if it's not one.\\n *\\n * @private\\n * @param {*} value The value to inspect.\\n * @returns {Array} Returns the cast property path array.\\n */\\n\\n\\nfunction castPath(value) {\\n  return isArray(value) ? value : stringToPath(value);\\n}\\n/**\\n * Compares values to sort them in ascending order.\\n *\\n * @private\\n * @param {*} value The value to compare.\\n * @param {*} other The other value to compare.\\n * @returns {number} Returns the sort order indicator for `value`.\\n */\\n\\n\\nfunction compareAscending(value, other) {\\n  if (value !== other) {\\n    var valIsDefined = value !== undefined,\\n        valIsNull = value === null,\\n        valIsReflexive = value === value,\\n        valIsSymbol = isSymbol(value);\\n    var othIsDefined = other !== undefined,\\n        othIsNull = other === null,\\n        othIsReflexive = other === other,\\n        othIsSymbol = isSymbol(other);\\n\\n    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\\n      return 1;\\n    }\\n\\n    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\\n      return -1;\\n    }\\n  }\\n\\n  return 0;\\n}\\n/**\\n * Used by `_.orderBy` to compare multiple properties of a value to another\\n * and stable sort them.\\n *\\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\\n * specify an order of \\\"desc\\\" for descending or \\\"asc\\\" for ascending sort order\\n * of corresponding values.\\n *\\n * @private\\n * @param {Object} object The object to compare.\\n * @param {Object} other The other object to compare.\\n * @param {boolean[]|string[]} orders The order to sort by for each property.\\n * @returns {number} Returns the sort order indicator for `object`.\\n */\\n\\n\\nfunction compareMultiple(object, other, orders) {\\n  var index = -1,\\n      objCriteria = object.criteria,\\n      othCriteria = other.criteria,\\n      length = objCriteria.length,\\n      ordersLength = orders.length;\\n\\n  while (++index < length) {\\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\\n\\n    if (result) {\\n      if (index >= ordersLength) {\\n        return result;\\n      }\\n\\n      var order = orders[index];\\n      return result * (order == 'desc' ? -1 : 1);\\n    }\\n  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\\n  // that causes it, under certain circumstances, to provide the same value for\\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\\n  // for more details.\\n  //\\n  // This also ensures a stable sort in V8 and other engines.\\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\\n\\n\\n  return object.index - other.index;\\n}\\n/**\\n * Creates a `baseEach` or `baseEachRight` function.\\n *\\n * @private\\n * @param {Function} eachFunc The function to iterate over a collection.\\n * @param {boolean} [fromRight] Specify iterating from right to left.\\n * @returns {Function} Returns the new base function.\\n */\\n\\n\\nfunction createBaseEach(eachFunc, fromRight) {\\n  return function (collection, iteratee) {\\n    if (collection == null) {\\n      return collection;\\n    }\\n\\n    if (!isArrayLike(collection)) {\\n      return eachFunc(collection, iteratee);\\n    }\\n\\n    var length = collection.length,\\n        index = fromRight ? length : -1,\\n        iterable = Object(collection);\\n\\n    while (fromRight ? index-- : ++index < length) {\\n      if (iteratee(iterable[index], index, iterable) === false) {\\n        break;\\n      }\\n    }\\n\\n    return collection;\\n  };\\n}\\n/**\\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\\n *\\n * @private\\n * @param {boolean} [fromRight] Specify iterating from right to left.\\n * @returns {Function} Returns the new base function.\\n */\\n\\n\\nfunction createBaseFor(fromRight) {\\n  return function (object, iteratee, keysFunc) {\\n    var index = -1,\\n        iterable = Object(object),\\n        props = keysFunc(object),\\n        length = props.length;\\n\\n    while (length--) {\\n      var key = props[fromRight ? length : ++index];\\n\\n      if (iteratee(iterable[key], key, iterable) === false) {\\n        break;\\n      }\\n    }\\n\\n    return object;\\n  };\\n}\\n/**\\n * A specialized version of `baseIsEqualDeep` for arrays with support for\\n * partial deep comparisons.\\n *\\n * @private\\n * @param {Array} array The array to compare.\\n * @param {Array} other The other array to compare.\\n * @param {Function} equalFunc The function to determine equivalents of values.\\n * @param {Function} customizer The function to customize comparisons.\\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\\n *  for more details.\\n * @param {Object} stack Tracks traversed `array` and `other` objects.\\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\\n */\\n\\n\\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\\n      arrLength = array.length,\\n      othLength = other.length;\\n\\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\\n    return false;\\n  } // Assume cyclic values are equal.\\n\\n\\n  var stacked = stack.get(array);\\n\\n  if (stacked && stack.get(other)) {\\n    return stacked == other;\\n  }\\n\\n  var index = -1,\\n      result = true,\\n      seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;\\n  stack.set(array, other);\\n  stack.set(other, array); // Ignore non-index properties.\\n\\n  while (++index < arrLength) {\\n    var arrValue = array[index],\\n        othValue = other[index];\\n\\n    if (customizer) {\\n      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\\n    }\\n\\n    if (compared !== undefined) {\\n      if (compared) {\\n        continue;\\n      }\\n\\n      result = false;\\n      break;\\n    } // Recursively compare arrays (susceptible to call stack limits).\\n\\n\\n    if (seen) {\\n      if (!arraySome(other, function (othValue, othIndex) {\\n        if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\\n          return seen.add(othIndex);\\n        }\\n      })) {\\n        result = false;\\n        break;\\n      }\\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\\n      result = false;\\n      break;\\n    }\\n  }\\n\\n  stack['delete'](array);\\n  stack['delete'](other);\\n  return result;\\n}\\n/**\\n * A specialized version of `baseIsEqualDeep` for comparing objects of\\n * the same `toStringTag`.\\n *\\n * **Note:** This function only supports comparing values with tags of\\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\\n *\\n * @private\\n * @param {Object} object The object to compare.\\n * @param {Object} other The other object to compare.\\n * @param {string} tag The `toStringTag` of the objects to compare.\\n * @param {Function} equalFunc The function to determine equivalents of values.\\n * @param {Function} customizer The function to customize comparisons.\\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\\n *  for more details.\\n * @param {Object} stack Tracks traversed `object` and `other` objects.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\n\\n\\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\\n  switch (tag) {\\n    case dataViewTag:\\n      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\\n        return false;\\n      }\\n\\n      object = object.buffer;\\n      other = other.buffer;\\n\\n    case arrayBufferTag:\\n      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\\n        return false;\\n      }\\n\\n      return true;\\n\\n    case boolTag:\\n    case dateTag:\\n    case numberTag:\\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\\n      // Invalid dates are coerced to `NaN`.\\n      return eq(+object, +other);\\n\\n    case errorTag:\\n      return object.name == other.name && object.message == other.message;\\n\\n    case regexpTag:\\n    case stringTag:\\n      // Coerce regexes to strings and treat strings, primitives and objects,\\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\\n      // for more details.\\n      return object == other + '';\\n\\n    case mapTag:\\n      var convert = mapToArray;\\n\\n    case setTag:\\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\\n      convert || (convert = setToArray);\\n\\n      if (object.size != other.size && !isPartial) {\\n        return false;\\n      } // Assume cyclic values are equal.\\n\\n\\n      var stacked = stack.get(object);\\n\\n      if (stacked) {\\n        return stacked == other;\\n      }\\n\\n      bitmask |= UNORDERED_COMPARE_FLAG; // Recursively compare objects (susceptible to call stack limits).\\n\\n      stack.set(object, other);\\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\\n      stack['delete'](object);\\n      return result;\\n\\n    case symbolTag:\\n      if (symbolValueOf) {\\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\\n      }\\n\\n  }\\n\\n  return false;\\n}\\n/**\\n * A specialized version of `baseIsEqualDeep` for objects with support for\\n * partial deep comparisons.\\n *\\n * @private\\n * @param {Object} object The object to compare.\\n * @param {Object} other The other object to compare.\\n * @param {Function} equalFunc The function to determine equivalents of values.\\n * @param {Function} customizer The function to customize comparisons.\\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\\n *  for more details.\\n * @param {Object} stack Tracks traversed `object` and `other` objects.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\n\\n\\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\\n      objProps = keys(object),\\n      objLength = objProps.length,\\n      othProps = keys(other),\\n      othLength = othProps.length;\\n\\n  if (objLength != othLength && !isPartial) {\\n    return false;\\n  }\\n\\n  var index = objLength;\\n\\n  while (index--) {\\n    var key = objProps[index];\\n\\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\\n      return false;\\n    }\\n  } // Assume cyclic values are equal.\\n\\n\\n  var stacked = stack.get(object);\\n\\n  if (stacked && stack.get(other)) {\\n    return stacked == other;\\n  }\\n\\n  var result = true;\\n  stack.set(object, other);\\n  stack.set(other, object);\\n  var skipCtor = isPartial;\\n\\n  while (++index < objLength) {\\n    key = objProps[index];\\n    var objValue = object[key],\\n        othValue = other[key];\\n\\n    if (customizer) {\\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\\n    } // Recursively compare objects (susceptible to call stack limits).\\n\\n\\n    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {\\n      result = false;\\n      break;\\n    }\\n\\n    skipCtor || (skipCtor = key == 'constructor');\\n  }\\n\\n  if (result && !skipCtor) {\\n    var objCtor = object.constructor,\\n        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.\\n\\n    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\\n      result = false;\\n    }\\n  }\\n\\n  stack['delete'](object);\\n  stack['delete'](other);\\n  return result;\\n}\\n/**\\n * Gets the data for `map`.\\n *\\n * @private\\n * @param {Object} map The map to query.\\n * @param {string} key The reference key.\\n * @returns {*} Returns the map data.\\n */\\n\\n\\nfunction getMapData(map, key) {\\n  var data = map.__data__;\\n  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\\n}\\n/**\\n * Gets the property names, values, and compare flags of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the match data of `object`.\\n */\\n\\n\\nfunction getMatchData(object) {\\n  var result = keys(object),\\n      length = result.length;\\n\\n  while (length--) {\\n    var key = result[length],\\n        value = object[key];\\n    result[length] = [key, value, isStrictComparable(value)];\\n  }\\n\\n  return result;\\n}\\n/**\\n * Gets the native function at `key` of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {string} key The key of the method to get.\\n * @returns {*} Returns the function if it's native, else `undefined`.\\n */\\n\\n\\nfunction getNative(object, key) {\\n  var value = getValue(object, key);\\n  return baseIsNative(value) ? value : undefined;\\n}\\n/**\\n * Gets the `toStringTag` of `value`.\\n *\\n * @private\\n * @param {*} value The value to query.\\n * @returns {string} Returns the `toStringTag`.\\n */\\n\\n\\nvar getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,\\n// for data views in Edge < 14, and promises in Node.js.\\n\\nif (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\\n  getTag = function getTag(value) {\\n    var result = objectToString.call(value),\\n        Ctor = result == objectTag ? value.constructor : undefined,\\n        ctorString = Ctor ? toSource(Ctor) : undefined;\\n\\n    if (ctorString) {\\n      switch (ctorString) {\\n        case dataViewCtorString:\\n          return dataViewTag;\\n\\n        case mapCtorString:\\n          return mapTag;\\n\\n        case promiseCtorString:\\n          return promiseTag;\\n\\n        case setCtorString:\\n          return setTag;\\n\\n        case weakMapCtorString:\\n          return weakMapTag;\\n      }\\n    }\\n\\n    return result;\\n  };\\n}\\n/**\\n * Checks if `path` exists on `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {Array|string} path The path to check.\\n * @param {Function} hasFunc The function to check properties.\\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\\n */\\n\\n\\nfunction hasPath(object, path, hasFunc) {\\n  path = isKey(path, object) ? [path] : castPath(path);\\n  var result,\\n      index = -1,\\n      length = path.length;\\n\\n  while (++index < length) {\\n    var key = toKey(path[index]);\\n\\n    if (!(result = object != null && hasFunc(object, key))) {\\n      break;\\n    }\\n\\n    object = object[key];\\n  }\\n\\n  if (result) {\\n    return result;\\n  }\\n\\n  var length = object ? object.length : 0;\\n  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\\n}\\n/**\\n * Checks if `value` is a flattenable `arguments` object or array.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\\n */\\n\\n\\nfunction isFlattenable(value) {\\n  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\\n}\\n/**\\n * Checks if `value` is a valid array-like index.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\\n */\\n\\n\\nfunction isIndex(value, length) {\\n  length = length == null ? MAX_SAFE_INTEGER : length;\\n  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\\n}\\n/**\\n * Checks if the given arguments are from an iteratee call.\\n *\\n * @private\\n * @param {*} value The potential iteratee value argument.\\n * @param {*} index The potential iteratee index or key argument.\\n * @param {*} object The potential iteratee object argument.\\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\\n *  else `false`.\\n */\\n\\n\\nfunction isIterateeCall(value, index, object) {\\n  if (!isObject(object)) {\\n    return false;\\n  }\\n\\n  var type = _typeof(index);\\n\\n  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\\n    return eq(object[index], value);\\n  }\\n\\n  return false;\\n}\\n/**\\n * Checks if `value` is a property name and not a property path.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @param {Object} [object] The object to query keys on.\\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\\n */\\n\\n\\nfunction isKey(value, object) {\\n  if (isArray(value)) {\\n    return false;\\n  }\\n\\n  var type = _typeof(value);\\n\\n  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\\n    return true;\\n  }\\n\\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\\n}\\n/**\\n * Checks if `value` is suitable for use as unique object key.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\\n */\\n\\n\\nfunction isKeyable(value) {\\n  var type = _typeof(value);\\n\\n  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\\n}\\n/**\\n * Checks if `func` has its source masked.\\n *\\n * @private\\n * @param {Function} func The function to check.\\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\\n */\\n\\n\\nfunction isMasked(func) {\\n  return !!maskSrcKey && maskSrcKey in func;\\n}\\n/**\\n * Checks if `value` is likely a prototype object.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\\n */\\n\\n\\nfunction isPrototype(value) {\\n  var Ctor = value && value.constructor,\\n      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\\n  return value === proto;\\n}\\n/**\\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` if suitable for strict\\n *  equality comparisons, else `false`.\\n */\\n\\n\\nfunction isStrictComparable(value) {\\n  return value === value && !isObject(value);\\n}\\n/**\\n * A specialized version of `matchesProperty` for source values suitable\\n * for strict equality comparisons, i.e. `===`.\\n *\\n * @private\\n * @param {string} key The key of the property to get.\\n * @param {*} srcValue The value to match.\\n * @returns {Function} Returns the new spec function.\\n */\\n\\n\\nfunction matchesStrictComparable(key, srcValue) {\\n  return function (object) {\\n    if (object == null) {\\n      return false;\\n    }\\n\\n    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\\n  };\\n}\\n/**\\n * Converts `string` to a property path array.\\n *\\n * @private\\n * @param {string} string The string to convert.\\n * @returns {Array} Returns the property path array.\\n */\\n\\n\\nvar stringToPath = memoize(function (string) {\\n  string = toString(string);\\n  var result = [];\\n\\n  if (reLeadingDot.test(string)) {\\n    result.push('');\\n  }\\n\\n  string.replace(rePropName, function (match, number, quote, string) {\\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\\n  });\\n  return result;\\n});\\n/**\\n * Converts `value` to a string key if it's not a string or symbol.\\n *\\n * @private\\n * @param {*} value The value to inspect.\\n * @returns {string|symbol} Returns the key.\\n */\\n\\nfunction toKey(value) {\\n  if (typeof value == 'string' || isSymbol(value)) {\\n    return value;\\n  }\\n\\n  var result = value + '';\\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\\n}\\n/**\\n * Converts `func` to its source code.\\n *\\n * @private\\n * @param {Function} func The function to process.\\n * @returns {string} Returns the source code.\\n */\\n\\n\\nfunction toSource(func) {\\n  if (func != null) {\\n    try {\\n      return funcToString.call(func);\\n    } catch (e) {}\\n\\n    try {\\n      return func + '';\\n    } catch (e) {}\\n  }\\n\\n  return '';\\n}\\n/**\\n * Creates an array of elements, sorted in ascending order by the results of\\n * running each element in a collection thru each iteratee. This method\\n * performs a stable sort, that is, it preserves the original sort order of\\n * equal elements. The iteratees are invoked with one argument: (value).\\n *\\n * @static\\n * @memberOf _\\n * @since 0.1.0\\n * @category Collection\\n * @param {Array|Object} collection The collection to iterate over.\\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\\n *  The iteratees to sort by.\\n * @returns {Array} Returns the new sorted array.\\n * @example\\n *\\n * var users = [\\n *   { 'user': 'fred',   'age': 48 },\\n *   { 'user': 'barney', 'age': 36 },\\n *   { 'user': 'fred',   'age': 40 },\\n *   { 'user': 'barney', 'age': 34 }\\n * ];\\n *\\n * _.sortBy(users, function(o) { return o.user; });\\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\\n *\\n * _.sortBy(users, ['user', 'age']);\\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\\n *\\n * _.sortBy(users, 'user', function(o) {\\n *   return Math.floor(o.age / 10);\\n * });\\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\\n */\\n\\n\\nvar sortBy = baseRest(function (collection, iteratees) {\\n  if (collection == null) {\\n    return [];\\n  }\\n\\n  var length = iteratees.length;\\n\\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\\n    iteratees = [];\\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\\n    iteratees = [iteratees[0]];\\n  }\\n\\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\\n});\\n/**\\n * Creates a function that memoizes the result of `func`. If `resolver` is\\n * provided, it determines the cache key for storing the result based on the\\n * arguments provided to the memoized function. By default, the first argument\\n * provided to the memoized function is used as the map cache key. The `func`\\n * is invoked with the `this` binding of the memoized function.\\n *\\n * **Note:** The cache is exposed as the `cache` property on the memoized\\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\\n * constructor with one whose instances implement the\\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\\n * method interface of `delete`, `get`, `has`, and `set`.\\n *\\n * @static\\n * @memberOf _\\n * @since 0.1.0\\n * @category Function\\n * @param {Function} func The function to have its output memoized.\\n * @param {Function} [resolver] The function to resolve the cache key.\\n * @returns {Function} Returns the new memoized function.\\n * @example\\n *\\n * var object = { 'a': 1, 'b': 2 };\\n * var other = { 'c': 3, 'd': 4 };\\n *\\n * var values = _.memoize(_.values);\\n * values(object);\\n * // => [1, 2]\\n *\\n * values(other);\\n * // => [3, 4]\\n *\\n * object.a = 2;\\n * values(object);\\n * // => [1, 2]\\n *\\n * // Modify the result cache.\\n * values.cache.set(object, ['a', 'b']);\\n * values(object);\\n * // => ['a', 'b']\\n *\\n * // Replace `_.memoize.Cache`.\\n * _.memoize.Cache = WeakMap;\\n */\\n\\nfunction memoize(func, resolver) {\\n  if (typeof func != 'function' || resolver && typeof resolver != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n\\n  var memoized = function memoized() {\\n    var args = arguments,\\n        key = resolver ? resolver.apply(this, args) : args[0],\\n        cache = memoized.cache;\\n\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n\\n    var result = func.apply(this, args);\\n    memoized.cache = cache.set(key, result);\\n    return result;\\n  };\\n\\n  memoized.cache = new (memoize.Cache || MapCache)();\\n  return memoized;\\n} // Assign cache to `_.memoize`.\\n\\n\\nmemoize.Cache = MapCache;\\n/**\\n * Performs a\\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\\n * comparison between two values to determine if they are equivalent.\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to compare.\\n * @param {*} other The other value to compare.\\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\\n * @example\\n *\\n * var object = { 'a': 1 };\\n * var other = { 'a': 1 };\\n *\\n * _.eq(object, object);\\n * // => true\\n *\\n * _.eq(object, other);\\n * // => false\\n *\\n * _.eq('a', 'a');\\n * // => true\\n *\\n * _.eq('a', Object('a'));\\n * // => false\\n *\\n * _.eq(NaN, NaN);\\n * // => true\\n */\\n\\nfunction eq(value, other) {\\n  return value === other || value !== value && other !== other;\\n}\\n/**\\n * Checks if `value` is likely an `arguments` object.\\n *\\n * @static\\n * @memberOf _\\n * @since 0.1.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\\n *  else `false`.\\n * @example\\n *\\n * _.isArguments(function() { return arguments; }());\\n * // => true\\n *\\n * _.isArguments([1, 2, 3]);\\n * // => false\\n */\\n\\n\\nfunction isArguments(value) {\\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\\n}\\n/**\\n * Checks if `value` is classified as an `Array` object.\\n *\\n * @static\\n * @memberOf _\\n * @since 0.1.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\\n * @example\\n *\\n * _.isArray([1, 2, 3]);\\n * // => true\\n *\\n * _.isArray(document.body.children);\\n * // => false\\n *\\n * _.isArray('abc');\\n * // => false\\n *\\n * _.isArray(_.noop);\\n * // => false\\n */\\n\\n\\nvar isArray = Array.isArray;\\n/**\\n * Checks if `value` is array-like. A value is considered array-like if it's\\n * not a function and has a `value.length` that's an integer greater than or\\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\\n * @example\\n *\\n * _.isArrayLike([1, 2, 3]);\\n * // => true\\n *\\n * _.isArrayLike(document.body.children);\\n * // => true\\n *\\n * _.isArrayLike('abc');\\n * // => true\\n *\\n * _.isArrayLike(_.noop);\\n * // => false\\n */\\n\\nfunction isArrayLike(value) {\\n  return value != null && isLength(value.length) && !isFunction(value);\\n}\\n/**\\n * This method is like `_.isArrayLike` except that it also checks if `value`\\n * is an object.\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an array-like object,\\n *  else `false`.\\n * @example\\n *\\n * _.isArrayLikeObject([1, 2, 3]);\\n * // => true\\n *\\n * _.isArrayLikeObject(document.body.children);\\n * // => true\\n *\\n * _.isArrayLikeObject('abc');\\n * // => false\\n *\\n * _.isArrayLikeObject(_.noop);\\n * // => false\\n */\\n\\n\\nfunction isArrayLikeObject(value) {\\n  return isObjectLike(value) && isArrayLike(value);\\n}\\n/**\\n * Checks if `value` is classified as a `Function` object.\\n *\\n * @static\\n * @memberOf _\\n * @since 0.1.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\\n * @example\\n *\\n * _.isFunction(_);\\n * // => true\\n *\\n * _.isFunction(/abc/);\\n * // => false\\n */\\n\\n\\nfunction isFunction(value) {\\n  // The use of `Object#toString` avoids issues with the `typeof` operator\\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\\n  var tag = isObject(value) ? objectToString.call(value) : '';\\n  return tag == funcTag || tag == genTag;\\n}\\n/**\\n * Checks if `value` is a valid array-like length.\\n *\\n * **Note:** This method is loosely based on\\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\\n * @example\\n *\\n * _.isLength(3);\\n * // => true\\n *\\n * _.isLength(Number.MIN_VALUE);\\n * // => false\\n *\\n * _.isLength(Infinity);\\n * // => false\\n *\\n * _.isLength('3');\\n * // => false\\n */\\n\\n\\nfunction isLength(value) {\\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\\n}\\n/**\\n * Checks if `value` is the\\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\\n *\\n * @static\\n * @memberOf _\\n * @since 0.1.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\\n * @example\\n *\\n * _.isObject({});\\n * // => true\\n *\\n * _.isObject([1, 2, 3]);\\n * // => true\\n *\\n * _.isObject(_.noop);\\n * // => true\\n *\\n * _.isObject(null);\\n * // => false\\n */\\n\\n\\nfunction isObject(value) {\\n  var type = _typeof(value);\\n\\n  return !!value && (type == 'object' || type == 'function');\\n}\\n/**\\n * Checks if `value` is object-like. A value is object-like if it's not `null`\\n * and has a `typeof` result of \\\"object\\\".\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n * @example\\n *\\n * _.isObjectLike({});\\n * // => true\\n *\\n * _.isObjectLike([1, 2, 3]);\\n * // => true\\n *\\n * _.isObjectLike(_.noop);\\n * // => false\\n *\\n * _.isObjectLike(null);\\n * // => false\\n */\\n\\n\\nfunction isObjectLike(value) {\\n  return !!value && _typeof(value) == 'object';\\n}\\n/**\\n * Checks if `value` is classified as a `Symbol` primitive or object.\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\\n * @example\\n *\\n * _.isSymbol(Symbol.iterator);\\n * // => true\\n *\\n * _.isSymbol('abc');\\n * // => false\\n */\\n\\n\\nfunction isSymbol(value) {\\n  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\\n}\\n/**\\n * Checks if `value` is classified as a typed array.\\n *\\n * @static\\n * @memberOf _\\n * @since 3.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\\n * @example\\n *\\n * _.isTypedArray(new Uint8Array);\\n * // => true\\n *\\n * _.isTypedArray([]);\\n * // => false\\n */\\n\\n\\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\\n/**\\n * Converts `value` to a string. An empty string is returned for `null`\\n * and `undefined` values. The sign of `-0` is preserved.\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to process.\\n * @returns {string} Returns the string.\\n * @example\\n *\\n * _.toString(null);\\n * // => ''\\n *\\n * _.toString(-0);\\n * // => '-0'\\n *\\n * _.toString([1, 2, 3]);\\n * // => '1,2,3'\\n */\\n\\nfunction toString(value) {\\n  return value == null ? '' : baseToString(value);\\n}\\n/**\\n * Gets the value at `path` of `object`. If the resolved value is\\n * `undefined`, the `defaultValue` is returned in its place.\\n *\\n * @static\\n * @memberOf _\\n * @since 3.7.0\\n * @category Object\\n * @param {Object} object The object to query.\\n * @param {Array|string} path The path of the property to get.\\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\\n * @returns {*} Returns the resolved value.\\n * @example\\n *\\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\\n *\\n * _.get(object, 'a[0].b.c');\\n * // => 3\\n *\\n * _.get(object, ['a', '0', 'b', 'c']);\\n * // => 3\\n *\\n * _.get(object, 'a.b.c', 'default');\\n * // => 'default'\\n */\\n\\n\\nfunction get(object, path, defaultValue) {\\n  var result = object == null ? undefined : baseGet(object, path);\\n  return result === undefined ? defaultValue : result;\\n}\\n/**\\n * Checks if `path` is a direct or inherited property of `object`.\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Object\\n * @param {Object} object The object to query.\\n * @param {Array|string} path The path to check.\\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\\n * @example\\n *\\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\\n *\\n * _.hasIn(object, 'a');\\n * // => true\\n *\\n * _.hasIn(object, 'a.b');\\n * // => true\\n *\\n * _.hasIn(object, ['a', 'b']);\\n * // => true\\n *\\n * _.hasIn(object, 'b');\\n * // => false\\n */\\n\\n\\nfunction hasIn(object, path) {\\n  return object != null && hasPath(object, path, baseHasIn);\\n}\\n/**\\n * Creates an array of the own enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects. See the\\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\\n * for more details.\\n *\\n * @static\\n * @since 0.1.0\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keys(new Foo);\\n * // => ['a', 'b'] (iteration order is not guaranteed)\\n *\\n * _.keys('hi');\\n * // => ['0', '1']\\n */\\n\\n\\nfunction keys(object) {\\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\\n}\\n/**\\n * This method returns the first argument it receives.\\n *\\n * @static\\n * @since 0.1.0\\n * @memberOf _\\n * @category Util\\n * @param {*} value Any value.\\n * @returns {*} Returns `value`.\\n * @example\\n *\\n * var object = { 'a': 1 };\\n *\\n * console.log(_.identity(object) === object);\\n * // => true\\n */\\n\\n\\nfunction identity(value) {\\n  return value;\\n}\\n/**\\n * Creates a function that returns the value at `path` of a given object.\\n *\\n * @static\\n * @memberOf _\\n * @since 2.4.0\\n * @category Util\\n * @param {Array|string} path The path of the property to get.\\n * @returns {Function} Returns the new accessor function.\\n * @example\\n *\\n * var objects = [\\n *   { 'a': { 'b': 2 } },\\n *   { 'a': { 'b': 1 } }\\n * ];\\n *\\n * _.map(objects, _.property('a.b'));\\n * // => [2, 1]\\n *\\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\\n * // => [1, 2]\\n */\\n\\n\\nfunction property(path) {\\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\\n}\\n\\nmodule.exports = sortBy;\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],4:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \\\"function\\\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \\\"function\\\") { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } if (typeof _cache !== \\\"undefined\\\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\\n\\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\\n\\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\\n\\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\\\"[native code]\\\") !== -1; }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nvar isString = require(\\\"is-string\\\");\\n\\nvar utf8 = require(\\\"utf8-typed\\\");\\n\\nvar Buffer = /*#__PURE__*/function (_Uint8Array) {\\n  _inherits(Buffer, _Uint8Array);\\n\\n  var _super = _createSuper(Buffer);\\n\\n  function Buffer(input) {\\n    _classCallCheck(this, Buffer);\\n\\n    if (isString(input)) {\\n      input = utf8.encode(input);\\n    }\\n\\n    return _super.call(this, input);\\n  }\\n\\n  _createClass(Buffer, [{\\n    key: \\\"toString\\\",\\n    value: function toString() {\\n      return utf8.decode(this);\\n    }\\n  }], [{\\n    key: \\\"alloc\\\",\\n    value: function alloc(size, fill) {\\n      /*if (typeof size !== \\\"number\\\")\\n      {\\n      \\tthrow new TypeError(`\\\"size\\\" argument must be a number`);\\n      }\\n      else if (size < 0)\\n      {\\n      \\tthrow new RangeError(`\\\"size\\\" argument must not be negative`);\\n      }\\n      else\\n      {*/\\n      return new Buffer(size).fill(fill); //}\\n    }\\n  }, {\\n    key: \\\"from\\\",\\n    value: function from(input) {\\n      return new Buffer(input);\\n    }\\n  }]);\\n\\n  return Buffer;\\n}( /*#__PURE__*/_wrapNativeSuper(Uint8Array));\\n\\nmodule.exports = {\\n  Buffer: Buffer\\n};\\n\\n},{\\\"is-string\\\":2,\\\"utf8-typed\\\":7}],5:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nvar punycode = require(\\\"punycode\\\");\\n\\nvar uppercaseChars = /[A-Z]/g;\\n\\nvar toASCII = function toASCII(domainName) {\\n  var error = false; // Lowercase without changing any international Unicode characters\\n\\n  domainName = domainName.replace(uppercaseChars, function (match) {\\n    return match.toLowerCase();\\n  });\\n  var labels = domainName.split(\\\".\\\").map(function (label) {\\n    try {\\n      return punycode.toASCII(label);\\n    } catch (e) {\\n      error = true;\\n      return label;\\n    }\\n  });\\n  return !error ? labels.join(\\\".\\\") : null;\\n};\\n\\nvar toUnicode = function toUnicode(domainName) {\\n  var error = false;\\n  var labels = domainName.split(\\\".\\\").map(function (label) {\\n    try {\\n      return punycode.toUnicode(label);\\n    } catch (e) {\\n      error = true;\\n      return label;\\n    }\\n  });\\n  return {\\n    domain: labels.join(\\\".\\\"),\\n    error: error\\n  };\\n};\\n\\nmodule.exports = {\\n  toASCII: toASCII,\\n  toUnicode: toUnicode\\n};\\n\\n},{\\\"punycode\\\":1}],6:[function(require,module,exports){\\n(function (global){\\n\\\"use strict\\\";\\n\\nvar output = {};\\nvar g, hasNative;\\n\\nif (typeof window !== \\\"undefined\\\") {\\n  g = window;\\n} else if (typeof global !== \\\"undefined\\\") {\\n  g = global;\\n} else if (typeof self !== \\\"undefined\\\") {\\n  g = self;\\n} else {\\n  g = void 0;\\n}\\n\\ntry {\\n  var url = new g.URL(\\\"http://domain.com\\\");\\n  var params = new g.URLSearchParams(\\\"?param=value\\\");\\n  hasNative = \\\"searchParams\\\" in url && params.get(\\\"param\\\") === \\\"value\\\";\\n} catch (error) {\\n  hasNative = false;\\n}\\n\\nif (hasNative) {\\n  output.URL = g.URL;\\n  output.URLSearchParams = g.URLSearchParams;\\n} else {\\n  var lib = require(\\\"whatwg-url\\\");\\n\\n  output.URL = lib.URL;\\n  output.URLSearchParams = lib.URLSearchParams;\\n}\\n\\noutput.shim = function () {\\n  g.URL = output.URL;\\n  g.URLSearchParams = output.URLSearchParams;\\n};\\n\\nmodule.exports = output;\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"whatwg-url\\\":14}],7:[function(require,module,exports){\\n'use strict';\\n\\nvar REPLACEMENT_CHARACTER = 0xfffd;\\nvar REPLACEMENT_CHARACTER_1 = \\\"\\\\uFFFD\\\";\\nvar REPLACEMENT_CHARACTER_3 = \\\"\\\\uFFFD\\\\uFFFD\\\\uFFFD\\\"; // Taken from https://mths.be/punycode\\n\\nfunction ucs2decode(string) {\\n  var output = [];\\n  var counter = 0;\\n\\n  while (counter < string.length) {\\n    var value = string.charCodeAt(counter++);\\n\\n    if (value >= 0xd800 && value <= 0xdbff && counter < string.length) {\\n      // high surrogate, and there is a next character\\n      var extra = string.charCodeAt(counter);\\n\\n      if ((extra & 0xfc00) === 0xdc00) {\\n        // low surrogate\\n        output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\\n        counter++;\\n      } else {\\n        // unmatched surrogate; only append this code unit, in case the next\\n        // code unit is the high surrogate of a surrogate pair\\n        output.push(value);\\n      }\\n    } else {\\n      output.push(value);\\n    }\\n  }\\n\\n  return output;\\n}\\n\\nfunction ucs2encode(value) {\\n  if (value > 0xffff) {\\n    value -= 0x10000;\\n    return String.fromCharCode(value >>> 10 & 0x3ff | 0xd800) + String.fromCharCode(0xdc00 | value & 0x3ff);\\n  } else {\\n    return String.fromCharCode(value);\\n  }\\n}\\n\\nfunction checkScalarValue(codePoint) {\\n  return codePoint < 0xd800 || codePoint > 0xdfff;\\n}\\n\\nfunction createByte(codePoint, shift) {\\n  return codePoint >> shift & 0x3f | 0x80;\\n}\\n\\nfunction getUtf8Length(codePoint) {\\n  if ((codePoint & 0xffffff80) === 0) {\\n    return 1;\\n  } else if ((codePoint & 0xfffff800) === 0) {\\n    return 2;\\n  } else if ((codePoint & 0xffff0000) === 0) {\\n    return 3;\\n  } else {\\n    return 4;\\n  }\\n}\\n\\nfunction encodeCodePoint(buffer, index, codePoint) {\\n  if ((codePoint & 0xffffff80) === 0) {\\n    // 1-byte sequence\\n    buffer[index] = codePoint;\\n    return 1;\\n  }\\n\\n  var length;\\n\\n  if ((codePoint & 0xfffff800) === 0) {\\n    // 2-byte sequence\\n    length = 2;\\n    buffer[index++] = codePoint >> 6 & 0x1f | 0xc0;\\n  } else if ((codePoint & 0xffff0000) === 0) {\\n    // 3-byte sequence\\n    length = 3;\\n\\n    if (!checkScalarValue(codePoint)) {\\n      codePoint = REPLACEMENT_CHARACTER;\\n    }\\n\\n    buffer[index++] = codePoint >> 12 & 0x0f | 0xe0;\\n    buffer[index++] = createByte(codePoint, 6);\\n  } else {\\n    // 4-byte sequence\\n    length = 4;\\n    buffer[index++] = codePoint >> 18 & 0x07 | 0xf0;\\n    buffer[index++] = createByte(codePoint, 12);\\n    buffer[index++] = createByte(codePoint, 6);\\n  }\\n\\n  buffer[index] = codePoint & 0x3f | 0x80;\\n  return length;\\n}\\n\\nfunction utf8encode(string) {\\n  var codePoints = ucs2decode(string);\\n  var utf8Length = 0;\\n  var i;\\n\\n  for (i = 0; i < codePoints.length; i++) {\\n    utf8Length += getUtf8Length(codePoints[i]);\\n  }\\n\\n  var encoded = new Uint8Array(utf8Length);\\n  var offset = 0;\\n\\n  for (i = 0; i < codePoints.length; i++) {\\n    offset += encodeCodePoint(encoded, offset, codePoints[i]);\\n  }\\n\\n  return encoded;\\n}\\n\\nfunction isContinuation(_byte) {\\n  return (_byte & 0xc0) === 0x80;\\n}\\n\\nfunction utf8decode(byteArray) {\\n  var l = byteArray.length;\\n  var result = '';\\n\\n  for (var i = 0; i < l; i++) {\\n    var c = byteArray[i];\\n    var c2;\\n    var c3;\\n    var c4;\\n\\n    if (c < 0x80) {\\n      result += String.fromCharCode(c);\\n    } else if ((c & 0xe0) === 0xc0) {\\n      // 2-byte sequence\\n      if (c < (0xc0 | 2)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      if (i + 1 === l) {\\n        return result + REPLACEMENT_CHARACTER_1;\\n      }\\n\\n      c2 = byteArray[i + 1];\\n\\n      if (!isContinuation(c2)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      i++;\\n      result += String.fromCharCode((c & 0x1f) << 6 | c2 & 0x3f);\\n    } else if ((c & 0xf0) === 0xe0) {\\n      // 3-byte sequence\\n      if (i + 1 === l) {\\n        return result + REPLACEMENT_CHARACTER_1;\\n      }\\n\\n      c2 = byteArray[i + 1];\\n\\n      if (!isContinuation(c2) || c === 0xe0 && c2 < (0x80 | 0x20)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      i++;\\n\\n      if (i + 1 === l) {\\n        return result + REPLACEMENT_CHARACTER_1;\\n      }\\n\\n      c3 = byteArray[i + 1];\\n\\n      if (!isContinuation(c3)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      i++;\\n      var codePoint = (c & 0x0f) << 12 | (c2 & 0x3f) << 6 | c3 & 0x3f;\\n\\n      if (!checkScalarValue(codePoint)) {\\n        result += REPLACEMENT_CHARACTER_3;\\n        continue;\\n      }\\n\\n      result += ucs2encode(codePoint);\\n    } else if ((c & 0xf8) === 0xf0) {\\n      // 4-byte sequence\\n      if (i + 1 === l) {\\n        return result + REPLACEMENT_CHARACTER_1;\\n      }\\n\\n      c2 = byteArray[i + 1];\\n\\n      if (!isContinuation(c2) || c === 0xf0 && c2 < (0x80 | 0x10)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      i++;\\n\\n      if (i + 1 === l) {\\n        return result + REPLACEMENT_CHARACTER_1;\\n      }\\n\\n      c3 = byteArray[i + 1];\\n\\n      if (!isContinuation(c3)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      i++;\\n\\n      if (i + 1 === l) {\\n        return result + REPLACEMENT_CHARACTER_1;\\n      }\\n\\n      c4 = byteArray[i + 1];\\n\\n      if (!isContinuation(c4)) {\\n        result += REPLACEMENT_CHARACTER_1;\\n        continue;\\n      }\\n\\n      i++;\\n      result += ucs2encode((c & 0x07) << 18 | (c2 & 0x3f) << 12 | (c3 & 0x3f) << 6 | c4 & 0x3f);\\n    } else {\\n      result += REPLACEMENT_CHARACTER_1;\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nexports.encode = utf8encode;\\nexports.decode = utf8decode;\\n\\n},{}],8:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _(message, opts) {\\n  return \\\"\\\".concat(opts && opts.context ? opts.context : \\\"Value\\\", \\\" \\\").concat(message, \\\".\\\");\\n}\\n\\nfunction type(V) {\\n  if (V === null) {\\n    return \\\"Null\\\";\\n  }\\n\\n  switch (_typeof(V)) {\\n    case \\\"undefined\\\":\\n      return \\\"Undefined\\\";\\n\\n    case \\\"boolean\\\":\\n      return \\\"Boolean\\\";\\n\\n    case \\\"number\\\":\\n      return \\\"Number\\\";\\n\\n    case \\\"string\\\":\\n      return \\\"String\\\";\\n\\n    case \\\"symbol\\\":\\n      return \\\"Symbol\\\";\\n\\n    case \\\"object\\\": // Falls through\\n\\n    case \\\"function\\\": // Falls through\\n\\n    default:\\n      // Per ES spec, typeof returns an implemention-defined value that is not any of the existing ones for\\n      // uncallable non-standard exotic objects. Yet Type() which the Web IDL spec depends on returns Object for\\n      // such cases. So treat the default case as an object.\\n      return \\\"Object\\\";\\n  }\\n} // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\\n\\n\\nfunction evenRound(x) {\\n  // There are four cases for numbers with fractional part being .5:\\n  //\\n  // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\\n  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\\n  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\\n  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\\n  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\\n  // (where n is a non-negative integer)\\n  //\\n  // Branch here for cases 1 and 4\\n  if (x > 0 && x % 1 === +0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {\\n    return censorNegativeZero(Math.floor(x));\\n  }\\n\\n  return censorNegativeZero(Math.round(x));\\n}\\n\\nfunction integerPart(n) {\\n  return censorNegativeZero(Math.trunc(n));\\n}\\n\\nfunction sign(x) {\\n  return x < 0 ? -1 : 1;\\n}\\n\\nfunction modulo(x, y) {\\n  // https://tc39.github.io/ecma262/#eqn-modulo\\n  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos\\n  var signMightNotMatch = x % y;\\n\\n  if (sign(y) !== sign(signMightNotMatch)) {\\n    return signMightNotMatch + y;\\n  }\\n\\n  return signMightNotMatch;\\n}\\n\\nfunction censorNegativeZero(x) {\\n  return x === 0 ? 0 : x;\\n}\\n\\nfunction createIntegerConversion(bitLength, typeOpts) {\\n  var isSigned = !typeOpts.unsigned;\\n  var lowerBound;\\n  var upperBound;\\n\\n  if (bitLength === 64) {\\n    upperBound = Math.pow(2, 53) - 1;\\n    lowerBound = !isSigned ? 0 : -Math.pow(2, 53) + 1;\\n  } else if (!isSigned) {\\n    lowerBound = 0;\\n    upperBound = Math.pow(2, bitLength) - 1;\\n  } else {\\n    lowerBound = -Math.pow(2, bitLength - 1);\\n    upperBound = Math.pow(2, bitLength - 1) - 1;\\n  }\\n\\n  var twoToTheBitLength = Math.pow(2, bitLength);\\n  var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);\\n  return function (V, opts) {\\n    if (opts === undefined) {\\n      opts = {};\\n    }\\n\\n    var x = +V;\\n    x = censorNegativeZero(x); // Spec discussion ongoing: https://github.com/heycam/webidl/issues/306\\n\\n    if (opts.enforceRange) {\\n      if (!Number.isFinite(x)) {\\n        throw new TypeError(_(\\\"is not a finite number\\\", opts));\\n      }\\n\\n      x = integerPart(x);\\n\\n      if (x < lowerBound || x > upperBound) {\\n        throw new TypeError(_(\\\"is outside the accepted range of \\\".concat(lowerBound, \\\" to \\\").concat(upperBound, \\\", inclusive\\\"), opts));\\n      }\\n\\n      return x;\\n    }\\n\\n    if (!Number.isNaN(x) && opts.clamp) {\\n      x = Math.min(Math.max(x, lowerBound), upperBound);\\n      x = evenRound(x);\\n      return x;\\n    }\\n\\n    if (!Number.isFinite(x) || x === 0) {\\n      return 0;\\n    }\\n\\n    x = integerPart(x); // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if\\n    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.\\n\\n    if (x >= lowerBound && x <= upperBound) {\\n      return x;\\n    } // These will not work great for bitLength of 64, but oh well. See the README for more details.\\n\\n\\n    x = modulo(x, twoToTheBitLength);\\n\\n    if (isSigned && x >= twoToOneLessThanTheBitLength) {\\n      return x - twoToTheBitLength;\\n    }\\n\\n    return x;\\n  };\\n}\\n\\nexports.any = function (V) {\\n  return V;\\n};\\n\\nexports[\\\"void\\\"] = function () {\\n  return undefined;\\n};\\n\\nexports[\\\"boolean\\\"] = function (val) {\\n  return !!val;\\n};\\n\\nexports[\\\"byte\\\"] = createIntegerConversion(8, {\\n  unsigned: false\\n});\\nexports.octet = createIntegerConversion(8, {\\n  unsigned: true\\n});\\nexports[\\\"short\\\"] = createIntegerConversion(16, {\\n  unsigned: false\\n});\\nexports[\\\"unsigned short\\\"] = createIntegerConversion(16, {\\n  unsigned: true\\n});\\nexports[\\\"long\\\"] = createIntegerConversion(32, {\\n  unsigned: false\\n});\\nexports[\\\"unsigned long\\\"] = createIntegerConversion(32, {\\n  unsigned: true\\n});\\nexports[\\\"long long\\\"] = createIntegerConversion(64, {\\n  unsigned: false\\n});\\nexports[\\\"unsigned long long\\\"] = createIntegerConversion(64, {\\n  unsigned: true\\n});\\n\\nexports[\\\"double\\\"] = function (V, opts) {\\n  var x = +V;\\n\\n  if (!Number.isFinite(x)) {\\n    throw new TypeError(_(\\\"is not a finite floating-point value\\\", opts));\\n  }\\n\\n  return x;\\n};\\n\\nexports[\\\"unrestricted double\\\"] = function (V) {\\n  var x = +V;\\n  return x;\\n};\\n\\nexports[\\\"float\\\"] = function (V, opts) {\\n  var x = +V;\\n\\n  if (!Number.isFinite(x)) {\\n    throw new TypeError(_(\\\"is not a finite floating-point value\\\", opts));\\n  }\\n\\n  if (Object.is(x, -0)) {\\n    return x;\\n  }\\n\\n  var y = Math.fround(x);\\n\\n  if (!Number.isFinite(y)) {\\n    throw new TypeError(_(\\\"is outside the range of a single-precision floating-point value\\\", opts));\\n  }\\n\\n  return y;\\n};\\n\\nexports[\\\"unrestricted float\\\"] = function (V) {\\n  var x = +V;\\n\\n  if (isNaN(x)) {\\n    return x;\\n  }\\n\\n  if (Object.is(x, -0)) {\\n    return x;\\n  }\\n\\n  return Math.fround(x);\\n};\\n\\nexports.DOMString = function (V, opts) {\\n  if (opts === undefined) {\\n    opts = {};\\n  }\\n\\n  if (opts.treatNullAsEmptyString && V === null) {\\n    return \\\"\\\";\\n  }\\n\\n  if (_typeof(V) === \\\"symbol\\\") {\\n    throw new TypeError(_(\\\"is a symbol, which cannot be converted to a string\\\", opts));\\n  }\\n\\n  return String(V);\\n};\\n\\nexports.ByteString = function (V, opts) {\\n  var x = exports.DOMString(V, opts);\\n  var c;\\n\\n  for (var i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\\n    if (c > 255) {\\n      throw new TypeError(_(\\\"is not a valid ByteString\\\", opts));\\n    }\\n  }\\n\\n  return x;\\n};\\n\\nexports.USVString = function (V, opts) {\\n  var S = exports.DOMString(V, opts);\\n  var n = S.length;\\n  var U = [];\\n\\n  for (var i = 0; i < n; ++i) {\\n    var c = S.charCodeAt(i);\\n\\n    if (c < 0xD800 || c > 0xDFFF) {\\n      U.push(String.fromCodePoint(c));\\n    } else if (0xDC00 <= c && c <= 0xDFFF) {\\n      U.push(String.fromCodePoint(0xFFFD));\\n    } else if (i === n - 1) {\\n      U.push(String.fromCodePoint(0xFFFD));\\n    } else {\\n      var d = S.charCodeAt(i + 1);\\n\\n      if (0xDC00 <= d && d <= 0xDFFF) {\\n        var a = c & 0x3FF;\\n        var b = d & 0x3FF;\\n        U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\\n        ++i;\\n      } else {\\n        U.push(String.fromCodePoint(0xFFFD));\\n      }\\n    }\\n  }\\n\\n  return U.join(\\\"\\\");\\n};\\n\\nexports.object = function (V, opts) {\\n  if (type(V) !== \\\"Object\\\") {\\n    throw new TypeError(_(\\\"is not an object\\\", opts));\\n  }\\n\\n  return V;\\n}; // Not exported, but used in Function and VoidFunction.\\n// Neither Function nor VoidFunction is defined with [TreatNonObjectAsNull], so\\n// handling for that is omitted.\\n\\n\\nfunction convertCallbackFunction(V, opts) {\\n  if (typeof V !== \\\"function\\\") {\\n    throw new TypeError(_(\\\"is not a function\\\", opts));\\n  }\\n\\n  return V;\\n}\\n\\n[Error, ArrayBuffer, // The IsDetachedBuffer abstract operation is not exposed in JS\\nDataView, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array].forEach(function (func) {\\n  var name = func.name;\\n  var article = /^[AEIOU]/.test(name) ? \\\"an\\\" : \\\"a\\\";\\n\\n  exports[name] = function (V, opts) {\\n    if (!(V instanceof func)) {\\n      throw new TypeError(_(\\\"is not \\\".concat(article, \\\" \\\").concat(name, \\\" object\\\"), opts));\\n    }\\n\\n    return V;\\n  };\\n}); // Common definitions\\n\\nexports.ArrayBufferView = function (V, opts) {\\n  if (!ArrayBuffer.isView(V)) {\\n    throw new TypeError(_(\\\"is not a view on an ArrayBuffer object\\\", opts));\\n  }\\n\\n  return V;\\n};\\n\\nexports.BufferSource = function (V, opts) {\\n  if (!(ArrayBuffer.isView(V) || V instanceof ArrayBuffer)) {\\n    throw new TypeError(_(\\\"is not an ArrayBuffer object or a view on one\\\", opts));\\n  }\\n\\n  return V;\\n};\\n\\nexports.DOMTimeStamp = exports[\\\"unsigned long long\\\"];\\nexports.Function = convertCallbackFunction;\\nexports.VoidFunction = convertCallbackFunction;\\n\\n},{}],9:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nvar usm = require(\\\"./url-state-machine\\\");\\n\\nvar urlencoded = require(\\\"./urlencoded\\\");\\n\\nvar URLSearchParams = require(\\\"./URLSearchParams\\\");\\n\\nexports.implementation = /*#__PURE__*/function () {\\n  function URLImpl(constructorArgs) {\\n    _classCallCheck(this, URLImpl);\\n\\n    var url = constructorArgs[0];\\n    var base = constructorArgs[1];\\n    var parsedBase = null;\\n\\n    if (base !== undefined) {\\n      parsedBase = usm.basicURLParse(base);\\n\\n      if (parsedBase === null) {\\n        throw new TypeError(\\\"Invalid base URL: \\\".concat(base));\\n      }\\n    }\\n\\n    var parsedURL = usm.basicURLParse(url, {\\n      baseURL: parsedBase\\n    });\\n\\n    if (parsedURL === null) {\\n      throw new TypeError(\\\"Invalid URL: \\\".concat(url));\\n    }\\n\\n    var query = parsedURL.query !== null ? parsedURL.query : \\\"\\\";\\n    this._url = parsedURL; // We cannot invoke the \\\"new URLSearchParams object\\\" algorithm without going through the constructor, which strips\\n    // question mark by default. Therefore the doNotStripQMark hack is used.\\n\\n    this._query = URLSearchParams.createImpl([query], {\\n      doNotStripQMark: true\\n    });\\n    this._query._url = this;\\n  }\\n\\n  _createClass(URLImpl, [{\\n    key: \\\"toJSON\\\",\\n    value: function toJSON() {\\n      return this.href;\\n    }\\n  }, {\\n    key: \\\"href\\\",\\n    get: function get() {\\n      return usm.serializeURL(this._url);\\n    },\\n    set: function set(v) {\\n      var parsedURL = usm.basicURLParse(v);\\n\\n      if (parsedURL === null) {\\n        throw new TypeError(\\\"Invalid URL: \\\".concat(v));\\n      }\\n\\n      this._url = parsedURL;\\n\\n      this._query._list.splice(0);\\n\\n      var query = parsedURL.query;\\n\\n      if (query !== null) {\\n        this._query._list = urlencoded.parseUrlencoded(query);\\n      }\\n    }\\n  }, {\\n    key: \\\"origin\\\",\\n    get: function get() {\\n      return usm.serializeURLOrigin(this._url);\\n    }\\n  }, {\\n    key: \\\"protocol\\\",\\n    get: function get() {\\n      return this._url.scheme + \\\":\\\";\\n    },\\n    set: function set(v) {\\n      usm.basicURLParse(v + \\\":\\\", {\\n        url: this._url,\\n        stateOverride: \\\"scheme start\\\"\\n      });\\n    }\\n  }, {\\n    key: \\\"username\\\",\\n    get: function get() {\\n      return this._url.username;\\n    },\\n    set: function set(v) {\\n      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\\n        return;\\n      }\\n\\n      usm.setTheUsername(this._url, v);\\n    }\\n  }, {\\n    key: \\\"password\\\",\\n    get: function get() {\\n      return this._url.password;\\n    },\\n    set: function set(v) {\\n      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\\n        return;\\n      }\\n\\n      usm.setThePassword(this._url, v);\\n    }\\n  }, {\\n    key: \\\"host\\\",\\n    get: function get() {\\n      var url = this._url;\\n\\n      if (url.host === null) {\\n        return \\\"\\\";\\n      }\\n\\n      if (url.port === null) {\\n        return usm.serializeHost(url.host);\\n      }\\n\\n      return usm.serializeHost(url.host) + \\\":\\\" + usm.serializeInteger(url.port);\\n    },\\n    set: function set(v) {\\n      if (this._url.cannotBeABaseURL) {\\n        return;\\n      }\\n\\n      usm.basicURLParse(v, {\\n        url: this._url,\\n        stateOverride: \\\"host\\\"\\n      });\\n    }\\n  }, {\\n    key: \\\"hostname\\\",\\n    get: function get() {\\n      if (this._url.host === null) {\\n        return \\\"\\\";\\n      }\\n\\n      return usm.serializeHost(this._url.host);\\n    },\\n    set: function set(v) {\\n      if (this._url.cannotBeABaseURL) {\\n        return;\\n      }\\n\\n      usm.basicURLParse(v, {\\n        url: this._url,\\n        stateOverride: \\\"hostname\\\"\\n      });\\n    }\\n  }, {\\n    key: \\\"port\\\",\\n    get: function get() {\\n      if (this._url.port === null) {\\n        return \\\"\\\";\\n      }\\n\\n      return usm.serializeInteger(this._url.port);\\n    },\\n    set: function set(v) {\\n      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\\n        return;\\n      }\\n\\n      if (v === \\\"\\\") {\\n        this._url.port = null;\\n      } else {\\n        usm.basicURLParse(v, {\\n          url: this._url,\\n          stateOverride: \\\"port\\\"\\n        });\\n      }\\n    }\\n  }, {\\n    key: \\\"pathname\\\",\\n    get: function get() {\\n      if (this._url.cannotBeABaseURL) {\\n        return this._url.path[0];\\n      }\\n\\n      if (this._url.path.length === 0) {\\n        return \\\"\\\";\\n      }\\n\\n      return \\\"/\\\" + this._url.path.join(\\\"/\\\");\\n    },\\n    set: function set(v) {\\n      if (this._url.cannotBeABaseURL) {\\n        return;\\n      }\\n\\n      this._url.path = [];\\n      usm.basicURLParse(v, {\\n        url: this._url,\\n        stateOverride: \\\"path start\\\"\\n      });\\n    }\\n  }, {\\n    key: \\\"search\\\",\\n    get: function get() {\\n      if (this._url.query === null || this._url.query === \\\"\\\") {\\n        return \\\"\\\";\\n      }\\n\\n      return \\\"?\\\" + this._url.query;\\n    },\\n    set: function set(v) {\\n      var url = this._url;\\n\\n      if (v === \\\"\\\") {\\n        url.query = null;\\n        this._query._list = [];\\n        return;\\n      }\\n\\n      var input = v[0] === \\\"?\\\" ? v.substring(1) : v;\\n      url.query = \\\"\\\";\\n      usm.basicURLParse(input, {\\n        url: url,\\n        stateOverride: \\\"query\\\"\\n      });\\n      this._query._list = urlencoded.parseUrlencoded(input);\\n    }\\n  }, {\\n    key: \\\"searchParams\\\",\\n    get: function get() {\\n      return this._query;\\n    }\\n  }, {\\n    key: \\\"hash\\\",\\n    get: function get() {\\n      if (this._url.fragment === null || this._url.fragment === \\\"\\\") {\\n        return \\\"\\\";\\n      }\\n\\n      return \\\"#\\\" + this._url.fragment;\\n    },\\n    set: function set(v) {\\n      if (v === \\\"\\\") {\\n        this._url.fragment = null;\\n        return;\\n      }\\n\\n      var input = v[0] === \\\"#\\\" ? v.substring(1) : v;\\n      this._url.fragment = \\\"\\\";\\n      usm.basicURLParse(input, {\\n        url: this._url,\\n        stateOverride: \\\"fragment\\\"\\n      });\\n    }\\n  }]);\\n\\n  return URLImpl;\\n}();\\n\\n},{\\\"./URLSearchParams\\\":12,\\\"./url-state-machine\\\":15,\\\"./urlencoded\\\":16}],10:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \\\"undefined\\\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(n); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nvar conversions = require(\\\"webidl-conversions\\\");\\n\\nvar utils = require(\\\"./utils.js\\\");\\n\\nvar impl = utils.implSymbol;\\n\\nvar URL = /*#__PURE__*/function () {\\n  function URL(url) {\\n    _classCallCheck(this, URL);\\n\\n    if (arguments.length < 1) {\\n      throw new TypeError(\\\"Failed to construct 'URL': 1 argument required, but only \\\" + arguments.length + \\\" present.\\\");\\n    }\\n\\n    var args = [];\\n    {\\n      var curArg = arguments[0];\\n      curArg = conversions[\\\"USVString\\\"](curArg, {\\n        context: \\\"Failed to construct 'URL': parameter 1\\\"\\n      });\\n      args.push(curArg);\\n    }\\n    {\\n      var _curArg = arguments[1];\\n\\n      if (_curArg !== undefined) {\\n        _curArg = conversions[\\\"USVString\\\"](_curArg, {\\n          context: \\\"Failed to construct 'URL': parameter 2\\\"\\n        });\\n      }\\n\\n      args.push(_curArg);\\n    }\\n    return iface.setup(Object.create((this instanceof URL ? this.constructor : void 0).prototype), args);\\n  }\\n\\n  _createClass(URL, [{\\n    key: \\\"toJSON\\\",\\n    value: function toJSON() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl].toJSON();\\n    }\\n  }, {\\n    key: \\\"toString\\\",\\n    value: function toString() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"href\\\"];\\n    }\\n  }, {\\n    key: \\\"href\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"href\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'href' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"href\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"origin\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"origin\\\"];\\n    }\\n  }, {\\n    key: \\\"protocol\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"protocol\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'protocol' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"protocol\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"username\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"username\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'username' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"username\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"password\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"password\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'password' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"password\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"host\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"host\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'host' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"host\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"hostname\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"hostname\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'hostname' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"hostname\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"port\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"port\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'port' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"port\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"pathname\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"pathname\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'pathname' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"pathname\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"search\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"search\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'search' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"search\\\"] = V;\\n    }\\n  }, {\\n    key: \\\"searchParams\\\",\\n    get: function get() {\\n      var _this = this;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return utils.getSameObject(this, \\\"searchParams\\\", function () {\\n        return utils.tryWrapperForImpl(_this[impl][\\\"searchParams\\\"]);\\n      });\\n    }\\n  }, {\\n    key: \\\"hash\\\",\\n    get: function get() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl][\\\"hash\\\"];\\n    },\\n    set: function set(V) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      V = conversions[\\\"USVString\\\"](V, {\\n        context: \\\"Failed to set the 'hash' property on 'URL': The provided value\\\"\\n      });\\n      this[impl][\\\"hash\\\"] = V;\\n    }\\n  }]);\\n\\n  return URL;\\n}();\\n\\nObject.defineProperties(URL.prototype, _defineProperty({\\n  toJSON: {\\n    enumerable: true\\n  },\\n  href: {\\n    enumerable: true\\n  },\\n  toString: {\\n    enumerable: true\\n  },\\n  origin: {\\n    enumerable: true\\n  },\\n  protocol: {\\n    enumerable: true\\n  },\\n  username: {\\n    enumerable: true\\n  },\\n  password: {\\n    enumerable: true\\n  },\\n  host: {\\n    enumerable: true\\n  },\\n  hostname: {\\n    enumerable: true\\n  },\\n  port: {\\n    enumerable: true\\n  },\\n  pathname: {\\n    enumerable: true\\n  },\\n  search: {\\n    enumerable: true\\n  },\\n  searchParams: {\\n    enumerable: true\\n  },\\n  hash: {\\n    enumerable: true\\n  }\\n}, Symbol.toStringTag, {\\n  value: \\\"URL\\\",\\n  configurable: true\\n}));\\nvar iface = {\\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\\n  // implementing this mixin interface.\\n  _mixedIntoPredicates: [],\\n  is: function is(obj) {\\n    if (obj) {\\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\\n        return true;\\n      }\\n\\n      var _iterator = _createForOfIteratorHelper(module.exports._mixedIntoPredicates),\\n          _step;\\n\\n      try {\\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n          var isMixedInto = _step.value;\\n\\n          if (isMixedInto(obj)) {\\n            return true;\\n          }\\n        }\\n      } catch (err) {\\n        _iterator.e(err);\\n      } finally {\\n        _iterator.f();\\n      }\\n    }\\n\\n    return false;\\n  },\\n  isImpl: function isImpl(obj) {\\n    if (obj) {\\n      if (obj instanceof Impl.implementation) {\\n        return true;\\n      }\\n\\n      var wrapper = utils.wrapperForImpl(obj);\\n\\n      var _iterator2 = _createForOfIteratorHelper(module.exports._mixedIntoPredicates),\\n          _step2;\\n\\n      try {\\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\n          var isMixedInto = _step2.value;\\n\\n          if (isMixedInto(wrapper)) {\\n            return true;\\n          }\\n        }\\n      } catch (err) {\\n        _iterator2.e(err);\\n      } finally {\\n        _iterator2.f();\\n      }\\n    }\\n\\n    return false;\\n  },\\n  convert: function convert(obj) {\\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\\n        _ref$context = _ref.context,\\n        context = _ref$context === void 0 ? \\\"The provided value\\\" : _ref$context;\\n\\n    if (module.exports.is(obj)) {\\n      return utils.implForWrapper(obj);\\n    }\\n\\n    throw new TypeError(\\\"\\\".concat(context, \\\" is not of type 'URL'.\\\"));\\n  },\\n  create: function create(constructorArgs, privateData) {\\n    var obj = Object.create(URL.prototype);\\n    obj = this.setup(obj, constructorArgs, privateData);\\n    return obj;\\n  },\\n  createImpl: function createImpl(constructorArgs, privateData) {\\n    var obj = Object.create(URL.prototype);\\n    obj = this.setup(obj, constructorArgs, privateData);\\n    return utils.implForWrapper(obj);\\n  },\\n  _internalSetup: function _internalSetup(obj) {},\\n  setup: function setup(obj, constructorArgs, privateData) {\\n    if (!privateData) privateData = {};\\n    privateData.wrapper = obj;\\n\\n    this._internalSetup(obj);\\n\\n    Object.defineProperty(obj, impl, {\\n      value: new Impl.implementation(constructorArgs, privateData),\\n      configurable: true\\n    });\\n    obj[impl][utils.wrapperSymbol] = obj;\\n\\n    if (Impl.init) {\\n      Impl.init(obj[impl], privateData);\\n    }\\n\\n    return obj;\\n  },\\n  \\\"interface\\\": URL,\\n  expose: {\\n    Window: {\\n      URL: URL\\n    },\\n    Worker: {\\n      URL: URL\\n    }\\n  }\\n}; // iface\\n\\nmodule.exports = iface;\\n\\nvar Impl = require(\\\"./URL-impl.js\\\");\\n\\n},{\\\"./URL-impl.js\\\":9,\\\"./utils.js\\\":17,\\\"webidl-conversions\\\":8}],11:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \\\"undefined\\\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(n); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nvar stableSortBy = require(\\\"lodash.sortby\\\");\\n\\nvar urlencoded = require(\\\"./urlencoded\\\");\\n\\nexports.implementation = /*#__PURE__*/function () {\\n  function URLSearchParamsImpl(constructorArgs, _ref) {\\n    var _ref$doNotStripQMark = _ref.doNotStripQMark,\\n        doNotStripQMark = _ref$doNotStripQMark === void 0 ? false : _ref$doNotStripQMark;\\n\\n    _classCallCheck(this, URLSearchParamsImpl);\\n\\n    var init = constructorArgs[0];\\n    this._list = [];\\n    this._url = null;\\n\\n    if (!doNotStripQMark && typeof init === \\\"string\\\" && init[0] === \\\"?\\\") {\\n      init = init.slice(1);\\n    }\\n\\n    if (Array.isArray(init)) {\\n      var _iterator = _createForOfIteratorHelper(init),\\n          _step;\\n\\n      try {\\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n          var pair = _step.value;\\n\\n          if (pair.length !== 2) {\\n            throw new TypeError(\\\"Failed to construct 'URLSearchParams': parameter 1 sequence's element does not \\\" + \\\"contain exactly two elements.\\\");\\n          }\\n\\n          this._list.push([pair[0], pair[1]]);\\n        }\\n      } catch (err) {\\n        _iterator.e(err);\\n      } finally {\\n        _iterator.f();\\n      }\\n    } else if (_typeof(init) === \\\"object\\\" && Object.getPrototypeOf(init) === null) {\\n      for (var _i = 0, _Object$keys = Object.keys(init); _i < _Object$keys.length; _i++) {\\n        var name = _Object$keys[_i];\\n        var value = init[name];\\n\\n        this._list.push([name, value]);\\n      }\\n    } else {\\n      this._list = urlencoded.parseUrlencoded(init);\\n    }\\n  }\\n\\n  _createClass(URLSearchParamsImpl, [{\\n    key: \\\"_updateSteps\\\",\\n    value: function _updateSteps() {\\n      if (this._url !== null) {\\n        var query = urlencoded.serializeUrlencoded(this._list);\\n\\n        if (query === \\\"\\\") {\\n          query = null;\\n        }\\n\\n        this._url._url.query = query;\\n      }\\n    }\\n  }, {\\n    key: \\\"append\\\",\\n    value: function append(name, value) {\\n      this._list.push([name, value]);\\n\\n      this._updateSteps();\\n    }\\n  }, {\\n    key: \\\"delete\\\",\\n    value: function _delete(name) {\\n      var i = 0;\\n\\n      while (i < this._list.length) {\\n        if (this._list[i][0] === name) {\\n          this._list.splice(i, 1);\\n        } else {\\n          i++;\\n        }\\n      }\\n\\n      this._updateSteps();\\n    }\\n  }, {\\n    key: \\\"get\\\",\\n    value: function get(name) {\\n      var _iterator2 = _createForOfIteratorHelper(this._list),\\n          _step2;\\n\\n      try {\\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\n          var tuple = _step2.value;\\n\\n          if (tuple[0] === name) {\\n            return tuple[1];\\n          }\\n        }\\n      } catch (err) {\\n        _iterator2.e(err);\\n      } finally {\\n        _iterator2.f();\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: \\\"getAll\\\",\\n    value: function getAll(name) {\\n      var output = [];\\n\\n      var _iterator3 = _createForOfIteratorHelper(this._list),\\n          _step3;\\n\\n      try {\\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\n          var tuple = _step3.value;\\n\\n          if (tuple[0] === name) {\\n            output.push(tuple[1]);\\n          }\\n        }\\n      } catch (err) {\\n        _iterator3.e(err);\\n      } finally {\\n        _iterator3.f();\\n      }\\n\\n      return output;\\n    }\\n  }, {\\n    key: \\\"has\\\",\\n    value: function has(name) {\\n      var _iterator4 = _createForOfIteratorHelper(this._list),\\n          _step4;\\n\\n      try {\\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\\n          var tuple = _step4.value;\\n\\n          if (tuple[0] === name) {\\n            return true;\\n          }\\n        }\\n      } catch (err) {\\n        _iterator4.e(err);\\n      } finally {\\n        _iterator4.f();\\n      }\\n\\n      return false;\\n    }\\n  }, {\\n    key: \\\"set\\\",\\n    value: function set(name, value) {\\n      var found = false;\\n      var i = 0;\\n\\n      while (i < this._list.length) {\\n        if (this._list[i][0] === name) {\\n          if (found) {\\n            this._list.splice(i, 1);\\n          } else {\\n            found = true;\\n            this._list[i][1] = value;\\n            i++;\\n          }\\n        } else {\\n          i++;\\n        }\\n      }\\n\\n      if (!found) {\\n        this._list.push([name, value]);\\n      }\\n\\n      this._updateSteps();\\n    }\\n  }, {\\n    key: \\\"sort\\\",\\n    value: function sort() {\\n      this._list = stableSortBy(this._list, [0]);\\n\\n      this._updateSteps();\\n    }\\n  }, {\\n    key: Symbol.iterator,\\n    value: function value() {\\n      return this._list[Symbol.iterator]();\\n    }\\n  }, {\\n    key: \\\"toString\\\",\\n    value: function toString() {\\n      return urlencoded.serializeUrlencoded(this._list);\\n    }\\n  }]);\\n\\n  return URLSearchParamsImpl;\\n}();\\n\\n},{\\\"./urlencoded\\\":16,\\\"lodash.sortby\\\":3}],12:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nvar _Object$definePropert;\\n\\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \\\"undefined\\\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\\n\\nfunction _nonIterableRest() { throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(n); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \\\"undefined\\\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\"return\\\"] != null) _i[\\\"return\\\"](); } finally { if (_d) throw _e; } } return _arr; }\\n\\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\n\\nvar conversions = require(\\\"webidl-conversions\\\");\\n\\nvar utils = require(\\\"./utils.js\\\");\\n\\nvar impl = utils.implSymbol;\\nvar IteratorPrototype = Object.create(utils.IteratorPrototype, _defineProperty({\\n  next: {\\n    value: function next() {\\n      var internal = this[utils.iterInternalSymbol];\\n      var target = internal.target,\\n          kind = internal.kind,\\n          index = internal.index;\\n      var values = Array.from(target[impl]);\\n      var len = values.length;\\n\\n      if (index >= len) {\\n        return {\\n          value: undefined,\\n          done: true\\n        };\\n      }\\n\\n      var pair = values[index];\\n      internal.index = index + 1;\\n\\n      var _pair$map = pair.map(utils.tryWrapperForImpl),\\n          _pair$map2 = _slicedToArray(_pair$map, 2),\\n          key = _pair$map2[0],\\n          value = _pair$map2[1];\\n\\n      var result;\\n\\n      switch (kind) {\\n        case \\\"key\\\":\\n          result = key;\\n          break;\\n\\n        case \\\"value\\\":\\n          result = value;\\n          break;\\n\\n        case \\\"key+value\\\":\\n          result = [key, value];\\n          break;\\n      }\\n\\n      return {\\n        value: result,\\n        done: false\\n      };\\n    },\\n    writable: true,\\n    enumerable: true,\\n    configurable: true\\n  }\\n}, Symbol.toStringTag, {\\n  value: \\\"URLSearchParams Iterator\\\",\\n  configurable: true\\n}));\\n\\nvar URLSearchParams = /*#__PURE__*/function () {\\n  function URLSearchParams() {\\n    _classCallCheck(this, URLSearchParams);\\n\\n    var args = [];\\n    {\\n      var curArg = arguments[0];\\n\\n      if (curArg !== undefined) {\\n        if (utils.isObject(curArg)) {\\n          if (curArg[Symbol.iterator] !== undefined) {\\n            if (!utils.isObject(curArg)) {\\n              throw new TypeError(\\\"Failed to construct 'URLSearchParams': parameter 1\\\" + \\\" sequence\\\" + \\\" is not an iterable object.\\\");\\n            } else {\\n              var V = [];\\n              var tmp = curArg;\\n\\n              var _iterator = _createForOfIteratorHelper(tmp),\\n                  _step;\\n\\n              try {\\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n                  var nextItem = _step.value;\\n\\n                  if (!utils.isObject(nextItem)) {\\n                    throw new TypeError(\\\"Failed to construct 'URLSearchParams': parameter 1\\\" + \\\" sequence\\\" + \\\"'s element\\\" + \\\" is not an iterable object.\\\");\\n                  } else {\\n                    var _V = [];\\n                    var _tmp = nextItem;\\n\\n                    var _iterator2 = _createForOfIteratorHelper(_tmp),\\n                        _step2;\\n\\n                    try {\\n                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\n                        var _nextItem = _step2.value;\\n                        _nextItem = conversions[\\\"USVString\\\"](_nextItem, {\\n                          context: \\\"Failed to construct 'URLSearchParams': parameter 1\\\" + \\\" sequence\\\" + \\\"'s element\\\" + \\\"'s element\\\"\\n                        });\\n\\n                        _V.push(_nextItem);\\n                      }\\n                    } catch (err) {\\n                      _iterator2.e(err);\\n                    } finally {\\n                      _iterator2.f();\\n                    }\\n\\n                    nextItem = _V;\\n                  }\\n\\n                  V.push(nextItem);\\n                }\\n              } catch (err) {\\n                _iterator.e(err);\\n              } finally {\\n                _iterator.f();\\n              }\\n\\n              curArg = V;\\n            }\\n          } else {\\n            if (!utils.isObject(curArg)) {\\n              throw new TypeError(\\\"Failed to construct 'URLSearchParams': parameter 1\\\" + \\\" record\\\" + \\\" is not an object.\\\");\\n            } else {\\n              var result = Object.create(null);\\n\\n              var _iterator3 = _createForOfIteratorHelper(Reflect.ownKeys(curArg)),\\n                  _step3;\\n\\n              try {\\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\n                  var key = _step3.value;\\n                  var desc = Object.getOwnPropertyDescriptor(curArg, key);\\n\\n                  if (desc && desc.enumerable) {\\n                    var typedKey = key;\\n                    var typedValue = curArg[key];\\n                    typedKey = conversions[\\\"USVString\\\"](typedKey, {\\n                      context: \\\"Failed to construct 'URLSearchParams': parameter 1\\\" + \\\" record\\\" + \\\"'s key\\\"\\n                    });\\n                    typedValue = conversions[\\\"USVString\\\"](typedValue, {\\n                      context: \\\"Failed to construct 'URLSearchParams': parameter 1\\\" + \\\" record\\\" + \\\"'s value\\\"\\n                    });\\n                    result[typedKey] = typedValue;\\n                  }\\n                }\\n              } catch (err) {\\n                _iterator3.e(err);\\n              } finally {\\n                _iterator3.f();\\n              }\\n\\n              curArg = result;\\n            }\\n          }\\n        } else {\\n          curArg = conversions[\\\"USVString\\\"](curArg, {\\n            context: \\\"Failed to construct 'URLSearchParams': parameter 1\\\"\\n          });\\n        }\\n      } else {\\n        curArg = \\\"\\\";\\n      }\\n\\n      args.push(curArg);\\n    }\\n    return iface.setup(Object.create((this instanceof URLSearchParams ? this.constructor : void 0).prototype), args);\\n  }\\n\\n  _createClass(URLSearchParams, [{\\n    key: \\\"append\\\",\\n    value: function append(name, value) {\\n      var _this$impl;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 2) {\\n        throw new TypeError(\\\"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \\\" + arguments.length + \\\" present.\\\");\\n      }\\n\\n      var args = [];\\n      {\\n        var curArg = arguments[0];\\n        curArg = conversions[\\\"USVString\\\"](curArg, {\\n          context: \\\"Failed to execute 'append' on 'URLSearchParams': parameter 1\\\"\\n        });\\n        args.push(curArg);\\n      }\\n      {\\n        var _curArg = arguments[1];\\n        _curArg = conversions[\\\"USVString\\\"](_curArg, {\\n          context: \\\"Failed to execute 'append' on 'URLSearchParams': parameter 2\\\"\\n        });\\n        args.push(_curArg);\\n      }\\n      return (_this$impl = this[impl]).append.apply(_this$impl, args);\\n    }\\n  }, {\\n    key: \\\"delete\\\",\\n    value: function _delete(name) {\\n      var _this$impl2;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 1) {\\n        throw new TypeError(\\\"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \\\" + arguments.length + \\\" present.\\\");\\n      }\\n\\n      var args = [];\\n      {\\n        var curArg = arguments[0];\\n        curArg = conversions[\\\"USVString\\\"](curArg, {\\n          context: \\\"Failed to execute 'delete' on 'URLSearchParams': parameter 1\\\"\\n        });\\n        args.push(curArg);\\n      }\\n      return (_this$impl2 = this[impl])[\\\"delete\\\"].apply(_this$impl2, args);\\n    }\\n  }, {\\n    key: \\\"get\\\",\\n    value: function get(name) {\\n      var _this$impl3;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 1) {\\n        throw new TypeError(\\\"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \\\" + arguments.length + \\\" present.\\\");\\n      }\\n\\n      var args = [];\\n      {\\n        var curArg = arguments[0];\\n        curArg = conversions[\\\"USVString\\\"](curArg, {\\n          context: \\\"Failed to execute 'get' on 'URLSearchParams': parameter 1\\\"\\n        });\\n        args.push(curArg);\\n      }\\n      return (_this$impl3 = this[impl]).get.apply(_this$impl3, args);\\n    }\\n  }, {\\n    key: \\\"getAll\\\",\\n    value: function getAll(name) {\\n      var _this$impl4;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 1) {\\n        throw new TypeError(\\\"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \\\" + arguments.length + \\\" present.\\\");\\n      }\\n\\n      var args = [];\\n      {\\n        var curArg = arguments[0];\\n        curArg = conversions[\\\"USVString\\\"](curArg, {\\n          context: \\\"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\\\"\\n        });\\n        args.push(curArg);\\n      }\\n      return utils.tryWrapperForImpl((_this$impl4 = this[impl]).getAll.apply(_this$impl4, args));\\n    }\\n  }, {\\n    key: \\\"has\\\",\\n    value: function has(name) {\\n      var _this$impl5;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 1) {\\n        throw new TypeError(\\\"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \\\" + arguments.length + \\\" present.\\\");\\n      }\\n\\n      var args = [];\\n      {\\n        var curArg = arguments[0];\\n        curArg = conversions[\\\"USVString\\\"](curArg, {\\n          context: \\\"Failed to execute 'has' on 'URLSearchParams': parameter 1\\\"\\n        });\\n        args.push(curArg);\\n      }\\n      return (_this$impl5 = this[impl]).has.apply(_this$impl5, args);\\n    }\\n  }, {\\n    key: \\\"set\\\",\\n    value: function set(name, value) {\\n      var _this$impl6;\\n\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 2) {\\n        throw new TypeError(\\\"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \\\" + arguments.length + \\\" present.\\\");\\n      }\\n\\n      var args = [];\\n      {\\n        var curArg = arguments[0];\\n        curArg = conversions[\\\"USVString\\\"](curArg, {\\n          context: \\\"Failed to execute 'set' on 'URLSearchParams': parameter 1\\\"\\n        });\\n        args.push(curArg);\\n      }\\n      {\\n        var _curArg2 = arguments[1];\\n        _curArg2 = conversions[\\\"USVString\\\"](_curArg2, {\\n          context: \\\"Failed to execute 'set' on 'URLSearchParams': parameter 2\\\"\\n        });\\n        args.push(_curArg2);\\n      }\\n      return (_this$impl6 = this[impl]).set.apply(_this$impl6, args);\\n    }\\n  }, {\\n    key: \\\"sort\\\",\\n    value: function sort() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl].sort();\\n    }\\n  }, {\\n    key: \\\"toString\\\",\\n    value: function toString() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return this[impl].toString();\\n    }\\n  }, {\\n    key: \\\"keys\\\",\\n    value: function keys() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return module.exports.createDefaultIterator(this, \\\"key\\\");\\n    }\\n  }, {\\n    key: \\\"values\\\",\\n    value: function values() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return module.exports.createDefaultIterator(this, \\\"value\\\");\\n    }\\n  }, {\\n    key: \\\"entries\\\",\\n    value: function entries() {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      return module.exports.createDefaultIterator(this, \\\"key+value\\\");\\n    }\\n  }, {\\n    key: \\\"forEach\\\",\\n    value: function forEach(callback) {\\n      if (!this || !module.exports.is(this)) {\\n        throw new TypeError(\\\"Illegal invocation\\\");\\n      }\\n\\n      if (arguments.length < 1) {\\n        throw new TypeError(\\\"Failed to execute 'forEach' on 'iterable': 1 argument required, \\\" + \\\"but only 0 present.\\\");\\n      }\\n\\n      if (typeof callback !== \\\"function\\\") {\\n        throw new TypeError(\\\"Failed to execute 'forEach' on 'iterable': The callback provided \\\" + \\\"as parameter 1 is not a function.\\\");\\n      }\\n\\n      var thisArg = arguments[1];\\n      var pairs = Array.from(this[impl]);\\n      var i = 0;\\n\\n      while (i < pairs.length) {\\n        var _pairs$i$map = pairs[i].map(utils.tryWrapperForImpl),\\n            _pairs$i$map2 = _slicedToArray(_pairs$i$map, 2),\\n            key = _pairs$i$map2[0],\\n            value = _pairs$i$map2[1];\\n\\n        callback.call(thisArg, value, key, this);\\n        pairs = Array.from(this[impl]);\\n        i++;\\n      }\\n    }\\n  }]);\\n\\n  return URLSearchParams;\\n}();\\n\\nObject.defineProperties(URLSearchParams.prototype, (_Object$definePropert = {\\n  append: {\\n    enumerable: true\\n  },\\n  \\\"delete\\\": {\\n    enumerable: true\\n  },\\n  get: {\\n    enumerable: true\\n  },\\n  getAll: {\\n    enumerable: true\\n  },\\n  has: {\\n    enumerable: true\\n  },\\n  set: {\\n    enumerable: true\\n  },\\n  sort: {\\n    enumerable: true\\n  },\\n  toString: {\\n    enumerable: true\\n  },\\n  keys: {\\n    enumerable: true\\n  },\\n  values: {\\n    enumerable: true\\n  },\\n  entries: {\\n    enumerable: true\\n  },\\n  forEach: {\\n    enumerable: true\\n  }\\n}, _defineProperty(_Object$definePropert, Symbol.toStringTag, {\\n  value: \\\"URLSearchParams\\\",\\n  configurable: true\\n}), _defineProperty(_Object$definePropert, Symbol.iterator, {\\n  value: URLSearchParams.prototype.entries,\\n  configurable: true,\\n  writable: true\\n}), _Object$definePropert));\\nvar iface = {\\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\\n  // implementing this mixin interface.\\n  _mixedIntoPredicates: [],\\n  is: function is(obj) {\\n    if (obj) {\\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\\n        return true;\\n      }\\n\\n      var _iterator4 = _createForOfIteratorHelper(module.exports._mixedIntoPredicates),\\n          _step4;\\n\\n      try {\\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\\n          var isMixedInto = _step4.value;\\n\\n          if (isMixedInto(obj)) {\\n            return true;\\n          }\\n        }\\n      } catch (err) {\\n        _iterator4.e(err);\\n      } finally {\\n        _iterator4.f();\\n      }\\n    }\\n\\n    return false;\\n  },\\n  isImpl: function isImpl(obj) {\\n    if (obj) {\\n      if (obj instanceof Impl.implementation) {\\n        return true;\\n      }\\n\\n      var wrapper = utils.wrapperForImpl(obj);\\n\\n      var _iterator5 = _createForOfIteratorHelper(module.exports._mixedIntoPredicates),\\n          _step5;\\n\\n      try {\\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\\n          var isMixedInto = _step5.value;\\n\\n          if (isMixedInto(wrapper)) {\\n            return true;\\n          }\\n        }\\n      } catch (err) {\\n        _iterator5.e(err);\\n      } finally {\\n        _iterator5.f();\\n      }\\n    }\\n\\n    return false;\\n  },\\n  convert: function convert(obj) {\\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\\n        _ref$context = _ref.context,\\n        context = _ref$context === void 0 ? \\\"The provided value\\\" : _ref$context;\\n\\n    if (module.exports.is(obj)) {\\n      return utils.implForWrapper(obj);\\n    }\\n\\n    throw new TypeError(\\\"\\\".concat(context, \\\" is not of type 'URLSearchParams'.\\\"));\\n  },\\n  createDefaultIterator: function createDefaultIterator(target, kind) {\\n    var iterator = Object.create(IteratorPrototype);\\n    Object.defineProperty(iterator, utils.iterInternalSymbol, {\\n      value: {\\n        target: target,\\n        kind: kind,\\n        index: 0\\n      },\\n      configurable: true\\n    });\\n    return iterator;\\n  },\\n  create: function create(constructorArgs, privateData) {\\n    var obj = Object.create(URLSearchParams.prototype);\\n    obj = this.setup(obj, constructorArgs, privateData);\\n    return obj;\\n  },\\n  createImpl: function createImpl(constructorArgs, privateData) {\\n    var obj = Object.create(URLSearchParams.prototype);\\n    obj = this.setup(obj, constructorArgs, privateData);\\n    return utils.implForWrapper(obj);\\n  },\\n  _internalSetup: function _internalSetup(obj) {},\\n  setup: function setup(obj, constructorArgs, privateData) {\\n    if (!privateData) privateData = {};\\n    privateData.wrapper = obj;\\n\\n    this._internalSetup(obj);\\n\\n    Object.defineProperty(obj, impl, {\\n      value: new Impl.implementation(constructorArgs, privateData),\\n      configurable: true\\n    });\\n    obj[impl][utils.wrapperSymbol] = obj;\\n\\n    if (Impl.init) {\\n      Impl.init(obj[impl], privateData);\\n    }\\n\\n    return obj;\\n  },\\n  \\\"interface\\\": URLSearchParams,\\n  expose: {\\n    Window: {\\n      URLSearchParams: URLSearchParams\\n    },\\n    Worker: {\\n      URLSearchParams: URLSearchParams\\n    }\\n  }\\n}; // iface\\n\\nmodule.exports = iface;\\n\\nvar Impl = require(\\\"./URLSearchParams-impl.js\\\");\\n\\n},{\\\"./URLSearchParams-impl.js\\\":11,\\\"./utils.js\\\":17,\\\"webidl-conversions\\\":8}],13:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nfunction isASCIIDigit(c) {\\n  return c >= 0x30 && c <= 0x39;\\n}\\n\\nfunction isASCIIAlpha(c) {\\n  return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;\\n}\\n\\nfunction isASCIIAlphanumeric(c) {\\n  return isASCIIAlpha(c) || isASCIIDigit(c);\\n}\\n\\nfunction isASCIIHex(c) {\\n  return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;\\n}\\n\\nmodule.exports = {\\n  isASCIIDigit: isASCIIDigit,\\n  isASCIIAlpha: isASCIIAlpha,\\n  isASCIIAlphanumeric: isASCIIAlphanumeric,\\n  isASCIIHex: isASCIIHex\\n};\\n\\n},{}],14:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nexports.URL = require(\\\"./URL\\\")[\\\"interface\\\"];\\nexports.URLSearchParams = require(\\\"./URLSearchParams\\\")[\\\"interface\\\"];\\nexports.parseURL = require(\\\"./url-state-machine\\\").parseURL;\\nexports.basicURLParse = require(\\\"./url-state-machine\\\").basicURLParse;\\nexports.serializeURL = require(\\\"./url-state-machine\\\").serializeURL;\\nexports.serializeHost = require(\\\"./url-state-machine\\\").serializeHost;\\nexports.serializeInteger = require(\\\"./url-state-machine\\\").serializeInteger;\\nexports.serializeURLOrigin = require(\\\"./url-state-machine\\\").serializeURLOrigin;\\nexports.setTheUsername = require(\\\"./url-state-machine\\\").setTheUsername;\\nexports.setThePassword = require(\\\"./url-state-machine\\\").setThePassword;\\nexports.cannotHaveAUsernamePasswordPort = require(\\\"./url-state-machine\\\").cannotHaveAUsernamePasswordPort;\\nexports.percentDecode = require(\\\"./urlencoded\\\").percentDecode;\\n\\n},{\\\"./URL\\\":10,\\\"./URLSearchParams\\\":12,\\\"./url-state-machine\\\":15,\\\"./urlencoded\\\":16}],15:[function(require,module,exports){\\n(function (Buffer){\\n\\\"use strict\\\";\\n\\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \\\"undefined\\\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(n); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nvar punycode = require(\\\"punycode\\\");\\n\\nvar tr46 = require('./../../universal-url-lite/shims/tr46');\\n\\nvar infra = require(\\\"./infra\\\");\\n\\nvar _require = require(\\\"./urlencoded\\\"),\\n    percentEncode = _require.percentEncode,\\n    percentDecode = _require.percentDecode;\\n\\nvar specialSchemes = {\\n  ftp: 21,\\n  file: null,\\n  http: 80,\\n  https: 443,\\n  ws: 80,\\n  wss: 443\\n};\\nvar failure = Symbol(\\\"failure\\\");\\n\\nfunction countSymbols(str) {\\n  return punycode.ucs2.decode(str).length;\\n}\\n\\nfunction at(input, idx) {\\n  var c = input[idx];\\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\\n}\\n\\nfunction isSingleDot(buffer) {\\n  return buffer === \\\".\\\" || buffer.toLowerCase() === \\\"%2e\\\";\\n}\\n\\nfunction isDoubleDot(buffer) {\\n  buffer = buffer.toLowerCase();\\n  return buffer === \\\"..\\\" || buffer === \\\"%2e.\\\" || buffer === \\\".%2e\\\" || buffer === \\\"%2e%2e\\\";\\n}\\n\\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\\n  return infra.isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\\n}\\n\\nfunction isWindowsDriveLetterString(string) {\\n  return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === \\\":\\\" || string[1] === \\\"|\\\");\\n}\\n\\nfunction isNormalizedWindowsDriveLetterString(string) {\\n  return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === \\\":\\\";\\n}\\n\\nfunction containsForbiddenHostCodePoint(string) {\\n  return string.search(/\\\\u0000|\\\\u0009|\\\\u000A|\\\\u000D|\\\\u0020|#|%|\\\\/|:|\\\\?|@|\\\\[|\\\\\\\\|\\\\]/) !== -1;\\n}\\n\\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\\n  return string.search(/\\\\u0000|\\\\u0009|\\\\u000A|\\\\u000D|\\\\u0020|#|\\\\/|:|\\\\?|@|\\\\[|\\\\\\\\|\\\\]/) !== -1;\\n}\\n\\nfunction isSpecialScheme(scheme) {\\n  return specialSchemes[scheme] !== undefined;\\n}\\n\\nfunction isSpecial(url) {\\n  return isSpecialScheme(url.scheme);\\n}\\n\\nfunction isNotSpecial(url) {\\n  return !isSpecialScheme(url.scheme);\\n}\\n\\nfunction defaultPort(scheme) {\\n  return specialSchemes[scheme];\\n}\\n\\nfunction utf8PercentEncode(c) {\\n  var buf = Buffer.from(c);\\n  var str = \\\"\\\";\\n\\n  for (var i = 0; i < buf.length; ++i) {\\n    str += percentEncode(buf[i]);\\n  }\\n\\n  return str;\\n}\\n\\nfunction isC0ControlPercentEncode(c) {\\n  return c <= 0x1F || c > 0x7E;\\n}\\n\\nvar extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\\n\\nfunction isUserinfoPercentEncode(c) {\\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\\n}\\n\\nvar extraFragmentPercentEncodeSet = new Set([32, 34, 60, 62, 96]);\\n\\nfunction isFragmentPercentEncode(c) {\\n  return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);\\n}\\n\\nvar extraPathPercentEncodeSet = new Set([35, 63, 123, 125]);\\n\\nfunction isPathPercentEncode(c) {\\n  return isFragmentPercentEncode(c) || extraPathPercentEncodeSet.has(c);\\n}\\n\\nfunction percentEncodeChar(c, encodeSetPredicate) {\\n  var cStr = String.fromCodePoint(c);\\n\\n  if (encodeSetPredicate(c)) {\\n    return utf8PercentEncode(cStr);\\n  }\\n\\n  return cStr;\\n}\\n\\nfunction parseIPv4Number(input) {\\n  var R = 10;\\n\\n  if (input.length >= 2 && input.charAt(0) === \\\"0\\\" && input.charAt(1).toLowerCase() === \\\"x\\\") {\\n    input = input.substring(2);\\n    R = 16;\\n  } else if (input.length >= 2 && input.charAt(0) === \\\"0\\\") {\\n    input = input.substring(1);\\n    R = 8;\\n  }\\n\\n  if (input === \\\"\\\") {\\n    return 0;\\n  }\\n\\n  var regex = /[^0-7]/;\\n\\n  if (R === 10) {\\n    regex = /[^0-9]/;\\n  }\\n\\n  if (R === 16) {\\n    regex = /[^0-9A-Fa-f]/;\\n  }\\n\\n  if (regex.test(input)) {\\n    return failure;\\n  }\\n\\n  return parseInt(input, R);\\n}\\n\\nfunction parseIPv4(input) {\\n  var parts = input.split(\\\".\\\");\\n\\n  if (parts[parts.length - 1] === \\\"\\\") {\\n    if (parts.length > 1) {\\n      parts.pop();\\n    }\\n  }\\n\\n  if (parts.length > 4) {\\n    return input;\\n  }\\n\\n  var numbers = [];\\n\\n  var _iterator = _createForOfIteratorHelper(parts),\\n      _step;\\n\\n  try {\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n      var part = _step.value;\\n\\n      if (part === \\\"\\\") {\\n        return input;\\n      }\\n\\n      var _n = parseIPv4Number(part);\\n\\n      if (_n === failure) {\\n        return input;\\n      }\\n\\n      numbers.push(_n);\\n    }\\n  } catch (err) {\\n    _iterator.e(err);\\n  } finally {\\n    _iterator.f();\\n  }\\n\\n  for (var i = 0; i < numbers.length - 1; ++i) {\\n    if (numbers[i] > 255) {\\n      return failure;\\n    }\\n  }\\n\\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\\n    return failure;\\n  }\\n\\n  var ipv4 = numbers.pop();\\n  var counter = 0;\\n\\n  for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {\\n    var n = _numbers[_i];\\n    ipv4 += n * Math.pow(256, 3 - counter);\\n    ++counter;\\n  }\\n\\n  return ipv4;\\n}\\n\\nfunction serializeIPv4(address) {\\n  var output = \\\"\\\";\\n  var n = address;\\n\\n  for (var i = 1; i <= 4; ++i) {\\n    output = String(n % 256) + output;\\n\\n    if (i !== 4) {\\n      output = \\\".\\\" + output;\\n    }\\n\\n    n = Math.floor(n / 256);\\n  }\\n\\n  return output;\\n}\\n\\nfunction parseIPv6(input) {\\n  var address = [0, 0, 0, 0, 0, 0, 0, 0];\\n  var pieceIndex = 0;\\n  var compress = null;\\n  var pointer = 0;\\n  input = punycode.ucs2.decode(input);\\n\\n  if (input[pointer] === 58) {\\n    if (input[pointer + 1] !== 58) {\\n      return failure;\\n    }\\n\\n    pointer += 2;\\n    ++pieceIndex;\\n    compress = pieceIndex;\\n  }\\n\\n  while (pointer < input.length) {\\n    if (pieceIndex === 8) {\\n      return failure;\\n    }\\n\\n    if (input[pointer] === 58) {\\n      if (compress !== null) {\\n        return failure;\\n      }\\n\\n      ++pointer;\\n      ++pieceIndex;\\n      compress = pieceIndex;\\n      continue;\\n    }\\n\\n    var value = 0;\\n    var length = 0;\\n\\n    while (length < 4 && infra.isASCIIHex(input[pointer])) {\\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\\n      ++pointer;\\n      ++length;\\n    }\\n\\n    if (input[pointer] === 46) {\\n      if (length === 0) {\\n        return failure;\\n      }\\n\\n      pointer -= length;\\n\\n      if (pieceIndex > 6) {\\n        return failure;\\n      }\\n\\n      var numbersSeen = 0;\\n\\n      while (input[pointer] !== undefined) {\\n        var ipv4Piece = null;\\n\\n        if (numbersSeen > 0) {\\n          if (input[pointer] === 46 && numbersSeen < 4) {\\n            ++pointer;\\n          } else {\\n            return failure;\\n          }\\n        }\\n\\n        if (!infra.isASCIIDigit(input[pointer])) {\\n          return failure;\\n        }\\n\\n        while (infra.isASCIIDigit(input[pointer])) {\\n          var number = parseInt(at(input, pointer));\\n\\n          if (ipv4Piece === null) {\\n            ipv4Piece = number;\\n          } else if (ipv4Piece === 0) {\\n            return failure;\\n          } else {\\n            ipv4Piece = ipv4Piece * 10 + number;\\n          }\\n\\n          if (ipv4Piece > 255) {\\n            return failure;\\n          }\\n\\n          ++pointer;\\n        }\\n\\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\\n        ++numbersSeen;\\n\\n        if (numbersSeen === 2 || numbersSeen === 4) {\\n          ++pieceIndex;\\n        }\\n      }\\n\\n      if (numbersSeen !== 4) {\\n        return failure;\\n      }\\n\\n      break;\\n    } else if (input[pointer] === 58) {\\n      ++pointer;\\n\\n      if (input[pointer] === undefined) {\\n        return failure;\\n      }\\n    } else if (input[pointer] !== undefined) {\\n      return failure;\\n    }\\n\\n    address[pieceIndex] = value;\\n    ++pieceIndex;\\n  }\\n\\n  if (compress !== null) {\\n    var swaps = pieceIndex - compress;\\n    pieceIndex = 7;\\n\\n    while (pieceIndex !== 0 && swaps > 0) {\\n      var temp = address[compress + swaps - 1];\\n      address[compress + swaps - 1] = address[pieceIndex];\\n      address[pieceIndex] = temp;\\n      --pieceIndex;\\n      --swaps;\\n    }\\n  } else if (compress === null && pieceIndex !== 8) {\\n    return failure;\\n  }\\n\\n  return address;\\n}\\n\\nfunction serializeIPv6(address) {\\n  var output = \\\"\\\";\\n  var seqResult = findLongestZeroSequence(address);\\n  var compress = seqResult.idx;\\n  var ignore0 = false;\\n\\n  for (var pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\\n    if (ignore0 && address[pieceIndex] === 0) {\\n      continue;\\n    } else if (ignore0) {\\n      ignore0 = false;\\n    }\\n\\n    if (compress === pieceIndex) {\\n      var separator = pieceIndex === 0 ? \\\"::\\\" : \\\":\\\";\\n      output += separator;\\n      ignore0 = true;\\n      continue;\\n    }\\n\\n    output += address[pieceIndex].toString(16);\\n\\n    if (pieceIndex !== 7) {\\n      output += \\\":\\\";\\n    }\\n  }\\n\\n  return output;\\n}\\n\\nfunction parseHost(input) {\\n  var isNotSpecialArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n  if (input[0] === \\\"[\\\") {\\n    if (input[input.length - 1] !== \\\"]\\\") {\\n      return failure;\\n    }\\n\\n    return parseIPv6(input.substring(1, input.length - 1));\\n  }\\n\\n  if (isNotSpecialArg) {\\n    return parseOpaqueHost(input);\\n  }\\n\\n  var domain = percentDecode(Buffer.from(input)).toString();\\n  var asciiDomain = domainToASCII(domain);\\n\\n  if (asciiDomain === failure) {\\n    return failure;\\n  }\\n\\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\\n    return failure;\\n  }\\n\\n  var ipv4Host = parseIPv4(asciiDomain);\\n\\n  if (typeof ipv4Host === \\\"number\\\" || ipv4Host === failure) {\\n    return ipv4Host;\\n  }\\n\\n  return asciiDomain;\\n}\\n\\nfunction parseOpaqueHost(input) {\\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\\n    return failure;\\n  }\\n\\n  var output = \\\"\\\";\\n  var decoded = punycode.ucs2.decode(input);\\n\\n  for (var i = 0; i < decoded.length; ++i) {\\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\\n  }\\n\\n  return output;\\n}\\n\\nfunction findLongestZeroSequence(arr) {\\n  var maxIdx = null;\\n  var maxLen = 1; // only find elements > 1\\n\\n  var currStart = null;\\n  var currLen = 0;\\n\\n  for (var i = 0; i < arr.length; ++i) {\\n    if (arr[i] !== 0) {\\n      if (currLen > maxLen) {\\n        maxIdx = currStart;\\n        maxLen = currLen;\\n      }\\n\\n      currStart = null;\\n      currLen = 0;\\n    } else {\\n      if (currStart === null) {\\n        currStart = i;\\n      }\\n\\n      ++currLen;\\n    }\\n  } // if trailing zeros\\n\\n\\n  if (currLen > maxLen) {\\n    maxIdx = currStart;\\n    maxLen = currLen;\\n  }\\n\\n  return {\\n    idx: maxIdx,\\n    len: maxLen\\n  };\\n}\\n\\nfunction serializeHost(host) {\\n  if (typeof host === \\\"number\\\") {\\n    return serializeIPv4(host);\\n  } // IPv6 serializer\\n\\n\\n  if (host instanceof Array) {\\n    return \\\"[\\\" + serializeIPv6(host) + \\\"]\\\";\\n  }\\n\\n  return host;\\n}\\n\\nfunction domainToASCII(domain) {\\n  var beStrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n  var result = tr46.toASCII(domain, {\\n    checkBidi: true,\\n    checkHyphens: false,\\n    checkJoiners: true,\\n    useSTD3ASCIIRules: beStrict,\\n    verifyDNSLength: beStrict\\n  });\\n\\n  if (result === null) {\\n    return failure;\\n  }\\n\\n  return result;\\n}\\n\\nfunction trimControlChars(url) {\\n  return url.replace(/^[\\\\u0000-\\\\u001F\\\\u0020]+|[\\\\u0000-\\\\u001F\\\\u0020]+$/g, \\\"\\\");\\n}\\n\\nfunction trimTabAndNewline(url) {\\n  return url.replace(/\\\\u0009|\\\\u000A|\\\\u000D/g, \\\"\\\");\\n}\\n\\nfunction shortenPath(url) {\\n  var path = url.path;\\n\\n  if (path.length === 0) {\\n    return;\\n  }\\n\\n  if (url.scheme === \\\"file\\\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\\n    return;\\n  }\\n\\n  path.pop();\\n}\\n\\nfunction includesCredentials(url) {\\n  return url.username !== \\\"\\\" || url.password !== \\\"\\\";\\n}\\n\\nfunction cannotHaveAUsernamePasswordPort(url) {\\n  return url.host === null || url.host === \\\"\\\" || url.cannotBeABaseURL || url.scheme === \\\"file\\\";\\n}\\n\\nfunction isNormalizedWindowsDriveLetter(string) {\\n  return /^[A-Za-z]:$/.test(string);\\n}\\n\\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\\n  this.pointer = 0;\\n  this.input = input;\\n  this.base = base || null;\\n  this.encodingOverride = encodingOverride || \\\"utf-8\\\";\\n  this.stateOverride = stateOverride;\\n  this.url = url;\\n  this.failure = false;\\n  this.parseError = false;\\n\\n  if (!this.url) {\\n    this.url = {\\n      scheme: \\\"\\\",\\n      username: \\\"\\\",\\n      password: \\\"\\\",\\n      host: null,\\n      port: null,\\n      path: [],\\n      query: null,\\n      fragment: null,\\n      cannotBeABaseURL: false\\n    };\\n\\n    var _res = trimControlChars(this.input);\\n\\n    if (_res !== this.input) {\\n      this.parseError = true;\\n    }\\n\\n    this.input = _res;\\n  }\\n\\n  var res = trimTabAndNewline(this.input);\\n\\n  if (res !== this.input) {\\n    this.parseError = true;\\n  }\\n\\n  this.input = res;\\n  this.state = stateOverride || \\\"scheme start\\\";\\n  this.buffer = \\\"\\\";\\n  this.atFlag = false;\\n  this.arrFlag = false;\\n  this.passwordTokenSeenFlag = false;\\n  this.input = punycode.ucs2.decode(this.input);\\n\\n  for (; this.pointer <= this.input.length; ++this.pointer) {\\n    var c = this.input[this.pointer];\\n    var cStr = isNaN(c) ? undefined : String.fromCodePoint(c); // exec state machine\\n\\n    var ret = this[\\\"parse \\\" + this.state](c, cStr);\\n\\n    if (!ret) {\\n      break; // terminate algorithm\\n    } else if (ret === failure) {\\n      this.failure = true;\\n      break;\\n    }\\n  }\\n}\\n\\nURLStateMachine.prototype[\\\"parse scheme start\\\"] = function parseSchemeStart(c, cStr) {\\n  if (infra.isASCIIAlpha(c)) {\\n    this.buffer += cStr.toLowerCase();\\n    this.state = \\\"scheme\\\";\\n  } else if (!this.stateOverride) {\\n    this.state = \\\"no scheme\\\";\\n    --this.pointer;\\n  } else {\\n    this.parseError = true;\\n    return failure;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse scheme\\\"] = function parseScheme(c, cStr) {\\n  if (infra.isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\\n    this.buffer += cStr.toLowerCase();\\n  } else if (c === 58) {\\n    if (this.stateOverride) {\\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\\n        return false;\\n      }\\n\\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\\n        return false;\\n      }\\n\\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \\\"file\\\") {\\n        return false;\\n      }\\n\\n      if (this.url.scheme === \\\"file\\\" && (this.url.host === \\\"\\\" || this.url.host === null)) {\\n        return false;\\n      }\\n    }\\n\\n    this.url.scheme = this.buffer;\\n\\n    if (this.stateOverride) {\\n      if (this.url.port === defaultPort(this.url.scheme)) {\\n        this.url.port = null;\\n      }\\n\\n      return false;\\n    }\\n\\n    this.buffer = \\\"\\\";\\n\\n    if (this.url.scheme === \\\"file\\\") {\\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\\n        this.parseError = true;\\n      }\\n\\n      this.state = \\\"file\\\";\\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\\n      this.state = \\\"special relative or authority\\\";\\n    } else if (isSpecial(this.url)) {\\n      this.state = \\\"special authority slashes\\\";\\n    } else if (this.input[this.pointer + 1] === 47) {\\n      this.state = \\\"path or authority\\\";\\n      ++this.pointer;\\n    } else {\\n      this.url.cannotBeABaseURL = true;\\n      this.url.path.push(\\\"\\\");\\n      this.state = \\\"cannot-be-a-base-URL path\\\";\\n    }\\n  } else if (!this.stateOverride) {\\n    this.buffer = \\\"\\\";\\n    this.state = \\\"no scheme\\\";\\n    this.pointer = -1;\\n  } else {\\n    this.parseError = true;\\n    return failure;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse no scheme\\\"] = function parseNoScheme(c) {\\n  if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {\\n    return failure;\\n  } else if (this.base.cannotBeABaseURL && c === 35) {\\n    this.url.scheme = this.base.scheme;\\n    this.url.path = this.base.path.slice();\\n    this.url.query = this.base.query;\\n    this.url.fragment = \\\"\\\";\\n    this.url.cannotBeABaseURL = true;\\n    this.state = \\\"fragment\\\";\\n  } else if (this.base.scheme === \\\"file\\\") {\\n    this.state = \\\"file\\\";\\n    --this.pointer;\\n  } else {\\n    this.state = \\\"relative\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse special relative or authority\\\"] = function parseSpecialRelativeOrAuthority(c) {\\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\\n    this.state = \\\"special authority ignore slashes\\\";\\n    ++this.pointer;\\n  } else {\\n    this.parseError = true;\\n    this.state = \\\"relative\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse path or authority\\\"] = function parsePathOrAuthority(c) {\\n  if (c === 47) {\\n    this.state = \\\"authority\\\";\\n  } else {\\n    this.state = \\\"path\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse relative\\\"] = function parseRelative(c) {\\n  this.url.scheme = this.base.scheme;\\n\\n  if (isNaN(c)) {\\n    this.url.username = this.base.username;\\n    this.url.password = this.base.password;\\n    this.url.host = this.base.host;\\n    this.url.port = this.base.port;\\n    this.url.path = this.base.path.slice();\\n    this.url.query = this.base.query;\\n  } else if (c === 47) {\\n    this.state = \\\"relative slash\\\";\\n  } else if (c === 63) {\\n    this.url.username = this.base.username;\\n    this.url.password = this.base.password;\\n    this.url.host = this.base.host;\\n    this.url.port = this.base.port;\\n    this.url.path = this.base.path.slice();\\n    this.url.query = \\\"\\\";\\n    this.state = \\\"query\\\";\\n  } else if (c === 35) {\\n    this.url.username = this.base.username;\\n    this.url.password = this.base.password;\\n    this.url.host = this.base.host;\\n    this.url.port = this.base.port;\\n    this.url.path = this.base.path.slice();\\n    this.url.query = this.base.query;\\n    this.url.fragment = \\\"\\\";\\n    this.state = \\\"fragment\\\";\\n  } else if (isSpecial(this.url) && c === 92) {\\n    this.parseError = true;\\n    this.state = \\\"relative slash\\\";\\n  } else {\\n    this.url.username = this.base.username;\\n    this.url.password = this.base.password;\\n    this.url.host = this.base.host;\\n    this.url.port = this.base.port;\\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\\n    this.state = \\\"path\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse relative slash\\\"] = function parseRelativeSlash(c) {\\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\\n    if (c === 92) {\\n      this.parseError = true;\\n    }\\n\\n    this.state = \\\"special authority ignore slashes\\\";\\n  } else if (c === 47) {\\n    this.state = \\\"authority\\\";\\n  } else {\\n    this.url.username = this.base.username;\\n    this.url.password = this.base.password;\\n    this.url.host = this.base.host;\\n    this.url.port = this.base.port;\\n    this.state = \\\"path\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse special authority slashes\\\"] = function parseSpecialAuthoritySlashes(c) {\\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\\n    this.state = \\\"special authority ignore slashes\\\";\\n    ++this.pointer;\\n  } else {\\n    this.parseError = true;\\n    this.state = \\\"special authority ignore slashes\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse special authority ignore slashes\\\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\\n  if (c !== 47 && c !== 92) {\\n    this.state = \\\"authority\\\";\\n    --this.pointer;\\n  } else {\\n    this.parseError = true;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse authority\\\"] = function parseAuthority(c, cStr) {\\n  if (c === 64) {\\n    this.parseError = true;\\n\\n    if (this.atFlag) {\\n      this.buffer = \\\"%40\\\" + this.buffer;\\n    }\\n\\n    this.atFlag = true; // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\\n\\n    var len = countSymbols(this.buffer);\\n\\n    for (var pointer = 0; pointer < len; ++pointer) {\\n      var codePoint = this.buffer.codePointAt(pointer);\\n\\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\\n        this.passwordTokenSeenFlag = true;\\n        continue;\\n      }\\n\\n      var encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\\n\\n      if (this.passwordTokenSeenFlag) {\\n        this.url.password += encodedCodePoints;\\n      } else {\\n        this.url.username += encodedCodePoints;\\n      }\\n    }\\n\\n    this.buffer = \\\"\\\";\\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {\\n    if (this.atFlag && this.buffer === \\\"\\\") {\\n      this.parseError = true;\\n      return failure;\\n    }\\n\\n    this.pointer -= countSymbols(this.buffer) + 1;\\n    this.buffer = \\\"\\\";\\n    this.state = \\\"host\\\";\\n  } else {\\n    this.buffer += cStr;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse hostname\\\"] = URLStateMachine.prototype[\\\"parse host\\\"] = function parseHostName(c, cStr) {\\n  if (this.stateOverride && this.url.scheme === \\\"file\\\") {\\n    --this.pointer;\\n    this.state = \\\"file host\\\";\\n  } else if (c === 58 && !this.arrFlag) {\\n    if (this.buffer === \\\"\\\") {\\n      this.parseError = true;\\n      return failure;\\n    }\\n\\n    var host = parseHost(this.buffer, isNotSpecial(this.url));\\n\\n    if (host === failure) {\\n      return failure;\\n    }\\n\\n    this.url.host = host;\\n    this.buffer = \\\"\\\";\\n    this.state = \\\"port\\\";\\n\\n    if (this.stateOverride === \\\"hostname\\\") {\\n      return false;\\n    }\\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {\\n    --this.pointer;\\n\\n    if (isSpecial(this.url) && this.buffer === \\\"\\\") {\\n      this.parseError = true;\\n      return failure;\\n    } else if (this.stateOverride && this.buffer === \\\"\\\" && (includesCredentials(this.url) || this.url.port !== null)) {\\n      this.parseError = true;\\n      return false;\\n    }\\n\\n    var _host = parseHost(this.buffer, isNotSpecial(this.url));\\n\\n    if (_host === failure) {\\n      return failure;\\n    }\\n\\n    this.url.host = _host;\\n    this.buffer = \\\"\\\";\\n    this.state = \\\"path start\\\";\\n\\n    if (this.stateOverride) {\\n      return false;\\n    }\\n  } else {\\n    if (c === 91) {\\n      this.arrFlag = true;\\n    } else if (c === 93) {\\n      this.arrFlag = false;\\n    }\\n\\n    this.buffer += cStr;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse port\\\"] = function parsePort(c, cStr) {\\n  if (infra.isASCIIDigit(c)) {\\n    this.buffer += cStr;\\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {\\n    if (this.buffer !== \\\"\\\") {\\n      var port = parseInt(this.buffer);\\n\\n      if (port > Math.pow(2, 16) - 1) {\\n        this.parseError = true;\\n        return failure;\\n      }\\n\\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\\n      this.buffer = \\\"\\\";\\n    }\\n\\n    if (this.stateOverride) {\\n      return false;\\n    }\\n\\n    this.state = \\\"path start\\\";\\n    --this.pointer;\\n  } else {\\n    this.parseError = true;\\n    return failure;\\n  }\\n\\n  return true;\\n};\\n\\nvar fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\\n\\nfunction startsWithWindowsDriveLetter(input, pointer) {\\n  var length = input.length - pointer;\\n  return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));\\n}\\n\\nURLStateMachine.prototype[\\\"parse file\\\"] = function parseFile(c) {\\n  this.url.scheme = \\\"file\\\";\\n\\n  if (c === 47 || c === 92) {\\n    if (c === 92) {\\n      this.parseError = true;\\n    }\\n\\n    this.state = \\\"file slash\\\";\\n  } else if (this.base !== null && this.base.scheme === \\\"file\\\") {\\n    if (isNaN(c)) {\\n      this.url.host = this.base.host;\\n      this.url.path = this.base.path.slice();\\n      this.url.query = this.base.query;\\n    } else if (c === 63) {\\n      this.url.host = this.base.host;\\n      this.url.path = this.base.path.slice();\\n      this.url.query = \\\"\\\";\\n      this.state = \\\"query\\\";\\n    } else if (c === 35) {\\n      this.url.host = this.base.host;\\n      this.url.path = this.base.path.slice();\\n      this.url.query = this.base.query;\\n      this.url.fragment = \\\"\\\";\\n      this.state = \\\"fragment\\\";\\n    } else {\\n      if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {\\n        this.url.host = this.base.host;\\n        this.url.path = this.base.path.slice();\\n        shortenPath(this.url);\\n      } else {\\n        this.parseError = true;\\n      }\\n\\n      this.state = \\\"path\\\";\\n      --this.pointer;\\n    }\\n  } else {\\n    this.state = \\\"path\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse file slash\\\"] = function parseFileSlash(c) {\\n  if (c === 47 || c === 92) {\\n    if (c === 92) {\\n      this.parseError = true;\\n    }\\n\\n    this.state = \\\"file host\\\";\\n  } else {\\n    if (this.base !== null && this.base.scheme === \\\"file\\\" && !startsWithWindowsDriveLetter(this.input, this.pointer)) {\\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\\n        this.url.path.push(this.base.path[0]);\\n      } else {\\n        this.url.host = this.base.host;\\n      }\\n    }\\n\\n    this.state = \\\"path\\\";\\n    --this.pointer;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse file host\\\"] = function parseFileHost(c, cStr) {\\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\\n    --this.pointer;\\n\\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\\n      this.parseError = true;\\n      this.state = \\\"path\\\";\\n    } else if (this.buffer === \\\"\\\") {\\n      this.url.host = \\\"\\\";\\n\\n      if (this.stateOverride) {\\n        return false;\\n      }\\n\\n      this.state = \\\"path start\\\";\\n    } else {\\n      var host = parseHost(this.buffer, isNotSpecial(this.url));\\n\\n      if (host === failure) {\\n        return failure;\\n      }\\n\\n      if (host === \\\"localhost\\\") {\\n        host = \\\"\\\";\\n      }\\n\\n      this.url.host = host;\\n\\n      if (this.stateOverride) {\\n        return false;\\n      }\\n\\n      this.buffer = \\\"\\\";\\n      this.state = \\\"path start\\\";\\n    }\\n  } else {\\n    this.buffer += cStr;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse path start\\\"] = function parsePathStart(c) {\\n  if (isSpecial(this.url)) {\\n    if (c === 92) {\\n      this.parseError = true;\\n    }\\n\\n    this.state = \\\"path\\\";\\n\\n    if (c !== 47 && c !== 92) {\\n      --this.pointer;\\n    }\\n  } else if (!this.stateOverride && c === 63) {\\n    this.url.query = \\\"\\\";\\n    this.state = \\\"query\\\";\\n  } else if (!this.stateOverride && c === 35) {\\n    this.url.fragment = \\\"\\\";\\n    this.state = \\\"fragment\\\";\\n  } else if (c !== undefined) {\\n    this.state = \\\"path\\\";\\n\\n    if (c !== 47) {\\n      --this.pointer;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse path\\\"] = function parsePath(c) {\\n  if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {\\n    if (isSpecial(this.url) && c === 92) {\\n      this.parseError = true;\\n    }\\n\\n    if (isDoubleDot(this.buffer)) {\\n      shortenPath(this.url);\\n\\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\\n        this.url.path.push(\\\"\\\");\\n      }\\n    } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {\\n      this.url.path.push(\\\"\\\");\\n    } else if (!isSingleDot(this.buffer)) {\\n      if (this.url.scheme === \\\"file\\\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\\n        if (this.url.host !== \\\"\\\" && this.url.host !== null) {\\n          this.parseError = true;\\n          this.url.host = \\\"\\\";\\n        }\\n\\n        this.buffer = this.buffer[0] + \\\":\\\";\\n      }\\n\\n      this.url.path.push(this.buffer);\\n    }\\n\\n    this.buffer = \\\"\\\";\\n\\n    if (this.url.scheme === \\\"file\\\" && (c === undefined || c === 63 || c === 35)) {\\n      while (this.url.path.length > 1 && this.url.path[0] === \\\"\\\") {\\n        this.parseError = true;\\n        this.url.path.shift();\\n      }\\n    }\\n\\n    if (c === 63) {\\n      this.url.query = \\\"\\\";\\n      this.state = \\\"query\\\";\\n    }\\n\\n    if (c === 35) {\\n      this.url.fragment = \\\"\\\";\\n      this.state = \\\"fragment\\\";\\n    }\\n  } else {\\n    // TODO: If c is not a URL code point and not \\\"%\\\", parse error.\\n    if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\\n      this.parseError = true;\\n    }\\n\\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse cannot-be-a-base-URL path\\\"] = function parseCannotBeABaseURLPath(c) {\\n  if (c === 63) {\\n    this.url.query = \\\"\\\";\\n    this.state = \\\"query\\\";\\n  } else if (c === 35) {\\n    this.url.fragment = \\\"\\\";\\n    this.state = \\\"fragment\\\";\\n  } else {\\n    // TODO: Add: not a URL code point\\n    if (!isNaN(c) && c !== 37) {\\n      this.parseError = true;\\n    }\\n\\n    if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\\n      this.parseError = true;\\n    }\\n\\n    if (!isNaN(c)) {\\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse query\\\"] = function parseQuery(c, cStr) {\\n  if (isNaN(c) || !this.stateOverride && c === 35) {\\n    if (!isSpecial(this.url) || this.url.scheme === \\\"ws\\\" || this.url.scheme === \\\"wss\\\") {\\n      this.encodingOverride = \\\"utf-8\\\";\\n    }\\n\\n    var buffer = Buffer.from(this.buffer); // TODO: Use encoding override instead\\n\\n    for (var i = 0; i < buffer.length; ++i) {\\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 || buffer[i] === 0x3C || buffer[i] === 0x3E || buffer[i] === 0x27 && isSpecial(this.url)) {\\n        this.url.query += percentEncode(buffer[i]);\\n      } else {\\n        this.url.query += String.fromCodePoint(buffer[i]);\\n      }\\n    }\\n\\n    this.buffer = \\\"\\\";\\n\\n    if (c === 35) {\\n      this.url.fragment = \\\"\\\";\\n      this.state = \\\"fragment\\\";\\n    }\\n  } else {\\n    // TODO: If c is not a URL code point and not \\\"%\\\", parse error.\\n    if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\\n      this.parseError = true;\\n    }\\n\\n    this.buffer += cStr;\\n  }\\n\\n  return true;\\n};\\n\\nURLStateMachine.prototype[\\\"parse fragment\\\"] = function parseFragment(c) {\\n  if (isNaN(c)) {// do nothing\\n  } else if (c === 0x0) {\\n    this.parseError = true;\\n  } else {\\n    // TODO: If c is not a URL code point and not \\\"%\\\", parse error.\\n    if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\\n      this.parseError = true;\\n    }\\n\\n    this.url.fragment += percentEncodeChar(c, isFragmentPercentEncode);\\n  }\\n\\n  return true;\\n};\\n\\nfunction serializeURL(url, excludeFragment) {\\n  var output = url.scheme + \\\":\\\";\\n\\n  if (url.host !== null) {\\n    output += \\\"//\\\";\\n\\n    if (url.username !== \\\"\\\" || url.password !== \\\"\\\") {\\n      output += url.username;\\n\\n      if (url.password !== \\\"\\\") {\\n        output += \\\":\\\" + url.password;\\n      }\\n\\n      output += \\\"@\\\";\\n    }\\n\\n    output += serializeHost(url.host);\\n\\n    if (url.port !== null) {\\n      output += \\\":\\\" + url.port;\\n    }\\n  } else if (url.host === null && url.scheme === \\\"file\\\") {\\n    output += \\\"//\\\";\\n  }\\n\\n  if (url.cannotBeABaseURL) {\\n    output += url.path[0];\\n  } else {\\n    var _iterator2 = _createForOfIteratorHelper(url.path),\\n        _step2;\\n\\n    try {\\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\n        var string = _step2.value;\\n        output += \\\"/\\\" + string;\\n      }\\n    } catch (err) {\\n      _iterator2.e(err);\\n    } finally {\\n      _iterator2.f();\\n    }\\n  }\\n\\n  if (url.query !== null) {\\n    output += \\\"?\\\" + url.query;\\n  }\\n\\n  if (!excludeFragment && url.fragment !== null) {\\n    output += \\\"#\\\" + url.fragment;\\n  }\\n\\n  return output;\\n}\\n\\nfunction serializeOrigin(tuple) {\\n  var result = tuple.scheme + \\\"://\\\";\\n  result += serializeHost(tuple.host);\\n\\n  if (tuple.port !== null) {\\n    result += \\\":\\\" + tuple.port;\\n  }\\n\\n  return result;\\n}\\n\\nmodule.exports.serializeURL = serializeURL;\\n\\nmodule.exports.serializeURLOrigin = function (url) {\\n  // https://url.spec.whatwg.org/#concept-url-origin\\n  switch (url.scheme) {\\n    case \\\"blob\\\":\\n      try {\\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\\n      } catch (e) {\\n        // serializing an opaque origin returns \\\"null\\\"\\n        return \\\"null\\\";\\n      }\\n\\n    case \\\"ftp\\\":\\n    case \\\"http\\\":\\n    case \\\"https\\\":\\n    case \\\"ws\\\":\\n    case \\\"wss\\\":\\n      return serializeOrigin({\\n        scheme: url.scheme,\\n        host: url.host,\\n        port: url.port\\n      });\\n\\n    case \\\"file\\\":\\n      // The spec says:\\n      // > Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.\\n      // Browsers tested so far:\\n      // - Chrome says \\\"file://\\\", but treats file: URLs as cross-origin for most (all?) purposes; see e.g.\\n      //   https://bugs.chromium.org/p/chromium/issues/detail?id=37586\\n      // - Firefox says \\\"null\\\", but treats file: URLs as same-origin sometimes based on directory stuff; see\\n      //   https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs\\n      return \\\"null\\\";\\n\\n    default:\\n      // serializing an opaque origin returns \\\"null\\\"\\n      return \\\"null\\\";\\n  }\\n};\\n\\nmodule.exports.basicURLParse = function (input, options) {\\n  if (options === undefined) {\\n    options = {};\\n  }\\n\\n  var usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\\n\\n  if (usm.failure) {\\n    return null;\\n  }\\n\\n  return usm.url;\\n};\\n\\nmodule.exports.setTheUsername = function (url, username) {\\n  url.username = \\\"\\\";\\n  var decoded = punycode.ucs2.decode(username);\\n\\n  for (var i = 0; i < decoded.length; ++i) {\\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\\n  }\\n};\\n\\nmodule.exports.setThePassword = function (url, password) {\\n  url.password = \\\"\\\";\\n  var decoded = punycode.ucs2.decode(password);\\n\\n  for (var i = 0; i < decoded.length; ++i) {\\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\\n  }\\n};\\n\\nmodule.exports.serializeHost = serializeHost;\\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\\n\\nmodule.exports.serializeInteger = function (integer) {\\n  return String(integer);\\n};\\n\\nmodule.exports.parseURL = function (input, options) {\\n  if (options === undefined) {\\n    options = {};\\n  } // We don't handle blobs, so this just delegates:\\n\\n\\n  return module.exports.basicURLParse(input, {\\n    baseURL: options.baseURL,\\n    encodingOverride: options.encodingOverride\\n  });\\n};\\n\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"./../../universal-url-lite/shims/tr46\\\":5,\\\"./infra\\\":13,\\\"./urlencoded\\\":16,\\\"buffer\\\":4,\\\"punycode\\\":1}],16:[function(require,module,exports){\\n(function (Buffer){\\n\\\"use strict\\\";\\n\\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\\n\\nfunction _nonIterableRest() { throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\n\\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \\\"undefined\\\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\"return\\\"] != null) _i[\\\"return\\\"](); } finally { if (_d) throw _e; } } return _arr; }\\n\\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\n\\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \\\"undefined\\\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(n); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nvar _require = require(\\\"./infra\\\"),\\n    isASCIIHex = _require.isASCIIHex;\\n\\nfunction strictlySplitByteSequence(buf, cp) {\\n  var list = [];\\n  var last = 0;\\n  var i = buf.indexOf(cp);\\n\\n  while (i >= 0) {\\n    list.push(buf.slice(last, i));\\n    last = i + 1;\\n    i = buf.indexOf(cp, last);\\n  }\\n\\n  if (last !== buf.length) {\\n    list.push(buf.slice(last));\\n  }\\n\\n  return list;\\n}\\n\\nfunction replaceByteInByteSequence(buf, from, to) {\\n  var i = buf.indexOf(from);\\n\\n  while (i >= 0) {\\n    buf[i] = to;\\n    i = buf.indexOf(from, i + 1);\\n  }\\n\\n  return buf;\\n}\\n\\nfunction percentEncode(c) {\\n  var hex = c.toString(16).toUpperCase();\\n\\n  if (hex.length === 1) {\\n    hex = \\\"0\\\" + hex;\\n  }\\n\\n  return \\\"%\\\" + hex;\\n}\\n\\nfunction percentDecode(input) {\\n  var output = Buffer.alloc(input.byteLength);\\n  var ptr = 0;\\n\\n  for (var i = 0; i < input.length; ++i) {\\n    if (input[i] !== 37 || !isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2])) {\\n      output[ptr++] = input[i];\\n    } else {\\n      output[ptr++] = parseInt(input.slice(i + 1, i + 3).toString(), 16);\\n      i += 2;\\n    }\\n  }\\n\\n  return output.slice(0, ptr);\\n}\\n\\nfunction _parseUrlencoded(input) {\\n  var sequences = strictlySplitByteSequence(input, 38);\\n  var output = [];\\n\\n  var _iterator = _createForOfIteratorHelper(sequences),\\n      _step;\\n\\n  try {\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n      var bytes = _step.value;\\n\\n      if (bytes.length === 0) {\\n        continue;\\n      }\\n\\n      var name = void 0;\\n      var value = void 0;\\n      var indexOfEqual = bytes.indexOf(61);\\n\\n      if (indexOfEqual >= 0) {\\n        name = bytes.slice(0, indexOfEqual);\\n        value = bytes.slice(indexOfEqual + 1);\\n      } else {\\n        name = bytes;\\n        value = Buffer.alloc(0);\\n      }\\n\\n      name = replaceByteInByteSequence(Buffer.from(name), 43, 32);\\n      value = replaceByteInByteSequence(Buffer.from(value), 43, 32);\\n      output.push([percentDecode(name).toString(), percentDecode(value).toString()]);\\n    }\\n  } catch (err) {\\n    _iterator.e(err);\\n  } finally {\\n    _iterator.f();\\n  }\\n\\n  return output;\\n}\\n\\nfunction serializeUrlencodedByte(input) {\\n  var output = \\\"\\\";\\n\\n  var _iterator2 = _createForOfIteratorHelper(input),\\n      _step2;\\n\\n  try {\\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\n      var _byte = _step2.value;\\n\\n      if (_byte === 32) {\\n        output += \\\"+\\\";\\n      } else if (_byte === 42 || _byte === 45 || _byte === 46 || _byte >= 48 && _byte <= 57 || _byte >= 65 && _byte <= 90 || _byte === 95 || _byte >= 97 && _byte <= 122) {\\n        output += String.fromCodePoint(_byte);\\n      } else {\\n        output += percentEncode(_byte);\\n      }\\n    }\\n  } catch (err) {\\n    _iterator2.e(err);\\n  } finally {\\n    _iterator2.f();\\n  }\\n\\n  return output;\\n}\\n\\nfunction serializeUrlencoded(tuples) {\\n  var encodingOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n  var encoding = \\\"utf-8\\\";\\n\\n  if (encodingOverride !== undefined) {\\n    encoding = encodingOverride;\\n  }\\n\\n  var output = \\\"\\\";\\n\\n  var _iterator3 = _createForOfIteratorHelper(tuples.entries()),\\n      _step3;\\n\\n  try {\\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\n      var _step3$value = _slicedToArray(_step3.value, 2),\\n          i = _step3$value[0],\\n          tuple = _step3$value[1];\\n\\n      // TODO: handle encoding override\\n      var name = serializeUrlencodedByte(Buffer.from(tuple[0]));\\n      var value = tuple[1];\\n\\n      if (tuple.length > 2 && tuple[2] !== undefined) {\\n        if (tuple[2] === \\\"hidden\\\" && name === \\\"_charset_\\\") {\\n          value = encoding;\\n        } else if (tuple[2] === \\\"file\\\") {\\n          // value is a File object\\n          value = value.name;\\n        }\\n      }\\n\\n      value = serializeUrlencodedByte(Buffer.from(value));\\n\\n      if (i !== 0) {\\n        output += \\\"&\\\";\\n      }\\n\\n      output += \\\"\\\".concat(name, \\\"=\\\").concat(value);\\n    }\\n  } catch (err) {\\n    _iterator3.e(err);\\n  } finally {\\n    _iterator3.f();\\n  }\\n\\n  return output;\\n}\\n\\nmodule.exports = {\\n  percentEncode: percentEncode,\\n  percentDecode: percentDecode,\\n  // application/x-www-form-urlencoded string parser\\n  parseUrlencoded: function parseUrlencoded(input) {\\n    return _parseUrlencoded(Buffer.from(input));\\n  },\\n  // application/x-www-form-urlencoded serializer\\n  serializeUrlencoded: serializeUrlencoded\\n};\\n\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"./infra\\\":13,\\\"buffer\\\":4}],17:[function(require,module,exports){\\n\\\"use strict\\\"; // Returns \\\"Type(value) is Object\\\" in ES terminology.\\n\\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \\\"undefined\\\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(n); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction isObject(value) {\\n  return _typeof(value) === \\\"object\\\" && value !== null || typeof value === \\\"function\\\";\\n}\\n\\nfunction hasOwn(obj, prop) {\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\nvar getOwnPropertyDescriptors = typeof Object.getOwnPropertyDescriptors === \\\"function\\\" ? Object.getOwnPropertyDescriptors : // Polyfill exists until we require Node.js v8.x\\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\\nfunction (obj) {\\n  if (obj === undefined || obj === null) {\\n    throw new TypeError(\\\"Cannot convert undefined or null to object\\\");\\n  }\\n\\n  obj = Object(obj);\\n  var ownKeys = Reflect.ownKeys(obj);\\n  var descriptors = {};\\n\\n  var _iterator = _createForOfIteratorHelper(ownKeys),\\n      _step;\\n\\n  try {\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n      var key = _step.value;\\n      var descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\\n\\n      if (descriptor !== undefined) {\\n        Reflect.defineProperty(descriptors, key, {\\n          value: descriptor,\\n          writable: true,\\n          enumerable: true,\\n          configurable: true\\n        });\\n      }\\n    }\\n  } catch (err) {\\n    _iterator.e(err);\\n  } finally {\\n    _iterator.f();\\n  }\\n\\n  return descriptors;\\n};\\nvar wrapperSymbol = Symbol(\\\"wrapper\\\");\\nvar implSymbol = Symbol(\\\"impl\\\");\\nvar sameObjectCaches = Symbol(\\\"SameObject caches\\\");\\n\\nfunction getSameObject(wrapper, prop, creator) {\\n  if (!wrapper[sameObjectCaches]) {\\n    wrapper[sameObjectCaches] = Object.create(null);\\n  }\\n\\n  if (prop in wrapper[sameObjectCaches]) {\\n    return wrapper[sameObjectCaches][prop];\\n  }\\n\\n  wrapper[sameObjectCaches][prop] = creator();\\n  return wrapper[sameObjectCaches][prop];\\n}\\n\\nfunction wrapperForImpl(impl) {\\n  return impl ? impl[wrapperSymbol] : null;\\n}\\n\\nfunction implForWrapper(wrapper) {\\n  return wrapper ? wrapper[implSymbol] : null;\\n}\\n\\nfunction tryWrapperForImpl(impl) {\\n  var wrapper = wrapperForImpl(impl);\\n  return wrapper ? wrapper : impl;\\n}\\n\\nfunction tryImplForWrapper(wrapper) {\\n  var impl = implForWrapper(wrapper);\\n  return impl ? impl : wrapper;\\n}\\n\\nvar iterInternalSymbol = Symbol(\\\"internal\\\");\\nvar IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\\n\\nfunction isArrayIndexPropName(P) {\\n  if (typeof P !== \\\"string\\\") {\\n    return false;\\n  }\\n\\n  var i = P >>> 0;\\n\\n  if (i === Math.pow(2, 32) - 1) {\\n    return false;\\n  }\\n\\n  var s = \\\"\\\".concat(i);\\n\\n  if (P !== s) {\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nvar supportsPropertyIndex = Symbol(\\\"supports property index\\\");\\nvar supportedPropertyIndices = Symbol(\\\"supported property indices\\\");\\nvar supportsPropertyName = Symbol(\\\"supports property name\\\");\\nvar supportedPropertyNames = Symbol(\\\"supported property names\\\");\\nvar indexedGet = Symbol(\\\"indexed property get\\\");\\nvar indexedSetNew = Symbol(\\\"indexed property set new\\\");\\nvar indexedSetExisting = Symbol(\\\"indexed property set existing\\\");\\nvar namedGet = Symbol(\\\"named property get\\\");\\nvar namedSetNew = Symbol(\\\"named property set new\\\");\\nvar namedSetExisting = Symbol(\\\"named property set existing\\\");\\nvar namedDelete = Symbol(\\\"named property delete\\\");\\nmodule.exports = exports = {\\n  isObject: isObject,\\n  hasOwn: hasOwn,\\n  getOwnPropertyDescriptors: getOwnPropertyDescriptors,\\n  wrapperSymbol: wrapperSymbol,\\n  implSymbol: implSymbol,\\n  getSameObject: getSameObject,\\n  wrapperForImpl: wrapperForImpl,\\n  implForWrapper: implForWrapper,\\n  tryWrapperForImpl: tryWrapperForImpl,\\n  tryImplForWrapper: tryImplForWrapper,\\n  iterInternalSymbol: iterInternalSymbol,\\n  IteratorPrototype: IteratorPrototype,\\n  isArrayIndexPropName: isArrayIndexPropName,\\n  supportsPropertyIndex: supportsPropertyIndex,\\n  supportedPropertyIndices: supportedPropertyIndices,\\n  supportsPropertyName: supportsPropertyName,\\n  supportedPropertyNames: supportedPropertyNames,\\n  indexedGet: indexedGet,\\n  indexedSetNew: indexedSetNew,\\n  indexedSetExisting: indexedSetExisting,\\n  namedGet: namedGet,\\n  namedSetNew: namedSetNew,\\n  namedSetExisting: namedSetExisting,\\n  namedDelete: namedDelete\\n};\\n\\n},{}]},{},[6])(6)\\n});\\n\\n},{}],55:[function(require,module,exports){\\nmodule.exports = read\\n\\nvar MSB = 0x80\\n  , REST = 0x7F\\n\\nfunction read(buf, offset) {\\n  var res    = 0\\n    , offset = offset || 0\\n    , shift  = 0\\n    , counter = offset\\n    , b\\n    , l = buf.length\\n\\n  do {\\n    if (counter >= l) {\\n      read.bytes = 0\\n      throw new RangeError('Could not decode varint')\\n    }\\n    b = buf[counter++]\\n    res += shift < 28\\n      ? (b & REST) << shift\\n      : (b & REST) * Math.pow(2, shift)\\n    shift += 7\\n  } while (b >= MSB)\\n\\n  read.bytes = counter - offset\\n\\n  return res\\n}\\n\\n},{}],56:[function(require,module,exports){\\nmodule.exports = encode\\n\\nvar MSB = 0x80\\n  , REST = 0x7F\\n  , MSBALL = ~REST\\n  , INT = Math.pow(2, 31)\\n\\nfunction encode(num, out, offset) {\\n  out = out || []\\n  offset = offset || 0\\n  var oldOffset = offset\\n\\n  while(num >= INT) {\\n    out[offset++] = (num & 0xFF) | MSB\\n    num /= 128\\n  }\\n  while(num & MSBALL) {\\n    out[offset++] = (num & 0xFF) | MSB\\n    num >>>= 7\\n  }\\n  out[offset] = num | 0\\n  \\n  encode.bytes = offset - oldOffset + 1\\n  \\n  return out\\n}\\n\\n},{}],57:[function(require,module,exports){\\nmodule.exports = {\\n    encode: require('./encode.js')\\n  , decode: require('./decode.js')\\n  , encodingLength: require('./length.js')\\n}\\n\\n},{\\\"./decode.js\\\":55,\\\"./encode.js\\\":56,\\\"./length.js\\\":58}],58:[function(require,module,exports){\\n\\nvar N1 = Math.pow(2,  7)\\nvar N2 = Math.pow(2, 14)\\nvar N3 = Math.pow(2, 21)\\nvar N4 = Math.pow(2, 28)\\nvar N5 = Math.pow(2, 35)\\nvar N6 = Math.pow(2, 42)\\nvar N7 = Math.pow(2, 49)\\nvar N8 = Math.pow(2, 56)\\nvar N9 = Math.pow(2, 63)\\n\\nmodule.exports = function (value) {\\n  return (\\n    value < N1 ? 1\\n  : value < N2 ? 2\\n  : value < N3 ? 3\\n  : value < N4 ? 4\\n  : value < N5 ? 5\\n  : value < N6 ? 6\\n  : value < N7 ? 7\\n  : value < N8 ? 8\\n  : value < N9 ? 9\\n  :              10\\n  )\\n}\\n\\n},{}],59:[function(require,module,exports){\\n(function (global){\\n'use strict'\\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\\n  (typeof global === 'object' && global.global === global && global) ||\\n  this\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],60:[function(require,module,exports){\\n(function (global){\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\n\\nvar _regenerator = _interopRequireDefault(require(\\\"@babel/runtime/regenerator\\\"));\\n\\nvar _asyncToGenerator2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/asyncToGenerator\\\"));\\n\\nvar _typeof2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/typeof\\\"));\\n\\nvar _cids = _interopRequireDefault(require(\\\"cids\\\"));\\n\\nvar _contentHash = _interopRequireDefault(require(\\\"content-hash\\\"));\\n\\n(function () {\\n  /*jslint node: true, browser: true*/\\n\\n  /*global $tw: false*/\\n  \\\"use strict\\\";\\n  /**\\n   * https://github.com/purposeindustries/window-or-global\\n   * The MIT License (MIT) Copyright (c) Purpose Industries\\n   * version: 1.0.1\\n   */\\n\\n  var root = (typeof self === \\\"undefined\\\" ? \\\"undefined\\\" : (0, _typeof2[\\\"default\\\"])(self)) === \\\"object\\\" && self.self === self && self || (typeof global === \\\"undefined\\\" ? \\\"undefined\\\" : (0, _typeof2[\\\"default\\\"])(global)) === \\\"object\\\" && global.global === global && global || this;\\n  var name = \\\"ens-library\\\";\\n\\n  var EnsLibrary = function EnsLibrary() {\\n    this.network = {\\n      1: \\\"Ethereum Main Network: 'Mainnet', chainId: '1'\\\",\\n      3: \\\"Ethereum Test Network (PoW): 'Ropsten', chainId: '3'\\\",\\n      4: \\\"Ethereum Test Network (PoA): 'Rinkeby', chainId: '4'\\\",\\n      5: \\\"Ethereum Test Network (PoA): 'Goerli', chainId: '5'\\\",\\n      42: \\\"Ethereum Test Network (PoA): 'Kovan', chainId: '42'\\\"\\n    };\\n    this.etherscan = {\\n      1: \\\"https://etherscan.io\\\",\\n      3: \\\"https://ropsten.etherscan.io\\\",\\n      4: \\\"https://rinkeby.etherscan.io\\\",\\n      5: \\\"https://goerli.etherscan.io\\\",\\n      42: \\\"https://kovan.etherscan.io\\\"\\n    }; // https://docs.ens.domains/ens-deployments\\n    // https://github.com/ensdomains/ui/blob/master/src/ens.js\\n\\n    this.registry = {\\n      1: \\\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\\\",\\n      3: \\\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\\\",\\n      4: \\\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\\\",\\n      5: \\\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\\\"\\n    };\\n  };\\n\\n  EnsLibrary.prototype.getLogger = function () {\\n    return root.log.getLogger(name);\\n  };\\n\\n  EnsLibrary.prototype.getEtherscanRegistry = function () {\\n    return this.etherscan;\\n  };\\n\\n  EnsLibrary.prototype.getNetwork = function () {\\n    return this.network;\\n  };\\n\\n  EnsLibrary.prototype.getENSRegistry = function () {\\n    return this.registry;\\n  };\\n\\n  EnsLibrary.prototype.getLogger = function () {\\n    return root.log.getLogger(name);\\n  };\\n\\n  EnsLibrary.prototype.loadEthers = /*#__PURE__*/(0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee() {\\n    return _regenerator[\\\"default\\\"].wrap(function _callee$(_context) {\\n      while (1) {\\n        switch (_context.prev = _context.next) {\\n          case 0:\\n            if (!(window.ethers == undefined || window.ethers == null)) {\\n              _context.next = 12;\\n              break;\\n            }\\n\\n            _context.prev = 1;\\n            _context.next = 4;\\n            return $tw.ipfs.getLoader().loadEtherJsLibrary();\\n\\n          case 4:\\n            if (!(window.ethers !== undefined && window.ethers !== null)) {\\n              _context.next = 6;\\n              break;\\n            }\\n\\n            return _context.abrupt(\\\"return\\\");\\n\\n          case 6:\\n            _context.next = 11;\\n            break;\\n\\n          case 8:\\n            _context.prev = 8;\\n            _context.t0 = _context[\\\"catch\\\"](1);\\n            this.getLogger().error(_context.t0);\\n\\n          case 11:\\n            throw new Error(\\\"Unavailable Ethereum library...\\\");\\n\\n          case 12:\\n          case \\\"end\\\":\\n            return _context.stop();\\n        }\\n      }\\n    }, _callee, this, [[1, 8]]);\\n  })); // https://github.com/ensdomains/ui/blob/master/src/utils/contents.js\\n\\n  EnsLibrary.prototype.decodeContenthash = function (content) {\\n    var decoded = null;\\n    var protocol = null;\\n\\n    if (content.error) {\\n      throw new Error(content.error);\\n    }\\n\\n    if (content) {\\n      var codec = _contentHash[\\\"default\\\"].getCodec(content);\\n\\n      decoded = _contentHash[\\\"default\\\"].decode(content);\\n\\n      if (codec === \\\"ipfs-ns\\\") {\\n        protocol = \\\"ipfs\\\";\\n      } else if (codec === \\\"swarm-ns\\\") {\\n        protocol = \\\"bzz\\\";\\n      } else if (codec === \\\"onion\\\") {\\n        protocol = \\\"onion\\\";\\n      } else if (codec === \\\"onion3\\\") {\\n        protocol = \\\"onion3\\\";\\n      }\\n    }\\n\\n    return {\\n      decoded: decoded,\\n      protocol: protocol\\n    };\\n  }; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1577.md\\n\\n\\n  EnsLibrary.prototype.encodeContenthash = function (content) {\\n    var type = null;\\n    var text = null;\\n    var encoded = null;\\n\\n    if (!!content) {\\n      var matched = content.match(/^(ipfs|bzz|onion|onion3):\\\\/\\\\/(.*)/) || content.match(/\\\\/(ipfs)\\\\/(.*)/);\\n\\n      if (matched) {\\n        type = matched[1];\\n        text = matched[2];\\n      }\\n\\n      if (type === \\\"ipfs\\\") {\\n        if (text.length >= 4) {\\n          var cid = new _cids[\\\"default\\\"](text);\\n\\n          if (cid.version !== 0) {\\n            throw new Error(\\\"ENS domain content should be Base58 (CidV0): \\\" + text);\\n          }\\n\\n          encoded = \\\"0x\\\" + _contentHash[\\\"default\\\"].fromIpfs(text);\\n        }\\n      } else {\\n        throw new Error(\\\"Unsupported ENS domain protocol: \\\" + type);\\n      }\\n    }\\n\\n    return {\\n      encoded: encoded\\n    };\\n  };\\n\\n  EnsLibrary.prototype.enableProvider = /*#__PURE__*/function () {\\n    var _ref2 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee2(provider) {\\n      var accounts;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee2$(_context2) {\\n        while (1) {\\n          switch (_context2.prev = _context2.next) {\\n            case 0:\\n              if (!(provider == undefined || provider == null)) {\\n                _context2.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Ethereum provider...\\\");\\n\\n            case 2:\\n              // Enable Provider\\n              accounts = null; // Handle connection, per EIP 1102\\n\\n              if (!(typeof provider.send === \\\"function\\\")) {\\n                _context2.next = 20;\\n                break;\\n              }\\n\\n              _context2.prev = 4;\\n              _context2.next = 7;\\n              return provider.send(\\\"eth_requestAccounts\\\");\\n\\n            case 7:\\n              _context2.next = 14;\\n              break;\\n\\n            case 9:\\n              _context2.prev = 9;\\n              _context2.t0 = _context2[\\\"catch\\\"](4);\\n\\n              if (!(_context2.t0.code === 4001)) {\\n                _context2.next = 13;\\n                break;\\n              }\\n\\n              throw new Error(\\\"User rejected request...\\\");\\n\\n            case 13:\\n              throw new Error(_context2.t0.message);\\n\\n            case 14:\\n              _context2.next = 16;\\n              return provider.send(\\\"eth_accounts\\\");\\n\\n            case 16:\\n              accounts = _context2.sent;\\n\\n              // https://medium.com/metamask/breaking-changes-to-the-metamask-inpage-provider-b4dde069dd0a\\n              // Metamask returns accounts.results rather than an array as described in their above communication\\n              if (accounts !== undefined && accounts !== null && typeof accounts.result !== \\\"undefined\\\" && Array.isArray(accounts.result)) {\\n                accounts = accounts.result;\\n              } // Legacy\\n\\n\\n              _context2.next = 24;\\n              break;\\n\\n            case 20:\\n              if (!(typeof provider.enable === \\\"function\\\")) {\\n                _context2.next = 24;\\n                break;\\n              }\\n\\n              _context2.next = 23;\\n              return provider.enable();\\n\\n            case 23:\\n              accounts = _context2.sent;\\n\\n            case 24:\\n              if (!(accounts == undefined || accounts == null || Array.isArray(accounts) == false || accounts.length == 0)) {\\n                _context2.next = 26;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Unable to retrieve an Ethereum account...\\\");\\n\\n            case 26:\\n              return _context2.abrupt(\\\"return\\\", accounts[0]);\\n\\n            case 27:\\n            case \\\"end\\\":\\n              return _context2.stop();\\n          }\\n        }\\n      }, _callee2, null, [[4, 9]]);\\n    }));\\n\\n    return function (_x) {\\n      return _ref2.apply(this, arguments);\\n    };\\n  }();\\n\\n  EnsLibrary.prototype.getProvider = /*#__PURE__*/(0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee3() {\\n    var provider;\\n    return _regenerator[\\\"default\\\"].wrap(function _callee3$(_context3) {\\n      while (1) {\\n        switch (_context3.prev = _context3.next) {\\n          case 0:\\n            // Retrieve an available Ethereum provider\\n            provider = null;\\n\\n            if (typeof root.ethereum !== \\\"undefined\\\") {\\n              provider = root.ethereum;\\n              this.getLogger().info(\\\"Ethereum provider: 'window.ethereum'...\\\");\\n            }\\n\\n            if (provider == null && root.web3 !== undefined && root.web3.currentProvider !== undefined) {\\n              provider = root.web3.currentProvider;\\n              this.getLogger().info(\\\"Ethereum provider: 'window.web3.currentProvider'...\\\");\\n            }\\n\\n            if (!(provider == null)) {\\n              _context3.next = 5;\\n              break;\\n            }\\n\\n            throw new Error(\\\"Unavailable Ethereum provider.\\\\nYou should consider installing Frame or MetaMask...\\\");\\n\\n          case 5:\\n            // https://docs.metamask.io/guide/ethereum-provider.html#methods-current-api\\n            if (provider.isMetaMask) {\\n              provider.autoRefreshOnNetworkChange = false;\\n            } // return provider\\n\\n\\n            return _context3.abrupt(\\\"return\\\", provider);\\n\\n          case 7:\\n          case \\\"end\\\":\\n            return _context3.stop();\\n        }\\n      }\\n    }, _callee3, this);\\n  }));\\n\\n  EnsLibrary.prototype.getEnabledWeb3Provider = /*#__PURE__*/function () {\\n    var _ref4 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee4(provider) {\\n      var account, web3, network;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee4$(_context4) {\\n        while (1) {\\n          switch (_context4.prev = _context4.next) {\\n            case 0:\\n              if (!(provider == undefined || provider == null)) {\\n                _context4.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Ethereum provider...\\\");\\n\\n            case 2:\\n              if (!(root.ethers == undefined || root.ethers == null)) {\\n                _context4.next = 5;\\n                break;\\n              }\\n\\n              _context4.next = 5;\\n              return this.loadEthers();\\n\\n            case 5:\\n              _context4.next = 7;\\n              return this.enableProvider(provider);\\n\\n            case 7:\\n              account = _context4.sent;\\n              // Instantiate a Web3Provider\\n              web3 = new root.ethers.providers.Web3Provider(provider); // Retrieve current network\\n\\n              _context4.next = 11;\\n              return web3.getNetwork();\\n\\n            case 11:\\n              network = _context4.sent;\\n              return _context4.abrupt(\\\"return\\\", {\\n                web3: web3,\\n                chainId: network.chainId,\\n                account: account\\n              });\\n\\n            case 13:\\n            case \\\"end\\\":\\n              return _context4.stop();\\n          }\\n        }\\n      }, _callee4, this);\\n    }));\\n\\n    return function (_x2) {\\n      return _ref4.apply(this, arguments);\\n    };\\n  }();\\n\\n  EnsLibrary.prototype.getWeb3Provider = /*#__PURE__*/function () {\\n    var _ref5 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee5(provider) {\\n      var web3, network;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee5$(_context5) {\\n        while (1) {\\n          switch (_context5.prev = _context5.next) {\\n            case 0:\\n              if (!(provider == undefined || provider == null)) {\\n                _context5.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Ethereum provider...\\\");\\n\\n            case 2:\\n              if (!(root.ethers == undefined || root.ethers == null)) {\\n                _context5.next = 5;\\n                break;\\n              }\\n\\n              _context5.next = 5;\\n              return this.loadEthers();\\n\\n            case 5:\\n              // Instantiate an ethers Web3Provider\\n              web3 = new root.ethers.providers.Web3Provider(provider); // Retrieve the current network\\n\\n              _context5.next = 8;\\n              return web3.getNetwork();\\n\\n            case 8:\\n              network = _context5.sent;\\n              return _context5.abrupt(\\\"return\\\", {\\n                web3: web3,\\n                chainId: network.chainId\\n              });\\n\\n            case 10:\\n            case \\\"end\\\":\\n              return _context5.stop();\\n          }\\n        }\\n      }, _callee5, this);\\n    }));\\n\\n    return function (_x3) {\\n      return _ref5.apply(this, arguments);\\n    };\\n  }();\\n\\n  EnsLibrary.prototype.getRegistry = /*#__PURE__*/function () {\\n    var _ref6 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee6(web3) {\\n      var network, registry;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee6$(_context6) {\\n        while (1) {\\n          switch (_context6.prev = _context6.next) {\\n            case 0:\\n              if (!(web3 == undefined || web3 == null)) {\\n                _context6.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Web3 provider...\\\");\\n\\n            case 2:\\n              _context6.next = 4;\\n              return web3.getNetwork();\\n\\n            case 4:\\n              network = _context6.sent;\\n              // Retrieve an Ethereum ENS Registry address\\n              registry = null;\\n\\n              try {\\n                registry = this.registry[network.chainId];\\n              } catch (error) {\\n                this.getLogger().error(error);\\n              }\\n\\n              if (!(registry == undefined || registry == null)) {\\n                _context6.next = 9;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Unsupported Ethereum network: \\\" + network.chainId);\\n\\n            case 9:\\n              return _context6.abrupt(\\\"return\\\", {\\n                chainId: network.chainId,\\n                registry: registry\\n              });\\n\\n            case 10:\\n            case \\\"end\\\":\\n              return _context6.stop();\\n          }\\n        }\\n      }, _callee6, this);\\n    }));\\n\\n    return function (_x4) {\\n      return _ref6.apply(this, arguments);\\n    };\\n  }();\\n\\n  EnsLibrary.prototype.getResolver = /*#__PURE__*/function () {\\n    var _ref7 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee7(web3, registry, node) {\\n      var abi, iface, data, result, decoded;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee7$(_context7) {\\n        while (1) {\\n          switch (_context7.prev = _context7.next) {\\n            case 0:\\n              if (!(web3 == undefined || web3 == null)) {\\n                _context7.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Web3 provider...\\\");\\n\\n            case 2:\\n              if (!(registry == undefined || registry == null || registry.trim() === \\\"\\\")) {\\n                _context7.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined ENS registry address...\\\");\\n\\n            case 4:\\n              if (!(node == undefined || node == null || node.trim() === \\\"\\\")) {\\n                _context7.next = 6;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined ENS domain resolver...\\\");\\n\\n            case 6:\\n              if (!(root.ethers == undefined || root.ethers == null)) {\\n                _context7.next = 9;\\n                break;\\n              }\\n\\n              _context7.next = 9;\\n              return this.loadEthers();\\n\\n            case 9:\\n              // Low level call\\n              abi = [{\\n                name: \\\"resolver\\\",\\n                type: \\\"function\\\",\\n                inputs: [{\\n                  type: \\\"bytes32\\\"\\n                }]\\n              }];\\n              iface = new root.ethers.utils.Interface(abi);\\n              data = iface.functions.resolver.encode([node]);\\n              _context7.next = 14;\\n              return web3.call({\\n                to: registry,\\n                data: data\\n              });\\n\\n            case 14:\\n              result = _context7.sent;\\n\\n              if (!(result == undefined || result == null || result === \\\"0x\\\")) {\\n                _context7.next = 17;\\n                break;\\n              }\\n\\n              return _context7.abrupt(\\\"return\\\", null);\\n\\n            case 17:\\n              _context7.prev = 17;\\n              decoded = root.ethers.utils.defaultAbiCoder.decode([\\\"address\\\"], result);\\n              return _context7.abrupt(\\\"return\\\", decoded[0]);\\n\\n            case 22:\\n              _context7.prev = 22;\\n              _context7.t0 = _context7[\\\"catch\\\"](17);\\n              this.getLogger().error(_context7.t0);\\n\\n            case 25:\\n              return _context7.abrupt(\\\"return\\\", null);\\n\\n            case 26:\\n            case \\\"end\\\":\\n              return _context7.stop();\\n          }\\n        }\\n      }, _callee7, this, [[17, 22]]);\\n    }));\\n\\n    return function (_x5, _x6, _x7) {\\n      return _ref7.apply(this, arguments);\\n    };\\n  }(); // https://eips.ethereum.org/EIPS/eip-165\\n\\n\\n  EnsLibrary.prototype.checkEip165 = /*#__PURE__*/function () {\\n    var _ref8 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee8(web3, address) {\\n      var abi, iface, data, result, decoded;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee8$(_context8) {\\n        while (1) {\\n          switch (_context8.prev = _context8.next) {\\n            case 0:\\n              if (!(web3 == undefined || web3 == null)) {\\n                _context8.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Web3 provider...\\\");\\n\\n            case 2:\\n              if (!(address == undefined || address == null || address.trim() === \\\"\\\")) {\\n                _context8.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Ethereum address...\\\");\\n\\n            case 4:\\n              if (!(root.ethers == undefined || root.ethers == null)) {\\n                _context8.next = 7;\\n                break;\\n              }\\n\\n              _context8.next = 7;\\n              return this.loadEthers();\\n\\n            case 7:\\n              // true when interfaceID is 0x01ffc9a7\\n              abi = [{\\n                name: \\\"supportsInterface\\\",\\n                type: \\\"function\\\",\\n                inputs: [{\\n                  type: \\\"bytes4\\\"\\n                }]\\n              }];\\n              iface = new root.ethers.utils.Interface(abi);\\n              data = iface.functions.supportsInterface.encode([\\\"0x01ffc9a7\\\"]);\\n              _context8.next = 12;\\n              return web3.call({\\n                to: address,\\n                data: data\\n              });\\n\\n            case 12:\\n              result = _context8.sent;\\n\\n              if (!(result == undefined || result == null || result === \\\"0x\\\")) {\\n                _context8.next = 15;\\n                break;\\n              }\\n\\n              return _context8.abrupt(\\\"return\\\", false);\\n\\n            case 15:\\n              _context8.prev = 15;\\n              decoded = root.ethers.utils.defaultAbiCoder.decode([\\\"bool\\\"], result);\\n\\n              if (!(decoded[0] == false)) {\\n                _context8.next = 19;\\n                break;\\n              }\\n\\n              return _context8.abrupt(\\\"return\\\", false);\\n\\n            case 19:\\n              _context8.next = 25;\\n              break;\\n\\n            case 21:\\n              _context8.prev = 21;\\n              _context8.t0 = _context8[\\\"catch\\\"](15);\\n              this.getLogger().error(_context8.t0);\\n              return _context8.abrupt(\\\"return\\\", false);\\n\\n            case 25:\\n              // false when interfaceID is 0xffffffff\\n              data = iface.functions.supportsInterface.encode([\\\"0xffffffff\\\"]);\\n              _context8.next = 28;\\n              return web3.call({\\n                to: address,\\n                data: data\\n              });\\n\\n            case 28:\\n              result = _context8.sent;\\n\\n              if (!(result == undefined || result == null || result === \\\"0x\\\")) {\\n                _context8.next = 31;\\n                break;\\n              }\\n\\n              return _context8.abrupt(\\\"return\\\", false);\\n\\n            case 31:\\n              _context8.prev = 31;\\n              decoded = root.ethers.utils.defaultAbiCoder.decode([\\\"bool\\\"], result); // conform to spec\\n\\n              if (!(decoded[0] == false)) {\\n                _context8.next = 35;\\n                break;\\n              }\\n\\n              return _context8.abrupt(\\\"return\\\", true);\\n\\n            case 35:\\n              _context8.next = 40;\\n              break;\\n\\n            case 37:\\n              _context8.prev = 37;\\n              _context8.t1 = _context8[\\\"catch\\\"](31);\\n              this.getLogger().error(_context8.t1);\\n\\n            case 40:\\n              return _context8.abrupt(\\\"return\\\", false);\\n\\n            case 41:\\n            case \\\"end\\\":\\n              return _context8.stop();\\n          }\\n        }\\n      }, _callee8, this, [[15, 21], [31, 37]]);\\n    }));\\n\\n    return function (_x8, _x9) {\\n      return _ref8.apply(this, arguments);\\n    };\\n  }(); // https://eips.ethereum.org/EIPS/eip-1577\\n\\n\\n  EnsLibrary.prototype.checkEip1577 = /*#__PURE__*/function () {\\n    var _ref9 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee9(web3, address) {\\n      var abi, iface, data, result, decoded;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee9$(_context9) {\\n        while (1) {\\n          switch (_context9.prev = _context9.next) {\\n            case 0:\\n              if (!(web3 == undefined || web3 == null)) {\\n                _context9.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Web3 provider...\\\");\\n\\n            case 2:\\n              if (!(address == undefined || address == null || address.trim() === \\\"\\\")) {\\n                _context9.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined Ethereum address...\\\");\\n\\n            case 4:\\n              if (!(root.ethers == undefined || root.ethers == null)) {\\n                _context9.next = 7;\\n                break;\\n              }\\n\\n              _context9.next = 7;\\n              return this.loadEthers();\\n\\n            case 7:\\n              // contenthash, true when interfaceID is 0xbc1c58d1\\n              abi = [{\\n                name: \\\"supportsInterface\\\",\\n                type: \\\"function\\\",\\n                inputs: [{\\n                  type: \\\"bytes4\\\"\\n                }]\\n              }];\\n              iface = new root.ethers.utils.Interface(abi);\\n              data = iface.functions.supportsInterface.encode([\\\"0xbc1c58d1\\\"]);\\n              _context9.next = 12;\\n              return web3.call({\\n                to: address,\\n                data: data\\n              });\\n\\n            case 12:\\n              result = _context9.sent;\\n\\n              if (!(result == undefined || result == null || result === \\\"0x\\\")) {\\n                _context9.next = 15;\\n                break;\\n              }\\n\\n              return _context9.abrupt(\\\"return\\\", false);\\n\\n            case 15:\\n              _context9.prev = 15;\\n              // decode\\n              decoded = root.ethers.utils.defaultAbiCoder.decode([\\\"bool\\\"], result);\\n\\n              if (!(decoded[0] == false)) {\\n                _context9.next = 19;\\n                break;\\n              }\\n\\n              return _context9.abrupt(\\\"return\\\", false);\\n\\n            case 19:\\n              _context9.next = 25;\\n              break;\\n\\n            case 21:\\n              _context9.prev = 21;\\n              _context9.t0 = _context9[\\\"catch\\\"](15);\\n              this.getLogger().error(_context9.t0);\\n              return _context9.abrupt(\\\"return\\\", false);\\n\\n            case 25:\\n              return _context9.abrupt(\\\"return\\\", true);\\n\\n            case 26:\\n            case \\\"end\\\":\\n              return _context9.stop();\\n          }\\n        }\\n      }, _callee9, this, [[15, 21]]);\\n    }));\\n\\n    return function (_x10, _x11) {\\n      return _ref9.apply(this, arguments);\\n    };\\n  }();\\n\\n  EnsLibrary.prototype.getContenthash = /*#__PURE__*/function () {\\n    var _ref10 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee10(domain, web3) {\\n      var _yield$this$getWeb3Pr, domainHash, _yield$this$getRegist, chainId, registry, resolver, eip165, eip1577, abi, iface, data, result, content, _this$decodeContentha, decoded, protocol;\\n\\n      return _regenerator[\\\"default\\\"].wrap(function _callee10$(_context10) {\\n        while (1) {\\n          switch (_context10.prev = _context10.next) {\\n            case 0:\\n              if (!(domain == undefined || domain == null)) {\\n                _context10.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined ENS domain...\\\");\\n\\n            case 2:\\n              if (!(root.ethers == undefined || root.ethers == null)) {\\n                _context10.next = 5;\\n                break;\\n              }\\n\\n              _context10.next = 5;\\n              return this.loadEthers();\\n\\n            case 5:\\n              if (!(web3 == undefined)) {\\n                _context10.next = 10;\\n                break;\\n              }\\n\\n              _context10.next = 8;\\n              return this.getWeb3Provider();\\n\\n            case 8:\\n              _yield$this$getWeb3Pr = _context10.sent;\\n              web3 = _yield$this$getWeb3Pr.web3;\\n\\n            case 10:\\n              // Resolve domain as namehash\\n              domainHash = root.ethers.utils.namehash(domain); // Fetch ens registry address\\n\\n              _context10.next = 13;\\n              return this.getRegistry(web3);\\n\\n            case 13:\\n              _yield$this$getRegist = _context10.sent;\\n              chainId = _yield$this$getRegist.chainId;\\n              registry = _yield$this$getRegist.registry;\\n              // Log\\n              this.getLogger().info(\\\"ENS registry:\\\" + \\\"\\\\n \\\" + this.etherscan[chainId] + \\\"/address/\\\" + registry); // Fetch resolver address\\n\\n              _context10.next = 19;\\n              return this.getResolver(web3, registry, domainHash);\\n\\n            case 19:\\n              resolver = _context10.sent;\\n\\n              if (!(resolver == null || /^0x0+$/.test(resolver) == true)) {\\n                _context10.next = 22;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined ENS domain resolver...\\\");\\n\\n            case 22:\\n              // Log\\n              this.getLogger().info(\\\"ENS domain resolver:\\\" + \\\"\\\\n \\\" + this.etherscan[chainId] + \\\"/address/\\\" + resolver); // Check if resolver is EIP165\\n\\n              _context10.next = 25;\\n              return this.checkEip165(web3, resolver);\\n\\n            case 25:\\n              eip165 = _context10.sent;\\n\\n              if (!(eip165 == false)) {\\n                _context10.next = 28;\\n                break;\\n              }\\n\\n              throw new Error(\\\"ENS domain resolver do not conform to EIP165...\\\");\\n\\n            case 28:\\n              _context10.next = 30;\\n              return this.checkEip1577(web3, resolver);\\n\\n            case 30:\\n              eip1577 = _context10.sent;\\n\\n              if (!(eip1577 == false)) {\\n                _context10.next = 33;\\n                break;\\n              }\\n\\n              throw new Error(\\\"ENS domain resolver do not conform to EIP1577...\\\");\\n\\n            case 33:\\n              // retrieve content hash\\n              this.getLogger().info(\\\"Processing ENS domain content...\\\");\\n              abi = [{\\n                name: \\\"contenthash\\\",\\n                type: \\\"function\\\",\\n                inputs: [{\\n                  type: \\\"bytes32\\\"\\n                }]\\n              }];\\n              iface = new root.ethers.utils.Interface(abi);\\n              data = iface.functions.contenthash.encode([domainHash]);\\n              _context10.next = 39;\\n              return web3.call({\\n                to: resolver,\\n                data: data\\n              });\\n\\n            case 39:\\n              result = _context10.sent;\\n\\n              if (!(result == undefined || result == null || result === \\\"0x\\\")) {\\n                _context10.next = 42;\\n                break;\\n              }\\n\\n              return _context10.abrupt(\\\"return\\\", {\\n                content: null,\\n                protocol: null\\n              });\\n\\n            case 42:\\n              // decode bytes result\\n              content = root.ethers.utils.defaultAbiCoder.decode([\\\"bytes\\\"], result);\\n\\n              if (!(content == undefined || content == null || Array.isArray(content) === false || content[0] === \\\"0x\\\")) {\\n                _context10.next = 45;\\n                break;\\n              }\\n\\n              return _context10.abrupt(\\\"return\\\", {\\n                content: null,\\n                protocol: null\\n              });\\n\\n            case 45:\\n              // decode content hash\\n              _this$decodeContentha = this.decodeContenthash(content[0]), decoded = _this$decodeContentha.decoded, protocol = _this$decodeContentha.protocol;\\n              return _context10.abrupt(\\\"return\\\", {\\n                content: decoded,\\n                protocol: protocol\\n              });\\n\\n            case 47:\\n            case \\\"end\\\":\\n              return _context10.stop();\\n          }\\n        }\\n      }, _callee10, this);\\n    }));\\n\\n    return function (_x12, _x13) {\\n      return _ref10.apply(this, arguments);\\n    };\\n  }();\\n\\n  EnsLibrary.prototype.setContenthash = /*#__PURE__*/function () {\\n    var _ref11 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee11(domain, cid, web3, account) {\\n      var _yield$this$getEnable, domainHash, _yield$this$getRegist2, chainId, registry, resolver, eip165, eip1577, _this$encodeContentha, encoded, abi, iface, data, signer, tx;\\n\\n      return _regenerator[\\\"default\\\"].wrap(function _callee11$(_context11) {\\n        while (1) {\\n          switch (_context11.prev = _context11.next) {\\n            case 0:\\n              if (!(domain == undefined || domain == null)) {\\n                _context11.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined ENS domain...\\\");\\n\\n            case 2:\\n              if (!(cid == undefined || cid == null)) {\\n                _context11.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS identifier...\\\");\\n\\n            case 4:\\n              if (!(web3 == undefined || account == undefined)) {\\n                _context11.next = 10;\\n                break;\\n              }\\n\\n              _context11.next = 7;\\n              return this.getEnabledWeb3Provider();\\n\\n            case 7:\\n              _yield$this$getEnable = _context11.sent;\\n              web3 = _yield$this$getEnable.web3;\\n              account = _yield$this$getEnable.account;\\n\\n            case 10:\\n              // Resolve domain as namehash\\n              domainHash = root.ethers.utils.namehash(domain); // Fetch ens registry address\\n\\n              _context11.next = 13;\\n              return this.getRegistry(web3);\\n\\n            case 13:\\n              _yield$this$getRegist2 = _context11.sent;\\n              chainId = _yield$this$getRegist2.chainId;\\n              registry = _yield$this$getRegist2.registry;\\n              // Log\\n              this.getLogger().info(\\\"ENS registry:\\\" + \\\"\\\\n \\\" + this.etherscan[chainId] + \\\"/address/\\\" + registry); // Fetch resolver address\\n\\n              _context11.next = 19;\\n              return this.getResolver(web3, registry, domainHash);\\n\\n            case 19:\\n              resolver = _context11.sent;\\n\\n              if (!(resolver == null || /^0x0+$/.test(resolver) == true)) {\\n                _context11.next = 22;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined ENS resolver...\\\");\\n\\n            case 22:\\n              // Log\\n              this.getLogger().info(\\\"ENS domain resolver:\\\" + \\\"\\\\n \\\" + this.etherscan[chainId] + \\\"/address/\\\" + resolver); // Check if resolver is EIP165\\n\\n              _context11.next = 25;\\n              return this.checkEip165(web3, resolver);\\n\\n            case 25:\\n              eip165 = _context11.sent;\\n\\n              if (!(eip165 == false)) {\\n                _context11.next = 28;\\n                break;\\n              }\\n\\n              throw new Error(\\\"ENS resolver do not conform to EIP165...\\\");\\n\\n            case 28:\\n              _context11.next = 30;\\n              return this.checkEip1577(web3, resolver);\\n\\n            case 30:\\n              eip1577 = _context11.sent;\\n\\n              if (!(eip1577 == false)) {\\n                _context11.next = 33;\\n                break;\\n              }\\n\\n              throw new Error(\\\"ENS resolver do not conform to EIP1577...\\\");\\n\\n            case 33:\\n              // Encode cid\\n              _this$encodeContentha = this.encodeContenthash(\\\"ipfs://\\\" + cid), encoded = _this$encodeContentha.encoded; // Set Contenthash\\n\\n              this.getLogger().info(\\\"Processing ENS domain content...\\\");\\n              abi = [{\\n                name: \\\"setContenthash\\\",\\n                type: \\\"function\\\",\\n                inputs: [{\\n                  type: \\\"bytes32\\\"\\n                }, {\\n                  type: \\\"bytes\\\"\\n                }]\\n              }];\\n              iface = new root.ethers.utils.Interface(abi);\\n              data = iface.functions.setContenthash.encode([domainHash, encoded]);\\n              signer = web3.getSigner();\\n              _context11.next = 41;\\n              return signer.sendTransaction({\\n                to: resolver,\\n                data: data\\n              });\\n\\n            case 41:\\n              tx = _context11.sent;\\n              this.getLogger().info(\\\"Processing Transaction:\\\" + \\\"\\\\n \\\" + this.etherscan[chainId] + \\\"/tx/\\\" + tx.hash); // Wait for transaction completion\\n\\n              _context11.next = 45;\\n              return tx.wait();\\n\\n            case 45:\\n              this.getLogger().info(\\\"Processed ENS domain content...\\\");\\n              return _context11.abrupt(\\\"return\\\");\\n\\n            case 47:\\n            case \\\"end\\\":\\n              return _context11.stop();\\n          }\\n        }\\n      }, _callee11, this);\\n    }));\\n\\n    return function (_x14, _x15, _x16, _x17) {\\n      return _ref11.apply(this, arguments);\\n    };\\n  }();\\n\\n  exports.EnsLibrary = EnsLibrary;\\n})();\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"@babel/runtime/helpers/asyncToGenerator\\\":2,\\\"@babel/runtime/helpers/interopRequireDefault\\\":3,\\\"@babel/runtime/helpers/typeof\\\":4,\\\"@babel/runtime/regenerator\\\":5,\\\"cids\\\":10,\\\"content-hash\\\":20}],61:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\n/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-bundle.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIpfsBundle\\n\\n\\\\*/\\nexports.EnsLibrary = require(\\\"./ens-library\\\");\\nexports.IpfsLibrary = require(\\\"./ipfs-library\\\");\\nexports.IpfsUri = require(\\\"./ipfs-uri\\\");\\n\\n},{\\\"./ens-library\\\":60,\\\"./ipfs-library\\\":62,\\\"./ipfs-uri\\\":63}],62:[function(require,module,exports){\\n(function (global,Buffer){\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\n\\nvar _regenerator = _interopRequireDefault(require(\\\"@babel/runtime/regenerator\\\"));\\n\\nvar _asyncToGenerator2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/asyncToGenerator\\\"));\\n\\nvar _typeof2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/typeof\\\"));\\n\\nvar _asyncIterator2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/asyncIterator\\\"));\\n\\nvar _cids = _interopRequireDefault(require(\\\"cids\\\"));\\n\\nvar _ipfsProvider = require(\\\"ipfs-provider\\\");\\n\\n(function () {\\n  /*jslint node: true, browser: true */\\n\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n  /**\\n   * https://github.com/purposeindustries/window-or-global\\n   * The MIT License (MIT) Copyright (c) Purpose Industries\\n   * version: 1.0.1\\n   */\\n\\n  var root = (typeof self === \\\"undefined\\\" ? \\\"undefined\\\" : (0, _typeof2[\\\"default\\\"])(self)) === \\\"object\\\" && self.self === self && self || (typeof global === \\\"undefined\\\" ? \\\"undefined\\\" : (0, _typeof2[\\\"default\\\"])(global)) === \\\"object\\\" && global.global === global && global || this;\\n  var cidAnalyser = \\\"https://cid.ipfs.io/#\\\";\\n  var name = \\\"ipfs-library\\\";\\n\\n  var IpfsLibrary = function IpfsLibrary() {};\\n\\n  IpfsLibrary.prototype.getLogger = function () {\\n    return root.log.getLogger(name);\\n  };\\n\\n  IpfsLibrary.prototype.decodeCid = function (pathname) {\\n    // Check\\n    if (pathname == undefined || pathname == null || pathname.trim() === \\\"\\\" || pathname.trim() === \\\"/\\\") {\\n      return {\\n        protocol: null,\\n        cid: null\\n      };\\n    } // Parse\\n\\n\\n    var members = pathname.trim().split(\\\"/\\\");\\n    var protocol = null;\\n    var cid = null;\\n\\n    for (var i = 0; i < members.length; i++) {\\n      // Ignore\\n      if (members[i].trim() === \\\"\\\") {\\n        continue;\\n      } // First non empty member\\n\\n\\n      if (protocol == null) {\\n        protocol = members[i];\\n        continue;\\n      } // Second non empty member\\n\\n\\n      if (cid == null) {\\n        cid = members[i];\\n        break;\\n      } // Nothing to process\\n\\n\\n      break;\\n    } // Check\\n\\n\\n    if (protocol == null || cid == null) {\\n      return {\\n        protocol: null,\\n        cid: null\\n      };\\n    } // Check protocol\\n\\n\\n    if (protocol !== \\\"ipfs\\\" && protocol !== \\\"ipns\\\") {\\n      return {\\n        protocol: null,\\n        cid: null\\n      };\\n    } // Check\\n\\n\\n    if (this.isCid(cid) == false) {\\n      return {\\n        protocol: protocol,\\n        cid: null\\n      };\\n    } // All good\\n\\n\\n    return {\\n      protocol: protocol,\\n      cid: cid\\n    };\\n  };\\n\\n  IpfsLibrary.prototype.isCid = function (cid) {\\n    try {\\n      var newCid = new _cids[\\\"default\\\"](cid);\\n      return _cids[\\\"default\\\"].isCID(newCid);\\n    } catch (error) {\\n      return false;\\n    }\\n  };\\n\\n  IpfsLibrary.prototype.cidV1ToCidV0 = function (cidv1) {\\n    var cidv0 = new _cids[\\\"default\\\"](cidv1);\\n\\n    if (cidv0.codec !== \\\"dag-pb\\\") {\\n      throw new Error(\\\"This 'cid' is not 'dag-pb' encoded: \\\" + cidAnalyser + cidv0);\\n    }\\n\\n    if (cidv0.version === 1) {\\n      cidv0 = cidv0.toV0().toString(); // Log\\n\\n      this.getLogger().info(\\\"Converted: \\\" + \\\"\\\\n 'cidv1' (Base32):\\\" + \\\"\\\\n  \\\" + cidAnalyser + cidv1 + \\\"\\\\n to 'cidv0' (Base58):\\\" + \\\"\\\\n  \\\" + cidAnalyser + cidv0);\\n    } else {\\n      // Log\\n      this.getLogger().info(\\\"'cidv0' (Base58):\\\" + \\\"\\\\n \\\" + cidAnalyser + cidv0);\\n    }\\n\\n    return cidv0;\\n  };\\n\\n  IpfsLibrary.prototype.cidV0ToCidV1 = function (cidv0) {\\n    var cidv1 = new _cids[\\\"default\\\"](cidv0);\\n\\n    if (cidv1.codec !== \\\"dag-pb\\\") {\\n      throw new Error(\\\"This 'cid' is not 'dag-pb' encoded: \\\" + cidAnalyser + cidv1);\\n    }\\n\\n    if (cidv1.version === 0) {\\n      cidv1 = cidv1.toV1().toString();\\n      this.getLogger().info(\\\"Converted: \\\" + \\\"\\\\n 'cidv0' (Base58):\\\" + \\\"\\\\n  \\\" + cidAnalyser + cidv0 + \\\"\\\\n to 'cidv1' (Base32):\\\" + \\\"\\\\n  \\\" + cidAnalyser + cidv1);\\n    } else {\\n      // Log\\n      this.getLogger().info(\\\"'cidv1' (Base32): \\\" + \\\"\\\\n \\\" + cidAnalyser + cidv1);\\n    }\\n\\n    return cidv1;\\n  };\\n\\n  IpfsLibrary.prototype.loadIpfsHttpClient = /*#__PURE__*/(0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee() {\\n    var self;\\n    return _regenerator[\\\"default\\\"].wrap(function _callee$(_context) {\\n      while (1) {\\n        switch (_context.prev = _context.next) {\\n          case 0:\\n            self = this;\\n\\n            if (!(typeof root.httpClient === \\\"undefined\\\" || typeof root.IpfsHttpClient === \\\"undefined\\\")) {\\n              _context.next = 13;\\n              break;\\n            }\\n\\n            _context.prev = 2;\\n            _context.next = 5;\\n            return $tw.ipfs.getLoader().loadIpfsHttpLibrary();\\n\\n          case 5:\\n            if (!(typeof root.httpClient !== \\\"undefined\\\")) {\\n              _context.next = 7;\\n              break;\\n            }\\n\\n            return _context.abrupt(\\\"return\\\");\\n\\n          case 7:\\n            _context.next = 12;\\n            break;\\n\\n          case 9:\\n            _context.prev = 9;\\n            _context.t0 = _context[\\\"catch\\\"](2);\\n            self.getLogger().error(_context.t0);\\n\\n          case 12:\\n            throw new Error(\\\"Unavailable IPFS HTTP Client library...\\\");\\n\\n          case 13:\\n          case \\\"end\\\":\\n            return _context.stop();\\n        }\\n      }\\n    }, _callee, this, [[2, 9]]);\\n  })); // Default\\n\\n  IpfsLibrary.prototype.getDefaultIpfs = /*#__PURE__*/function () {\\n    var _ref2 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee2(apiUrl) {\\n      var _yield$this$getWindow, ipfs, provider, _yield$this$getHttpIp, _ipfs, _provider;\\n\\n      return _regenerator[\\\"default\\\"].wrap(function _callee2$(_context2) {\\n        while (1) {\\n          switch (_context2.prev = _context2.next) {\\n            case 0:\\n              _context2.prev = 0;\\n              _context2.next = 3;\\n              return this.getWindowIpfs();\\n\\n            case 3:\\n              _yield$this$getWindow = _context2.sent;\\n              ipfs = _yield$this$getWindow.ipfs;\\n              provider = _yield$this$getWindow.provider;\\n\\n              if (!(ipfs !== null)) {\\n                _context2.next = 8;\\n                break;\\n              }\\n\\n              return _context2.abrupt(\\\"return\\\", {\\n                ipfs: ipfs,\\n                provider: provider\\n              });\\n\\n            case 8:\\n              _context2.next = 12;\\n              break;\\n\\n            case 10:\\n              _context2.prev = 10;\\n              _context2.t0 = _context2[\\\"catch\\\"](0);\\n\\n            case 12:\\n              if (!(apiUrl == undefined || apiUrl == null || apiUrl.href === \\\"\\\")) {\\n                _context2.next = 14;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS API URL...\\\");\\n\\n            case 14:\\n              _context2.prev = 14;\\n              _context2.next = 17;\\n              return this.getHttpIpfs(apiUrl);\\n\\n            case 17:\\n              _yield$this$getHttpIp = _context2.sent;\\n              _ipfs = _yield$this$getHttpIp.ipfs;\\n              _provider = _yield$this$getHttpIp.provider;\\n\\n              if (!(_ipfs !== null)) {\\n                _context2.next = 22;\\n                break;\\n              }\\n\\n              return _context2.abrupt(\\\"return\\\", {\\n                ipfs: _ipfs,\\n                provider: _provider\\n              });\\n\\n            case 22:\\n              _context2.next = 26;\\n              break;\\n\\n            case 24:\\n              _context2.prev = 24;\\n              _context2.t1 = _context2[\\\"catch\\\"](14);\\n\\n            case 26:\\n              throw new Error(\\\"Unable to retrieve IPFS Companion and IPFS API URL...\\\");\\n\\n            case 27:\\n            case \\\"end\\\":\\n              return _context2.stop();\\n          }\\n        }\\n      }, _callee2, this, [[0, 10], [14, 24]]);\\n    }));\\n\\n    return function (_x) {\\n      return _ref2.apply(this, arguments);\\n    };\\n  }(); // IPFS companion\\n\\n\\n  IpfsLibrary.prototype.getWindowIpfs = /*#__PURE__*/(0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee3() {\\n    var self, windowIpfs, _yield$getIpfs, ipfs, provider;\\n\\n    return _regenerator[\\\"default\\\"].wrap(function _callee3$(_context3) {\\n      while (1) {\\n        switch (_context3.prev = _context3.next) {\\n          case 0:\\n            self = this;\\n            _context3.prev = 1;\\n            windowIpfs = _ipfsProvider.providers.windowIpfs;\\n            this.getLogger().info(\\\"Processing connection to IPFS Companion...\\\");\\n            _context3.next = 6;\\n            return (0, _ipfsProvider.getIpfs)({\\n              providers: [windowIpfs()]\\n            });\\n\\n          case 6:\\n            _yield$getIpfs = _context3.sent;\\n            ipfs = _yield$getIpfs.ipfs;\\n            provider = _yield$getIpfs.provider;\\n            return _context3.abrupt(\\\"return\\\", {\\n              ipfs: ipfs,\\n              provider: provider\\n            });\\n\\n          case 12:\\n            _context3.prev = 12;\\n            _context3.t0 = _context3[\\\"catch\\\"](1);\\n            self.getLogger().error(_context3.t0);\\n\\n          case 15:\\n            throw new Error(\\\"Unreachable IPFS Companion...\\\");\\n\\n          case 16:\\n          case \\\"end\\\":\\n            return _context3.stop();\\n        }\\n      }\\n    }, _callee3, this, [[1, 12]]);\\n  })); // ipfs-http-client\\n\\n  IpfsLibrary.prototype.getHttpIpfs = /*#__PURE__*/function () {\\n    var _ref4 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee4(apiUrl) {\\n      var self, httpClient, _yield$getIpfs2, ipfs, provider;\\n\\n      return _regenerator[\\\"default\\\"].wrap(function _callee4$(_context4) {\\n        while (1) {\\n          switch (_context4.prev = _context4.next) {\\n            case 0:\\n              self = this; // Check\\n\\n              if (!(apiUrl == undefined || apiUrl == null || apiUrl.href === \\\"\\\")) {\\n                _context4.next = 3;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS API URL...\\\");\\n\\n            case 3:\\n              _context4.prev = 3;\\n\\n              if (!(typeof root.httpClient === \\\"undefined\\\" || typeof root.IpfsHttpClient === \\\"undefined\\\")) {\\n                _context4.next = 7;\\n                break;\\n              }\\n\\n              _context4.next = 7;\\n              return this.loadIpfsHttpClient();\\n\\n            case 7:\\n              // Instantiate client\\n              httpClient = _ipfsProvider.providers.httpClient;\\n              self.getLogger().info(\\\"Processing connection to IPFS API URL:\\\" + \\\"\\\\n \\\" + apiUrl.href);\\n              _context4.next = 11;\\n              return (0, _ipfsProvider.getIpfs)({\\n                providers: [httpClient({\\n                  apiAddress: apiUrl.href\\n                })]\\n              });\\n\\n            case 11:\\n              _yield$getIpfs2 = _context4.sent;\\n              ipfs = _yield$getIpfs2.ipfs;\\n              provider = _yield$getIpfs2.provider;\\n              return _context4.abrupt(\\\"return\\\", {\\n                ipfs: ipfs,\\n                provider: provider + \\\", \\\" + apiUrl.href\\n              });\\n\\n            case 17:\\n              _context4.prev = 17;\\n              _context4.t0 = _context4[\\\"catch\\\"](3);\\n              self.getLogger().error(_context4.t0);\\n\\n            case 20:\\n              throw new Error(\\\"Unreachable IPFS API URL...\\\");\\n\\n            case 21:\\n            case \\\"end\\\":\\n              return _context4.stop();\\n          }\\n        }\\n      }, _callee4, this, [[3, 17]]);\\n    }));\\n\\n    return function (_x2) {\\n      return _ref4.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.add = /*#__PURE__*/function () {\\n    var _ref5 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee5(client, content) {\\n      var buffer, addSource, lastResult, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, added, cidv1;\\n\\n      return _regenerator[\\\"default\\\"].wrap(function _callee5$(_context5) {\\n        while (1) {\\n          switch (_context5.prev = _context5.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context5.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(content == undefined || content == null)) {\\n                _context5.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined content...\\\");\\n\\n            case 4:\\n              if (!client.enable) {\\n                _context5.next = 8;\\n                break;\\n              }\\n\\n              _context5.next = 7;\\n              return client.enable({\\n                commands: [\\\"add\\\"]\\n              });\\n\\n            case 7:\\n              client = _context5.sent;\\n\\n            case 8:\\n              if (!(client !== undefined && client.add !== undefined)) {\\n                _context5.next = 52;\\n                break;\\n              }\\n\\n              // Process\\n              buffer = Buffer.from(content);\\n              this.getLogger().info(\\\"Processing IPFS add...\\\"); // 1 - https://github.com/ipfs/go-ipfs/issues/5683\\n              // default chunker: \\\"size-262144\\\"\\n              // chunker: \\\"rabin-262144-524288-1048576\\\"\\n              // 2 - TODO: small content generates a wrong cid when cidVersion: 1 is set:\\n              // Not a 'dag-pb' but a 'raw' multicodec instead\\n              // We generate a V0 and convert it to a V1\\n              // https://github.com/xmaysonnave/tiddlywiki-ipfs/issues/14\\n\\n              _context5.next = 13;\\n              return client.add(buffer, {\\n                cidVersion: 0,\\n                hashAlg: \\\"sha2-256\\\",\\n                chunker: \\\"rabin-262144-524288-1048576\\\",\\n                pin: false\\n              });\\n\\n            case 13:\\n              addSource = _context5.sent;\\n              // https://gist.github.com/alanshaw/04b2ddc35a6fff25c040c011ac6acf26\\n              lastResult = null;\\n              _iteratorNormalCompletion = true;\\n              _didIteratorError = false;\\n              _context5.prev = 17;\\n              _iterator = (0, _asyncIterator2[\\\"default\\\"])(addSource);\\n\\n            case 19:\\n              _context5.next = 21;\\n              return _iterator.next();\\n\\n            case 21:\\n              _step = _context5.sent;\\n              _iteratorNormalCompletion = _step.done;\\n              _context5.next = 25;\\n              return _step.value;\\n\\n            case 25:\\n              _value = _context5.sent;\\n\\n              if (_iteratorNormalCompletion) {\\n                _context5.next = 32;\\n                break;\\n              }\\n\\n              added = _value;\\n              lastResult = added;\\n\\n            case 29:\\n              _iteratorNormalCompletion = true;\\n              _context5.next = 19;\\n              break;\\n\\n            case 32:\\n              _context5.next = 38;\\n              break;\\n\\n            case 34:\\n              _context5.prev = 34;\\n              _context5.t0 = _context5[\\\"catch\\\"](17);\\n              _didIteratorError = true;\\n              _iteratorError = _context5.t0;\\n\\n            case 38:\\n              _context5.prev = 38;\\n              _context5.prev = 39;\\n\\n              if (!(!_iteratorNormalCompletion && _iterator[\\\"return\\\"] != null)) {\\n                _context5.next = 43;\\n                break;\\n              }\\n\\n              _context5.next = 43;\\n              return _iterator[\\\"return\\\"]();\\n\\n            case 43:\\n              _context5.prev = 43;\\n\\n              if (!_didIteratorError) {\\n                _context5.next = 46;\\n                break;\\n              }\\n\\n              throw _iteratorError;\\n\\n            case 46:\\n              return _context5.finish(43);\\n\\n            case 47:\\n              return _context5.finish(38);\\n\\n            case 48:\\n              if (!(lastResult == null || lastResult.path == undefined || lastResult.path == null)) {\\n                _context5.next = 50;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 50:\\n              // Convert\\n              cidv1 = this.cidV0ToCidV1(lastResult.path);\\n              return _context5.abrupt(\\\"return\\\", {\\n                hash: cidv1,\\n                size: lastResult.size\\n              });\\n\\n            case 52:\\n              throw new Error(\\\"Undefined IPFS command add...\\\");\\n\\n            case 53:\\n            case \\\"end\\\":\\n              return _context5.stop();\\n          }\\n        }\\n      }, _callee5, this, [[17, 34, 38, 48], [39,, 43, 47]]);\\n    }));\\n\\n    return function (_x3, _x4) {\\n      return _ref5.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.pin = /*#__PURE__*/function () {\\n    var _ref6 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee6(client, cid) {\\n      var result;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee6$(_context6) {\\n        while (1) {\\n          switch (_context6.prev = _context6.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context6.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(cid == undefined || cid == null || cid.trim() === \\\"\\\")) {\\n                _context6.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS identifier...\\\");\\n\\n            case 4:\\n              if (!client.enable) {\\n                _context6.next = 8;\\n                break;\\n              }\\n\\n              _context6.next = 7;\\n              return client.enable({\\n                commands: [\\\"pin\\\"]\\n              });\\n\\n            case 7:\\n              client = _context6.sent;\\n\\n            case 8:\\n              if (!(client !== undefined && client.pin !== undefined && client.pin.add !== undefined)) {\\n                _context6.next = 16;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPFS pin add...\\\");\\n              _context6.next = 12;\\n              return client.pin.add(cid.trim());\\n\\n            case 12:\\n              result = _context6.sent;\\n\\n              if (!(result == undefined || result == null)) {\\n                _context6.next = 15;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 15:\\n              return _context6.abrupt(\\\"return\\\", result);\\n\\n            case 16:\\n              throw new Error(\\\"Undefined IPFS pin add...\\\");\\n\\n            case 17:\\n            case \\\"end\\\":\\n              return _context6.stop();\\n          }\\n        }\\n      }, _callee6, this);\\n    }));\\n\\n    return function (_x5, _x6) {\\n      return _ref6.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.unpin = /*#__PURE__*/function () {\\n    var _ref7 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee7(client, cid) {\\n      var result;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee7$(_context7) {\\n        while (1) {\\n          switch (_context7.prev = _context7.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context7.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(cid == undefined || cid == null || cid.trim() === \\\"\\\")) {\\n                _context7.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS identifier...\\\");\\n\\n            case 4:\\n              if (!client.enable) {\\n                _context7.next = 8;\\n                break;\\n              }\\n\\n              _context7.next = 7;\\n              return client.enable({\\n                commands: [\\\"pin\\\"]\\n              });\\n\\n            case 7:\\n              client = _context7.sent;\\n\\n            case 8:\\n              if (!(client !== undefined && client.pin !== undefined && client.pin.rm !== undefined)) {\\n                _context7.next = 16;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPFS pin rm...\\\");\\n              _context7.next = 12;\\n              return client.pin.rm(cid.trim());\\n\\n            case 12:\\n              result = _context7.sent;\\n\\n              if (!(result == undefined || result == null)) {\\n                _context7.next = 15;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 15:\\n              return _context7.abrupt(\\\"return\\\", result);\\n\\n            case 16:\\n              throw new Error(\\\"Undefined IPFS pin rm\\\");\\n\\n            case 17:\\n            case \\\"end\\\":\\n              return _context7.stop();\\n          }\\n        }\\n      }, _callee7, this);\\n    }));\\n\\n    return function (_x7, _x8) {\\n      return _ref7.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.publish = /*#__PURE__*/function () {\\n    var _ref8 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee8(client, name, cid) {\\n      var result;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee8$(_context8) {\\n        while (1) {\\n          switch (_context8.prev = _context8.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context8.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(name == undefined || name == null || name.trim() === \\\"\\\")) {\\n                _context8.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPNS name...\\\");\\n\\n            case 4:\\n              if (!(cid == undefined || cid == null || cid.trim() === \\\"\\\")) {\\n                _context8.next = 6;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS identifier...\\\");\\n\\n            case 6:\\n              if (!client.enable) {\\n                _context8.next = 10;\\n                break;\\n              }\\n\\n              _context8.next = 9;\\n              return client.enable({\\n                commands: [\\\"name\\\"]\\n              });\\n\\n            case 9:\\n              client = _context8.sent;\\n\\n            case 10:\\n              if (!(client !== undefined && client.name !== undefined && client.name.publish !== undefined)) {\\n                _context8.next = 18;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPNS name publish...\\\");\\n              _context8.next = 14;\\n              return client.name.publish(cid.trim(), {\\n                key: name.trim()\\n              });\\n\\n            case 14:\\n              result = _context8.sent;\\n\\n              if (!(result == undefined || result == null)) {\\n                _context8.next = 17;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 17:\\n              return _context8.abrupt(\\\"return\\\", result);\\n\\n            case 18:\\n              throw new Error(\\\"Undefined IPNS name publish...\\\");\\n\\n            case 19:\\n            case \\\"end\\\":\\n              return _context8.stop();\\n          }\\n        }\\n      }, _callee8, this);\\n    }));\\n\\n    return function (_x9, _x10, _x11) {\\n      return _ref8.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.resolve = /*#__PURE__*/function () {\\n    var _ref9 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee9(client, id) {\\n      var resolvedSource, lastResult, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, resolved;\\n\\n      return _regenerator[\\\"default\\\"].wrap(function _callee9$(_context9) {\\n        while (1) {\\n          switch (_context9.prev = _context9.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context9.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(id == undefined || id == null || id.trim() === \\\"\\\")) {\\n                _context9.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPNS key...\\\");\\n\\n            case 4:\\n              if (!client.enable) {\\n                _context9.next = 8;\\n                break;\\n              }\\n\\n              _context9.next = 7;\\n              return client.enable({\\n                commands: [\\\"name\\\"]\\n              });\\n\\n            case 7:\\n              client = _context9.sent;\\n\\n            case 8:\\n              if (!(client !== undefined && client.name !== undefined && client.name.resolve !== undefined)) {\\n                _context9.next = 50;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPNS name resolve...\\\");\\n              _context9.next = 12;\\n              return client.name.resolve(id.trim(), {\\n                recursive: true\\n              });\\n\\n            case 12:\\n              resolvedSource = _context9.sent;\\n              // https://gist.github.com/alanshaw/04b2ddc35a6fff25c040c011ac6acf26\\n              lastResult = null;\\n              _iteratorNormalCompletion2 = true;\\n              _didIteratorError2 = false;\\n              _context9.prev = 16;\\n              _iterator2 = (0, _asyncIterator2[\\\"default\\\"])(resolvedSource);\\n\\n            case 18:\\n              _context9.next = 20;\\n              return _iterator2.next();\\n\\n            case 20:\\n              _step2 = _context9.sent;\\n              _iteratorNormalCompletion2 = _step2.done;\\n              _context9.next = 24;\\n              return _step2.value;\\n\\n            case 24:\\n              _value2 = _context9.sent;\\n\\n              if (_iteratorNormalCompletion2) {\\n                _context9.next = 31;\\n                break;\\n              }\\n\\n              resolved = _value2;\\n              lastResult = resolved;\\n\\n            case 28:\\n              _iteratorNormalCompletion2 = true;\\n              _context9.next = 18;\\n              break;\\n\\n            case 31:\\n              _context9.next = 37;\\n              break;\\n\\n            case 33:\\n              _context9.prev = 33;\\n              _context9.t0 = _context9[\\\"catch\\\"](16);\\n              _didIteratorError2 = true;\\n              _iteratorError2 = _context9.t0;\\n\\n            case 37:\\n              _context9.prev = 37;\\n              _context9.prev = 38;\\n\\n              if (!(!_iteratorNormalCompletion2 && _iterator2[\\\"return\\\"] != null)) {\\n                _context9.next = 42;\\n                break;\\n              }\\n\\n              _context9.next = 42;\\n              return _iterator2[\\\"return\\\"]();\\n\\n            case 42:\\n              _context9.prev = 42;\\n\\n              if (!_didIteratorError2) {\\n                _context9.next = 45;\\n                break;\\n              }\\n\\n              throw _iteratorError2;\\n\\n            case 45:\\n              return _context9.finish(42);\\n\\n            case 46:\\n              return _context9.finish(37);\\n\\n            case 47:\\n              if (!(lastResult == null || lastResult == undefined || lastResult.trim() === \\\"\\\")) {\\n                _context9.next = 49;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 49:\\n              return _context9.abrupt(\\\"return\\\", lastResult);\\n\\n            case 50:\\n              throw new Error(\\\"Undefined IPNS name resolve...\\\");\\n\\n            case 51:\\n            case \\\"end\\\":\\n              return _context9.stop();\\n          }\\n        }\\n      }, _callee9, this, [[16, 33, 37, 47], [38,, 42, 46]]);\\n    }));\\n\\n    return function (_x12, _x13) {\\n      return _ref9.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.getKeys = /*#__PURE__*/function () {\\n    var _ref10 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee10(client) {\\n      var result;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee10$(_context10) {\\n        while (1) {\\n          switch (_context10.prev = _context10.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context10.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!client.enable) {\\n                _context10.next = 6;\\n                break;\\n              }\\n\\n              _context10.next = 5;\\n              return client.enable({\\n                commands: [\\\"key\\\"]\\n              });\\n\\n            case 5:\\n              client = _context10.sent;\\n\\n            case 6:\\n              if (!(client !== undefined && client.key !== undefined && client.key.list !== undefined)) {\\n                _context10.next = 14;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPNS key list...\\\");\\n              _context10.next = 10;\\n              return client.key.list();\\n\\n            case 10:\\n              result = _context10.sent;\\n\\n              if (!(result == undefined || result == null || Array.isArray(result) == false)) {\\n                _context10.next = 13;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 13:\\n              return _context10.abrupt(\\\"return\\\", result);\\n\\n            case 14:\\n              throw new Error(\\\"Undefined IPNS key list...\\\");\\n\\n            case 15:\\n            case \\\"end\\\":\\n              return _context10.stop();\\n          }\\n        }\\n      }, _callee10, this);\\n    }));\\n\\n    return function (_x14) {\\n      return _ref10.apply(this, arguments);\\n    };\\n  }(); // Only rsa is supported yet...\\n  // https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/KEY.md#keygen\\n  // https://github.com/libp2p/js-libp2p-crypto/issues/145\\n\\n\\n  IpfsLibrary.prototype.genKey = /*#__PURE__*/function () {\\n    var _ref11 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee11(client, name) {\\n      var key;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee11$(_context11) {\\n        while (1) {\\n          switch (_context11.prev = _context11.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context11.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(name == undefined || name == null || name.trim() === \\\"\\\")) {\\n                _context11.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPNS name...\\\");\\n\\n            case 4:\\n              if (!client.enable) {\\n                _context11.next = 8;\\n                break;\\n              }\\n\\n              _context11.next = 7;\\n              return client.enable({\\n                commands: [\\\"key\\\"]\\n              });\\n\\n            case 7:\\n              client = _context11.sent;\\n\\n            case 8:\\n              if (!(client !== undefined && client.key !== undefined && client.key.gen !== undefined)) {\\n                _context11.next = 16;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPNS key gen...\\\");\\n              _context11.next = 12;\\n              return client.key.gen(name.trim(), {\\n                type: \\\"rsa\\\",\\n                size: 2048\\n              });\\n\\n            case 12:\\n              key = _context11.sent;\\n\\n              if (!(key == undefined || key == null || key.id == undefined || key.id == null)) {\\n                _context11.next = 15;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 15:\\n              return _context11.abrupt(\\\"return\\\", key.id);\\n\\n            case 16:\\n              throw new Error(\\\"Undefined IPNS key gen...\\\");\\n\\n            case 17:\\n            case \\\"end\\\":\\n              return _context11.stop();\\n          }\\n        }\\n      }, _callee11, this);\\n    }));\\n\\n    return function (_x15, _x16) {\\n      return _ref11.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.rmKey = /*#__PURE__*/function () {\\n    var _ref12 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee12(client, name) {\\n      var key;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee12$(_context12) {\\n        while (1) {\\n          switch (_context12.prev = _context12.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context12.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(name == undefined || name == null || name.trim() === \\\"\\\")) {\\n                _context12.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPNS name...\\\");\\n\\n            case 4:\\n              if (!client.enable) {\\n                _context12.next = 8;\\n                break;\\n              }\\n\\n              _context12.next = 7;\\n              return client.enable({\\n                commands: [\\\"key\\\"]\\n              });\\n\\n            case 7:\\n              client = _context12.sent;\\n\\n            case 8:\\n              if (!(client !== undefined && client.key !== undefined && client.key.rm !== undefined)) {\\n                _context12.next = 16;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPNS key rm...\\\");\\n              _context12.next = 12;\\n              return client.key.rm(name.trim());\\n\\n            case 12:\\n              key = _context12.sent;\\n\\n              if (!(key == undefined || key == null || key.id == undefined || key.id == null)) {\\n                _context12.next = 15;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 15:\\n              return _context12.abrupt(\\\"return\\\", key.id);\\n\\n            case 16:\\n              throw new Error(\\\"Undefined IPNS key rm...\\\");\\n\\n            case 17:\\n            case \\\"end\\\":\\n              return _context12.stop();\\n          }\\n        }\\n      }, _callee12, this);\\n    }));\\n\\n    return function (_x17, _x18) {\\n      return _ref12.apply(this, arguments);\\n    };\\n  }();\\n\\n  IpfsLibrary.prototype.renameKey = /*#__PURE__*/function () {\\n    var _ref13 = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee13(client, oldName, newName) {\\n      var key, id, was, now, overwrite;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee13$(_context13) {\\n        while (1) {\\n          switch (_context13.prev = _context13.next) {\\n            case 0:\\n              if (!(client == undefined || client == null)) {\\n                _context13.next = 2;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPFS provider...\\\");\\n\\n            case 2:\\n              if (!(oldName == undefined || oldName == null || oldName.trim() === \\\"\\\")) {\\n                _context13.next = 4;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPNS old name...\\\");\\n\\n            case 4:\\n              if (!(newName == undefined || newName == null || newName.trim() === \\\"\\\")) {\\n                _context13.next = 6;\\n                break;\\n              }\\n\\n              throw new Error(\\\"Undefined IPNS nem name...\\\");\\n\\n            case 6:\\n              if (!client.enable) {\\n                _context13.next = 10;\\n                break;\\n              }\\n\\n              _context13.next = 9;\\n              return client.enable({\\n                commands: [\\\"key\\\"]\\n              });\\n\\n            case 9:\\n              client = _context13.sent;\\n\\n            case 10:\\n              if (!(client !== undefined && client.key !== undefined && client.key.rename !== undefined)) {\\n                _context13.next = 26;\\n                break;\\n              }\\n\\n              this.getLogger().info(\\\"Processing IPNS key rename...\\\");\\n              _context13.next = 14;\\n              return client.key.rename(oldName.trim(), newName.trim());\\n\\n            case 14:\\n              key = _context13.sent;\\n\\n              if (!(key == undefined || key == null)) {\\n                _context13.next = 17;\\n                break;\\n              }\\n\\n              throw new Error(\\\"IPFS client returned an unknown result...\\\");\\n\\n            case 17:\\n              id = null;\\n\\n              if (key.id !== undefined && key.id !== null) {\\n                id = key.id;\\n              }\\n\\n              was = null;\\n\\n              if (key.was !== undefined && key.was !== null) {\\n                was = key.was;\\n              }\\n\\n              now = null;\\n\\n              if (key.now !== undefined && key.now !== null) {\\n                now = key.now;\\n              }\\n\\n              overwrite = null;\\n\\n              if (key.overwrite !== undefined && key.overwrite !== null) {\\n                overwrite = key.overwrite;\\n              }\\n\\n              return _context13.abrupt(\\\"return\\\", {\\n                id: id,\\n                was: was,\\n                now: now,\\n                overwrite: overwrite\\n              });\\n\\n            case 26:\\n              throw new Error(\\\"Undefined IPNS key rename...\\\");\\n\\n            case 27:\\n            case \\\"end\\\":\\n              return _context13.stop();\\n          }\\n        }\\n      }, _callee13, this);\\n    }));\\n\\n    return function (_x19, _x20, _x21) {\\n      return _ref13.apply(this, arguments);\\n    };\\n  }();\\n\\n  exports.IpfsLibrary = IpfsLibrary;\\n})();\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {},require(\\\"buffer\\\").Buffer)\\n},{\\\"@babel/runtime/helpers/asyncIterator\\\":1,\\\"@babel/runtime/helpers/asyncToGenerator\\\":2,\\\"@babel/runtime/helpers/interopRequireDefault\\\":3,\\\"@babel/runtime/helpers/typeof\\\":4,\\\"@babel/runtime/regenerator\\\":5,\\\"buffer\\\":8,\\\"cids\\\":10,\\\"ipfs-provider\\\":24}],63:[function(require,module,exports){\\n(function (global){\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\n\\nvar _regenerator = _interopRequireDefault(require(\\\"@babel/runtime/regenerator\\\"));\\n\\nvar _asyncToGenerator2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/asyncToGenerator\\\"));\\n\\nvar _typeof2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/typeof\\\"));\\n\\nvar _universalUrl = require(\\\"universal-url\\\");\\n\\n(function () {\\n  /*jslint node: true, browser: true */\\n\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n  /**\\n   * https://github.com/purposeindustries/window-or-global\\n   * The MIT License (MIT) Copyright (c) Purpose Industries\\n   * version: 1.0.1\\n   */\\n\\n  var root = (typeof self === \\\"undefined\\\" ? \\\"undefined\\\" : (0, _typeof2[\\\"default\\\"])(self)) === \\\"object\\\" && self.self === self && self || (typeof global === \\\"undefined\\\" ? \\\"undefined\\\" : (0, _typeof2[\\\"default\\\"])(global)) === \\\"object\\\" && global.global === global && global || this;\\n  var name = \\\"ipfs-uri\\\";\\n  var defaultApiUrl = new _universalUrl.URL(\\\"https://ipfs.infura.io:5001\\\");\\n  var defaultGatewayUrl = new _universalUrl.URL(\\\"https://ipfs.infura.io\\\");\\n\\n  var IpfsUri = function IpfsUri() {};\\n\\n  IpfsUri.prototype.getLogger = function () {\\n    return root.log.getLogger(name);\\n  };\\n  /**\\n   * url.href;\\n   * url.origin\\n   * url.protocol;\\n   * url.username;\\n   * url.password;\\n   * url.host;\\n   * url.hostname;\\n   * url.port;\\n   * url.pathname;\\n   * url.search;\\n   * url.hash;\\n   * https://jsdom.github.io/whatwg-url/\\n   * https://github.com/stevenvachon/universal-url\\n   * https://github.com/stevenvachon/universal-url-lite\\n   * https://url.spec.whatwg.org/\\n   */\\n\\n\\n  IpfsUri.prototype.getDocumentUrl = function () {\\n    try {\\n      return new _universalUrl.URL(root.location.href);\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n\\n    throw new Error(\\\"Invalid current HTML Document URL...\\\");\\n  };\\n\\n  IpfsUri.prototype.getIpfsApiUrl = function () {\\n    try {\\n      return new _universalUrl.URL($tw.utils.getIpfsSaverApiUrl());\\n    } catch (error) {\\n      return this.getDefaultIpfsApiUrl();\\n    }\\n  };\\n\\n  IpfsUri.prototype.getDefaultIpfsApiUrl = function () {\\n    return defaultApiUrl;\\n  };\\n\\n  IpfsUri.prototype.getIpfsGatewayUrl = function () {\\n    try {\\n      return new _universalUrl.URL($tw.utils.getIpfsSaverGatewayUrl());\\n    } catch (error) {\\n      return this.getDefaultIpfsGatewayUrl();\\n    }\\n  };\\n\\n  IpfsUri.prototype.getDefaultIpfsGatewayUrl = function () {\\n    return defaultGatewayUrl;\\n  };\\n\\n  IpfsUri.prototype.getUrl = function (url, base) {\\n    try {\\n      return new _universalUrl.URL(url, base);\\n    } catch (error) {// Ignore\\n    }\\n\\n    throw new Error(\\\"Invalid URL...\\\");\\n  };\\n\\n  IpfsUri.prototype.getIpfsBaseUrl = function () {\\n    var base = this.getIpfsGatewayUrl();\\n\\n    try {\\n      if ($tw.utils.getIpfsUrlPolicy() === \\\"origin\\\") {\\n        base = this.getDocumentUrl();\\n\\n        if (base.protocol === \\\"file:\\\") {\\n          base = this.getIpfsGatewayUrl();\\n        }\\n      }\\n    } catch (error) {\\n      base = this.getIpfsGatewayUrl();\\n    }\\n\\n    return new _universalUrl.URL(base.protocol + \\\"//\\\" + base.host);\\n  };\\n\\n  IpfsUri.prototype.normalizeUrl = /*#__PURE__*/function () {\\n    var _ref = (0, _asyncToGenerator2[\\\"default\\\"])( /*#__PURE__*/_regenerator[\\\"default\\\"].mark(function _callee(url, base) {\\n      var parsed, jest;\\n      return _regenerator[\\\"default\\\"].wrap(function _callee$(_context) {\\n        while (1) {\\n          switch (_context.prev = _context.next) {\\n            case 0:\\n              // Parse\\n              parsed = null;\\n\\n              if (!(url !== undefined && url !== null && url.toString().trim() !== \\\"\\\")) {\\n                _context.next = 12;\\n                break;\\n              }\\n\\n              try {\\n                parsed = new _universalUrl.URL(url);\\n              } catch (error) {\\n                parsed = null;\\n              } // Invalid URL, try to parse with a Base URL\\n\\n\\n              if (parsed == null) {\\n                base = base !== undefined && base !== null ? base : this.getIpfsBaseUrl();\\n\\n                if (url !== undefined && url !== null) {\\n                  parsed = this.getUrl(url, base);\\n                }\\n              } // Remove .link from .eth.link\\n\\n\\n              if (parsed.hostname.endsWith(\\\".eth.link\\\")) {\\n                parsed.hostname = parsed.hostname.substring(0, parsed.hostname.indexOf(\\\".link\\\"));\\n              } // Resolve .eth\\n\\n\\n              if (!parsed.hostname.endsWith(\\\".eth\\\")) {\\n                _context.next = 12;\\n                break;\\n              }\\n\\n              // To accomodate jest\\n              jest = true;\\n\\n              try {\\n                if ($tw.browser) {\\n                  // It never happen as node raises an exception...\\n                  jest = false;\\n                }\\n              } catch (error) {} // Ignore\\n              // Errors are triggered and tests are running...\\n\\n\\n              if (!(jest === false)) {\\n                _context.next = 12;\\n                break;\\n              }\\n\\n              _context.next = 11;\\n              return $tw.ipfs.resolveENS(parsed.hostname);\\n\\n            case 11:\\n              parsed = _context.sent;\\n\\n            case 12:\\n              return _context.abrupt(\\\"return\\\", parsed);\\n\\n            case 13:\\n            case \\\"end\\\":\\n              return _context.stop();\\n          }\\n        }\\n      }, _callee, this);\\n    }));\\n\\n    return function (_x, _x2) {\\n      return _ref.apply(this, arguments);\\n    };\\n  }();\\n\\n  exports.IpfsUri = IpfsUri;\\n})();\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"@babel/runtime/helpers/asyncToGenerator\\\":2,\\\"@babel/runtime/helpers/interopRequireDefault\\\":3,\\\"@babel/runtime/helpers/typeof\\\":4,\\\"@babel/runtime/regenerator\\\":5,\\\"universal-url\\\":54}]},{},[61])(61)\\n});\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-controller.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-controller.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-controller.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIpfsController\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const EnsWrapper = require(\\\"$:/plugins/ipfs/ens-wrapper.js\\\").EnsWrapper;\\n  const IpfsLoader = require(\\\"$:/plugins/ipfs/ipfs-loader.js\\\").IpfsLoader;\\n  const IpfsWrapper = require(\\\"$:/plugins/ipfs/ipfs-wrapper.js\\\").IpfsWrapper;\\n  const IpfsUri = require(\\\"./ipfs-bundle.js\\\").IpfsUri;\\n\\n  const name = \\\"ipfs-controller\\\";\\n\\n  var IpfsController = function() {\\n    this.web3 = null;\\n    this.chainId = null;\\n    this.account = null;\\n    this.ethereum = null;\\n    this.ensWrapper = new EnsWrapper();\\n    this.loader = new IpfsLoader();\\n    this.ipfsUri = new IpfsUri.IpfsUri();\\n    this.ipfsWrapper = new IpfsWrapper();\\n    this.ipfsClients = new Map();\\n    this.unpin = [];\\n  };\\n\\n  IpfsController.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  IpfsController.prototype.requestToUnpin = async function(cid) {\\n    if (this.addToUnpin(cid)) {\\n      const url = await this.normalizeIpfsUrl(\\\"/ipfs/\\\" + cid);\\n      this.getLogger().info(\\\"Request to unpin:\\\" + \\\"\\\\n \\\" + url.toString());\\n    }\\n  };\\n\\n  IpfsController.prototype.addToUnpin = async function(cid) {\\n    if (cid !== undefined && cid !== null) {\\n      if (this.unpin.indexOf(cid) === -1) {\\n        this.unpin.push(cid);\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  IpfsController.prototype.discardRequestToUnpin = async function(cid) {\\n    if (cid !== undefined && cid !== null && this.removeFromUnpin(cid)) {\\n      const url = await this.normalizeIpfsUrl(\\\"/ipfs/\\\" + cid);\\n      this.getLogger().info(\\\"Discard request to unpin:\\\" + \\\"\\\\n \\\" + url.toString());\\n    }\\n  };\\n\\n  IpfsController.prototype.removeFromUnpin = async function(cid) {\\n    if (cid !== undefined && cid !== null) {\\n      var index = this.unpin.indexOf(cid);\\n      if (index !== -1) {\\n        this.unpin.splice(index, 1);\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  IpfsController.prototype.isJSON = function(content) {\\n    if (content !== undefined && content !== null && typeof content === \\\"string\\\") {\\n      try {\\n        JSON.parse(content);\\n        return true;\\n      } catch (error) {\\n        // Ignore\\n      }\\n    }\\n    return false;\\n  };\\n\\n  IpfsController.prototype.load = function(loaded) {\\n    var importedTiddlers = null;\\n    if (this.isJSON(loaded)) {\\n      importedTiddlers = $tw.wiki.deserializeTiddlers(\\\".json\\\", loaded, $tw.wiki.getCreationFields());\\n    } else {\\n      importedTiddlers = $tw.wiki.deserializeTiddlers(\\\".tid\\\", loaded, $tw.wiki.getCreationFields());\\n    }\\n    return importedTiddlers;\\n  };\\n\\n  IpfsController.prototype.getLoader = function() {\\n    return this.loader;\\n  };\\n\\n  IpfsController.prototype.getNoBaseUrl = function(url) {\\n    return this.ipfsUri.getUrl(url);\\n  };\\n\\n  IpfsController.prototype.getUrl = function(url, base) {\\n    return this.ipfsUri.getUrl(url, base ? base : this.getIpfsBaseUrl());\\n  };\\n\\n  IpfsController.prototype.getIpfsBaseUrl = function() {\\n    return this.ipfsUri.getIpfsBaseUrl();\\n  };\\n\\n  IpfsController.prototype.normalizeIpfsUrl = async function(url) {\\n    return await this.ipfsUri.normalizeUrl(url, this.getIpfsBaseUrl());\\n  };\\n\\n  IpfsController.prototype.getDocumentUrl = function() {\\n    return this.ipfsUri.getDocumentUrl();\\n  };\\n\\n  IpfsController.prototype.getIpfsApiUrl = function() {\\n    return this.ipfsUri.getIpfsApiUrl();\\n  };\\n\\n  IpfsController.prototype.getIpfsGatewayUrl = function() {\\n    return this.ipfsUri.getIpfsGatewayUrl();\\n  };\\n\\n  IpfsController.prototype.decodeUrl = async function(value) {\\n    return await this.ipfsWrapper.decodeUrl(value);\\n  };\\n\\n  IpfsController.prototype.decodeCid = function(pathname) {\\n    return this.ipfsWrapper.decodeCid(pathname);\\n  };\\n\\n  IpfsController.prototype.getIpnsIdentifiers = function(ipfs, ipnsKey, ipnsName) {\\n    return this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n  };\\n\\n  IpfsController.prototype.loadTiddlers = async function(uri) {\\n    return await this.ipfsWrapper.loadTiddlers(uri);\\n  };\\n\\n  IpfsController.prototype.getIpfsClient = async function() {\\n    // Provider\\n    const ipfsProvider = $tw.utils.getIpfsProvider();\\n    // IPFS companion\\n    if (ipfsProvider === \\\"window\\\") {\\n      const client = await this.ipfsWrapper.getWindowIpfsClient();\\n      return {\\n        ipfs: client.ipfs,\\n        provider: client.provider\\n      };\\n    }\\n    // Default, try IPFS companion\\n    if (ipfsProvider === \\\"default\\\") {\\n      try {\\n        const client = await this.ipfsWrapper.getWindowIpfsClient();\\n        return {\\n          ipfs: client.ipfs,\\n          provider: client.provider\\n        };\\n      } catch (error) {\\n        // Ignore, fallback to HTTP\\n      }\\n    }\\n    // Current API URL\\n    const apiUrl = this.getIpfsApiUrl();\\n    // Check\\n    if (apiUrl == undefined || apiUrl == null || apiUrl.href === \\\"\\\") {\\n      throw new Error(\\\"Undefined IPFS API URL...\\\");\\n    }\\n    // HTTP Client\\n    const client = this.ipfsClients.get(apiUrl.href);\\n    if (client !== undefined && client !== null) {\\n      // Log\\n      this.getLogger().info(\\\"Reuse IPFS provider:\\\" + \\\"\\\\n \\\" + client.provider);\\n      // Done\\n      return {\\n        ipfs: client.ipfs,\\n        provider: client.provider\\n      };\\n    }\\n    // Build a new HTTP client\\n    const policy = await this.ipfsWrapper.getHttpIpfsClient(apiUrl);\\n    const ipfs = policy.ipfs;\\n    const provider = policy.provider;\\n    // Store\\n    this.ipfsClients.set(apiUrl.href, { ipfs, provider });\\n    // Log\\n    this.getLogger().info(\\\"New IPFS provider:\\\" + \\\"\\\\n \\\" + policy.provider);\\n    // Done\\n    return {\\n      ipfs: ipfs,\\n      provider: provider\\n    };\\n  };\\n\\n  IpfsController.prototype.getEthereumProvider = async function() {\\n    if (this.ethereum == null) {\\n      const self = this;\\n      this.ethereum = await this.ensWrapper.getProvider();\\n      // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md\\n      this.ethereum.on(\\\"chainChanged\\\", function networkChanged(chainId) {\\n        self.networkChanged(chainId);\\n      });\\n      this.ethereum.on(\\\"networkChanged\\\", function networkChanged(chainId) {\\n        self.networkChanged(chainId);\\n      });\\n      this.ethereum.on(\\\"accountsChanged\\\", function accountChanged(accounts) {\\n        self.accountChanged(accounts);\\n      });\\n      this.ethereum.on(\\\"close\\\", function closeProvider(code, reason) {\\n        self.closeProvider(code, reason);\\n      });\\n    }\\n    return this.ethereum;\\n  };\\n\\n  IpfsController.prototype.networkChanged = function(chainId) {\\n    if (this.chainId !== chainId) {\\n      const network = this.ensWrapper.getNetwork();\\n      try {\\n        this.web3 = null;\\n        this.chainId = chainId;\\n        this.account = null;\\n        this.getLogger().info(\\\"Current Ethereum network:\\\" + \\\"\\\\n \\\" + network[chainId]);\\n      } catch (error) {\\n        this.getLogger().error(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n    }\\n  };\\n\\n  IpfsController.prototype.accountChanged = async function(accounts) {\\n    if (accounts == undefined || accounts == null || Array.isArray(accounts) == false || accounts.length === 0) {\\n      this.web3 = null;\\n      this.chainId = null;\\n      this.account = null;\\n      this.getLogger().info(\\\"Closing Ethereum provider...\\\");\\n    } else if (this.account !== accounts[0]) {\\n      try {\\n        if (this.web3 == null && this.chainId == null) {\\n          const { web3, chainId } = await this.getWeb3Provider();\\n          this.web3 = web3;\\n          this.chainId = chainId;\\n        }\\n        this.account = accounts[0];\\n        const etherscan = this.ensWrapper.getEtherscanRegistry();\\n        this.getLogger().info(\\n          \\\"Current Ethereum account:\\\" + \\\"\\\\n \\\" + etherscan[this.chainId] + \\\"/address/\\\" + this.account\\n        );\\n      } catch (error) {\\n        this.getLogger().error(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n    }\\n  };\\n\\n  IpfsController.prototype.closeProvider = function(code, reason) {\\n    this.web3 = null;\\n    this.chainId = null;\\n    this.account = null;\\n    this.getLogger().info(\\\"Closing Ethereum provider:\\\" + \\\"\\\\n \\\" + \\\"Reason: \\\" + reason + \\\"\\\\n \\\" + \\\"Code: \\\" + code);\\n  };\\n\\n  IpfsController.prototype.getEnabledWeb3Provider = async function() {\\n    const provider = await this.getEthereumProvider();\\n    const network = this.ensWrapper.getNetwork();\\n    const etherscan = this.ensWrapper.getEtherscanRegistry();\\n    var info = \\\"Reuse Web3 provider:\\\";\\n    if (this.account == null) {\\n      const { web3, chainId, account } = await this.ensWrapper.getEnabledWeb3Provider(provider);\\n      this.web3 = web3;\\n      this.chainId = chainId;\\n      this.account = account;\\n      info = \\\"New Web3 provider:\\\";\\n    }\\n    // Log\\n    this.getLogger().info(\\n      info +\\n        \\\"\\\\n network: \\\" +\\n        network[this.chainId] +\\n        \\\"\\\\n account: \\\" +\\n        etherscan[this.chainId] +\\n        \\\"/address/\\\" +\\n        this.account\\n    );\\n    return {\\n      web3: this.web3,\\n      chainId: this.chainId,\\n      account: this.account\\n    };\\n  };\\n\\n  IpfsController.prototype.getWeb3Provider = async function() {\\n    const provider = await this.getEthereumProvider();\\n    const network = this.ensWrapper.getNetwork();\\n    var info = \\\"Reuse Web3 provider:\\\";\\n    if (this.web3 == null) {\\n      const { web3, chainId } = await this.ensWrapper.getWeb3Provider(provider);\\n      this.web3 = web3;\\n      this.chainId = chainId;\\n      info = \\\"New Web3 provider:\\\";\\n    }\\n    // Log\\n    this.getLogger().info(info + \\\"\\\\n network: \\\" + network[this.chainId]);\\n    return {\\n      web3: this.web3,\\n      chainId: this.chainId\\n    };\\n  };\\n\\n  IpfsController.prototype.resolveENS = async function(ensDomain) {\\n    // Retrieve a Web3 provider\\n    const { web3 } = await this.getWeb3Provider();\\n    // Fetch ENS domain content\\n    const { content, protocol } = await this.ensWrapper.getContenthash(ensDomain, web3);\\n    if (content !== null && protocol !== null) {\\n      const parsed = await $tw.ipfs.normalizeIpfsUrl(\\\"/\\\" + protocol + \\\"/\\\" + content);\\n      return parsed;\\n    }\\n    // Empty content\\n    return null;\\n  };\\n\\n  exports.IpfsController = IpfsController;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-default.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-default.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-default.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nutils\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const ipfsDefaultName = \\\"ipfs-default\\\";\\n\\n  /*\\n   * Retrieve ipfs saver export protocol with default value if applicable\\n   */\\n  exports.getIpfsExport = function() {\\n    var output = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/export\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        output = text.trim();\\n      }\\n    }\\n    if (output === null) {\\n      output = $tw.utils.getIpfsDefaultExport();\\n    }\\n    return output;\\n  };\\n\\n  /*\\n   * Default Export\\n   */\\n  exports.getIpfsDefaultExport = function() {\\n    return \\\"json\\\";\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver protocol with default value if applicable\\n   */\\n  exports.getIpfsProtocol = function() {\\n    var protocol = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/protocol\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        protocol = text.trim();\\n      }\\n    }\\n    if (protocol === null) {\\n      protocol = $tw.utils.getIpfsDefaultProtocol();\\n    }\\n    return protocol;\\n  };\\n\\n  /*\\n   * Default Protocol\\n   */\\n  exports.getIpfsDefaultProtocol = function() {\\n    return \\\"ipfs\\\";\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver api url with default value if applicable\\n   */\\n  exports.getIpfsSaverApiUrl = function() {\\n    var api = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/api\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        api = text.trim();\\n      }\\n    }\\n    if (api !== null) {\\n      tiddler = $tw.wiki.getTiddler(api);\\n      if (tiddler !== undefined && tiddler !== null) {\\n        const text = tiddler.getFieldString(\\\"text\\\");\\n        if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n          api = text.trim();\\n        }\\n      }\\n    }\\n    if (api === null) {\\n      api = $tw.utils.getIpfsDefaultApiUrl();\\n    }\\n    return api;\\n  };\\n\\n  /*\\n   * Default API URL\\n   */\\n  exports.getIpfsDefaultApiUrl = function() {\\n    return \\\"https://ipfs.infura.io:5001\\\";\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver gateway url with default value if applicable\\n   */\\n  exports.getIpfsSaverGatewayUrl = function() {\\n    var gateway = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/gateway\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        gateway = text.trim();\\n      }\\n    }\\n    if (gateway !== null) {\\n      tiddler = $tw.wiki.getTiddler(gateway);\\n      if ($tw.wiki.getTiddler(gateway) !== undefined) {\\n        const text = $tw.wiki.getTiddler(gateway).getFieldString(\\\"text\\\");\\n        if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n          gateway = text.trim();\\n        }\\n      }\\n    }\\n    if (gateway === null) {\\n      gateway = $tw.utils.getIpfsDefaultGatewayUrl();\\n    }\\n    return gateway;\\n  };\\n\\n  /*\\n   * Default Gateway URL\\n   */\\n  exports.getIpfsDefaultGatewayUrl = function() {\\n    return \\\"https://ipfs.infura.io\\\";\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver ens domain with default value if applicable\\n   */\\n  exports.getIpfsEnsDomain = function() {\\n    var ensDomain = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ens/domain\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        ensDomain = text.trim();\\n      }\\n    }\\n    return ensDomain;\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver ipns name with default value if applicable\\n   */\\n  exports.getIpfsIpnsName = function() {\\n    var ipnsName = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/name\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        ipnsName = text.trim();\\n      }\\n    }\\n    return ipnsName;\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver ipns key with default value if applicable\\n   */\\n  exports.getIpfsIpnsKey = function() {\\n    var ipnsKey = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        ipnsKey = text.trim();\\n      }\\n    }\\n    return ipnsKey;\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver verbose with default value if applicable\\n   */\\n  exports.getIpfsVerbose = function() {\\n    var verbose = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/verbose\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        verbose = text.trim();\\n      }\\n    }\\n    if (verbose === null) {\\n      verbose = true; // default, see ipfs-saver.tid\\n    } else {\\n      verbose = verbose === \\\"yes\\\";\\n    }\\n    return verbose;\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver unpin with default value if applicable\\n   */\\n  exports.getIpfsUnpin = function() {\\n    var unpin = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/unpin\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        unpin = text.trim();\\n      }\\n    }\\n    if (unpin === null) {\\n      unpin = false; // default, see ipfs-saver.tid\\n    } else {\\n      unpin = unpin === \\\"yes\\\";\\n    }\\n    return unpin;\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver url policy with default value if applicable\\n   */\\n  exports.getIpfsUrlPolicy = function() {\\n    var policy = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/policy\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        policy = text.trim();\\n      }\\n    }\\n    if (policy === null) {\\n      policy = $tw.utils.getIpfsDefaultPolicy();\\n    }\\n    return policy;\\n  };\\n\\n  /*\\n   * Default Policy\\n   */\\n  exports.getIpfsDefaultPolicy = function() {\\n    return \\\"gateway\\\";\\n  };\\n\\n  /*\\n   * Retrieve ipfs saver provider with default value if applicable\\n   */\\n  exports.getIpfsProvider = function() {\\n    var provider = null;\\n    var tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/provider\\\");\\n    if (tiddler !== undefined && tiddler !== null) {\\n      const text = tiddler.getFieldString(\\\"text\\\");\\n      if (text !== undefined && text !== null && text.trim() !== \\\"\\\") {\\n        provider = text.trim();\\n      }\\n    }\\n    if (provider === null) {\\n      provider = $tw.utils.getIpfsDefaultProvider();\\n    }\\n    return provider;\\n  };\\n\\n  /*\\n   * Default Provider\\n   */\\n  exports.getIpfsDefaultProvider = function() {\\n    return \\\"http\\\";\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/ipfs/macro/ipfs-info-saver.js\": {\n            \"title\": \"$:/plugins/ipfs/macro/ipfs-info-saver.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macro/ipfs-info-saver.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\n   * Information about this macro\\n   */\\n  exports.name = \\\"ipfs-info-saver\\\";\\n\\n  exports.params = [{ name: \\\"tiddler\\\" }];\\n\\n  /*\\n   * Run the macro\\n   */\\n  exports.run = function(tiddler) {\\n    return $tw.saverHandler.getSaver(tiddler).module.info.name;\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/modules/widgets/ipfs-link.js\": {\n            \"title\": \"$:/plugins/ipfs/modules/widgets/ipfs-link.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/modules/widgets/ipfs-link.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nIpfs Link widget\\n\\n\\\\*/\\n\\n/**\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  var Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n  const name = \\\"ipfs-link\\\";\\n\\n  var IpfsLinkWidget = function(parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options);\\n  };\\n\\n  /*\\n   * Inherit from the base widget class\\n   */\\n  IpfsLinkWidget.prototype = new Widget();\\n\\n  IpfsLinkWidget.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.render = function(parent, nextSibling) {\\n    // self\\n    const self = this;\\n    // Save the parent dom node\\n    this.parentDomNode = parent;\\n    // Compute our attributes\\n    this.computeAttributes();\\n    // Execute our logic\\n    this.execute();\\n    // Tiddler link\\n    const tiddler = $tw.wiki.getTiddler(this.value);\\n    if (tiddler !== undefined && tiddler !== null) {\\n      this.renderTiddlerLink(parent, nextSibling);\\n    } else {\\n      var text = false;\\n      try {\\n        $tw.ipfs.getNoBaseUrl(this.value);\\n      } catch (error) {\\n        if (this.value.startsWith(\\\"/\\\") === false) {\\n          text = true;\\n        }\\n      }\\n      // Text\\n      if (text) {\\n        this.renderText(parent, nextSibling);\\n        // External URL\\n      } else {\\n        this.renderText(parent, nextSibling);\\n        $tw.ipfs\\n          .normalizeIpfsUrl(this.value)\\n          .then(normalized_uri => {\\n            self.removeChildDomNodes();\\n            self.renderExternalLink(parent, nextSibling, normalized_uri.href);\\n          })\\n          .catch(error => {\\n            self.getLogger().error(error);\\n            $tw.utils.alert(name, error.message);\\n          });\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.renderExternalLink = function(parent, nextSibling, uri) {\\n    // Link\\n    const domNode = this.document.createElement(\\\"a\\\");\\n    domNode.setAttribute(\\\"href\\\", uri);\\n    // Add a click event handler\\n    $tw.utils.addEventListeners(domNode, [\\n      { name: \\\"click\\\", handlerObject: this, handlerMethod: \\\"handleExternalClickEvent\\\" }\\n    ]);\\n    // Assign classes\\n    const classes = [];\\n    if (this.classes) {\\n      classes.push(this.classes);\\n    }\\n    if (classes.length > 0) {\\n      domNode.setAttribute(\\\"class\\\", classes.join(\\\" \\\"));\\n    }\\n    if (this[\\\"aria-label\\\"]) {\\n      domNode.setAttribute(\\\"aria-label\\\", this[\\\"aria-label\\\"]);\\n    }\\n    // Insert the URL into the DOM and render any children\\n    parent.insertBefore(domNode, nextSibling);\\n    // Process\\n    this.renderChildren(domNode, null);\\n    this.domNodes.push(domNode);\\n  };\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.renderTiddlerLink = function(parent, nextSibling) {\\n    // self\\n    var self = this;\\n    // Sanitise the specified tag\\n    var tag = this.linkTag;\\n    if ($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {\\n      tag = \\\"a\\\";\\n    }\\n    // Create our element\\n    var domNode = this.document.createElement(tag);\\n    // Assign classes\\n    var classes = [];\\n    if (this.overrideClasses === undefined) {\\n      classes.push(\\\"tc-tiddlylink\\\");\\n      if (this.isShadow) {\\n        classes.push(\\\"tc-tiddlylink-shadow\\\");\\n      }\\n      if (this.isMissing && !this.isShadow) {\\n        classes.push(\\\"tc-tiddlylink-missing\\\");\\n      } else {\\n        if (!this.isMissing) {\\n          classes.push(\\\"tc-tiddlylink-resolves\\\");\\n        }\\n      }\\n      if (this.linkClasses) {\\n        classes.push(this.linkClasses);\\n      }\\n    } else if (this.overrideClasses !== \\\"\\\") {\\n      classes.push(this.overrideClasses);\\n    }\\n    if (classes.length > 0) {\\n      domNode.setAttribute(\\\"class\\\", classes.join(\\\" \\\"));\\n    }\\n    // Set an href\\n    var wikilinkTransformFilter = this.getVariable(\\\"tv-filter-export-link\\\"),\\n      wikiLinkText;\\n    if (wikilinkTransformFilter) {\\n      // Use the filter to construct the href\\n      wikiLinkText = this.wiki.filterTiddlers(wikilinkTransformFilter, this, function(iterator) {\\n        iterator(self.wiki.getTiddler(self.value), self.value);\\n      })[0];\\n    } else {\\n      // Expand the tv-wikilink-template variable to construct the href\\n      var wikiLinkTemplateMacro = this.getVariable(\\\"tv-wikilink-template\\\"),\\n        wikiLinkTemplate = wikiLinkTemplateMacro ? wikiLinkTemplateMacro.trim() : \\\"#$uri_encoded$\\\";\\n      wikiLinkText = $tw.utils.replaceString(wikiLinkTemplate, \\\"$uri_encoded$\\\", encodeURIComponent(this.value));\\n      wikiLinkText = $tw.utils.replaceString(\\n        wikiLinkText,\\n        \\\"$uri_doubleencoded$\\\",\\n        encodeURIComponent(encodeURIComponent(this.value))\\n      );\\n    }\\n    // Override with the value of tv-get-export-link if defined\\n    wikiLinkText = this.getVariable(\\\"tv-get-export-link\\\", {\\n      params: [{ name: \\\"to\\\", value: this.value }],\\n      defaultValue: wikiLinkText\\n    });\\n    if (tag === \\\"a\\\") {\\n      domNode.setAttribute(\\\"href\\\", wikiLinkText);\\n    }\\n    // Set the tabindex\\n    if (this.tabIndex) {\\n      domNode.setAttribute(\\\"tabindex\\\", this.tabIndex);\\n    }\\n    // Set the tooltip\\n    // HACK: Performance issues with re-parsing the tooltip prevent us defaulting the tooltip to \\\"<$transclude field='tooltip'><$transclude field='title'/></$transclude>\\\"\\n    var tooltipWikiText = this.tooltip || this.getVariable(\\\"tv-wikilink-tooltip\\\");\\n    if (tooltipWikiText) {\\n      var tooltipText = this.wiki.renderText(\\\"text/plain\\\", \\\"text/vnd.tiddlywiki\\\", tooltipWikiText, {\\n        parseAsInline: true,\\n        variables: {\\n          currentTiddler: this.value\\n        },\\n        parentWidget: this\\n      });\\n      domNode.setAttribute(\\\"title\\\", tooltipText);\\n    }\\n    if (this[\\\"aria-label\\\"]) {\\n      domNode.setAttribute(\\\"aria-label\\\", this[\\\"aria-label\\\"]);\\n    }\\n    // Add a click event handler\\n    $tw.utils.addEventListeners(domNode, [\\n      { name: \\\"click\\\", handlerObject: this, handlerMethod: \\\"handleTiddlerClickEvent\\\" }\\n    ]);\\n    // Make the link draggable if required\\n    if (this.draggable === \\\"yes\\\") {\\n      $tw.utils.makeDraggable({\\n        domNode: domNode,\\n        dragTiddlerFn: function() {\\n          return self.value;\\n        },\\n        widget: this\\n      });\\n    }\\n    // Insert the link into the DOM and render any children\\n    parent.insertBefore(domNode, nextSibling);\\n    // Process\\n    this.renderChildren(domNode, null);\\n    this.domNodes.push(domNode);\\n  };\\n\\n  /*\\n   * Render this widget into the DOM\\n   */\\n  IpfsLinkWidget.prototype.renderText = function(parent, nextSibling) {\\n    const domNode = this.document.createElement(\\\"span\\\");\\n    // Insert the text into the DOM and render any children\\n    parent.insertBefore(domNode, nextSibling);\\n    // Process\\n    this.renderChildren(domNode, null);\\n    this.domNodes.push(domNode);\\n  };\\n\\n  IpfsLinkWidget.prototype.handleExternalClickEvent = function(event) {\\n    // self\\n    const self = this;\\n    // Normalize\\n    $tw.ipfs\\n      .normalizeIpfsUrl(this.value)\\n      .then(normalized_uri => {\\n        // Process\\n        window.open(normalized_uri.href, self.target, self.rel);\\n      })\\n      .catch(error => {\\n        // Log\\n        self.getLogger().error(error);\\n        $tw.utils.alert(name, error.message);\\n        // Fallback\\n        window.open(this.value, self.target, self.rel);\\n      });\\n    event.preventDefault();\\n    event.stopPropagation();\\n    return false;\\n  };\\n\\n  IpfsLinkWidget.prototype.handleTiddlerClickEvent = function(event) {\\n    // Send the click on its way as a navigate event\\n    var bounds = this.domNodes[0].getBoundingClientRect();\\n    this.dispatchEvent({\\n      type: \\\"tm-navigate\\\",\\n      navigateTo: this.value,\\n      navigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n      navigateFromNode: this,\\n      navigateFromClientRect: {\\n        top: bounds.top,\\n        left: bounds.left,\\n        width: bounds.width,\\n        right: bounds.right,\\n        bottom: bounds.bottom,\\n        height: bounds.height\\n      },\\n      navigateSuppressNavigation: event.metaKey || event.ctrlKey || event.button === 1,\\n      metaKey: event.metaKey,\\n      ctrlKey: event.ctrlKey,\\n      altKey: event.altKey,\\n      shiftKey: event.shiftKey\\n    });\\n    if (this.domNodes[0].hasAttribute(\\\"href\\\")) {\\n      event.preventDefault();\\n    }\\n    event.stopPropagation();\\n    return false;\\n  };\\n\\n  /*\\n   * Compute the internal state of the widget\\n   */\\n  IpfsLinkWidget.prototype.execute = function() {\\n    // Tiddler\\n    this.tiddler = this.getAttribute(\\\"tiddler\\\");\\n    // Internal link\\n    this.tooltip = this.getAttribute(\\\"tooltip\\\");\\n    this.overrideClasses = this.getAttribute(\\\"overrideClass\\\");\\n    this.tabIndex = this.getAttribute(\\\"tabindex\\\");\\n    this.draggable = this.getAttribute(\\\"draggable\\\", \\\"yes\\\");\\n    // Determine the link characteristics\\n    this.isMissing = !this.wiki.tiddlerExists(this.to);\\n    this.isShadow = this.wiki.isShadowTiddler(this.to);\\n    this.hideMissingLinks = (this.getVariable(\\\"tv-show-missing-links\\\") || \\\"yes\\\") === \\\"no\\\";\\n    // External link\\n    this.caption = this.getAttribute(\\\"caption\\\");\\n    this.value = this.getAttribute(\\\"value\\\");\\n    this.field = this.getAttribute(\\\"field\\\");\\n    this.linkTag = this.getAttribute(\\\"tag\\\", \\\"a\\\");\\n    const tiddler = $tw.wiki.getTiddler(this.tiddler);\\n    if (this.value == undefined) {\\n      this.value = tiddler.getFieldString(this.field);\\n    }\\n    this.target = this.getAttribute(\\\"target\\\") || \\\"_blank\\\";\\n    this.rel = this.getAttribute(\\\"rel\\\") || \\\"noopener\\\";\\n    this[\\\"aria-label\\\"] = this.getAttribute(\\\"aria-label\\\");\\n    this.classes = this.getAttribute(\\\"class\\\") || \\\"tc-ipfs-link-external\\\";\\n    this.makeChildWidgets([{ type: \\\"text\\\", text: this.caption }]);\\n  };\\n\\n  /*\\n   * Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n   */\\n  IpfsLinkWidget.prototype.refresh = function(changedTiddlers) {\\n    const changedAttributes = this.computeAttributes();\\n    const tiddler = $tw.wiki.getTiddler(this.tiddler);\\n    var value = null;\\n    if (this.field !== undefined && this.field !== null) {\\n      value = tiddler.getFieldString(this.field);\\n    }\\n    if (\\n      changedAttributes.caption ||\\n      changedTiddlers[this.caption] ||\\n      changedAttributes.field ||\\n      changedTiddlers[this.field] ||\\n      changedAttributes.value ||\\n      changedTiddlers[this.value] ||\\n      changedAttributes.to ||\\n      changedTiddlers[this.to] ||\\n      changedAttributes.tooltip ||\\n      changedAttributes[\\\"aria-label\\\"] ||\\n      changedTiddlers[\\\"$:/ipfs/saver/gateway\\\"] ||\\n      changedTiddlers[\\\"$:/ipfs/saver/policy\\\"] ||\\n      (value !== null && value !== this.value)\\n    ) {\\n      this.refreshSelf();\\n      return true;\\n    }\\n    return this.refreshChildren(changedTiddlers);\\n  };\\n\\n  exports.ipfslink = IpfsLinkWidget;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/ipfs/ipfs-loader.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-loader.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-loader.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIpfsLoader\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const name = \\\"ipfs-loader\\\";\\n\\n  const eruda = \\\"https://cdn.jsdelivr.net/npm/eruda@2.2.2/eruda.min.js\\\";\\n  const eruda_sri = \\\"sha384-DpZY+q2987LFJTTg+f8oByjMwhVQSkHZCc9r0TEXBS23Ld5LrsULQFXMU+f04K4H\\\";\\n\\n  const ethers = \\\"https://cdn.jsdelivr.net/npm/ethers@4.0.46/dist/ethers.min.js\\\";\\n  const ethers_sri = \\\"sha384-bjw8iFWKeuQECzXYvYmPXhtav8lsYy9YyJ+yhvwohfvs2mUXzTPktLSi5YsMgczG\\\";\\n\\n  const ipfs_http_client = \\\"https://cdn.jsdelivr.net/npm/ipfs-http-client@44.0.0/dist/index.min.js\\\";\\n  const ipfs_http_client_sri = \\\"sha384-ris+q6J23d31ehRco1HyHYfwUJz4S10N8218wcuw8IZLoM+Q1/TOYVVeDskhoSgM\\\";\\n\\n  var IpfsLoader = function() {};\\n\\n  IpfsLoader.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  // https://www.srihash.org/\\n  // https://github.com/liriliri/eruda\\n  IpfsLoader.prototype.loadErudaLibrary = async function() {\\n    if (typeof window.eruda === \\\"undefined\\\") {\\n      await this.loadLibrary(\\\"ErudaLibrary\\\", eruda, eruda_sri, true);\\n      if (typeof window.eruda !== \\\"undefined\\\") {\\n        this.getLogger(name).info(\\\"Loaded ErudaLibrary:\\\" + \\\"\\\\n \\\" + eruda);\\n      }\\n    }\\n  };\\n\\n  // https://www.srihash.org/\\n  // https://github.com/ethers-io/ethers.js/\\n  IpfsLoader.prototype.loadEtherJsLibrary = async function() {\\n    if (typeof window.ethers === \\\"undefined\\\") {\\n      await this.loadLibrary(\\\"EtherJsLibrary\\\", ethers, ethers_sri, true);\\n      if (typeof window.ethers !== \\\"undefined\\\") {\\n        this.getLogger(name).info(\\\"Loaded EtherJsLibrary:\\\" + \\\"\\\\n \\\" + ethers);\\n      }\\n    }\\n  };\\n\\n  // https://www.srihash.org/\\n  // https://github.com/ipfs/js-ipfs-http-client\\n  IpfsLoader.prototype.loadIpfsHttpLibrary = async function() {\\n    if (typeof window.httpClient === \\\"undefined\\\" || typeof window.IpfsHttpClient === \\\"undefined\\\") {\\n      await this.loadLibrary(\\\"IpfsHttpLibrary\\\", ipfs_http_client, ipfs_http_client_sri, true);\\n      if (typeof window.IpfsHttpClient !== \\\"undefined\\\") {\\n        window.httpClient = window.IpfsHttpClient;\\n        this.getLogger(name).info(\\\"Loaded IpfsHttpLibrary:\\\" + \\\"\\\\n \\\" + ipfs_http_client);\\n      }\\n    }\\n  };\\n\\n  // https://observablehq.com/@bryangingechen/dynamic-import-polyfill\\n  IpfsLoader.prototype.loadLibrary = async function(id, url, sri, asModule) {\\n    // if dynamic import is supported\\n    try {\\n      return new Function(`return import(\\\"${url}\\\")`)();\\n    } catch (err) {\\n      // Ignore\\n    }\\n    // self\\n    const self = this;\\n    // promise\\n    return new Promise((resolve, reject) => {\\n      try {\\n        // Loaded\\n        if (window.document.getElementById(id) !== null) {\\n          return resolve(window[id]);\\n        }\\n        // Process\\n        const script = window.document.createElement(\\\"script\\\");\\n        // Functions\\n        const cleanup = () => {\\n          delete window[id];\\n          script.onerror = null;\\n          script.onload = null;\\n          script.remove();\\n          URL.revokeObjectURL(script.src);\\n          script.src = \\\"\\\";\\n        };\\n        script.onload = () => {\\n          if (asModule) {\\n            self.getLogger(name).info(\\\"Loaded Module:\\\" + \\\"\\\\n \\\" + url);\\n          } else {\\n            self.getLogger(name).info(\\\"Loaded Script:\\\" + \\\"\\\\n \\\" + url);\\n          }\\n          resolve(window[id]);\\n          cleanup();\\n        };\\n        script.onerror = () => {\\n          reject(new Error(\\\"Failed to load: \\\" + url));\\n          cleanup();\\n        };\\n        // Attributes\\n        if (asModule) {\\n          script.type = \\\"module\\\";\\n        } else {\\n          script.type = \\\"text/javascript\\\";\\n        }\\n        script.id = id;\\n        script.async = false;\\n        script.defer = \\\"defer\\\";\\n        if (sri) {\\n          script.integrity = sri;\\n        }\\n        script.crossOrigin = \\\"anonymous\\\";\\n        // URL\\n        script.src = url.toString();\\n        // Load\\n        window.document.head.appendChild(script);\\n      } catch (error) {\\n        reject(error);\\n      }\\n    });\\n  };\\n\\n  exports.IpfsLoader = IpfsLoader;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-parser.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-parser.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-parser.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nThe saver handler tracks changes to the store and handles saving the entire wiki via saver modules.\\n\\nutils\\n\\n\\\\*/\\n\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst ipfsParserName = \\\"ipfs-parser\\\";\\n\\nexports.httpGetToUint8Array = async function(url) {\\n  return new Promise(function(resolve, reject) {\\n    const xhr = new XMLHttpRequest();\\n    xhr.responseType = \\\"arraybuffer\\\";\\n    xhr.onreadystatechange = function() {\\n      if (xhr.readyState == 4 && xhr.status !== 0) {\\n        if (xhr.status >= 300) {\\n          reject(new Error($tw.language.getString(\\\"NetworkError/XMLHttpRequest\\\")));\\n          return;\\n        }\\n        try {\\n          const array = new Uint8Array(this.response);\\n          const logger = window.log.getLogger(ipfsParserName);\\n          logger.info(\\n            \\\"[\\\"\\n            + xhr.status\\n            + \\\"] Loaded:\\\"\\n            + \\\"\\\\n \\\"\\n            + url\\n          );\\n          resolve(array);\\n        } catch (error) {\\n          reject(error);\\n        }\\n      }\\n    };\\n    xhr.onerror = function() {\\n      reject(new Error($tw.language.getString(\\\"NetworkError/XMLHttpRequest\\\")));\\n    };\\n    try {\\n      xhr.open(\\\"get\\\", url.toString(), true);\\n      xhr.send();\\n    } catch (error) {\\n      reject(error);\\n    }\\n  });\\n};\\n\\n/*\\n * Load to Base64\\n */\\nexports.loadToBase64 = function(url) {\\n  return new Promise( async (resolve, reject) => {\\n    $tw.utils.httpGetToUint8Array(url)\\n    .then( (array) => {\\n      // Empty\\n      if (array.length == 0) {\\n        resolve({\\n          data: \\\"\\\",\\n          decrypted : false\\n        });\\n      }\\n      // Decrypt\\n      if ($tw.utils.isUtf8ArrayEncrypted(array)) {\\n        $tw.utils.decryptUint8ArrayToBase64(array)\\n        .then( (base64) => {\\n          resolve({\\n            data: base64,\\n            decrypted : true\\n          });\\n        })\\n        .catch( (error) => {\\n          reject(error);\\n        });\\n      } else {\\n        resolve({\\n          data: $tw.utils.Uint8ArrayToBase64(array),\\n          decrypted : false\\n        });\\n      }\\n    })\\n    .catch( (error) => {\\n      reject(error);\\n    });\\n  });\\n};\\n\\n/*\\n * Load to UTF-8\\n */\\nexports.loadToUtf8 = function(url) {\\n  return new Promise( async (resolve, reject) => {\\n    $tw.utils.httpGetToUint8Array(url)\\n    .then( (array) => {\\n      // Empty\\n      if (array.length == 0) {\\n        resolve({\\n          data: \\\"\\\",\\n          decrypted : false\\n        });\\n      }\\n      // Decrypt\\n      if ($tw.utils.isUtf8ArrayEncrypted(array)) {\\n        $tw.utils.decryptUint8ArrayToUtf8(array)\\n        .then( (data) => {\\n          resolve({\\n            data: data,\\n            decrypted: true\\n          });\\n        })\\n        .catch( (error) => {\\n          reject(error);\\n        });\\n      } else {\\n        resolve({\\n          data: $tw.utils.Utf8ArrayToStr(array),\\n          decrypted : false\\n        });\\n      }\\n    })\\n    .catch( (error) => {\\n      reject(error);\\n    });\\n  });\\n};\\n\\n/*\\n * Decrypt Uint8 Array to Base64 String\\n */\\nexports.decryptUint8ArrayToBase64 = async function(array) {\\n  return new Promise( async (resolve, reject) => {\\n    try {\\n      var content = $tw.utils.Utf8ArrayToStr(array);\\n      if ($tw.crypto.hasPassword() == false) {\\n        content = await $tw.utils.decryptFromPasswordPrompt(content);\\n      } else {\\n        content = $tw.crypto.decrypt(content, $tw.crypto.currentPassword);\\n      }\\n      const base64 = btoa(content);\\n      resolve(base64);\\n    } catch (error) {\\n      reject(error);\\n    }\\n  });\\n};\\n\\n/*\\n * Decrypt Uint8 Array to UTF-8 String\\n */\\nexports.decryptUint8ArrayToUtf8 = async function(array) {\\n  return new Promise( async (resolve, reject) => {\\n    try {\\n      var content = $tw.utils.Utf8ArrayToStr(array);\\n      if ($tw.crypto.hasPassword() == false) {\\n        content = await $tw.utils.decryptFromPasswordPrompt(content);\\n      } else {\\n        content = $tw.crypto.decrypt(content, $tw.crypto.currentPassword);\\n      }\\n      resolve(content);\\n    } catch (error) {\\n      reject(error);\\n    }\\n  });\\n};\\n\\nexports.decryptFromPasswordPrompt = async function(encrypted) {\\n  return new Promise( (resolve, reject) => {\\n    $tw.passwordPrompt.createPrompt({\\n      serviceName: \\\"Enter a password to decrypt the imported content!!\\\",\\n      noUserName: true,\\n      canCancel: true,\\n      submitText: \\\"Decrypt\\\",\\n      callback: function(data) {\\n        if (!data) {\\n          reject(new Error(\\\"User canceled password input...\\\"));\\n          return false;\\n        }\\n        // Decrypt\\n        try {\\n          const content = $tw.crypto.decrypt(encrypted, data.password);\\n          resolve(content);\\n          return true;\\n        } catch (error) {\\n          reject(error);\\n          return false;\\n        }\\n      }\\n    });\\n  });\\n}\\n\\nexports.isUtf8ArrayEncrypted = function(content) {\\n  // Check\\n  if (content instanceof Uint8Array == false || content.length == 0) {\\n    return false;\\n  }\\n  // Process\\n  const standford = $tw.utils.StringToUint8Array(\\\"{\\\\\\\"iv\\\\\\\":\\\\\\\"\\\");\\n  var encrypted = false;\\n  for (var i = 0; i < content.length && i < standford.length; i++) {\\n    if (content[i] == standford[i]) {\\n      encrypted = true;\\n    } else {\\n      encrypted = false;\\n      break;\\n    }\\n  }\\n  return encrypted;\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/ipfs/ipfs-saver.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-saver.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-saver.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: saver\\n\\nIpfsSaver\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const log = require(\\\"$:/plugins/ipfs/loglevel/loglevel.js\\\");\\n\\n  const IpfsController = require(\\\"$:/plugins/ipfs/ipfs-controller.js\\\").IpfsController;\\n  const EnsWrapper = require(\\\"$:/plugins/ipfs/ens-wrapper.js\\\").EnsWrapper;\\n  const IpfsWrapper = require(\\\"$:/plugins/ipfs/ipfs-wrapper.js\\\").IpfsWrapper;\\n\\n  const fileProtocol = \\\"file:\\\";\\n  const ensKeyword = \\\"ens\\\";\\n  const ipfsKeyword = \\\"ipfs\\\";\\n  const ipnsKeyword = \\\"ipns\\\";\\n\\n  const name = \\\"ipfs-saver\\\";\\n\\n  /*\\n   * Select the appropriate saver module and set it up\\n   */\\n  var IpfsSaver = function(wiki) {\\n    this.wiki = wiki;\\n    this.apiUrl = null;\\n    this.ipfsProvider = null;\\n    // Loglevel\\n    if (window.log == undefined || window.log == null) {\\n      // Init\\n      window.log = log;\\n      if ($tw.utils.getIpfsVerbose()) {\\n        log.setLevel(\\\"info\\\", false);\\n      } else {\\n        log.setLevel(\\\"warn\\\", false);\\n      }\\n    }\\n    // Controller\\n    $tw.ipfs = new IpfsController();\\n    // Wrapper\\n    this.ensWrapper = new EnsWrapper();\\n    this.ipfsWrapper = new IpfsWrapper();\\n    // Logger\\n    const logger = window.log.getLogger(name);\\n    // Log\\n    logger.info(\\\"ipfs-saver is starting up...\\\");\\n    // Log url policy\\n    const base = $tw.ipfs.getIpfsBaseUrl();\\n    if ($tw.utils.getIpfsUrlPolicy() === \\\"origin\\\") {\\n      logger.info(\\\"Origin base URL:\\\" + \\\"\\\\n \\\" + base.toString());\\n    } else {\\n      logger.info(\\\"Gateway base URL:\\\" + \\\"\\\\n \\\" + base.toString());\\n    }\\n  };\\n\\n  IpfsSaver.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  IpfsSaver.prototype.save = async function(text, method, callback, options) {\\n    // Is there anything to do\\n    if ($tw.saverHandler.isDirty() == false) {\\n      return false;\\n    }\\n\\n    try {\\n      // Init\\n      var ipfsProtocol = null;\\n      var ipnsKey = null;\\n      var ipnsName = null;\\n      var ipnsContent = null;\\n      var cid = null;\\n      var ensDomain = null;\\n      var ensContent = null;\\n      var web3 = null;\\n      var account = null;\\n      var options = options || {};\\n\\n      // Process document URL\\n      const wiki = $tw.ipfs.getDocumentUrl();\\n\\n      // Retrieve base URL\\n      const base = $tw.ipfs.getIpfsBaseUrl();\\n\\n      // Next\\n      const nextWiki = $tw.ipfs.getUrl(wiki);\\n      nextWiki.protocol = base.protocol;\\n      nextWiki.hostname = base.hostname;\\n      nextWiki.port = base.port;\\n\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // URL Analysis\\n      if (wiki.protocol !== fileProtocol) {\\n        // Decode pathname\\n        var { protocol, cid } = this.ipfsWrapper.decodeCid(wiki.pathname);\\n        // Check\\n        if (protocol != null && cid != null) {\\n          // Store current protocol\\n          ipfsProtocol = protocol;\\n          // Request to unpin\\n          if ($tw.utils.getIpfsUnpin() && ipfsProtocol === ipfsKeyword) {\\n            $tw.ipfs.requestToUnpin(cid);\\n          }\\n        }\\n      }\\n\\n      // IPNS Analysis\\n      if (ipfsProtocol === ipnsKeyword || $tw.utils.getIpfsProtocol() === ipnsKeyword) {\\n        // Resolve current IPNS\\n        if (ipfsProtocol === ipnsKeyword) {\\n          this.getLogger().info(\\\"Processing current IPNS key...\\\");\\n          try {\\n            var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, cid);\\n            ipnsContent = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n          } catch (error) {\\n            // Log and continue\\n            if (ipnsName == null || ipnsKey == null) {\\n              this.getLogger().error(error);\\n            } else {\\n              this.getLogger().warn(error);\\n            }\\n            $tw.utils.alert(name, error.message);\\n            // Fallback to default\\n            if (ipnsName === null && ipnsKey === null && $tw.utils.getIpfsProtocol() === ipnsKeyword) {\\n              ipnsName = $tw.utils.getIpfsIpnsName();\\n              ipnsKey = $tw.utils.getIpfsIpnsKey();\\n              this.getLogger().info(\\\"Processing default IPNS...\\\");\\n              var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n              try {\\n                ipnsContent = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n              } catch (error) {\\n                // Log and continue\\n                this.getLogger().warn(error);\\n                $tw.utils.alert(name, error.message);\\n              }\\n            }\\n          }\\n          // Resolve default IPNS\\n        } else {\\n          ipnsName = $tw.utils.getIpfsIpnsName();\\n          ipnsKey = $tw.utils.getIpfsIpnsKey();\\n          this.getLogger().info(\\\"Processing default IPNS name and IPNS key...\\\");\\n          var { ipnsKey, ipnsName } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, ipnsKey, ipnsName);\\n          try {\\n            ipnsContent = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n          } catch (error) {\\n            // Log and continue\\n            this.getLogger().warn(error);\\n            $tw.utils.alert(name, error.message);\\n          }\\n        }\\n\\n        // Request to unpin\\n        if ($tw.utils.getIpfsUnpin() && ipnsContent !== null) {\\n          $tw.ipfs.requestToUnpin(ipnsContent);\\n        }\\n      }\\n\\n      // ENS Analysis\\n      if ($tw.utils.getIpfsProtocol() === ensKeyword) {\\n        // Getting default ens domain\\n        ensDomain = $tw.utils.getIpfsEnsDomain();\\n        // Check\\n        if (ensDomain == null) {\\n          callback(\\\"Undefined ENS domain...\\\");\\n          return false;\\n        }\\n        // Retrieve an enabled Web3 provider\\n        var { web3, account } = await $tw.ipfs.getEnabledWeb3Provider();\\n        // Fetch ENS domain content\\n        const { content } = await this.ensWrapper.getContenthash(ensDomain, web3);\\n        // Request to unpin\\n        if ($tw.utils.getIpfsUnpin() && content !== null) {\\n          $tw.ipfs.requestToUnpin(content);\\n        }\\n      }\\n\\n      // Upload  current document\\n      this.getLogger().info(\\\"Uploading wiki: \\\" + text.length + \\\" bytes\\\");\\n\\n      // Add\\n      const { added } = await this.ipfsWrapper.addToIpfs(ipfs, text);\\n\\n      // Default next\\n      nextWiki.pathname = \\\"/\\\" + ipfsKeyword + \\\"/\\\" + added;\\n\\n      // Pin, if failure log and continue\\n      try {\\n        await this.ipfsWrapper.pinToIpfs(ipfs, added);\\n      } catch (error) {\\n        this.getLogger().warn(error);\\n        $tw.utils.alert(name, error.message);\\n      }\\n\\n      // Publish to IPNS\\n      if (ipnsName !== null && (ipfsProtocol === ipnsKeyword || $tw.utils.getIpfsProtocol() === ipnsKeyword)) {\\n        this.getLogger().info(\\\"Publishing IPNS name: \\\" + ipnsName);\\n        try {\\n          await this.ipfsWrapper.publishToIpns(ipfs, ipnsKey, ipnsName, added);\\n          // IPNS next\\n          nextWiki.pathname = \\\"/\\\" + ipnsKeyword + \\\"/\\\" + ipnsKey;\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().warn(error);\\n          $tw.utils.alert(name, error.message);\\n          // Discard unpin request\\n          if (ipfsProtocol === ipnsKeyword && $tw.utils.getIpfsUnpin() && ipnsContent !== null) {\\n            $tw.ipfs.discardRequestToUnpin(ipnsContent);\\n          }\\n        }\\n      }\\n\\n      // Publish to ENS\\n      if ($tw.utils.getIpfsProtocol() === ensKeyword) {\\n        const parsed = await $tw.ipfs.normalizeIpfsUrl(\\\"/\\\" + ipfsKeyword + \\\"/\\\" + added);\\n        this.getLogger().info(\\\"Publishing wiki:\\\" + \\\"\\\\n \\\" + parsed.href + \\\"\\\\n to ENS domain: \\\" + ensDomain);\\n        try {\\n          await this.ensWrapper.setContenthash(ensDomain, added, web3, account);\\n          // ENS next\\n          nextWiki.protocol = \\\"https:\\\";\\n          nextWiki.host = ensDomain;\\n        } catch (error) {\\n          // Log and continue\\n          this.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n          // Discard unpin request\\n          if (ipfsProtocol === ipnsKeyword && $tw.utils.getIpfsUnpin() && ensContent !== null) {\\n            $tw.ipfs.discardRequestToUnpin(ensContent);\\n          }\\n        }\\n      }\\n\\n      // Unpin\\n      if ($tw.utils.getIpfsUnpin()) {\\n        for (var i = 0; i < $tw.ipfs.unpin.length; i++) {\\n          try {\\n            const unpin = $tw.ipfs.unpin[i];\\n            await this.ipfsWrapper.unpinFromIpfs(ipfs, unpin);\\n            // Remove unpin request\\n            $tw.ipfs.removeFromUnpin(unpin);\\n          } catch (error) {\\n            // Log and continue\\n            this.getLogger().warn(error);\\n            $tw.utils.alert(name, error.message);\\n          }\\n        }\\n      }\\n\\n      // Done\\n      callback(null);\\n\\n      // Next\\n      if (nextWiki.toString() !== wiki.toString()) {\\n        window.location.assign(nextWiki.toString());\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      callback(error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  /*\\n   * Information about this saver\\n   */\\n  IpfsSaver.prototype.info = {\\n    name: \\\"Ipfs\\\",\\n    priority: 3100,\\n    capabilities: [\\\"save\\\"]\\n  };\\n\\n  /*\\n   * Static method that returns true if this saver is capable of working\\n   */\\n  exports.canSave = function(wiki) {\\n    return true;\\n  };\\n\\n  /*\\n   * Create an instance of this saver\\n   */\\n  exports.create = function(wiki) {\\n    return new IpfsSaver(wiki);\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"saver\"\n        },\n        \"$:/plugins/ipfs/operator/ipfs-savers.js\": {\n            \"title\": \"$:/plugins/ipfs/operator/ipfs-savers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/operator/ipfs-savers.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nThis Filter operator return savers title\\n\\n\\\\*/\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\n  Export our filter function\\n  */\\n  exports.savers = function(source, operator, options) {\\n    var results = [];\\n    for (var i in $tw.saverHandler.savers) {\\n      results.push($tw.saverHandler.savers[i].title);\\n    }\\n    return results;\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"filteroperator\"\n        },\n        \"$:/plugins/ipfs/ipfs-startup.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-startup.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-startup.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: startup\\n\\nStartup initialisation\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const EnsAction = require(\\\"$:/plugins/ipfs/ens-action.js\\\").EnsAction;\\n  const IpfsAction = require(\\\"$:/plugins/ipfs/ipfs-action.js\\\").IpfsAction;\\n  const IpfsTiddler = require(\\\"$:/plugins/ipfs/ipfs-tiddler.js\\\").IpfsTiddler;\\n\\n  exports.platforms = [\\\"browser\\\"];\\n  exports.after = [\\\"startup\\\"];\\n  exports.synchronous = true;\\n\\n  exports.startup = function() {\\n    // Logger name\\n    const name = \\\"ipfs-startup\\\";\\n\\n    // Missing Media Types\\n    $tw.utils.registerFileType(\\\"audio/mpeg\\\", \\\"base64\\\", \\\".mp2\\\");\\n    $tw.utils.registerFileType(\\\"video/quicktime\\\", \\\"base64\\\", [\\\".mov\\\", \\\".qt\\\"]);\\n\\n    // Listener\\n    this.ensAction = new EnsAction();\\n    this.ipfsAction = new IpfsAction();\\n    this.ipfsTiddler = new IpfsTiddler();\\n\\n    // Init event listeners\\n    this.ensAction.init();\\n    this.ipfsAction.init();\\n    this.ipfsTiddler.init();\\n\\n    // Log\\n    const logger = window.log.getLogger(name);\\n    logger.info(\\\"ipfs-startup is starting up...\\\");\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/ipfs/ipfs-tiddler.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-tiddler.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-tiddler.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIpfsTiddler\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  const IpfsWrapper = require(\\\"$:/plugins/ipfs/ipfs-wrapper.js\\\").IpfsWrapper;\\n\\n  /*\\n   * $:/core/modules/server/routes/get-tiddler.js\\n   */\\n  const reservedFields = [\\n    \\\"bag\\\",\\n    \\\"created\\\",\\n    \\\"creator\\\",\\n    \\\"modified\\\",\\n    \\\"modifier\\\",\\n    \\\"permissions\\\",\\n    \\\"recipe\\\",\\n    \\\"revision\\\",\\n    \\\"tags\\\",\\n    \\\"fields\\\",\\n    \\\"list\\\",\\n    \\\"text\\\",\\n    \\\"title\\\",\\n    \\\"type\\\"\\n  ];\\n\\n  const fileProtocol = \\\"file:\\\";\\n  const ipnsKeyword = \\\"ipns\\\";\\n\\n  const name = \\\"ipfs-tiddler\\\";\\n\\n  var IpfsTiddler = function() {\\n    this.once = false;\\n    this.ipfsWrapper = new IpfsWrapper();\\n  };\\n\\n  IpfsTiddler.prototype.getLogger = function() {\\n    return window.log.getLogger(name);\\n  };\\n\\n  IpfsTiddler.prototype.init = function() {\\n    // Init once\\n    if (this.once) {\\n      return;\\n    }\\n    const self = this;\\n    // Wiki\\n    $tw.wiki.addEventListener(\\\"change\\\", function(changes) {\\n      return self.handleChangeEvent(changes);\\n    });\\n    // Hook\\n    $tw.hooks.addHook(\\\"th-deleting-tiddler\\\", async function(tiddler) {\\n      return await self.handleDeleteTiddler(tiddler);\\n    });\\n    $tw.hooks.addHook(\\\"th-importing-tiddler\\\", function(tiddler) {\\n      return self.handleFileImport(tiddler);\\n    });\\n    $tw.hooks.addHook(\\\"th-saving-tiddler\\\", async function(tiddler) {\\n      return await self.handleSaveTiddler(tiddler);\\n    });\\n    // Widget\\n    $tw.rootWidget.addEventListener(\\\"tm-ipfs-pin\\\", async function(event) {\\n      return await self.handleIpfsPin(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-refresh-tiddler\\\", async function(event) {\\n      return await self.handleRefreshTiddler(event);\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-ipfs-unpin\\\", async function(event) {\\n      return await self.handleIpfsUnpin(event);\\n    });\\n    // Init once\\n    this.once = true;\\n  };\\n\\n  IpfsTiddler.prototype.handleChangeEvent = function(changes) {\\n    // Gateway preference\\n    const gateway = changes[\\\"$:/ipfs/saver/gateway\\\"];\\n    if (gateway !== undefined && gateway.modified) {\\n      const base = $tw.ipfs.getIpfsBaseUrl();\\n      if ($tw.utils.getIpfsUrlPolicy() === \\\"gateway\\\") {\\n        this.getLogger().info(\\\"Gateway Relative URL:\\\" + \\\"\\\\n \\\" + base.toString());\\n      }\\n    }\\n    // IPNS name preference\\n    const name = changes[\\\"$:/ipfs/saver/ipns/name\\\"];\\n    if (name !== undefined && name.modified) {\\n      const tiddler = $tw.wiki.getTiddler(\\\"$:/ipfs/saver/ipns/key\\\");\\n      if (tiddler !== undefined) {\\n        if ($tw.utils.getIpfsIpnsKey() !== null) {\\n          const updatedTiddler = $tw.utils.updateTiddler({\\n            tiddler: tiddler,\\n            fields: [{ key: \\\"text\\\", value: \\\"\\\" }]\\n          });\\n          $tw.wiki.addTiddler(updatedTiddler);\\n        }\\n      }\\n    }\\n    // Policy preference\\n    const policy = changes[\\\"$:/ipfs/saver/policy\\\"];\\n    if (policy !== undefined && policy.modified) {\\n      const base = $tw.ipfs.getIpfsBaseUrl();\\n      if ($tw.utils.getIpfsUrlPolicy() === \\\"origin\\\") {\\n        this.getLogger().info(\\\"Origin base URL:\\\" + \\\"\\\\n \\\" + base.toString());\\n      } else {\\n        this.getLogger().info(\\\"Gateway base URL:\\\" + \\\"\\\\n \\\" + base.toString());\\n      }\\n    }\\n    // Unpin preference\\n    const unpin = changes[\\\"$:/ipfs/saver/unpin\\\"];\\n    if (unpin !== undefined && unpin.modified) {\\n      if ($tw.utils.getIpfsUnpin()) {\\n        this.getLogger().info(\\\"Unpin previous IPFS content...\\\");\\n      } else {\\n        this.getLogger().info(\\\"Do not unpin previous IPFS content...\\\");\\n      }\\n    }\\n    // Verbose preference\\n    const verbose = changes[\\\"$:/ipfs/saver/verbose\\\"];\\n    if (verbose !== undefined && verbose.modified) {\\n      if ($tw.utils.getIpfsVerbose()) {\\n        this.updateLoggers(\\\"info\\\");\\n      } else {\\n        this.updateLoggers(\\\"warn\\\");\\n      }\\n    }\\n  };\\n\\n  IpfsTiddler.prototype.handleIpfsPin = async function(event) {\\n    try {\\n      const self = this;\\n\\n      const title = event.tiddlerTitle;\\n\\n      // Load tiddler\\n      const tiddler = $tw.wiki.getTiddler(title);\\n      if (tiddler == undefined || tiddler == null) {\\n        $tw.utils.alert(name, \\\"Unknown tiddler: \\\" + title);\\n        return false;\\n      }\\n\\n      // Tiddler\\n      if (event.param !== undefined && event.param !== null) {\\n        // Process fields\\n        $tw.utils.each(tiddler.fields, async function(field, name) {\\n          var uri = null;\\n          var value = tiddler.getFieldString(name);\\n          // Not a reserved keyword process\\n          if (reservedFields.indexOf(name) == -1) {\\n            // URI or not\\n            try {\\n              uri = await $tw.ipfs.normalizeIpfsUrl(value);\\n            } catch (error) {\\n              // Ignore\\n            }\\n            // Process\\n            if (uri !== null) {\\n              try {\\n                await self.ipfsPin(name, uri);\\n              } catch (error) {\\n                self.getLogger().error(error);\\n                $tw.utils.alert(name, error.message);\\n              }\\n            }\\n          }\\n        });\\n        // Document\\n      } else {\\n        const parsed = await $tw.ipfs.getDocumentUrl();\\n        await this.ipfsPin(\\\"document\\\", parsed);\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsTiddler.prototype.ipfsPin = async function(name, uri) {\\n    // Check\\n    if (uri == undefined || uri == null) {\\n      throw new Error(\\\"Undefined URI...\\\");\\n    }\\n\\n    if (uri.protocol === fileProtocol) {\\n      throw new Error(\\\"Unable to Pin a local filesystem resource...\\\");\\n    }\\n\\n    if (uri.pathname === \\\"/\\\") {\\n      throw new Error(\\\"Unknown pathname...\\\");\\n    }\\n\\n    // Extract and check URL IPFS protocol and cid\\n    var { protocol, cid } = this.ipfsWrapper.decodeCid(uri.pathname);\\n\\n    // Process if valid\\n    if (protocol !== null && cid !== null) {\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Resolve ipns key if applicable\\n      if (protocol === ipnsKeyword) {\\n        const { ipnsKey } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, cid);\\n        cid = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n      }\\n\\n      this.getLogger().info(\\\"Pinning reference: \\\" + name + \\\"\\\\n \\\" + uri.href);\\n\\n      // Pin\\n      await this.ipfsWrapper.pinToIpfs(ipfs, cid);\\n\\n      // Remove unpin request\\n      $tw.ipfs.removeFromUnpin(cid);\\n    }\\n  };\\n\\n  IpfsTiddler.prototype.handleIpfsUnpin = async function(event) {\\n    try {\\n      const self = this;\\n\\n      const title = event.tiddlerTitle;\\n\\n      // Load tiddler\\n      const tiddler = $tw.wiki.getTiddler(title);\\n      if (tiddler == undefined || tiddler == null) {\\n        $tw.utils.alert(name, \\\"Unknown tiddler: \\\" + title);\\n        return false;\\n      }\\n\\n      // Tiddler\\n      if (event.param !== undefined && event.param !== null) {\\n        // Process fields\\n        $tw.utils.each(tiddler.fields, async function(field, name) {\\n          var uri = null;\\n          var value = tiddler.getFieldString(name);\\n          // Not a reserved keyword process\\n          if (reservedFields.indexOf(name) == -1) {\\n            // URI or not\\n            try {\\n              uri = await $tw.ipfs.normalizeIpfsUrl(value);\\n            } catch (error) {\\n              // Ignore\\n            }\\n            // Process\\n            if (uri !== null) {\\n              try {\\n                await self.ipfsUnpin(name, uri);\\n              } catch (error) {\\n                self.getLogger().error(error);\\n                $tw.utils.alert(name, error.message);\\n              }\\n            }\\n          }\\n        });\\n        // Document\\n      } else {\\n        const parsed = await $tw.ipfs.getDocumentUrl();\\n        await this.ipfsUnpin(\\\"document\\\", parsed);\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, error.message);\\n      return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsTiddler.prototype.ipfsUnpin = async function(name, uri) {\\n    // Check\\n    if (uri == undefined || uri == null) {\\n      throw new Error(\\\"Undefined URI...\\\");\\n    }\\n\\n    if (uri.protocol === fileProtocol) {\\n      throw new Error(\\\"Unable to Unpin a local filesystem resource...\\\");\\n    }\\n\\n    if (uri.pathname === \\\"/\\\") {\\n      throw new Error(\\\"Unknown pathname...\\\");\\n    }\\n\\n    // Extract and check URL IPFS protocol and cid\\n    var { protocol, cid } = this.ipfsWrapper.decodeCid(uri.pathname);\\n\\n    // Process if valid\\n    if (protocol !== null && cid !== null) {\\n      // IPFS client\\n      const { ipfs } = await $tw.ipfs.getIpfsClient();\\n\\n      // Resolve IPNS key if applicable\\n      if (protocol === ipnsKeyword) {\\n        const { ipnsKey } = await this.ipfsWrapper.getIpnsIdentifiers(ipfs, cid);\\n        cid = await this.ipfsWrapper.resolveIpnsKey(ipfs, ipnsKey);\\n      }\\n\\n      this.getLogger().info(\\\"Unpinning reference: \\\" + name + \\\"\\\\n \\\" + uri.href);\\n\\n      // Unpin\\n      await this.ipfsWrapper.unpinFromIpfs(ipfs, cid);\\n\\n      // Remove unpin request\\n      $tw.ipfs.removeFromUnpin(cid);\\n    }\\n  };\\n\\n  IpfsTiddler.prototype.updateLoggers = function(level) {\\n    window.log.setLevel(level, false);\\n    const loggers = window.log.getLoggers();\\n    for (var property in loggers) {\\n      if (Object.prototype.hasOwnProperty.call(loggers, property)) {\\n        const logger = window.log.getLogger(property);\\n        logger.setLevel(level, false);\\n      }\\n    }\\n  };\\n\\n  IpfsTiddler.prototype.handleDeleteTiddler = async function(tiddler) {\\n    // self\\n    const self = this;\\n    // Process fields\\n    $tw.utils.each(tiddler.fields, async function(field, name) {\\n      var uri = null;\\n      var value = tiddler.getFieldString(name);\\n      // Not a reserved keyword process\\n      if (reservedFields.indexOf(name) == -1) {\\n        // URI or not\\n        try {\\n          uri = await $tw.ipfs.normalizeIpfsUrl(value);\\n        } catch (error) {\\n          // Ignore\\n        }\\n        // Process\\n        if (uri !== null) {\\n          try {\\n            const { cid } = self.ipfsWrapper.decodeCid(uri.pathname);\\n            // Request to unpin\\n            if ($tw.utils.getIpfsUnpin() && cid !== null) {\\n              $tw.ipfs.requestToUnpin(cid);\\n            }\\n          } catch (error) {\\n            self.getLogger().error(error);\\n            $tw.utils.alert(name, error.message);\\n          }\\n        }\\n      }\\n    });\\n    return tiddler;\\n  };\\n\\n  IpfsTiddler.prototype.handleFileImport = function(tiddler) {\\n    // Update tiddler\\n    const addition = $tw.wiki.getModificationFields();\\n    addition.title = tiddler.fields.title;\\n    addition.tags = (tiddler.fields.tags || []).slice(0);\\n    // Add isAttachment tag\\n    if (addition.tags.indexOf(\\\"$:/isAttachment\\\") == -1) {\\n      $tw.utils.pushTop(addition.tags, \\\"$:/isAttachment\\\");\\n    }\\n    // Add isEmbedded tag\\n    if (addition.tags.indexOf(\\\"$:/isEmbedded\\\") == -1) {\\n      $tw.utils.pushTop(addition.tags, \\\"$:/isEmbedded\\\");\\n    }\\n    return new $tw.Tiddler(tiddler, addition);\\n  };\\n\\n  IpfsTiddler.prototype.merge = function(tiddler, target) {\\n    // Merge\\n    const currentTags = (tiddler.fields.tags || []).slice(0);\\n\\n    // Merge Tiddler fields with remote fields\\n    // $:/core/modules/server/routes/get-tiddler.js\\n    const fields = [];\\n\\n    // Iterate over target properties\\n    for (var properties in target) {\\n      fields.push({ key: properties, value: target[properties] });\\n    }\\n\\n    // Merge target tags with current tags\\n    var importedTags = target[\\\"tags\\\"] == undefined ? \\\"\\\" : target[\\\"tags\\\"];\\n    for (var i = 0; i < currentTags.length; i++) {\\n      const tag = currentTags[i];\\n      if (importedTags.includes(tag) == false) {\\n        importedTags = importedTags + \\\" \\\" + tag;\\n      }\\n    }\\n    const addTags = importedTags;\\n\\n    // Update Tiddler\\n    const updatedTiddler = $tw.utils.updateTiddler({\\n      tiddler: tiddler,\\n      addTags: addTags,\\n      fields: fields\\n    });\\n\\n    return updatedTiddler;\\n  };\\n\\n  IpfsTiddler.prototype.mergeImported = async function(tiddler, uri) {\\n    // Check\\n    if (tiddler == undefined || tiddler == null) {\\n      return tiddler;\\n    }\\n    const title = tiddler.getFieldString(\\\"title\\\");\\n    if (title == undefined || title == null) {\\n      return tiddler;\\n    }\\n    if (uri == undefined || uri == null) {\\n      return tiddler;\\n    }\\n\\n    // Load remote if any\\n    const remotes = await this.ipfsWrapper.loadTiddlers(uri);\\n\\n    // Iterate over remote for new and update\\n    if (remotes !== undefined && remotes !== null) {\\n      var current = null;\\n      for (var k = 0; k < remotes.length; k++) {\\n        // Current remote\\n        const remote = remotes[k];\\n\\n        // Head\\n        if (current == null) {\\n          current = tiddler;\\n        } else {\\n          current = $tw.wiki.getTiddler(remote.title);\\n        }\\n\\n        // New\\n        if (current == null) {\\n          // New Tiddler\\n          current = new $tw.Tiddler({\\n            title: remote.title\\n          });\\n        }\\n\\n        if (current !== null) {\\n          // Merge\\n          const mergedTiddler = this.merge(current, remote);\\n          // Update\\n          $tw.wiki.addTiddler(mergedTiddler);\\n        }\\n      }\\n    }\\n\\n    return true;\\n  };\\n\\n  IpfsTiddler.prototype.handleRefreshTiddler = async function(event) {\\n    // self\\n    const self = this;\\n    // current tiddler title\\n    const title = event.tiddlerTitle;\\n\\n    // Load tiddler\\n    const tiddler = $tw.wiki.getTiddler(title);\\n    if (tiddler == undefined || tiddler == null) {\\n      $tw.utils.alert(name, \\\"Unknown tiddler: \\\" + title);\\n      return false;\\n    }\\n\\n    // Count fields\\n    var count = 0;\\n    $tw.utils.each(tiddler.getFieldStrings(), function(value, fieldName) {\\n      count += 1;\\n    });\\n\\n    // Process fields\\n    $tw.utils.each(tiddler.fields, async function(field, name) {\\n      // Not a reserved keyword process\\n      if (reservedFields.indexOf(name) == -1) {\\n        // Uri\\n        var uri = null;\\n        // Value\\n        var value = tiddler.getFieldString(name);\\n        // Process if any update\\n        if (value !== undefined && value !== null) {\\n          // URI or not\\n          try {\\n            uri = await $tw.ipfs.normalizeIpfsUrl(value);\\n          } catch (error) {\\n            // Ignore\\n          }\\n          // Process if any update\\n          if (uri !== undefined && uri !== null) {\\n            // Process canonical_uri if any\\n            if (name === \\\"_canonical_uri\\\") {\\n              // import_uri supersed canonical_uri\\n              var import_uri = tiddler.getFieldString(\\\"_import_uri\\\");\\n              if (import_uri !== undefined && import_uri !== null) {\\n                uri = import_uri;\\n              }\\n              // Import and merge\\n              var updatedTiddler = await self.mergeImported(tiddler, uri);\\n              // Empty text to force refresh\\n              updatedTiddler = $tw.utils.updateTiddler({\\n                tiddler: updatedTiddler,\\n                fields: [{ key: \\\"text\\\", value: \\\"\\\" }]\\n              });\\n              $tw.wiki.addTiddler(updatedTiddler);\\n            }\\n          }\\n        }\\n      }\\n\\n      // Empty cache once\\n      if (--count == 0) {\\n        $tw.wiki.clearCache(title);\\n        // Tiddler to be refreshed\\n        const changedTiddler = $tw.utils.getChangedTiddler(title);\\n        // Refresh\\n        $tw.rootWidget.refresh(changedTiddler);\\n      }\\n    });\\n\\n    return true;\\n  };\\n\\n  IpfsTiddler.prototype.handleSaveTiddler = async function(tiddler) {\\n    var updatedTiddler = new $tw.Tiddler(tiddler);\\n\\n    // Type\\n    var type = tiddler.getFieldString(\\\"type\\\");\\n    // Default\\n    if (type == undefined || type == null || type.trim() === \\\"\\\") {\\n      type = \\\"text/vnd.tiddlywiki\\\";\\n    }\\n\\n    // Content Type\\n    const info = $tw.config.contentTypeInfo[type];\\n\\n    // Check\\n    if (info == undefined || info == null) {\\n      const unknownType = new Error(\\\"Unknown Tiddler type: \\\" + type);\\n      this.getLogger().error(unknownType);\\n      $tw.utils.alert(name, unknownType.message);\\n      $tw.wiki.addTiddler(updatedTiddler);\\n      return updatedTiddler;\\n    }\\n\\n    // Previous tiddler\\n    const oldTiddler = $tw.wiki.getTiddler(tiddler.fields.title);\\n\\n    // Process deleted fields\\n    if (oldTiddler !== undefined && oldTiddler !== null) {\\n      for (var name in oldTiddler.fields) {\\n        // Not a reserved keyword\\n        if (reservedFields.indexOf(name) !== -1) {\\n          continue;\\n        }\\n        // Discard updated\\n        const field = tiddler.fields[name];\\n        if (field !== undefined && field !== null && tiddler.getFieldString(name).trim() !== \\\"\\\") {\\n          continue;\\n        }\\n        // Process\\n        const value = oldTiddler.getFieldString(name);\\n        var { uri, cid } = await this.ipfsWrapper.decodeUrl(value);\\n        if (name === \\\"_canonical_uri\\\") {\\n          var content = tiddler.getFieldString(\\\"text\\\");\\n          // Attachment\\n          if (info.encoding === \\\"base64\\\" || type === \\\"image/svg+xml\\\") {\\n            // Embed\\n            if (uri !== null) {\\n              try {\\n                if (info.encoding === \\\"base64\\\") {\\n                  content = await $tw.utils.loadToBase64(uri);\\n                } else {\\n                  content = await $tw.utils.loadToUtf8(uri);\\n                }\\n                updatedTiddler = $tw.utils.updateTiddler({\\n                  tiddler: updatedTiddler,\\n                  addTags: [\\\"$:/isAttachment\\\", \\\"$:/isEmbedded\\\"],\\n                  fields: [{ key: \\\"text\\\", value: content.data }]\\n                });\\n                this.getLogger().info(\\\"Embed attachment: \\\" + content.data.length + \\\" bytes\\\" + \\\"\\\\n \\\" + uri.href);\\n              } catch (error) {\\n                this.getLogger().error(error);\\n                $tw.utils.alert(name, error.message);\\n              }\\n            }\\n          }\\n        }\\n        // Unpin\\n        if (uri !== null) {\\n          try {\\n            // Unpin request\\n            if ($tw.utils.getIpfsUnpin() && cid !== null) {\\n              $tw.ipfs.requestToUnpin(cid);\\n            }\\n          } catch (error) {\\n            this.getLogger().error(error);\\n            $tw.utils.alert(name, error.message);\\n          }\\n        }\\n      }\\n    }\\n\\n    // Special fields\\n    var canonicalUri = null;\\n    var exportUri = null;\\n    var importUri = null;\\n    var canonicalCid = null;\\n    var exportCid = null;\\n    var importCid = null;\\n\\n    // Process new and updated fields\\n    for (var name in tiddler.fields) {\\n      // Not a reserved keyword\\n      if (reservedFields.indexOf(name) !== -1) {\\n        continue;\\n      }\\n      // Process\\n      const value = tiddler.getFieldString(name);\\n      const { uri, cid } = await this.ipfsWrapper.decodeUrl(value);\\n      // Store\\n      if (name === \\\"_canonical_uri\\\") {\\n        canonicalUri = uri;\\n        canonicalCid = cid;\\n      }\\n      if (name === \\\"_import_uri\\\") {\\n        importUri = uri;\\n        importCid = cid;\\n      }\\n      if (name === \\\"_export_uri\\\") {\\n        exportUri = uri;\\n        exportCid = cid;\\n      }\\n\\n      // Previous values if any\\n      var oldValue = null;\\n      if (oldTiddler !== undefined && oldTiddler !== null) {\\n        oldValue = oldTiddler.getFieldString(name);\\n      }\\n      const { uri: oldUri, cid: oldCid } = await this.ipfsWrapper.decodeUrl(oldValue);\\n      // Process new or updated\\n      if (value === oldValue) {\\n        continue;\\n      }\\n      // Process _canonical_uri\\n      if (name === \\\"_canonical_uri\\\") {\\n        updatedTiddler = $tw.utils.updateTiddler({\\n          tiddler: updatedTiddler,\\n          fields: [{ key: \\\"text\\\", value: \\\"\\\" }]\\n        });\\n      }\\n      // Unpin\\n      if (oldUri !== null) {\\n        try {\\n          // Unpin request\\n          if ($tw.utils.getIpfsUnpin() && oldCid !== null) {\\n            $tw.ipfs.requestToUnpin(oldCid);\\n          }\\n        } catch (error) {\\n          this.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        }\\n      }\\n      // Discard unpin\\n      if (uri !== null) {\\n        try {\\n          if ($tw.utils.getIpfsUnpin() && cid !== null) {\\n            $tw.ipfs.discardRequestToUnpin(cid);\\n          }\\n        } catch (error) {\\n          this.getLogger().error(error);\\n          $tw.utils.alert(name, error.message);\\n        }\\n      }\\n    }\\n    // Tag management\\n    var addTags = [];\\n    var removeTags = [];\\n    if (canonicalUri == null && exportUri == null && importUri == null) {\\n      removeTags.push(\\\"$:/isExported\\\", \\\"$:/isImported\\\", \\\"$:/isIpfs\\\");\\n    }\\n    if (canonicalCid == null && exportCid == null && importCid == null) {\\n      if (removeTags.indexOf(\\\"$:/isIpfs\\\") === -1) {\\n        removeTags.push(\\\"$:/isIpfs\\\");\\n      }\\n    } else {\\n      addTags.push(\\\"$:/isIpfs\\\");\\n    }\\n    if (canonicalUri !== null) {\\n      // Attachment\\n      if (info.encoding === \\\"base64\\\" || type === \\\"image/svg+xml\\\") {\\n        if (addTags.indexOf(\\\"$:/isAttachment\\\") === -1) {\\n          addTags.push(\\\"$:/isAttachment\\\");\\n        }\\n        if (removeTags.indexOf(\\\"$:/isEmbedded\\\") === -1) {\\n          removeTags.push(\\\"$:/isEmbedded\\\");\\n        }\\n        if (importUri !== null) {\\n          if (addTags.indexOf(\\\"$:/isImported\\\") === -1) {\\n            addTags.push(\\\"$:/isImported\\\");\\n          }\\n        } else {\\n          if (removeTags.indexOf(\\\"$:/isImported\\\") === -1) {\\n            removeTags.push(\\\"$:/isImported\\\");\\n          }\\n        }\\n        // Others\\n      } else {\\n        if (removeTags.indexOf(\\\"$:/isAttachment\\\") === -1) {\\n          removeTags.push(\\\"$:/isAttachment\\\");\\n        }\\n        if (removeTags.indexOf(\\\"$:/isEmbedded\\\") === -1) {\\n          removeTags.push(\\\"$:/isEmbedded\\\");\\n        }\\n        if (addTags.indexOf(\\\"$:/isImported\\\") === -1) {\\n          addTags.push(\\\"$:/isImported\\\");\\n        }\\n      }\\n    } else {\\n      // Attachment\\n      if (info.encoding === \\\"base64\\\" || type === \\\"image/svg+xml\\\") {\\n        if (addTags.indexOf(\\\"$:/isAttachment\\\") === -1) {\\n          addTags.push(\\\"$:/isAttachment\\\");\\n        }\\n        if (addTags.indexOf(\\\"$:/isEmbedded\\\") === -1) {\\n          addTags.push(\\\"$:/isEmbedded\\\");\\n        }\\n        // Others\\n      } else {\\n        if (removeTags.indexOf(\\\"$:/isAttachment\\\") === -1) {\\n          removeTags.push(\\\"$:/isAttachment\\\");\\n        }\\n        if (removeTags.indexOf(\\\"$:/isEmbedded\\\") === -1) {\\n          removeTags.push(\\\"$:/isEmbedded\\\");\\n        }\\n      }\\n      if (importUri !== null) {\\n        if (addTags.indexOf(\\\"$:/isImported\\\") === -1) {\\n          addTags.push(\\\"$:/isImported\\\");\\n        }\\n      } else {\\n        if (removeTags.indexOf(\\\"$:/isImported\\\") === -1) {\\n          removeTags.push(\\\"$:/isImported\\\");\\n        }\\n      }\\n    }\\n    if (exportUri !== null) {\\n      if (addTags.indexOf(\\\"$:/isExported\\\") === -1) {\\n        addTags.push(\\\"$:/isExported\\\");\\n      }\\n    } else {\\n      if (removeTags.indexOf(\\\"$:/isExported\\\") === -1) {\\n        removeTags.push(\\\"$:/isExported\\\");\\n      }\\n    }\\n    if (addTags.length > 0 || removeTags.length > 0) {\\n      updatedTiddler = $tw.utils.updateTiddler({\\n        tiddler: updatedTiddler,\\n        addTags: addTags,\\n        removeTags: removeTags\\n      });\\n    }\\n\\n    // Update\\n    $tw.wiki.addTiddler(updatedTiddler);\\n    return updatedTiddler;\\n  };\\n\\n  exports.IpfsTiddler = IpfsTiddler;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/ipfs/ipfs-utils.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-utils.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-utils.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: utils\\n\\nutils\\n\\n\\\\*/\\n\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.Base64ToUint8Array = function(base64) {\\n  var raw = atob(base64);\\n  var ua = new Uint8Array(raw.length);\\n  for (var i = 0; i < raw.length; i++) {\\n    ua[i] = raw.charCodeAt(i);\\n  }\\n  return ua;\\n}\\n\\nexports.Uint8ArrayToBase64 = function(uint8) {\\n  var CHUNK_SIZE = 0x8000; //arbitrary number\\n  var index = 0;\\n  var length = uint8.length;\\n  var str = \\\"\\\";\\n  var slice;\\n  while (index < length) {\\n    slice = uint8.subarray(index, Math.min(index + CHUNK_SIZE, length));\\n    str += String.fromCharCode.apply(null, slice);\\n    index += CHUNK_SIZE;\\n  }\\n  return btoa(str);\\n}\\n\\n// String to uint array\\nexports.StringToUint8Array = function(string) {\\n  var escstr = encodeURIComponent(string);\\n  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function(match, p1) {\\n      return String.fromCharCode('0x' + p1);\\n  });\\n  var ua = new Uint8Array(binstr.length);\\n  Array.prototype.forEach.call(binstr, function (ch, i) {\\n      ua[i] = ch.charCodeAt(0);\\n  });\\n  return ua;\\n}\\n\\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\\n\\n/*\\n * utf.js - UTF-8 <=> UTF-16 convertion\\n *\\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\\n * Version: 1.0\\n * LastModified: Dec 25 1999\\n * This library is free.  You can redistribute it and/or modify it.\\n */\\nexports.Utf8ArrayToStr = function(array) {\\n  var c, char2, char3;\\n  var out = \\\"\\\";\\n  var len = array.length;\\n  var i = 0;\\n  while(i < len) {\\n    c = array[i++];\\n    switch(c >> 4) {\\n    case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\\n      // 0xxxxxxx\\n      out += String.fromCharCode(c);\\n      break;\\n    case 12: case 13:\\n      // 110x xxxx   10xx xxxx\\n      char2 = array[i++];\\n      out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\\n      break;\\n    case 14:\\n      // 1110 xxxx  10xx xxxx  10xx xxxx\\n      char2 = array[i++];\\n      char3 = array[i++];\\n      out += String.fromCharCode(((c & 0x0F) << 12)\\n        | ((char2 & 0x3F) << 6)\\n        | ((char3 & 0x3F) << 0));\\n      break;\\n    }\\n  }\\n  return out;\\n}\\n\\n/**\\n * $:/core/modules/utils/logger.js\\n *\\n * TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n *\\n * Copyright (c) 2004-2007, Jeremy Ruston\\n * Copyright (c) 2007-2018, UnaMesa Association\\n * Copyright (c) 2019-2020, Blue Light\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * * Neither the name of the copyright holder nor the names of its\\n *   contributors may be used to endorse or promote products derived from\\n *   this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\nexports.alert = function(callee, text) {\\n\\n  if (typeof window === \\\"undefined\\\" || typeof window.navigator === \\\"undefined\\\") {\\n    return;\\n  }\\n\\n  const ALERT_TAG = \\\"$:/tags/Alert\\\";\\n\\n  // Check if there is an existing alert with the same text and the same component\\n  var existingAlerts = $tw.wiki.getTiddlersWithTag(\\\"$:/tags/Alert\\\");\\n  var alertFields;\\n  var existingCount;\\n\\n  $tw.utils.each(existingAlerts, function(title) {\\n    var tiddler = $tw.wiki.getTiddler(title);\\n    if (tiddler.fields.text === text\\n      && tiddler.fields.component === self.componentName\\n      && tiddler.fields.modified\\n      && (!alertFields || tiddler.fields.modified < alertFields.modified)\\n    ) {\\n        alertFields = $tw.utils.extend({}, tiddler.fields);\\n    }\\n  });\\n\\n  if (alertFields) {\\n    existingCount = alertFields.count || 1;\\n  } else {\\n    alertFields = {\\n      title: $tw.wiki.generateNewTitle(\\\"$:/temp/alerts/alert\\\", {prefix: \\\"\\\"}),\\n      text: text,\\n      tags: [ALERT_TAG],\\n      component: callee\\n    };\\n    existingCount = 0;\\n  }\\n\\n  alertFields.modified = new Date();\\n  if (++existingCount > 1) {\\n    alertFields.count = existingCount;\\n  } else {\\n    alertFields.count = undefined;\\n  }\\n\\n  $tw.wiki.addTiddler(new $tw.Tiddler(alertFields));\\n\\n}\\n\\nexports.getChangedTiddler = function(object) {\\n  // Holder\\n  const changedTiddler = Object.create(null);\\n  // Check\\n  if (object == undefined || object == null) {\\n    return changedTiddler;\\n  }\\n  if (object instanceof $tw.Tiddler == false && typeof object !== \\\"string\\\") {\\n    return changedTiddler;\\n  }\\n  // Retrieve title\\n  var title = null;\\n  if (typeof object === \\\"string\\\") {\\n    title = object;\\n  }\\n  if (object instanceof $tw.Tiddler) {\\n    title = object.getFieldString(\\\"title\\\");\\n  }\\n  // Check\\n  if (title == undefined || title == null) {\\n    return changedTiddler;\\n  }\\n  // Process title\\n  changedTiddler[title] = Object.create(null);\\n  // Done\\n  return changedTiddler;\\n}\\n\\nexports.updateTiddler = function(updates) {\\n  // Is there anything to do\\n  if (updates == undefined || updates == null || updates.tiddler == undefined || updates.tiddler == null) {\\n    return null;\\n  }\\n  // Prepare updates\\n  const fields = $tw.wiki.getModificationFields();\\n  // Tags\\n  fields.tags = (updates.tiddler.fields.tags || []).slice(0);\\n  // Process add tags\\n  if (updates.addTags !== undefined && updates.addTags !== null && Array.isArray(updates.addTags)) {\\n    for (var i = 0; i < updates.addTags.length; i++) {\\n      const tag = updates.addTags[i];\\n      if (fields.tags.indexOf(tag) == -1) {\\n        $tw.utils.pushTop(fields.tags, tag);\\n      }\\n    }\\n  }\\n  // Process remove tags\\n  if (updates.removeTags !== undefined && updates.removeTags !== null && Array.isArray(updates.removeTags)) {\\n    for (var i = 0; i < updates.removeTags.length; i++) {\\n      const tag = updates.removeTags[i];\\n      const index = fields.tags.indexOf(tag);\\n      if (index !== -1) {\\n        fields.tags.splice(index, 1);\\n      }\\n    }\\n  }\\n  // Process fields\\n  if (updates.fields !== undefined && updates.fields !== null && Array.isArray(updates.fields)) {\\n    for (var i = 0; i < updates.fields.length; i++) {\\n      const field = updates.fields[i];\\n      if (field.key !== undefined && field.key !== null) {\\n        fields[field.key] = field.value;\\n      }\\n    }\\n  }\\n  // Update tiddler\\n  const updatedTiddler = new $tw.Tiddler(updates.tiddler, fields);\\n  return updatedTiddler;\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/ipfs/macro/ipfs-version.js\": {\n            \"title\": \"$:/plugins/ipfs/macro/ipfs-version.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/macro/ipfs-version.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: macro\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\n   * Information about this macro\\n   */\\n  exports.name = \\\"ipfs-version\\\";\\n\\n  exports.params = [];\\n\\n  /*\\n   * Run the macro\\n   */\\n  exports.run = function() {\\n    return $tw.wiki.getTiddler(\\\"$:/plugins/ipfs\\\").fields.version;\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/ipfs/ipfs-wrapper.js\": {\n            \"title\": \"$:/plugins/ipfs/ipfs-wrapper.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/ipfs/ipfs-wrapper.js\\ntype: application/javascript\\ntags: $:/ipfs/core\\nmodule-type: library\\n\\nIpfsWrapper\\n\\n\\\\*/\\n\\n(function() {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /**\\n   * https://github.com/purposeindustries/window-or-global\\n   * The MIT License (MIT) Copyright (c) Purpose Industries\\n   * version: 1.0.1\\n   */\\n  const root =\\n    (typeof self === \\\"object\\\" && self.self === self && self) ||\\n    (typeof global === \\\"object\\\" && global.global === global && global) ||\\n    this;\\n\\n  const IpfsLibrary = require(\\\"./ipfs-bundle.js\\\").IpfsLibrary;\\n  const IpfsUri = require(\\\"./ipfs-bundle.js\\\").IpfsUri;\\n\\n  const ipfsKeyword = \\\"ipfs\\\";\\n  const ipnsKeyword = \\\"ipns\\\";\\n\\n  const name = \\\"ipfs-wrapper\\\";\\n\\n  var IpfsWrapper = function() {\\n    this.ipfsLibrary = new IpfsLibrary.IpfsLibrary();\\n    this.ipfsUri = new IpfsUri.IpfsUri();\\n  };\\n\\n  IpfsWrapper.prototype.getLogger = function() {\\n    return root.log.getLogger(name);\\n  };\\n\\n  IpfsWrapper.prototype.decodeCid = function(pathname) {\\n    return this.ipfsLibrary.decodeCid(pathname);\\n  };\\n\\n  IpfsWrapper.prototype.decodeUrl = async function(value) {\\n    // Check\\n    var text = false;\\n    try {\\n      this.ipfsUri.getUrl(value);\\n    } catch (error) {\\n      if (value !== undefined && value !== null && value.startsWith(\\\"/\\\") === false) {\\n        text = true;\\n      }\\n    }\\n    var uri = null;\\n    var cid = null;\\n    if (text == false) {\\n      try {\\n        uri = await this.ipfsUri.normalizeUrl(value, this.ipfsUri.getIpfsBaseUrl());\\n      } catch (error) {\\n        // Ignore\\n      }\\n      if (uri !== null) {\\n        // Ipfs\\n        try {\\n          var { cid } = this.ipfsLibrary.decodeCid(uri.pathname);\\n        } catch (error) {\\n          // Ignore\\n        }\\n      }\\n    }\\n    return {\\n      uri: uri,\\n      cid: cid\\n    };\\n  };\\n\\n  IpfsWrapper.prototype.getTiddlerContent = function(tiddler) {\\n    // Check\\n    if (tiddler == undefined || tiddler == null) {\\n      $tw.utils.alert(name, \\\"Unknown Tiddler...\\\");\\n      return null;\\n    }\\n\\n    // Type\\n    var type = tiddler.getFieldString(\\\"type\\\");\\n    // Default\\n    if (type == undefined || type == null || type.trim() === \\\"\\\") {\\n      type = \\\"text/vnd.tiddlywiki\\\";\\n    }\\n\\n    // Content Type\\n    const info = $tw.config.contentTypeInfo[type];\\n    // Check\\n    if (info == undefined || info == null) {\\n      $tw.utils.alert(name, \\\"Unknown Tiddler Content Type: \\\" + type);\\n      return null;\\n    }\\n\\n    // Check\\n    if (info.encoding !== \\\"base64\\\" && type !== \\\"image/svg+xml\\\") {\\n      $tw.utils.alert(name, \\\"Unsupported Tiddler Content Type...\\\\nLook at the documentation...\\\");\\n      return null;\\n    }\\n\\n    // Retrieve content\\n    var text = tiddler.getFieldString(\\\"text\\\");\\n    if (text == undefined || text == null || text.trim() === \\\"\\\") {\\n      return null;\\n    }\\n\\n    try {\\n      // Encrypt\\n      if ($tw.crypto.hasPassword()) {\\n        // https://github.com/xmaysonnave/tiddlywiki-ipfs/issues/9\\n        if (info.encoding === \\\"base64\\\") {\\n          text = atob(text);\\n        }\\n        text = $tw.crypto.encrypt(text, $tw.crypto.currentPassword);\\n        text = $tw.utils.StringToUint8Array(text);\\n      } else {\\n        // process base64\\n        if (info.encoding === \\\"base64\\\") {\\n          text = $tw.utils.Base64ToUint8Array(text);\\n        } else {\\n          text = $tw.utils.StringToUint8Array(text);\\n        }\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, \\\"Failed to encrypt content...\\\");\\n      return null;\\n    }\\n\\n    return text;\\n  };\\n\\n  IpfsWrapper.prototype.isJSON = function(content) {\\n    if (content !== undefined && content !== null && typeof content === \\\"string\\\") {\\n      try {\\n        JSON.parse(content);\\n        return true;\\n      } catch (erro) {\\n        // Ignore\\n      }\\n    }\\n    return false;\\n  };\\n\\n  IpfsWrapper.prototype.getTiddlersAsJson = async function(filter, spaces) {\\n    var tiddlers = $tw.wiki.filterTiddlers(filter);\\n    var spaces = spaces === undefined ? $tw.config.preferences.jsonSpaces : spaces;\\n    var data = [];\\n    // Process Tiddlers\\n    for (var t = 0; t < tiddlers.length; t++) {\\n      var tiddler = $tw.wiki.getTiddler(tiddlers[t]);\\n      if (tiddler == undefined || tiddler == null) {\\n        continue;\\n      }\\n      var isIpfs = false;\\n      var fields = new Object();\\n      // Process fields\\n      for (var field in tiddler.fields) {\\n        // Discard\\n        if (field === \\\"tags\\\" || field === \\\"_export_uri\\\" || field === \\\"_import_uri\\\") {\\n          continue;\\n        }\\n        // Process value\\n        const value = tiddler.getFieldString(field);\\n        const { uri, cid } = await this.decodeUrl(value);\\n        // Discard canonical_uri if import_uri is not set\\n        if (uri !== null && field === \\\"_canonical_uri\\\") {\\n          if (tiddler.fields[\\\"_import_uri\\\"] == undefined || tiddler.fields[\\\"_import_uri\\\"] == null || tiddler.fields[\\\"_import_uri\\\"].trim() === \\\"\\\") {\\n            continue;\\n          }\\n        }\\n        if (cid !== null) {\\n          isIpfs = true;\\n        }\\n        // Store field\\n        fields[field] = value;\\n      }\\n      // Process tags\\n      var tags = tiddler.fields[\\\"tags\\\"];\\n      if (tags !== undefined && tags !== null) {\\n        var value = \\\"\\\";\\n        for (var i = 0; i < tags.length; i++) {\\n          const tag = tags[i];\\n          // Discard\\n          if (tag === \\\"$:/isExported\\\" || tag === \\\"$:/isImported\\\" || (isIpfs === false && tag === \\\"$:/isIpfs\\\")) {\\n            continue;\\n          }\\n          value = value + \\\" \\\" + tag;\\n        }\\n        // Store tags\\n        fields[\\\"tags\\\"] = value;\\n      }\\n      // Store\\n      data.push(fields);\\n    }\\n    return JSON.stringify(data, null, spaces);\\n  };\\n\\n  /*\\n   * imported tiddler supersed hosting tiddler\\n   */\\n  IpfsWrapper.prototype.loadTiddlers = async function(uri) {\\n    // Normalize\\n    const normalized_uri = await $tw.ipfs.normalizeIpfsUrl(uri);\\n    // Load\\n    var importedTiddlers = null;\\n    const content = await $tw.utils.loadToUtf8(normalized_uri);\\n    if (this.isJSON(content.data)) {\\n      importedTiddlers = $tw.wiki.deserializeTiddlers(\\\".json\\\", content.data, $tw.wiki.getCreationFields());\\n    } else {\\n      importedTiddlers = $tw.wiki.deserializeTiddlers(\\\".tid\\\", content.data, $tw.wiki.getCreationFields());\\n    }\\n    $tw.utils.each(importedTiddlers, function(importedTiddler) {\\n      importedTiddler[\\\"_canonical_uri\\\"] = uri;\\n    });\\n    return importedTiddlers;\\n  };\\n\\n  IpfsWrapper.prototype.exportTiddler = async function(tiddler, child) {\\n    // Check\\n    if (tiddler == undefined || tiddler == null) {\\n      $tw.utils.alert(name, \\\"Unknown Tiddler...\\\");\\n      return null;\\n    }\\n\\n    const title = tiddler.getFieldString(\\\"title\\\");\\n\\n    // Type\\n    var type = tiddler.getFieldString(\\\"type\\\");\\n    // Default\\n    if (type == undefined || type == null || type.trim() === \\\"\\\") {\\n      type = \\\"text/vnd.tiddlywiki\\\";\\n    }\\n\\n    // Content Type\\n    const info = $tw.config.contentTypeInfo[type];\\n    // Check\\n    if (info == undefined || info == null) {\\n      $tw.utils.alert(name, \\\"Unknown Tiddler Content Type: \\\" + type);\\n      return null;\\n    }\\n\\n    // Filter\\n    var exportFilter = \\\"[[\\\" + tiddler.fields.title + \\\"]]\\\";\\n\\n    // Child filters\\n    if (child) {\\n      // Links\\n      const linked = $tw.wiki.getTiddlerLinks(title);\\n      this.getLogger().info(\\\"Found \\\" + linked.length + \\\" Tiddler link(s).\\\");\\n      // Transcluded\\n      const transcluded = this.transcludeContent(title);\\n      this.getLogger().info(\\\"Found \\\" + transcluded.length + \\\" transcluded Tiddler reference(s).\\\");\\n      const filtered = linked.concat(transcluded);\\n      // Process filtered content\\n      for (var i = 0; i < filtered.length; i++) {\\n        if (exportFilter.includes(\\\"[[\\\" + filtered[i] + \\\"]]\\\") == false) {\\n          exportFilter = exportFilter + \\\" [[\\\" + filtered[i] + \\\"]]\\\";\\n        }\\n      }\\n    }\\n\\n    var content = null;\\n\\n    if (child || $tw.utils.getIpfsExport() === \\\"json\\\") {\\n      content = await this.getTiddlersAsJson(exportFilter);\\n    } else if ($tw.utils.getIpfsExport() === \\\"static\\\") {\\n      // Export Tiddler as Static River\\n      const options = {\\n        downloadType: \\\"text/plain\\\",\\n        method: \\\"download\\\",\\n        template: \\\"$:/core/templates/exporters/StaticRiver\\\",\\n        variables: {\\n          exportFilter: exportFilter\\n        }\\n      };\\n      content = $tw.wiki.renderTiddler(\\\"text/plain\\\", \\\"$:/core/templates/exporters/StaticRiver\\\", options);\\n    } else {\\n      // Export Tiddler as tid\\n      const options = {\\n        downloadType: \\\"text/plain\\\",\\n        method: \\\"download\\\",\\n        template: \\\"$:/core/templates/exporters/TidFile\\\",\\n        variables: {\\n          exportFilter: exportFilter\\n        }\\n      };\\n      content = $tw.wiki.renderTiddler(\\\"text/plain\\\", \\\"$:/core/templates/exporters/TidFile\\\", options);\\n    }\\n\\n    try {\\n      // Encrypt\\n      if ($tw.crypto.hasPassword()) {\\n        content = $tw.crypto.encrypt(content, $tw.crypto.currentPassword);\\n      }\\n      content = $tw.utils.StringToUint8Array(content);\\n    } catch (error) {\\n      this.getLogger().error(error);\\n      $tw.utils.alert(name, \\\"Failed to encrypt content...\\\");\\n      return null;\\n    }\\n\\n    return content;\\n  };\\n\\n  IpfsWrapper.prototype.transcludeContent = function(title) {\\n    var tiddlers = [];\\n    // Build a transclude widget\\n    var transclude = $tw.wiki.makeTranscludeWidget(title);\\n    // Build a fake document element\\n    const container = $tw.fakeDocument.createElement(\\\"div\\\");\\n    // Transclude\\n    transclude.render(container, null);\\n    // Process children\\n    this.locateTiddlers(transclude, tiddlers);\\n    // Return\\n    return tiddlers;\\n  };\\n\\n  IpfsWrapper.prototype.locateTiddlers = function(transclude, tiddlers) {\\n    // Children lookup\\n    for (var i = 0; i < transclude.children.length; i++) {\\n      // Current child\\n      const child = transclude.children[i];\\n      if (child.variables !== undefined && child.variables !== null) {\\n        // Locate Tiddler\\n        const name = \\\"currentTiddler\\\";\\n        const current = child.variables[name];\\n        if (current !== undefined && current !== null && current.value !== undefined && current.value !== null) {\\n          if (tiddlers.indexOf(current.value) === -1) {\\n            tiddlers.push(current.value);\\n          }\\n        }\\n      }\\n      // Process children\\n      this.locateTiddlers(child, tiddlers);\\n    }\\n  };\\n\\n  IpfsWrapper.prototype.getWindowIpfsClient = async function() {\\n    // IPFS Companion\\n    try {\\n      const policy = await this.ipfsLibrary.getWindowIpfs();\\n      if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n        return policy;\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to retrieve IPFS Companion...\\\");\\n  };\\n\\n  IpfsWrapper.prototype.getHttpIpfsClient = async function(apiUrl) {\\n    // HTTP Client\\n    try {\\n      const policy = await this.ipfsLibrary.getHttpIpfs(apiUrl);\\n      if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n        return policy;\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to retrieve an IPFS HTTP provider...\\\");\\n  };\\n\\n  IpfsWrapper.prototype.getIpfsClient = async function(apiUrl) {\\n    // IPFS client\\n    try {\\n      var policy = null;\\n      const ipfsProvider = $tw.utils.getIpfsProvider();\\n      if (ipfsProvider === \\\"window\\\") {\\n        policy = await this.ipfsLibrary.getWindowIpfs();\\n      } else if (ipfsProvider === \\\"http\\\") {\\n        policy = await this.ipfsLibrary.getHttpIpfs(apiUrl);\\n      } else {\\n        policy = await this.ipfsLibrary.getDefaultIpfs(apiUrl);\\n      }\\n      if (policy !== null && policy.ipfs !== null && policy.provider !== null) {\\n        return policy;\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to retrieve an IPFS provider...\\\");\\n  };\\n\\n  IpfsWrapper.prototype.getIpnsIdentifiers = async function(ipfs, ipnsKey, ipnsName) {\\n    // Cleanup\\n    if (ipnsKey == undefined || ipnsKey == null) {\\n      ipnsKey = null;\\n    }\\n    if (ipnsName == undefined || ipnsName == null) {\\n      ipnsName = null;\\n    }\\n\\n    // Check\\n    if (ipnsKey == null && ipnsName == null) {\\n      throw new Error(\\\"Undefined IPNS key and IPNS name...\\\");\\n    }\\n\\n    // Load IPNS keys\\n    const keys = await this.getIpnsKeys(ipfs);\\n\\n    // Fetch IPNS name and IPNS key\\n    if (ipnsName !== null && ipnsKey !== null) {\\n      var found = false;\\n      for (var index = 0; index < keys.length; index++) {\\n        if (keys[index].id === ipnsKey && keys[index].name === ipnsName) {\\n          found = true;\\n          break;\\n        }\\n      }\\n      if (found === false) {\\n        throw new Error(\\\"Unknown IPNS key and IPNS name...\\\");\\n      }\\n    } else if (ipnsName !== null) {\\n      var found = false;\\n      if (keys !== null && keys !== undefined && Array.isArray(keys)) {\\n        for (var index = 0; index < keys.length; index++) {\\n          if (keys[index].name === ipnsName) {\\n            ipnsKey = keys[index].id;\\n            found = true;\\n            break;\\n          }\\n        }\\n      }\\n      if (found === false) {\\n        throw new Error(\\\"Unknown IPNS name...\\\");\\n      }\\n    } else {\\n      var found = false;\\n      if (keys !== null && keys !== undefined && Array.isArray(keys)) {\\n        for (var index = 0; index < keys.length; index++) {\\n          if (keys[index].id === ipnsKey) {\\n            ipnsName = keys[index].name;\\n            found = true;\\n            break;\\n          }\\n        }\\n      }\\n      if (found === false) {\\n        throw new Error(\\\"Unknown IPNS key...\\\");\\n      }\\n    }\\n\\n    // jest\\n    try {\\n      const url = await this.ipfsUri.normalizeUrl(\\\"/\\\" + ipnsKeyword + \\\"/\\\" + ipnsKey);\\n      this.getLogger().info(\\\"Successfully Fetched IPNS name: \\\" + ipnsName + \\\"\\\\n \\\" + url.href);\\n    } catch (error) {\\n      // Ignore\\n    }\\n\\n    return {\\n      ipnsKey: ipnsKey,\\n      ipnsName: ipnsName\\n    };\\n  };\\n\\n  IpfsWrapper.prototype.generateIpnsKey = async function(ipfs, ipnsName) {\\n    try {\\n      const key = await this.ipfsLibrary.genKey(ipfs, ipnsName);\\n      // jest\\n      try {\\n        const url = await this.ipfsUri.normalizeUrl(\\\"/\\\" + ipnsKeyword + \\\"/\\\" + key);\\n        this.getLogger().info(\\\"Successfully generated IPNS key with IPNS name: \\\" + ipnsName + \\\"\\\\n \\\" + url.href);\\n      } catch (error) {\\n        // Ignore\\n      }\\n      return key;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to generate IPNS key with IPNS name: \\\" + ipnsName);\\n  };\\n\\n  IpfsWrapper.prototype.removeIpnsKey = async function(ipfs, ipnsKey, ipnsName) {\\n    try {\\n      const hash = await this.ipfsLibrary.rmKey(ipfs, ipnsName);\\n      this.getLogger().info(\\\"Successfully removed IPNS name: \\\" + ipnsName);\\n      return hash;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to remove IPNS name: \\\" + ipnsName + \\\"\\\\n \\\" + \\\"/\\\" + ipnsKeyword + \\\"/\\\" + ipnsKey);\\n  };\\n\\n  IpfsWrapper.prototype.renameIpnsName = async function(ipfs, oldName, newName) {\\n    try {\\n      const { id: key, was, now } = await this.ipfsLibrary.renameKey(ipfs, oldName, newName);\\n      this.getLogger().info(\\\"Successfully renamed IPNS name: \\\" + was + \\\" with \\\" + now);\\n      return {\\n        key: key,\\n        name: now\\n      };\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to rename IPNS name: \\\" + oldName + \\\" with \\\" + newName);\\n  };\\n\\n  IpfsWrapper.prototype.getIpnsKeys = async function(ipfs) {\\n    try {\\n      const keys = await this.ipfsLibrary.getKeys(ipfs);\\n      this.getLogger().info(\\\"Successfully fetched IPNS keys...\\\");\\n      return keys;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to fetch IPNS keys...\\\");\\n  };\\n\\n  IpfsWrapper.prototype.fetchFromIpfs = async function(ipfs, cid) {\\n    const pathname = \\\"/\\\" + ipfsKeyword + \\\"/\\\" + cid;\\n    try {\\n      const fetched = await this.ipfsLibrary.cat(ipfs, pathname);\\n      // jest\\n      try {\\n        const url = await this.ipfsUri.normalizeUrl(pathname);\\n        this.getLogger().info(\\\"Successfully fetched:\\\" + \\\"\\\\n \\\" + url.href);\\n      } catch (error) {\\n        // Ignore\\n      }\\n      return fetched;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to fetch:\\\" + \\\"\\\\n \\\" + pathname);\\n  };\\n\\n  IpfsWrapper.prototype.addToIpfs = async function(ipfs, content) {\\n    try {\\n      const { hash, size } = await this.ipfsLibrary.add(ipfs, content);\\n      // jest\\n      try {\\n        const pathname = \\\"/\\\" + ipfsKeyword + \\\"/\\\" + hash;\\n        const url = await this.ipfsUri.normalizeUrl(pathname);\\n        this.getLogger().info(\\\"Successfully added \\\" + size + \\\" bytes:\\\" + \\\"\\\\n \\\" + url.href);\\n      } catch (error) {\\n        // Ignore\\n      }\\n      return {\\n        added: hash,\\n        size: size\\n      };\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to add content...\\\");\\n  };\\n\\n  IpfsWrapper.prototype.resolveIpnsKey = async function(ipfs, ipnsKey) {\\n    const pathname = \\\"/\\\" + ipnsKeyword + \\\"/\\\" + ipnsKey;\\n    try {\\n      const url = await this.ipfsUri.normalizeUrl(pathname);\\n      const resolved = await this.ipfsLibrary.resolve(ipfs, pathname);\\n      const { cid } = await this.ipfsLibrary.decodeCid(resolved);\\n      if (cid !== null) {\\n        // jest\\n        try {\\n          const parsed = await this.ipfsUri.normalizeUrl(\\\"/\\\" + ipfsKeyword + \\\"/\\\" + resolved);\\n          this.getLogger().info(\\\"Successfully resolved IPNS key:\\\" + \\\"\\\\n \\\" + url.href + \\\"\\\\n \\\" + parsed.href);\\n        } catch (error) {\\n          // Ignore\\n        }\\n        return cid;\\n      }\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to resolve IPNS key:\\\" + \\\"\\\\n \\\" + pathname);\\n  };\\n\\n  IpfsWrapper.prototype.publishToIpns = async function(ipfs, ipnsKey, ipnsName, cid) {\\n    // Publish\\n    const key = \\\"/\\\" + ipnsKeyword + \\\"/\\\" + ipnsKey;\\n    const pathname = \\\"/\\\" + ipfsKeyword + \\\"/\\\" + cid;\\n    try {\\n      const published = await this.ipfsLibrary.publish(ipfs, ipnsName, pathname);\\n      // jest\\n      try {\\n        const keyParsed = await this.ipfsUri.normalizeUrl(key);\\n        const parsed = await this.ipfsUri.normalizeUrl(pathname);\\n        this.getLogger().info(\\n          \\\"Successfully published IPNS name: \\\" + ipnsName + \\\"\\\\n \\\" + keyParsed.href + \\\"\\\\n \\\" + parsed.href\\n        );\\n      } catch (error) {\\n        // Ignore\\n      }\\n      return published;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to publish IPNS name: \\\" + ipnsName + \\\"\\\\n \\\" + key + \\\"\\\\n \\\" + pathname);\\n  };\\n\\n  IpfsWrapper.prototype.pinToIpfs = async function(ipfs, cid) {\\n    const pathname = \\\"/\\\" + ipfsKeyword + \\\"/\\\" + cid;\\n    try {\\n      const pinned = await this.ipfsLibrary.pin(ipfs, pathname);\\n      // jest\\n      try {\\n        const url = await this.ipfsUri.normalizeUrl(pathname);\\n        this.getLogger().info(\\\"Successfully pinned:\\\" + \\\"\\\\n \\\" + url.href);\\n      } catch (error) {\\n        // Ignore\\n      }\\n      return pinned;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to pin:\\\" + \\\"\\\\n \\\" + pathname);\\n  };\\n\\n  IpfsWrapper.prototype.unpinFromIpfs = async function(ipfs, cid) {\\n    const pathname = \\\"/\\\" + ipfsKeyword + \\\"/\\\" + cid;\\n    try {\\n      const unpinned = await this.ipfsLibrary.unpin(ipfs, pathname);\\n      // jest\\n      try {\\n        const parsed = await this.ipfsUri.normalizeUrl(pathname);\\n        this.getLogger().info(\\\"Successfully unpinned:\\\" + \\\"\\\\n \\\" + parsed.href);\\n      } catch (error) {\\n        // Ignore\\n      }\\n      return unpinned;\\n    } catch (error) {\\n      this.getLogger().error(error);\\n    }\\n    throw new Error(\\\"Failed to unpin:\\\" + \\\"\\\\n \\\" + pathname);\\n  };\\n\\n  exports.IpfsWrapper = IpfsWrapper;\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"tags\": \"$:/ipfs/core\",\n            \"module-type\": \"library\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"export to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export this tiddler to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Attachment/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Attachment/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"export attachment to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Attachment/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Attachment/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export attachment to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Content/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Content/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"export content to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Export/Content/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Export/Content/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export this tiddler content to IPFS\"\n        },\n        \"$:/language/Buttons/Ipns/Fetch/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Fetch/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"fetch from IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Fetch/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Fetch/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Fetch IPNS key\"\n        },\n        \"$:/language/Buttons/Ipns/Generate/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Generate/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"generate IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Generate/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Generate/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Generate IPNS key\"\n        },\n        \"$:/language/Buttons/Ipfs/Refresh/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Refresh/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"refresh\"\n        },\n        \"$:/language/Buttons/Ipfs/Refresh/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Refresh/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Perform a full refresh of the tiddler\"\n        },\n        \"$:/language/Buttons/Ipfs/Pin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Pin/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"pin to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Pin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Pin/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Pin this wiki to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Pin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Pin/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"pin to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Pin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Pin/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Pin tiddler resources to IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"unpin from IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Unpin tiddler resources from IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Unpin/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Unpin/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"unpin from IPFS\"\n        },\n        \"$:/language/Buttons/Ipfs/Unpin/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipfs/Unpin/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Unpin this wiki from IPFS\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Caption\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"mobile console\"\n        },\n        \"$:/language/Buttons/Console/Mobile/Hint\": {\n            \"title\": \"$:/language/Buttons/Console/Mobile/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Load/Unload Mobile Console\"\n        },\n        \"$:/language/Buttons/Ens/Manager/Open/Caption\": {\n            \"title\": \"$:/language/Buttons/Ens/Manager/Open/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"open ENS Manager\"\n        },\n        \"$:/language/Buttons/Ens/Manager/Open/Hint\": {\n            \"title\": \"$:/language/Buttons/Ens/Manager/Open/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open ENS Domain Manager\"\n        },\n        \"$:/language/Buttons/Ens/Publish/Caption\": {\n            \"title\": \"$:/language/Buttons/Ens/Publish/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"publish ENS Domain content\"\n        },\n        \"$:/language/Buttons/Ens/Publish/Hint\": {\n            \"title\": \"$:/language/Buttons/Ens/Publish/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Publish this wiki as ENS Domain content\"\n        },\n        \"$:/language/Buttons/Ens/Resolve/And/Open/Caption\": {\n            \"title\": \"$:/language/Buttons/Ens/Resolve/And/Open/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"open ENS Domain content\"\n        },\n        \"$:/language/Buttons/Ens/Resolve/And/Open/Hint\": {\n            \"title\": \"$:/language/Buttons/Ens/Resolve/And/Open/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open resolved ENS Domain content\"\n        },\n        \"$:/language/Buttons/Ipns/Publish/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Publish/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"publish to IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Publish/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Publish/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Publish this wiki to IPNS\"\n        },\n        \"$:/language/Buttons/Ipns/Remove/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Remove/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"remove\"\n        },\n        \"$:/language/Buttons/Ipns/Remove/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Remove/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Remove IPNS name and IPNS key\"\n        },\n        \"$:/language/Buttons/Ipns/Rename/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Rename/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"rename\"\n        },\n        \"$:/language/Buttons/Ipns/Rename/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Rename/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Rename IPNS name\"\n        },\n        \"$:/language/Buttons/Ipns/Resolve/And/Open/Caption\": {\n            \"title\": \"$:/language/Buttons/Ipns/Resolve/And/Open/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"resolve and open\"\n        },\n        \"$:/language/Buttons/Ipns/Resolve/And/Open/Hint\": {\n            \"title\": \"$:/language/Buttons/Ipns/Resolve/And/Open/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Open resolved IPNS key\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Saver\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"These settings are only used when saving to IPFS.\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Verbose\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Verbose\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Saver Verbose\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Url\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Url\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Server URL\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/ApiUrl\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/ApiUrl\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"API\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/GatewayUrl\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/GatewayUrl\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Gateway\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Ens\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Ens\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ENS\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/EnsDomain\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/EnsDomain\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ENS domain\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Ipns\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Ipns\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/IpnsName\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/IpnsName\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS name\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/IpnsKey\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/IpnsKey\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS key\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Resolved\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Resolved\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Resolved\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Global\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Global\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Global\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Verbose/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Verbose/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Verbose\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Unpin/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Unpin/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Unpin previous content\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Wait/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Wait/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Wait\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Policy\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Policy\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Relative URL Policy\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Policy/Origin/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Policy/Origin/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Origin\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Policy/Gateway/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Policy/Gateway/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Gateway\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Protocol\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Protocol\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Protocol\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Protocol/Ens/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Protocol/Ens/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"ENS\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Protocol/Ipfs/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Protocol/Ipfs/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Protocol/Ipns/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Protocol/Ipns/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPNS\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Export\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Export\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Export\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Export/Static/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Export/Static/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Static\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Export/Json/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Export/Json/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"JSON\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Export/Tid/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Export/Tid/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"TID\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Provider\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Provider\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Provider\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Provider/Default/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Provider/Default/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Default\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Provider/Window/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Provider/Window/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"IPFS Companion\"\n        },\n        \"$:/language/ControlPanel/Saving/IpfsService/Provider/HTTP/Description\": {\n            \"title\": \"$:/language/ControlPanel/Saving/IpfsService/Provider/HTTP/Description\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"HTTP Client\"\n        },\n        \"$:/language/ControlPanel/Basics/Version/Prompt\": {\n            \"title\": \"$:/language/ControlPanel/Basics/Version/Prompt\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<b>~TiddlyWiki</b>:\"\n        },\n        \"$:/language/ControlPanel/Ipfs/Version/Prompt\": {\n            \"title\": \"$:/language/ControlPanel/Ipfs/Version/Prompt\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"<b>IPFS</b>:\"\n        },\n        \"$:/language/ControlPanel/Settings/PreferredSaver/Caption\": {\n            \"title\": \"$:/language/ControlPanel/Settings/PreferredSaver/Caption\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Preferred Saver\"\n        },\n        \"$:/language/ControlPanel/Appearance/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Appearance/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Ways to customise the appearance of your <b>~TiddlyWiki</b>.\"\n        },\n        \"$:/language/ControlPanel/Info/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Info/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Information about this <b>~TiddlyWiki</b>\"\n        },\n        \"$:/language/ControlPanel/Saving/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Saving/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"Settings used for saving the entire <b>~TiddlyWiki</b> as a single file via a saver module.\"\n        },\n        \"$:/language/ControlPanel/Settings/Hint\": {\n            \"title\": \"$:/language/ControlPanel/Settings/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"text\": \"These settings let you customise the behaviour of <b>~TiddlyWiki</b>.\"\n        },\n        \"$:/language/EditTemplate/Body/External/Hint\": {\n            \"title\": \"$:/language/EditTemplate/Body/External/Hint\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"text\": \"This tiddler shows content stored outside of the main ~TiddlyWiki file.<br/>You can edit the tags and fields but cannot directly edit the content itself\"\n        },\n        \"$:/language/NetworkError/XMLHttpRequest\": {\n            \"title\": \"$:/language/NetworkError/XMLHttpRequest\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"text\": \"Network Error while loading.\"\n        },\n        \"$:/language/LazyLoadingWarning\": {\n            \"title\": \"$:/language/LazyLoadingWarning\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"text\": \"<p>Trying to load external Tiddler content from:<p></p>''<$ipfslink caption={{!!_canonical_uri}} value={{!!_canonical_uri}} tiddler=<<currentTiddler>>/>''</p>\"\n        },\n        \"$:/language/EmptyTidddler\": {\n            \"title\": \"$:/language/EmptyTidddler\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"text\": \"<p>An external Tiddler content has been loaded:</p><p>''<$ipfslink caption={{!!_canonical_uri}} value={{!!_canonical_uri}} tiddler=<<currentTiddler>>/>''</p><p>The imported Tiddler content is empty, possible reasons:</p><ul><li>The Tiddler Content Type doesn't match the type of the external content.</li>\"\n        },\n        \"$:/plugins/ipfs/changelog\": {\n            \"title\": \"$:/plugins/ipfs/changelog\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"!! v0.3.0\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.2.9...v0.3.0]]\\n\\n!! v0.2.9\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.2.8...v0.2.9]]\\n\\n!! v0.2.8\\n\\n[[See GitHub for detailed change history of this release|https://github.com/xmaysonnave/tiddlywiki-ipfs/compare/v0.2.7...v0.2.8]]\\n\\n...\\n\\n!! 0.2.2\\n\\n* First public release\"\n        },\n        \"$:/plugins/ipfs/readme\": {\n            \"title\": \"$:/plugins/ipfs/readme\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"!! IPFS with ~TiddlyWiki\\n\\nFeatures:\\n\\n* Persist over [ext[IPFS|https://ipfs.io/]] saved <b>~TiddlyWiki's</b> and file attachments\\n* Publish IPNS Names when <b>~TiddlyWiki</b> are saved\\n* Interact with Ethereum wallets [ext[Metamask|https://metamask.io]] or [ext[Frame|https://frame.sh]]\\n* Publish to [ext[ENS|https://ens.domains]]\\n\\nSupported Browsers:\\n\\n* [ext[Firefox|https://www.mozilla.org]]\\n* [ext[Chrome|https://www.google.com/chrome/]]\\n* [ext[Chromium|https://www.chromium.org]]\\n\\nSupported Ethereum wallets:\\n\\n* [ext[Metamask|https://metamask.io]]\\n* [ext[Frame|https://frame.sh]]\\n\\nSupported Mobile App browser:\\n\\n* [ext[Metamask|https://metamask.io]]\\n\\nSupported ENS Ethereum Networks\\n\\n* 'Mainnet': Ethereum Main Network\\n* 'Ropsten': Ethereum Test Network (~PoW)\\n* 'Rinkeby': Ethereum Test Network (~PoA)\\n* 'Goerli': Ethereum Test Network (~PoA)\\n\\nResources:\\n\\n* https://github.com/xmaysonnave/tiddlywiki-ipfs/\\n* https://github.com/xmaysonnave/tiddlywiki-ipfs/blob/master/README.md\\n\\n!! With a capable ENS browser:\\n\\n* [ext[IPFS with TiddlyWiki|https://bluelightav.eth]] on \\\"Mainnet: Ethereum Main Network\\\"\\n* <$ipfslink caption=\\\"IPFS with TiddlyWiki Development\\\" value=\\\"https://bluelightav.eth\\\" tiddler=<<currentTiddler>>/> on \\\"[ext[Ropsten|https://faucet.ropsten.be/]] (~PoW): Ethereum Test Network\\\"\\n* [ext[IPFS with TiddlyWiki plugin|https://bluelightav.eth/#%24%3A%2Fplugins%2Fipfs]]\\n* [ext[IPFS with TiddlyWiki Documentation|https://bluelightav.eth/#IPFS%20Documentation]]\\n\\n!! With a non capable ENS browser:\\n\\n* [ext[IPFS with TiddlyWiki|https://bluelightav.eth.link]]\\n* [ext[IPFS with TiddlyWiki plugin|https://bluelightav.eth.link/#%24%3A%2Fplugins%2Fipfs]]\\n* [ext[IPFS with TiddlyWiki Documentation|https://bluelightav.eth.link/#IPFS%20Documentation]]\"\n        },\n        \"$:/ipfs/saver/api/http/localhost/5001\": {\n            \"title\": \"$:/ipfs/saver/api/http/localhost/5001\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"http://127.0.0.1:5001\"\n        },\n        \"$:/ipfs/saver/api/https/ipfs.infura.io/5001\": {\n            \"title\": \"$:/ipfs/saver/api/https/ipfs.infura.io/5001\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"https://ipfs.infura.io:5001\"\n        },\n        \"$:/ipfs/saver/api/https/ipfs.bluelightav.org\": {\n            \"title\": \"$:/ipfs/saver/api/https/ipfs.bluelightav.org\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/api\",\n            \"text\": \"https://ipfs.bluelightav.org\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.busy.org\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.busy.org\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.busy.org\"\n        },\n        \"$:/ipfs/saver/gateway/https/cloudflare-ipfs.com\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/cloudflare-ipfs.com\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://cloudflare-ipfs.com\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.eternum.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.eternum.io\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.eternum.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.bluelightav.org\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.bluelightav.org\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.bluelightav.org\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.ipfs.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.ipfs.io\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.ipfs.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.greyh.at\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.greyh.at\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.greyh.at\"\n        },\n        \"$:/ipfs/saver/gateway/https/hardbin.com\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/hardbin.com\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://hardbin.com\"\n        },\n        \"$:/ipfs/saver/gateway/http/localhost\": {\n            \"title\": \"$:/ipfs/saver/gateway/http/localhost\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"http://127.0.0.1:8080\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.infura.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.infura.io\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.infura.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.bluelightav.org\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.bluelightav.org\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.bluelightav.org\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.io\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.jes.xxx\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.jes.xxx\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.jes.xxx\"\n        },\n        \"$:/ipfs/saver/gateway/https/ninetailed.ninja\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ninetailed.ninja\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ninetailed.ninja\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.pinata.cloud\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.pinata.cloud\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.pinata.cloud\"\n        },\n        \"$:/ipfs/saver/gateway/https/siderus.io\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/siderus.io\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://siderus.io\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.sloppyta.co\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.sloppyta.co\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.sloppyta.co\"\n        },\n        \"$:/ipfs/saver/gateway/https/gateway.temporal.cloud\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/gateway.temporal.cloud\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://gateway.temporal.cloud\"\n        },\n        \"$:/ipfs/saver/gateway/https/ipfs.wa.hle.rs\": {\n            \"title\": \"$:/ipfs/saver/gateway/https/ipfs.wa.hle.rs\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/ipfs/saver/gateway\",\n            \"text\": \"https://ipfs.wa.hle.rs\"\n        },\n        \"$:/core/ui/Buttons/ipfs/console/mobile\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/console/mobile\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core  $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/preview-open}} {{$:/language/Buttons/Console/Mobile/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Console/Mobile/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-console-mobile\\\" tooltip={{$:/language/Buttons/Console/Mobile/Hint}} aria-label={{$:/language/Buttons/Console/Mobile/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/preview-open}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Console/Mobile/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/pin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/pin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/chevron-up}} {{$:/language/Buttons/Ipfs/Pin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Pin/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ipfs-pin\\\" tooltip={{$:/language/Buttons/Ipfs/Pin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Pin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-up}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipfs/Pin/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ens/publish\": {\n            \"title\": \"$:/core/ui/Buttons/ens/publish\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/ens}} {{$:/language/Buttons/Ens/Publish/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ens/Publish/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ens-publish\\\" tooltip={{$:/language/Buttons/Ens/Publish/Hint}} aria-label={{$:/language/Buttons/Ens/Publish/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/ens}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ens/Publish/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipns/publish\": {\n            \"title\": \"$:/core/ui/Buttons/ipns/publish\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/excise}} {{$:/language/Buttons/Ipns/Publish/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipns/Publish/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ipns-publish\\\" tooltip={{$:/language/Buttons/Ipns/Publish/Hint}} aria-label={{$:/language/Buttons/Ipns/Publish/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/excise}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Publish/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/unpin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/unpin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core  $:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/chevron-down}} {{$:/language/Buttons/Ipfs/Unpin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Unpin/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-ipfs-unpin\\\" tooltip={{$:/language/Buttons/Ipfs/Unpin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Unpin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-down}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipfs/Unpin/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/ControlPanel/Saving/Ipfs\": {\n            \"title\": \"$:/core/ui/ControlPanel/Saving/Ipfs\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ControlPanel/Saving\",\n            \"caption\": \"{{$:/language/ControlPanel/Saving/IpfsService/Caption}}\",\n            \"text\": \"\\\\define lingo-base() $:/language/ControlPanel/Saving/IpfsService/\\n\\\\define service-name() Ipfs\\n\\n<<lingo Description>>\\n\\n''<<lingo Global>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"90%\\\"><<lingo Verbose/Description>></td>\\n<td width=\\\"10%\\\"><$checkbox tiddler=\\\"$:/ipfs/saver/verbose\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"yes\\\"/></td>\\n</tr>\\n<tr>\\n<td width=\\\"90%\\\"><<lingo Unpin/Description>></td>\\n<td width=\\\"10%\\\"><$checkbox tiddler=\\\"$:/ipfs/saver/unpin\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"/></td>\\n</tr>\\n</tbody>\\n</table>\\n\\n''<<lingo Provider>>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/provider\\\" value=\\\"default\\\"><<lingo Provider/Default/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/provider\\\" value=\\\"window\\\"><<lingo Provider/Window/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/provider\\\" value=\\\"http\\\"><<lingo Provider/HTTP/Description>></$radio>\\n\\n''<<lingo Export>>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/export\\\" value=\\\"json\\\"><<lingo Export/Json/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/export\\\" value=\\\"static\\\"><<lingo Export/Static/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/export\\\" value=\\\"tid\\\"><<lingo Export/Tid/Description>></$radio>\\n\\n''<<lingo Protocol>>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/protocol\\\" value=\\\"ens\\\"><<lingo Protocol/Ens/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/protocol\\\" value=\\\"ipfs\\\"><<lingo Protocol/Ipfs/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/protocol\\\" value=\\\"ipns\\\"><<lingo Protocol/Ipns/Description>></$radio>\\n\\n''<<lingo Policy>>''\\n\\n<$radio tiddler=\\\"$:/ipfs/saver/policy\\\" value=\\\"origin\\\"><<lingo Policy/Origin/Description>></$radio>\\n<$radio tiddler=\\\"$:/ipfs/saver/policy\\\" value=\\\"gateway\\\"><<lingo Policy/Gateway/Description>></$radio>\\n\\n''<<lingo Url>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"20%\\\"><<lingo ApiUrl>></td>\\n<td width=\\\"80%\\\">\\n<$select tiddler=\\\"$:/ipfs/saver/api\\\" default=\\\"$:/ipfs/saver/api/https/ipfs.infura.io/5001\\\" class=\\\"tc-edit-texteditor\\\">\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/ipfs/saver/api]!has[draft.of]]\\\">\\n<option value=<<currentTiddler>>><$transclude field=\\\"text\\\"><$text text=<<currentTiddler>>/></$transclude></option>\\n</$list>\\n</$select>\\n</td>\\n</tr>\\n<tr>\\n<td width=\\\"20%\\\"><<lingo GatewayUrl>></td>\\n<td width=\\\"80%\\\">\\n<$select tiddler=\\\"$:/ipfs/saver/gateway\\\" default=\\\"$:/ipfs/saver/gateway/https/ipfs.infura.io\\\" class=\\\"tc-edit-texteditor\\\">\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/ipfs/saver/gateway]!has[draft.of]]\\\">\\n<option value=<<currentTiddler>>><$transclude field=\\\"text\\\"><$text text=<<currentTiddler>>/></$transclude></option>\\n</$list>\\n</$select>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n\\n''<<lingo Ens>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"20%\\\"><<lingo EnsDomain>></td>\\n<td width=\\\"80%\\\"><$edit-text tiddler=\\\"$:/ipfs/saver/ens/domain\\\" class=\\\"tc-edit-texteditor\\\" default=\\\"\\\" tag=\\\"input\\\"/></td>\\n</tr>\\n</tbody>\\n</table>\\n\\n<table style=\\\"width:20%;margin-left:40%;margin-right:40%;text-align:center;\\\">\\n<tbody>\\n<tr>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ens-manager-open\\\" tooltip={{$:/language/Buttons/Ens/Manager/Open/Hint}} aria-label={{$:/language/Buttons/Ens/Manager/Open/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/ens}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ens/Manager/Open/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ens-resolve-and-open\\\" tooltip={{$:/language/Buttons/Ens/Resolve/And/Open/Hint}} aria-label={{$:/language/Buttons/Ens/Resolve/And/Open/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/globe}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ens/Resolve/And/Open/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n\\n''<<lingo Ipns>>''\\n\\n<table>\\n<tbody>\\n<tr>\\n<td width=\\\"20%\\\"><<lingo IpnsName>></td>\\n<td width=\\\"80%\\\"><$edit-text tiddler=\\\"$:/ipfs/saver/ipns/name\\\" class=\\\"tc-edit-texteditor\\\" default=\\\"\\\" tag=\\\"input\\\"/></td>\\n</tr>\\n<tr>\\n<td width=\\\"20%\\\"><<lingo IpnsKey>></td>\\n<td width=\\\"80%\\\"><$text text={{$:/ipfs/saver/ipns/key}} class=\\\"tc-edit-texteditor\\\"/></td>\\n</tr>\\n</tbody>\\n</table>\\n\\n<table style=\\\"width:50%;margin-left:25%;margin-right:25%;text-align:center;\\\">\\n<tbody>\\n<tr>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-rename\\\" tooltip={{$:/language/Buttons/Ipns/Rename/Hint}} aria-label={{$:/language/Buttons/Ipns/Rename/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/mono-line}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Rename/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-generate\\\" tooltip={{$:/language/Buttons/Ipns/Generate/Hint}} aria-label={{$:/language/Buttons/Ipns/Generate/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/new-here-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Generate/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-remove\\\" tooltip={{$:/language/Buttons/Ipns/Remove/Hint}} aria-label={{$:/language/Buttons/Ipns/Remove/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/delete-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Remove/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-fetch\\\" tooltip={{$:/language/Buttons/Ipns/Fetch/Hint}} aria-label={{$:/language/Buttons/Ipns/Fetch/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/refresh-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Fetch/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n<td style=\\\"width:10%\\\">\\n<$button message=\\\"tm-ipns-resolve-and-open\\\" tooltip={{$:/language/Buttons/Ipns/Resolve/And/Open/Hint}} aria-label={{$:/language/Buttons/Ipns/Resolve/And/Open/Caption}} class=\\\"tc-btn-invisible tc-ipfs-action\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/globe}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipns/Resolve/And/Open/Caption}}/></span>\\n</$list>\\n</$button>\\n</td>\\n</tr>\\n</tbody>\\n</table>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/export/attachment\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/export/attachment\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/ipfs}} {{$:/language/Buttons/Ipfs/Export/Attachment/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Export/Attachment/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-export-attachment\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Export/Attachment/Hint}} aria-label={{$:/language/Buttons/Ipfs/Export/Attachment/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/ipfs}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Export/Attachment/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/export/content\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/export/content\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/excise}} {{$:/language/Buttons/Ipfs/Export/Content/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Export/Content/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-export-content\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Export/Content/Hint}} aria-label={{$:/language/Buttons/Ipfs/Export/Content/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/excise}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Export/Content/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/export\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/export\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/excise}} {{$:/language/Buttons/Ipfs/Export/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Export/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-export\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Export/Hint}} aria-label={{$:/language/Buttons/Ipfs/Export/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/excise}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Export/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/refresh\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/refresh\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/refresh-button}} {{$:/language/Buttons/Ipfs/Refresh/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Refresh/Hint}}\",\n            \"text\": \"<$button message=\\\"tm-refresh-tiddler\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Refresh/Hint}} aria-label={{$:/language/Buttons/Ipfs/Refresh/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/refresh-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/Ipfs/Refresh/Caption}}/></span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/tiddler/pin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/tiddler/pin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/chevron-up}} {{$:/language/Buttons/Ipfs/Tiddler/Pin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Tiddler/Pin/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-pin\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Tiddler/Pin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Tiddler/Pin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-up}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Tiddler/Pin/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/core/ui/Buttons/ipfs/tiddler/unpin\": {\n            \"title\": \"$:/core/ui/Buttons/ipfs/tiddler/unpin\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/chevron-down}} {{$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint}}\",\n            \"text\": \"\\\\whitespace trim\\n<$button message=\\\"tm-ipfs-unpin\\\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Ipfs/Tiddler/Unpin/Hint}} aria-label={{$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/core/images/chevron-down}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Ipfs/Tiddler/Unpin/Caption}}/>\\n</span>\\n</$list>\\n</$button>\"\n        },\n        \"$:/plugins/ipfs/styles\": {\n            \"title\": \"$:/plugins/ipfs/styles\",\n            \"created\": \"20200420094915385\",\n            \"modified\": \"20200420094915385\",\n            \"tags\": \"$:/ipfs/core $:/tags/Stylesheet\",\n            \"type\": \"text/css\",\n            \"text\": \".tc-ipfs-action {\\n  display: block;\\n  margin: auto;\\n  width: 18px;\\n  height: 18px;\\n}\\n\\n.tc-icon-ipfs-wrapper {\\n  display: inline-block;\\n  width: 1em;\\n  height: 1em;\\n}\\n\\na.tc-ipfs-link-external {\\n\\ttext-decoration: underline;\\n\\tcolor: <<colour external-link-foreground>>;\\n\\tbackground-color: <<colour external-link-background>>;\\n}\\n\\na.tc-ipfs-link-external:visited {\\n\\tcolor: <<colour external-link-foreground-visited>>;\\n\\tbackground-color: <<colour external-link-background-visited>>;\\n}\\n\\na.tc-ipfs-link-external:hover {\\n\\tcolor: <<colour external-link-foreground-hover>>;\\n\\tbackground-color: <<colour external-link-background-hover>>;\\n  cursor: pointer;\\n}\"\n        }\n    }\n}"
}