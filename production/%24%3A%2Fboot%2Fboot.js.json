{
    "title": "$:/boot/boot.js",
    "text": "/*\\\ntitle: $:/boot/boot.js\ntype: application/javascript\ntags: $:/ipfs/core\n\nThe main boot kernel for TiddlyWiki. This single file creates a barebones TW environment that is just sufficient to bootstrap the modules containing the main logic of the application.\n\nOn the server this file is executed directly to boot TiddlyWiki. In the browser, this file is packed into a single HTML file.\n\n\\*/\n\nvar _boot = function ($tw) {\n  /*jslint node: true, browser: true */\n  'use strict'\n\n  // Include bootprefix if we're not given module data\n  if (!$tw) {\n    $tw = require('./bootprefix.js').bootprefix()\n  }\n\n  $tw.utils = $tw.utils || Object.create(null)\n\n  /////////////////////////// Standard node.js libraries\n\n  var fs, path, vm\n  if ($tw.node) {\n    fs = require('fs')\n    path = require('path')\n    vm = require('vm')\n  }\n\n  /////////////////////////// Utility functions\n\n  $tw.boot.log = function (str) {\n    $tw.boot.logMessages = $tw.boot.logMessages || []\n    $tw.boot.logMessages.push(str)\n  }\n\n  /**\n   * Check if an object has a property\n   */\n  $tw.utils.hop = function (object, property) {\n    return object\n      ? Object.prototype.hasOwnProperty.call(object, property)\n      : false\n  }\n\n  /**\n   * Determine if a value is an array\n   */\n  $tw.utils.isArray = function (value) {\n    return Object.prototype.toString.call(value) === '[object Array]'\n  }\n\n  /**\n   * Check if an array is equal by value and by reference.\n   */\n  $tw.utils.isArrayEqual = function (array1, array2) {\n    if (array1 === array2) {\n      return true\n    }\n    array1 = array1 || []\n    array2 = array2 || []\n    if (array1.length !== array2.length) {\n      return false\n    }\n    return array1.every(function (value, index) {\n      return value === array2[index]\n    })\n  }\n\n  /**\n   * Push entries onto an array, removing them first if they already exist in the array\n   * array: array to modify (assumed to be free of duplicates)\n   * value: a single value to push or an array of values to push\n   */\n  $tw.utils.pushTop = function (array, value) {\n    var t, p\n    if ($tw.utils.isArray(value)) {\n      // Remove any array entries that are duplicated in the new values\n      if (value.length !== 0) {\n        if (array.length !== 0) {\n          if (value.length < array.length) {\n            for (t = 0; t < value.length; t++) {\n              p = array.indexOf(value[t])\n              if (p !== -1) {\n                array.splice(p, 1)\n              }\n            }\n          } else {\n            for (t = array.length - 1; t >= 0; t--) {\n              p = value.indexOf(array[t])\n              if (p !== -1) {\n                array.splice(t, 1)\n              }\n            }\n          }\n        }\n        // Push the values on top of the main array\n        array.push.apply(array, value)\n      }\n    } else {\n      p = array.indexOf(value)\n      if (p !== -1) {\n        array.splice(p, 1)\n      }\n      array.push(value)\n    }\n    return array\n  }\n\n  /**\n   * Determine if a value is a date\n   */\n  $tw.utils.isDate = function (value) {\n    return Object.prototype.toString.call(value) === '[object Date]'\n  }\n\n  /**\n   * Iterate through all the own properties of an object or array. Callback is invoked with (element,title,object)\n   */\n  $tw.utils.each = function (object, callback) {\n    var next, f, length\n    if (object) {\n      if (Object.prototype.toString.call(object) === '[object Array]') {\n        for (f = 0, length = object.length; f < length; f++) {\n          next = callback(object[f], f, object)\n          if (next === false) {\n            break\n          }\n        }\n      } else {\n        var keys = Object.keys(object)\n        for (f = 0, length = keys.length; f < length; f++) {\n          var key = keys[f]\n          next = callback(object[key], key, object)\n          if (next === false) {\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Helper for making DOM elements\n   * tag: tag name\n   * options: see below\n   * Options include:\n   * namespace: defaults to http://www.w3.org/1999/xhtml\n   * attributes: hashmap of attribute values\n   * style: hashmap of styles\n   * text: text to add as a child node\n   * children: array of further child nodes\n   * innerHTML: optional HTML for element\n   * class: class name(s)\n   * document: defaults to current document\n   * eventListeners: array of event listeners (this option won't work until $tw.utils.addEventListeners() has been loaded)\n   */\n  $tw.utils.domMaker = function (tag, options) {\n    var doc = options.document || document\n    var element = doc.createElementNS(\n      options.namespace || 'http://www.w3.org/1999/xhtml',\n      tag\n    )\n    if (options.class) {\n      element.className = options.class\n    }\n    if (options.text) {\n      element.appendChild(doc.createTextNode(options.text))\n    }\n    $tw.utils.each(options.children, function (child) {\n      element.appendChild(child)\n    })\n    if (options.innerHTML) {\n      element.innerHTML = options.innerHTML\n    }\n    $tw.utils.each(options.attributes, function (attribute, name) {\n      element.setAttribute(name, attribute)\n    })\n    $tw.utils.each(options.style, function (value, name) {\n      element.style[name] = value\n    })\n    if (options.eventListeners) {\n      $tw.utils.addEventListeners(element, options.eventListeners)\n    }\n    return element\n  }\n\n  /**\n   * Display an error and exit\n   */\n  $tw.utils.error = function (err) {\n    // Prepare the error message\n    var errHeading =\n      $tw.language === undefined\n        ? 'Internal JavaScript Error'\n        : $tw.language.getString('InternalJavaScriptError/Title')\n    var promptMsg =\n      $tw.language === undefined\n        ? 'Well, this is embarrassing. It is recommended that you restart TiddlyWiki by refreshing your browser'\n        : $tw.language.getString('InternalJavaScriptError/Hint')\n    // Log the error to the console\n    console.error($tw.node ? '\\x1b[1;31m' + err + '\\x1b[0m' : err)\n    if ($tw.browser && !$tw.node) {\n      // Display an error message to the user\n      var dm = $tw.utils.domMaker\n      var heading = dm('h1', { text: errHeading })\n      var prompt = dm('div', { text: promptMsg, class: 'tc-error-prompt' })\n      var message = dm('div', { text: err, class: 'tc-error-message' })\n      var button = dm('div', {\n        children: [\n          dm('button', {\n            text:\n              $tw.language === undefined\n                ? 'close'\n                : $tw.language.getString('Buttons/Close/Caption')\n          })\n        ],\n        class: 'tc-error-prompt'\n      })\n      var form = dm('form', {\n        children: [heading, prompt, message, button],\n        class: 'tc-error-form'\n      })\n      document.body.insertBefore(form, document.body.firstChild)\n      form.addEventListener(\n        'submit',\n        function (event) {\n          document.body.removeChild(form)\n          event.preventDefault()\n          return false\n        },\n        true\n      )\n      return null\n    } else if (!$tw.browser) {\n      // Exit if we're under node.js\n      process.exit(1)\n    }\n  }\n\n  /**\n   * Use our custom error handler if we're in the browser\n   */\n  if ($tw.boot.tasks.trapErrors) {\n    window.onerror = function (errorMsg, url, lineNumber) {\n      $tw.utils.error(errorMsg)\n      return false\n    }\n  }\n\n  /**\n   * Extend an object with the properties from a list of source objects\n   */\n  $tw.utils.extend = function (object /*, sourceObjectList */) {\n    $tw.utils.each(Array.prototype.slice.call(arguments, 1), function (source) {\n      if (source) {\n        for (var p in source) {\n          object[p] = source[p]\n        }\n      }\n    })\n    return object\n  }\n\n  /**\n   * Fill in any null or undefined properties of an object with the properties from a list of source objects.\n   * Each property that is an object is called recursively\n   */\n  $tw.utils.deepDefaults = function (object /*, sourceObjectList */) {\n    $tw.utils.each(Array.prototype.slice.call(arguments, 1), function (source) {\n      if (source) {\n        for (var p in source) {\n          if (object[p] === null || object[p] === undefined) {\n            object[p] = source[p]\n          }\n          if (typeof object[p] === 'object' && typeof source[p] === 'object') {\n            $tw.utils.deepDefaults(object[p], source[p])\n          }\n        }\n      }\n    })\n    return object\n  }\n\n  /**\n   * Convert \"&amp;\" to &, \"&nbsp;\" to nbsp, \"&lt;\" to <, \"&gt;\" to > and \"&quot;\" to \"\n   */\n  $tw.utils.htmlDecode = function (s) {\n    return s\n      .toString()\n      .replace(/&lt;/gm, '<')\n      .replace(/&nbsp;/gm, '\\xA0')\n      .replace(/&gt;/gm, '>')\n      .replace(/&quot;/gm, '\"')\n      .replace(/&amp;/gm, '&')\n  }\n\n  /**\n   * Get the browser location.hash. We don't use location.hash because of the way that Firefox auto-urldecodes it\n   * (see http://stackoverflow.com/questions/1703552/encoding-of-window-location-hash)\n   */\n  $tw.utils.getLocationHash = function () {\n    var parts = window.location.href.split('#')\n    return '#' + (parts.length > 1 ? parts[1] : '')\n  }\n\n  /**\n   * Pad a string to a given length with \"0\"s. Length defaults to 2\n   */\n  $tw.utils.pad = function (value, length) {\n    length = length || 2\n    var s = value.toString()\n    if (s.length < length) {\n      s = '000000000000000000000000000'.substr(0, length - s.length) + s\n    }\n    return s\n  }\n\n  // Convert a date into UTC YYYYMMDDHHMMSSmmm format\n  $tw.utils.stringifyDate = function (value) {\n    return (\n      value.getUTCFullYear() +\n      $tw.utils.pad(value.getUTCMonth() + 1) +\n      $tw.utils.pad(value.getUTCDate()) +\n      $tw.utils.pad(value.getUTCHours()) +\n      $tw.utils.pad(value.getUTCMinutes()) +\n      $tw.utils.pad(value.getUTCSeconds()) +\n      $tw.utils.pad(value.getUTCMilliseconds(), 3)\n    )\n  }\n\n  // Parse a date from a UTC YYYYMMDDHHMMSSmmm format string\n  $tw.utils.parseDate = function (value) {\n    if (typeof value === 'string') {\n      return new Date(\n        Date.UTC(\n          parseInt(value.substr(0, 4), 10),\n          parseInt(value.substr(4, 2), 10) - 1,\n          parseInt(value.substr(6, 2), 10),\n          parseInt(value.substr(8, 2) || '00', 10),\n          parseInt(value.substr(10, 2) || '00', 10),\n          parseInt(value.substr(12, 2) || '00', 10),\n          parseInt(value.substr(14, 3) || '000', 10)\n        )\n      )\n    } else if ($tw.utils.isDate(value)) {\n      return value\n    } else {\n      return null\n    }\n  }\n\n  // Stringify an array of tiddler titles into a list string\n  $tw.utils.stringifyList = function (value) {\n    if ($tw.utils.isArray(value)) {\n      var result = new Array(value.length)\n      for (var t = 0, l = value.length; t < l; t++) {\n        var entry = value[t] || ''\n        if (entry.indexOf(' ') !== -1) {\n          result[t] = '[[' + entry + ']]'\n        } else {\n          result[t] = entry\n        }\n      }\n      return result.join(' ')\n    } else {\n      return value || ''\n    }\n  }\n\n  // Parse a string array from a bracketted list. For example \"OneTiddler [[Another Tiddler]] LastOne\"\n  $tw.utils.parseStringArray = function (value, allowDuplicate) {\n    if (typeof value === 'string') {\n      var memberRegExp = /(?:^|[^\\S\\xA0])(?:\\[\\[(.*?)\\]\\])(?=[^\\S\\xA0]|$)|([\\S\\xA0]+)/gm\n      var results = []\n      var names = {}\n      var match\n      do {\n        match = memberRegExp.exec(value)\n        if (match) {\n          var item = match[1] || match[2]\n          if (\n            item !== undefined &&\n            (!$tw.utils.hop(names, item) || allowDuplicate)\n          ) {\n            results.push(item)\n            names[item] = true\n          }\n        }\n      } while (match)\n      return results\n    } else if ($tw.utils.isArray(value)) {\n      return value\n    } else {\n      return null\n    }\n  }\n\n  // Parse a block of name:value fields. The `fields` object is used as the basis for the return value\n  $tw.utils.parseFields = function (text, fields) {\n    fields = fields || Object.create(null)\n    text.split(/\\r?\\n/gm).forEach(function (line) {\n      if (line.charAt(0) !== '#') {\n        var p = line.indexOf(':')\n        if (p !== -1) {\n          var field = line.substr(0, p).trim()\n          var value = line.substr(p + 1).trim()\n          if (field) {\n            fields[field] = value\n          }\n        }\n      }\n    })\n    return fields\n  }\n\n  /**\n   * Resolves a source filepath delimited with `/` relative to a specified absolute root filepath.\n   * In relative paths, the special folder name `..` refers to immediate parent directory, and the\n   * name `.` refers to the current directory\n   */\n  $tw.utils.resolvePath = function (sourcepath, rootpath) {\n    // If the source path starts with ./ or ../ then it is relative to the root\n    if (sourcepath.substr(0, 2) === './' || sourcepath.substr(0, 3) === '../') {\n      var src = sourcepath.split('/')\n      var root = rootpath.split('/')\n      // Remove the filename part of the root\n      root.splice(root.length - 1, 1)\n      // Process the source path bit by bit onto the end of the root path\n      while (src.length > 0) {\n        var c = src.shift()\n        if (c === '..') {\n          // Slice off the last root entry for a double dot\n          if (root.length > 0) {\n            root.splice(root.length - 1, 1)\n          }\n        } else if (c !== '.') {\n          // Ignore dots\n          root.push(c) // Copy other elements across\n        }\n      }\n      return root.join('/')\n    } else {\n      // If it isn't relative, just return the path\n      if (rootpath) {\n        var root = rootpath.split('/')\n        // Remove the filename part of the root\n        root.splice(root.length - 1, 1)\n        return root.join('/') + '/' + sourcepath\n      } else {\n        return sourcepath\n      }\n    }\n  }\n\n  /**\n   * Parse a semantic version string into its constituent parts -- see https://semver.org\n   */\n  $tw.utils.parseVersion = function (version) {\n    /*eslint no-useless-escape:\"off\"*/\n    var match = /^v?((\\d+)\\.(\\d+)\\.(\\d+))(?:-([\\dA-Za-z\\-]+(?:\\.[\\dA-Za-z\\-]+)*))?(?:\\+([\\dA-Za-z\\-]+(?:\\.[\\dA-Za-z\\-]+)*))?$/.exec(\n      version\n    )\n    if (match) {\n      return {\n        version: match[1],\n        major: parseInt(match[2], 10),\n        minor: parseInt(match[3], 10),\n        patch: parseInt(match[4], 10),\n        prerelease: match[5],\n        build: match[6]\n      }\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Returns +1 if the version string A is greater than the version string B, 0 if they are the same, and +1 if B is greater than A.\n   * Missing or malformed version strings are parsed as 0.0.0\n   */\n  $tw.utils.compareVersions = function (versionStringA, versionStringB) {\n    var defaultVersion = {\n      major: 0,\n      minor: 0,\n      patch: 0\n    }\n    var versionA = $tw.utils.parseVersion(versionStringA) || defaultVersion\n    var versionB = $tw.utils.parseVersion(versionStringB) || defaultVersion\n    var diff = [\n      versionA.major - versionB.major,\n      versionA.minor - versionB.minor,\n      versionA.patch - versionB.patch\n    ]\n    if (\n      diff[0] > 0 ||\n      (diff[0] === 0 && diff[1] > 0) ||\n      (diff[0] === 0) & (diff[1] === 0) & (diff[2] > 0)\n    ) {\n      return +1\n    } else if (\n      diff[0] < 0 ||\n      (diff[0] === 0 && diff[1] < 0) ||\n      (diff[0] === 0) & (diff[1] === 0) & (diff[2] < 0)\n    ) {\n      return -1\n    } else {\n      return 0\n    }\n  }\n\n  /**\n   * Returns true if the version string A is greater than the version string B. Returns true if the versions are the same\n   */\n  $tw.utils.checkVersions = function (versionStringA, versionStringB) {\n    return $tw.utils.compareVersions(versionStringA, versionStringB) !== -1\n  }\n\n  /**\n   * Register file type information\n   * options: {flags: flags,deserializerType: deserializerType}\n   * flags:\"image\" for image types\n   * deserializerType: defaults to type if not specified\n   */\n  $tw.utils.registerFileType = function (type, encoding, extension, options) {\n    options = options || {}\n    if ($tw.utils.isArray(extension)) {\n      $tw.utils.each(extension, function (extension) {\n        $tw.config.fileExtensionInfo[extension] = { type: type }\n      })\n      extension = extension[0]\n    } else {\n      $tw.config.fileExtensionInfo[extension] = { type: type }\n    }\n    $tw.config.contentTypeInfo[type] = {\n      encoding: encoding,\n      extension: extension,\n      flags: options.flags || [],\n      deserializerType: options.deserializerType || type\n    }\n  }\n\n  /**\n   * Given an extension, always access the $tw.config.fileExtensionInfo\n   *  using a lowercase extension only.\n   */\n  $tw.utils.getFileExtensionInfo = function (ext) {\n    return ext ? $tw.config.fileExtensionInfo[ext.toLowerCase()] : null\n  }\n\n  /**\n   * Given an extension, get the correct encoding for that file.\n   * defaults to utf8\n   */\n  $tw.utils.getTypeEncoding = function (ext) {\n    var extensionInfo = $tw.utils.getFileExtensionInfo(ext)\n    var type = extensionInfo ? extensionInfo.type : null\n    var typeInfo = type ? $tw.config.contentTypeInfo[type] : null\n    return typeInfo ? typeInfo.encoding : 'utf8'\n  }\n\n  /**\n   * Run code globally with specified context variables in scope\n   */\n  $tw.utils.evalGlobal = function (code, context, filename) {\n    var contextCopy = $tw.utils.extend(Object.create(null), context)\n    // Get the context variables as a pair of arrays of names and values\n    var contextNames = []\n    var contextValues = []\n    $tw.utils.each(contextCopy, function (value, name) {\n      contextNames.push(name)\n      contextValues.push(value)\n    })\n    // Add the code prologue and epilogue\n    code =\n      '(function(' +\n      contextNames.join(',') +\n      ') {(function(){\\n' +\n      code +\n      '\\n;})();\\nreturn exports;\\n})\\n'\n    // Compile the code into a function\n    var fn\n    if ($tw.browser) {\n      /*eslint no-eval:\"off\", dot-notation:\"off\"*/\n      fn = window['eval'](code + '\\n\\n//# sourceURL=' + filename)\n    } else {\n      fn = vm.runInThisContext(code, filename)\n    }\n    // Call the function and return the exports\n    return fn.apply(null, contextValues)\n  }\n\n  /**\n   * Run code in a sandbox with only the specified context variables in scope\n   */\n  $tw.utils.evalSandboxed = $tw.browser\n    ? $tw.utils.evalGlobal\n    : function (code, context, filename) {\n        var sandbox = $tw.utils.extend(Object.create(null), context)\n        vm.runInNewContext(code, sandbox, filename)\n        return sandbox.exports\n      }\n\n  /**\n   * Creates a PasswordPrompt object\n   */\n  $tw.utils.PasswordPrompt = function () {\n    // Store of pending password prompts\n    this.passwordPrompts = []\n    // Create the wrapper\n    this.promptWrapper = $tw.utils.domMaker('div', {\n      class: 'tc-password-wrapper'\n    })\n    document.body.appendChild(this.promptWrapper)\n    // Hide the empty wrapper\n    this.setWrapperDisplay()\n  }\n\n  /**\n   * Hides or shows the wrapper depending on whether there are any outstanding prompts\n   */\n  $tw.utils.PasswordPrompt.prototype.setWrapperDisplay = function () {\n    if (this.passwordPrompts.length) {\n      this.promptWrapper.style.display = 'block'\n    } else {\n      this.promptWrapper.style.display = 'none'\n    }\n  }\n\n  /**\n   * Adds a new password prompt. Options are:\n   * submitText: text to use for submit button (defaults to \"Login\")\n   * serviceName: text of the human readable service name\n   * noUserName: set true to disable username prompt\n   * canCancel: set true to enable a cancel button (callback called with null)\n   * repeatPassword: set true to prompt for the password twice\n   * callback: function to be called on submission with parameter of object {username:,password:}.\n   *  Callback must return `true` to remove the password prompt\n   */\n  $tw.utils.PasswordPrompt.prototype.createPrompt = function (options) {\n    // Create and add the prompt to the DOM\n    var self = this\n    var submitText = options.submitText || 'Login'\n    var dm = $tw.utils.domMaker\n    var children = [dm('h1', { text: options.serviceName })]\n    if (!options.noUserName) {\n      children.push(\n        dm('input', {\n          attributes: {\n            type: 'text',\n            name: 'username',\n            placeholder: $tw.language.getString('Encryption/Username')\n          }\n        })\n      )\n    }\n    children.push(\n      dm('input', {\n        attributes: {\n          type: 'password',\n          name: 'password',\n          placeholder:\n            $tw.language === undefined\n              ? 'Password'\n              : $tw.language.getString('Encryption/Password')\n        }\n      })\n    )\n    if (options.repeatPassword) {\n      children.push(\n        dm('input', {\n          attributes: {\n            type: 'password',\n            name: 'password2',\n            placeholder: $tw.language.getString('Encryption/RepeatPassword')\n          }\n        })\n      )\n    }\n    if (options.canCancel) {\n      children.push(\n        dm('button', {\n          text: $tw.language.getString('Encryption/Cancel'),\n          attributes: {\n            type: 'button'\n          },\n          eventListeners: [\n            {\n              name: 'click',\n              handlerFunction: function (event) {\n                self.removePrompt(promptInfo)\n                options.callback(null)\n              }\n            }\n          ]\n        })\n      )\n    }\n    children.push(\n      dm('button', {\n        attributes: { type: 'submit' },\n        text: submitText\n      })\n    )\n    var form = dm('form', {\n      attributes: { autocomplete: 'off' },\n      children: children\n    })\n    this.promptWrapper.appendChild(form)\n    window.setTimeout(function () {\n      form.elements[0].focus()\n    }, 10)\n    // Add a submit event handler\n    var self = this\n    form.addEventListener(\n      'submit',\n      function (event) {\n        // Collect the form data\n        var data = {}\n        $tw.utils.each(form.elements, function (element) {\n          if (element.name && element.value) {\n            data[element.name] = element.value\n          }\n        })\n        // Check that the passwords match\n        if (options.repeatPassword && data.password !== data.password2) {\n          alert($tw.language.getString('Encryption/PasswordNoMatch'))\n        } else {\n          // Call the callback\n          if (options.callback(data)) {\n            // Remove the prompt if the callback returned true\n            self.removePrompt(promptInfo)\n          } else {\n            // Clear the password if the callback returned false\n            $tw.utils.each(form.elements, function (element) {\n              if (element.name === 'password' || element.name === 'password2') {\n                element.value = ''\n              }\n            })\n          }\n        }\n        event.preventDefault()\n        return false\n      },\n      true\n    )\n    // Add the prompt to the list\n    var promptInfo = {\n      serviceName: options.serviceName,\n      callback: options.callback,\n      form: form\n    }\n    this.passwordPrompts.push(promptInfo)\n    // Make sure the wrapper is displayed\n    this.setWrapperDisplay()\n  }\n\n  $tw.utils.PasswordPrompt.prototype.removePrompt = function (promptInfo) {\n    var i = this.passwordPrompts.indexOf(promptInfo)\n    if (i !== -1) {\n      this.passwordPrompts.splice(i, 1)\n      promptInfo.form.parentNode.removeChild(promptInfo.form)\n      this.setWrapperDisplay()\n    }\n  }\n\n  /**\n   * Crypto helper object for encrypted content. It maintains the password text in a closure, and provides methods to change\n   * the password, and to encrypt/decrypt a block of text\n   */\n  $tw.utils.Crypto = function () {\n    var currentPassword = null\n    var currentPublicKey = null\n    var callSjcl = function (method, inputText, password) {\n      password = password || currentPassword\n      var outputText\n      var sjcl = $tw.node ? global.sjcl || require('sjcl') : window.sjcl\n      try {\n        if (password) {\n          var tStart = new Date()\n          outputText = sjcl[method](password, inputText)\n          var tStop = new Date() - tStart\n          var ratio = Math.floor((outputText.length * 100) / inputText.length)\n          var uMethod = method.charAt(0).toUpperCase() + method.slice(1) + 'ion'\n          console.log(\n            `Standford ${uMethod}: ${tStop}ms, In: ${inputText.length} bytes, Out: ${outputText.length} bytes, Ratio: ${ratio}%`\n          )\n        }\n      } catch (ex) {\n        console.error('Crypto error:' + ex)\n        outputText = null\n      }\n      return outputText\n    }\n    this.setPassword = function (newPassword) {\n      currentPassword =\n        newPassword === undefined || newPassword == null ? null : newPassword\n      currentPublicKey = null\n      if ($tw.wiki) {\n        this.updateCryptoStateTiddler()\n        var standford = $tw.wiki.getTiddler('$:/config/Standford')\n        if (\n          !standford ||\n          (currentPassword !== null && standford.fields.text === 'no')\n        ) {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({ title: '$:/config/Standford', text: 'yes' })\n          )\n        }\n      }\n    }\n    this.setEncryptionKey = function (newPublicKey) {\n      currentPassword = null\n      currentPublicKey =\n        newPublicKey === undefined || newPublicKey == null ? null : newPublicKey\n      if ($tw.wiki) {\n        this.updateCryptoStateTiddler()\n        var standford = $tw.wiki.getTiddler('$:/config/Standford')\n        if (!standford) {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({ title: '$:/config/Standford', text: 'yes' })\n          )\n        } else {\n          if (currentPublicKey !== null && standford.fields.text === 'yes') {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({ title: '$:/config/Standford', text: 'no' })\n            )\n          }\n        }\n      }\n    }\n    this.updateCryptoStateTiddler = function () {\n      if ($tw.wiki) {\n        var state = currentPassword || currentPublicKey ? 'yes' : 'no'\n        var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\n        if (!encrypted || encrypted.fields.text !== state) {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({\n              title: '$:/isEncrypted',\n              _public_key:\n                currentPublicKey !== null ? currentPublicKey : undefined,\n              text: state\n            })\n          )\n        }\n      }\n    }\n    this.hasPassword = function () {\n      return !!currentPassword\n    }\n    this.hasEncryptionKey = function () {\n      return !!currentPublicKey\n    }\n    this.encrypt = function (text, password, publicKey) {\n      publicKey = publicKey || currentPublicKey\n      if (publicKey) {\n        var output\n        var sigUtil = $tw.node\n          ? global.sigUtil || require('eth-sig-util')\n          : window.sigUtil\n        var tStart = new Date()\n        try {\n          output = sigUtil.encrypt(\n            publicKey,\n            { data: text },\n            'x25519-xsalsa20-poly1305'\n          )\n          output = JSON.stringify(output)\n          var tStop = new Date() - tStart\n          var ratio = Math.floor((output.length * 100) / text.length)\n          console.log(\n            `Ethereum Encryption: ${tStop}ms, In: ${text.length} bytes, Out: ${output.length} bytes, Ratio: ${ratio}%`\n          )\n        } catch (error) {\n          console.error('Crypto error:' + error)\n          output = null\n        }\n        return output\n      } else {\n        return callSjcl('encrypt', text, password)\n      }\n    }\n    this.decrypt = function (text, password) {\n      return callSjcl('decrypt', text, password)\n    }\n  }\n\n  /**\n   * Compress helper object for compressed content.\n   */\n  $tw.utils.Compress = function () {\n    var pako = $tw.node ? global.pako || require('pako') : window.pako\n    var currentState = null\n    this.setCompressState = function (state) {\n      currentState = state ? 'yes' : 'no'\n      this.updateCompressStateTiddler()\n    }\n    this.updateCompressStateTiddler = function () {\n      if ($tw.wiki) {\n        var state = currentState === 'yes' ? 'yes' : 'no'\n        var tiddler = $tw.wiki.getTiddler('$:/isCompressed')\n        if (!tiddler || tiddler.fields.text !== state) {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({ title: '$:/isCompressed', text: state })\n          )\n        }\n      }\n    }\n    this.deflate = function (str) {\n      var tStart = new Date()\n      var ua = pako.deflate(str, { raw: false })\n      var b64 = this.btoa(ua)\n      var tStop = new Date() - tStart\n      var ratio = Math.floor((b64.length * 100) / str.length)\n      console.log(\n        `Deflate: ${tStop}ms, In: ${str.length} bytes, Out: ${b64.length} bytes, Ratio: ${ratio}%`\n      )\n      return b64\n    }\n    this.inflate = function (b64) {\n      var tStart = new Date()\n      var ua = this.decode(b64)\n      var str = pako.inflate(ua, { to: 'string' })\n      var tStop = new Date() - tStart\n      var ratio = Math.floor((str.length * 100) / b64.length)\n      console.log(\n        `Inflate: ${tStop}ms, In: ${b64.length} bytes, Out: ${str.length} bytes, Ratio: ${ratio}%`\n      )\n      return str\n    }\n    this.decode = function (b64) {\n      return Base64Binary.decode(b64)\n    }\n    this.btoa = function (ua) {\n      try {\n        return this.Uint8ArrayToBase64(ua)\n      } catch (error) {\n        return Buffer.from(ua).toString('base64')\n      }\n    }\n    // https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string\n    this.Uint8ArrayToBase64 = function (uint8) {\n      var CHUNK_SIZE = 0x8000\n      var index = 0\n      var length = uint8.length\n      var str = ''\n      var slice\n      while (index < length) {\n        slice = uint8.subarray(index, Math.min(index + CHUNK_SIZE, length))\n        str += String.fromCharCode.apply(null, slice)\n        index += CHUNK_SIZE\n      }\n      return btoa(str)\n    }\n    // https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer/21797381\n    // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\n    /*\n     * Copyright (c) 2011, Daniel Guerrero\n     * All rights reserved.\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     * Redistributions of source code must retain the above copyright\n     * notice, this list of conditions and the following disclaimer.\n     * Redistributions in binary form must reproduce the above copyright\n     * notice, this list of conditions and the following disclaimer in the\n     * documentation and/or other materials provided with the distribution.\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL DANIEL GUERRERO BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n    /**\n     * Uses the new array typed in javascript to binary base64 encode/decode\n     * at the moment just decodes a binary base64 encoded\n     * into either an ArrayBuffer (decodeArrayBuffer)\n     * or into an Uint8Array (decode)\n     *\n     * References:\n     * https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer\n     * https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array\n     */\n    var Base64Binary = {\n      _keyStr:\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      /* will return a  Uint8Array type */\n      decodeArrayBuffer: function (input) {\n        var bytes = (input.length / 4) * 3\n        var ab = new ArrayBuffer(bytes)\n        this.decode(input, ab)\n        return ab\n      },\n      removePaddingChars: function (input) {\n        var lkey = this._keyStr.indexOf(input.charAt(input.length - 1))\n        if (lkey === 64) {\n          return input.substring(0, input.length - 1)\n        }\n        return input\n      },\n      decode: function (input, ab) {\n        //get last chars to see if are valid\n        input = this.removePaddingChars(input)\n        input = this.removePaddingChars(input)\n        var bytes = parseInt((input.length / 4) * 3, 10)\n        var ua\n        var chr1, chr2, chr3\n        var enc1, enc2, enc3, enc4\n        var i = 0\n        var j = 0\n        if (ab) ua = new Uint8Array(ab)\n        else ua = new Uint8Array(bytes)\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '')\n        for (i = 0; i < bytes; i += 3) {\n          //get the 3 octects in 4 ascii chars\n          enc1 = this._keyStr.indexOf(input.charAt(j++))\n          enc2 = this._keyStr.indexOf(input.charAt(j++))\n          enc3 = this._keyStr.indexOf(input.charAt(j++))\n          enc4 = this._keyStr.indexOf(input.charAt(j++))\n          chr1 = (enc1 << 2) | (enc2 >> 4)\n          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n          chr3 = ((enc3 & 3) << 6) | enc4\n          ua[i] = chr1\n          if (enc3 !== 64) ua[i + 1] = chr2\n          if (enc4 !== 64) ua[i + 2] = chr3\n        }\n        return ua\n      }\n    }\n  }\n\n  /////////////////////////// Module mechanism\n\n  /**\n   * Execute the module named 'moduleName'. The name can optionally be relative to the module named 'moduleRoot'\n   */\n  $tw.modules.execute = function (moduleName, moduleRoot) {\n    var name = moduleName\n    if (moduleName.charAt(0) === '.') {\n      name = $tw.utils.resolvePath(moduleName, moduleRoot)\n    }\n    if (!$tw.modules.titles[name]) {\n      if ($tw.modules.titles[name + '.js']) {\n        name = name + '.js'\n      } else if ($tw.modules.titles[name + '/index.js']) {\n        name = name + '/index.js'\n      } else if ($tw.modules.titles[moduleName]) {\n        name = moduleName\n      } else if ($tw.modules.titles[moduleName + '.js']) {\n        name = moduleName + '.js'\n      } else if ($tw.modules.titles[moduleName + '/index.js']) {\n        name = moduleName + '/index.js'\n      }\n    }\n    var moduleInfo = $tw.modules.titles[name]\n    var tiddler = $tw.wiki.getTiddler(name)\n    var _exports = {}\n    var sandbox = {\n      module: { exports: _exports },\n      //moduleInfo: moduleInfo,\n      exports: _exports,\n      console: console,\n      setInterval: setInterval,\n      clearInterval: clearInterval,\n      setTimeout: setTimeout,\n      clearTimeout: clearTimeout,\n      Buffer: $tw.browser ? undefined : Buffer,\n      $tw: $tw,\n      require: function (title) {\n        return $tw.modules.execute(title, name)\n      }\n    }\n\n    Object.defineProperty(sandbox.module, 'id', {\n      value: name,\n      writable: false,\n      enumerable: true,\n      configurable: false\n    })\n\n    if (!$tw.browser) {\n      $tw.utils.extend(sandbox, {\n        process: process\n      })\n    } else {\n      /**\n       * CommonJS optional require.main property:\n       * In a browser we offer a fake main module which points back to the boot function\n       * (Theoretically, this may allow TW to eventually load itself as a module in the browser)\n       */\n      Object.defineProperty(sandbox.require, 'main', {\n        value:\n          typeof require !== 'undefined' ? require.main : { TiddlyWiki: _boot },\n        writable: false,\n        enumerable: true,\n        configurable: false\n      })\n    }\n    if (!moduleInfo) {\n      // We could not find the module on this path\n      // Try to defer to browserify etc, or node\n      if ($tw.browser) {\n        if (window.require) {\n          try {\n            return window.require(moduleName)\n          } catch (e) {}\n        }\n        throw new Error(\n          \"Cannot find module named '\" +\n            moduleName +\n            \"' required by module '\" +\n            moduleRoot +\n            \"', resolved to \" +\n            name\n        )\n      } else {\n        // If we don't have a module with that name, let node.js try to find it\n        return require(moduleName)\n      }\n    }\n    // Execute the module if we haven't already done so\n    if (!moduleInfo.exports) {\n      try {\n        // Check the type of the definition\n        if (typeof moduleInfo.definition === 'function') {\n          // Function\n          moduleInfo.exports = _exports\n          moduleInfo.definition(moduleInfo, moduleInfo.exports, sandbox.require)\n        } else if (typeof moduleInfo.definition === 'string') {\n          // String\n          moduleInfo.exports = _exports\n          $tw.utils.evalSandboxed(\n            moduleInfo.definition,\n            sandbox,\n            tiddler.fields.title\n          )\n          if (sandbox.module.exports) {\n            moduleInfo.exports = sandbox.module.exports //more codemirror workaround\n          }\n        } else {\n          // Object\n          moduleInfo.exports = moduleInfo.definition\n        }\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          var line = e.lineNumber || e.line // Firefox || Safari\n          if (typeof line !== 'undefined' && line !== null) {\n            $tw.utils.error(\n              'Syntax error in boot module ' +\n                name +\n                ':' +\n                line +\n                ':\\n' +\n                e.stack\n            )\n          } else if (!$tw.browser) {\n            // this is the only way to get node.js to display the line at which the syntax error appeared,\n            // and $tw.utils.error would exit anyway\n            // cf. https://bugs.chromium.org/p/v8/issues/detail?id=2589\n            throw e\n          } else {\n            // Opera: line number is included in e.message\n            // Chrome/IE: there's currently no way to get the line number\n            $tw.utils.error(\n              'Syntax error in boot module ' +\n                name +\n                ': ' +\n                e.message +\n                '\\n' +\n                e.stack\n            )\n          }\n        } else {\n          // line number should be included in e.stack for runtime errors\n          $tw.utils.error(\n            'Error executing boot module ' +\n              name +\n              ': ' +\n              JSON.stringify(e) +\n              '\\n\\n' +\n              e.stack\n          )\n        }\n      }\n    }\n    // Return the exports of the module\n    return moduleInfo.exports\n  }\n\n  /**\n   * Apply a callback to each module of a particular type\n   * moduleType: type of modules to enumerate\n   * callback: function called as callback(title,moduleExports) for each module\n   */\n  $tw.modules.forEachModuleOfType = function (moduleType, callback) {\n    var modules = $tw.modules.types[moduleType]\n    $tw.utils.each(modules, function (element, title) {\n      callback(title, $tw.modules.execute(title))\n    })\n  }\n\n  /**\n   * Get all the modules of a particular type in a hashmap by their `name` field\n   */\n  $tw.modules.getModulesByTypeAsHashmap = function (moduleType, nameField) {\n    nameField = nameField || 'name'\n    var results = Object.create(null)\n    $tw.modules.forEachModuleOfType(moduleType, function (title, module) {\n      results[module[nameField]] = module\n    })\n    return results\n  }\n\n  /**\n   * Apply the exports of the modules of a particular type to a target object\n   */\n  $tw.modules.applyMethods = function (moduleType, targetObject) {\n    if (!targetObject) {\n      targetObject = Object.create(null)\n    }\n    $tw.modules.forEachModuleOfType(moduleType, function (title, module) {\n      $tw.utils.each(module, function (element, title, object) {\n        targetObject[title] = module[title]\n      })\n    })\n    return targetObject\n  }\n\n  /**\n   * Return an array of classes created from the modules of a specified type.\n   * Each module should export the properties to be added to those of the optional base class\n   */\n  $tw.modules.createClassesFromModules = function (\n    moduleType,\n    subType,\n    baseClass\n  ) {\n    var classes = Object.create(null)\n    $tw.modules.forEachModuleOfType(moduleType, function (\n      title,\n      moduleExports\n    ) {\n      if (!subType || moduleExports.types[subType]) {\n        var newClass = function () {}\n        if (baseClass) {\n          /*eslint new-cap:\"off\"*/\n          newClass.prototype = new baseClass()\n          newClass.prototype.constructor = baseClass\n        }\n        $tw.utils.extend(newClass.prototype, moduleExports)\n        classes[moduleExports.name] = newClass\n      }\n    })\n    return classes\n  }\n\n  /////////////////////////// Barebones tiddler object\n\n  /**\n   * Construct a tiddler object from a hashmap of tiddler fields.\n   * If multiple hasmaps are provided they are merged, taking precedence to the right\n   */\n  $tw.Tiddler = function (/* [fields,] fields */) {\n    this.fields = Object.create(null)\n    this.cache = Object.create(null)\n    for (var c = 0; c < arguments.length; c++) {\n      var arg = arguments[c]\n      var src = arg instanceof $tw.Tiddler ? arg.fields : arg\n      for (var t in src) {\n        if (src[t] === undefined || src[t] === null) {\n          if (t in this.fields) {\n            delete this.fields[t] // If we get a field that's undefined, delete any previous field value\n          }\n        } else {\n          // Parse the field with the associated field module (if any)\n          var fieldModule = $tw.Tiddler.fieldModules[t]\n          var value\n          if (fieldModule && fieldModule.parse) {\n            value = fieldModule.parse.call(this, src[t])\n          } else {\n            value = src[t]\n          }\n          // Freeze the field to keep it immutable\n          if (value != null && typeof value === 'object') {\n            Object.freeze(value)\n          }\n          this.fields[t] = value\n        }\n      }\n    }\n    // Freeze the tiddler against modification\n    Object.freeze(this.fields)\n    Object.freeze(this)\n  }\n\n  $tw.Tiddler.prototype.hasField = function (field) {\n    return $tw.utils.hop(this.fields, field)\n  }\n\n  /**\n   * Compare two tiddlers for equality\n   * tiddler: the tiddler to compare\n   * excludeFields: array of field names to exclude from the comparison\n   */\n  $tw.Tiddler.prototype.isEqual = function (tiddler, excludeFields) {\n    if (!(tiddler instanceof $tw.Tiddler)) {\n      return false\n    }\n    excludeFields = excludeFields || []\n    var self = this\n    var differences = [] // Fields that have differences\n    // Add to the differences array\n    function addDifference (fieldName) {\n      // Check for this field being excluded\n      if (excludeFields.indexOf(fieldName) === -1) {\n        // Save the field as a difference\n        $tw.utils.pushTop(differences, fieldName)\n      }\n    }\n    // Returns true if the two values of this field are equal\n    function isFieldValueEqual (fieldName) {\n      var valueA = self.fields[fieldName]\n      var valueB = tiddler.fields[fieldName]\n      // Check for identical string values\n      if (\n        typeof valueA === 'string' &&\n        typeof valueB === 'string' &&\n        valueA === valueB\n      ) {\n        return true\n      }\n      // Check for identical array values\n      if (\n        $tw.utils.isArray(valueA) &&\n        $tw.utils.isArray(valueB) &&\n        $tw.utils.isArrayEqual(valueA, valueB)\n      ) {\n        return true\n      }\n      // Check for identical date values\n      if (\n        $tw.utils.isDate(valueA) &&\n        $tw.utils.isDate(valueB) &&\n        valueA.getTime() === valueB.getTime()\n      ) {\n        return true\n      }\n      // Otherwise the fields must be different\n      return false\n    }\n    // Compare our fields\n    for (var fieldName in this.fields) {\n      if (!isFieldValueEqual(fieldName)) {\n        addDifference(fieldName)\n      }\n    }\n    // There's a difference for every field in the other tiddler that we don't have\n    for (fieldName in tiddler.fields) {\n      if (!(fieldName in this.fields)) {\n        addDifference(fieldName)\n      }\n    }\n    // Return whether there were any differences\n    return differences.length === 0\n  }\n\n  /**\n   * Register and install the built in tiddler field modules\n   */\n  $tw.modules.define('$:/boot/tiddlerfields/modified', 'tiddlerfield', {\n    name: 'modified',\n    parse: $tw.utils.parseDate,\n    stringify: $tw.utils.stringifyDate\n  })\n  $tw.modules.define('$:/boot/tiddlerfields/created', 'tiddlerfield', {\n    name: 'created',\n    parse: $tw.utils.parseDate,\n    stringify: $tw.utils.stringifyDate\n  })\n  $tw.modules.define('$:/boot/tiddlerfields/color', 'tiddlerfield', {\n    name: 'color',\n    editTag: 'input',\n    editType: 'color'\n  })\n  $tw.modules.define('$:/boot/tiddlerfields/tags', 'tiddlerfield', {\n    name: 'tags',\n    parse: $tw.utils.parseStringArray,\n    stringify: $tw.utils.stringifyList\n  })\n  $tw.modules.define('$:/boot/tiddlerfields/list', 'tiddlerfield', {\n    name: 'list',\n    parse: $tw.utils.parseStringArray,\n    stringify: $tw.utils.stringifyList\n  })\n\n  /////////////////////////// Barebones wiki store\n\n  /**\n   * Wiki constructor. State is stored in private members that only a small number of privileged accessor methods have direct access.\n   * Methods added via the prototype have to use these accessors and cannot access the state data directly.\n   * options include:\n   * enableIndexers - Array of indexer names to enable, or null to use all available indexers\n   */\n  $tw.Wiki = function (options) {\n    options = options || {}\n    var tiddlers = Object.create(null) // Hashmap of tiddlers\n    var tiddlerTitles = null // Array of tiddler titles\n    var getTiddlerTitles = function () {\n      if (!tiddlerTitles) {\n        tiddlerTitles = Object.keys(tiddlers)\n      }\n      return tiddlerTitles\n    }\n    var pluginTiddlers = [] // Array of tiddlers containing registered plugins, ordered by priority\n    var pluginInfo = Object.create(null) // Hashmap of parsed plugin content\n    var shadowTiddlers = Object.create(null) // Hashmap by title of {source:, tiddler:}\n    var shadowTiddlerTitles = null\n    var getShadowTiddlerTitles = function () {\n      if (!shadowTiddlerTitles) {\n        shadowTiddlerTitles = Object.keys(shadowTiddlers)\n      }\n      return shadowTiddlerTitles\n    }\n    var enableIndexers = options.enableIndexers || null\n    var indexers = []\n    var indexersByName = Object.create(null)\n\n    this.addIndexer = function (indexer, name) {\n      // Bail if this indexer is not enabled\n      if (enableIndexers && enableIndexers.indexOf(name) === -1) {\n        return\n      }\n      indexers.push(indexer)\n      indexersByName[name] = indexer\n      indexer.init()\n    }\n\n    this.getIndexer = function (name) {\n      return indexersByName[name] || null\n    }\n\n    // Add a tiddler to the store\n    this.addTiddler = function (tiddler) {\n      if (!(tiddler instanceof $tw.Tiddler)) {\n        tiddler = new $tw.Tiddler(tiddler)\n      }\n      // Save the tiddler\n      if (tiddler) {\n        var title = tiddler.fields.title\n        if (title) {\n          // Uncomment the following line for detailed logs of all tiddler writes\n          // console.log(\"Adding\",title,tiddler)\n          // Record the old tiddler state\n          var updateDescriptor = {\n            old: {\n              tiddler: this.getTiddler(title),\n              shadow: this.isShadowTiddler(title),\n              exists: this.tiddlerExists(title)\n            }\n          }\n          // Save the new tiddler\n          tiddlers[title] = tiddler\n          // Check we've got it's title\n          if (tiddlerTitles && tiddlerTitles.indexOf(title) === -1) {\n            tiddlerTitles.push(title)\n          }\n          // Record the new tiddler state\n          updateDescriptor['new'] = {\n            tiddler: tiddler,\n            shadow: this.isShadowTiddler(title),\n            exists: this.tiddlerExists(title)\n          }\n          // Update indexes\n          this.clearCache(title)\n          this.clearGlobalCache()\n          $tw.utils.each(indexers, function (indexer) {\n            indexer.update(updateDescriptor)\n          })\n          // Queue a change event\n          this.enqueueTiddlerEvent(title)\n        }\n      }\n    }\n\n    // Delete a tiddler\n    this.deleteTiddler = function (title) {\n      // Uncomment the following line for detailed logs of all tiddler deletions\n      // console.log(\"Deleting\",title)\n      if ($tw.utils.hop(tiddlers, title)) {\n        // Record the old tiddler state\n        var updateDescriptor = {\n          old: {\n            tiddler: this.getTiddler(title),\n            shadow: this.isShadowTiddler(title),\n            exists: this.tiddlerExists(title)\n          }\n        }\n        // Delete the tiddler\n        delete tiddlers[title]\n        // Delete it from the list of titles\n        if (tiddlerTitles) {\n          var index = tiddlerTitles.indexOf(title)\n          if (index !== -1) {\n            tiddlerTitles.splice(index, 1)\n          }\n        }\n        // Record the new tiddler state\n        updateDescriptor['new'] = {\n          tiddler: this.getTiddler(title),\n          shadow: this.isShadowTiddler(title),\n          exists: this.tiddlerExists(title)\n        }\n        // Update indexes\n        this.clearCache(title)\n        this.clearGlobalCache()\n        $tw.utils.each(indexers, function (indexer) {\n          indexer.update(updateDescriptor)\n        })\n        // Queue a change event\n        this.enqueueTiddlerEvent(title, true)\n      }\n    }\n\n    // Get a tiddler from the store\n    this.getTiddler = function (title) {\n      if (title) {\n        var t = tiddlers[title]\n        if (t instanceof $tw.Tiddler) {\n          return t\n        } else if (title !== undefined && shadowTiddlers[title]) {\n          return shadowTiddlers[title].tiddler\n        }\n        return undefined\n      }\n    }\n\n    // Get an array of all tiddler titles\n    this.allTitles = function () {\n      return getTiddlerTitles().slice(0)\n    }\n\n    // Iterate through all tiddler titles\n    this.each = function (callback) {\n      var titles = getTiddlerTitles()\n      var index\n      var titlesLength\n      var title\n      for (\n        index = 0, titlesLength = titles.length;\n        index < titlesLength;\n        index++\n      ) {\n        title = titles[index]\n        callback(tiddlers[title], title)\n      }\n    }\n\n    // Get an array of all shadow tiddler titles\n    this.allShadowTitles = function () {\n      return getShadowTiddlerTitles().slice(0)\n    }\n\n    // Iterate through all shadow tiddler titles\n    this.eachShadow = function (callback) {\n      var titles = getShadowTiddlerTitles()\n      var index\n      var titlesLength\n      var title\n      for (\n        index = 0, titlesLength = titles.length;\n        index < titlesLength;\n        index++\n      ) {\n        title = titles[index]\n        var shadowInfo = shadowTiddlers[title]\n        callback(shadowInfo.tiddler, title)\n      }\n    }\n\n    // Iterate through all tiddlers and then the shadows\n    this.eachTiddlerPlusShadows = function (callback) {\n      var index\n      var titlesLength\n      var title\n      var titles = getTiddlerTitles()\n      for (\n        index = 0, titlesLength = titles.length;\n        index < titlesLength;\n        index++\n      ) {\n        title = titles[index]\n        callback(tiddlers[title], title)\n      }\n      titles = getShadowTiddlerTitles()\n      for (\n        index = 0, titlesLength = titles.length;\n        index < titlesLength;\n        index++\n      ) {\n        title = titles[index]\n        if (!tiddlers[title]) {\n          var shadowInfo = shadowTiddlers[title]\n          callback(shadowInfo.tiddler, title)\n        }\n      }\n    }\n\n    // Iterate through all the shadows and then the tiddlers\n    this.eachShadowPlusTiddlers = function (callback) {\n      var index\n      var titlesLength\n      var title\n      var titles = getShadowTiddlerTitles()\n      for (\n        index = 0, titlesLength = titles.length;\n        index < titlesLength;\n        index++\n      ) {\n        title = titles[index]\n        if (tiddlers[title]) {\n          callback(tiddlers[title], title)\n        } else {\n          var shadowInfo = shadowTiddlers[title]\n          callback(shadowInfo.tiddler, title)\n        }\n      }\n      titles = getTiddlerTitles()\n      for (\n        index = 0, titlesLength = titles.length;\n        index < titlesLength;\n        index++\n      ) {\n        title = titles[index]\n        if (!shadowTiddlers[title]) {\n          callback(tiddlers[title], title)\n        }\n      }\n    }\n\n    // Test for the existence of a tiddler (excludes shadow tiddlers)\n    this.tiddlerExists = function (title) {\n      return !!$tw.utils.hop(tiddlers, title)\n    }\n\n    // Determines if a tiddler is a shadow tiddler, regardless of whether it has been overridden by a real tiddler\n    this.isShadowTiddler = function (title) {\n      return $tw.utils.hop(shadowTiddlers, title)\n    }\n\n    this.getShadowSource = function (title) {\n      if ($tw.utils.hop(shadowTiddlers, title)) {\n        return shadowTiddlers[title].source\n      }\n      return null\n    }\n\n    // Get an array of all the currently recognised plugin types\n    this.getPluginTypes = function () {\n      var types = []\n      $tw.utils.each(pluginTiddlers, function (pluginTiddler) {\n        var pluginType = pluginTiddler.fields['plugin-type']\n        if (pluginType && types.indexOf(pluginType) === -1) {\n          types.push(pluginType)\n        }\n      })\n      return types\n    }\n\n    // Read plugin info for all plugins, or just an array of titles. Returns the number of plugins updated or deleted\n    this.readPluginInfo = function (titles) {\n      var results = {\n        modifiedPlugins: [],\n        deletedPlugins: []\n      }\n      $tw.utils.each(titles || getTiddlerTitles(), function (title) {\n        var tiddler = tiddlers[title]\n        if (tiddler) {\n          if (\n            tiddler.fields.type === 'application/json' &&\n            tiddler.hasField('plugin-type')\n          ) {\n            pluginInfo[tiddler.fields.title] = JSON.parse(tiddler.fields.text)\n            results.modifiedPlugins.push(tiddler.fields.title)\n          }\n        } else {\n          if (pluginInfo[title]) {\n            delete pluginInfo[title]\n            results.deletedPlugins.push(title)\n          }\n        }\n      })\n      return results\n    }\n\n    // Get plugin info for a plugin\n    this.getPluginInfo = function (title) {\n      return pluginInfo[title]\n    }\n\n    // Register the plugin tiddlers of a particular type, or null/undefined for any type,\n    // optionally restricting registration to an array of tiddler titles.\n    // Return the array of titles affected\n    this.registerPluginTiddlers = function (pluginType, titles) {\n      var self = this\n      var registeredTitles = []\n      var checkTiddler = function (tiddler, title) {\n        if (\n          tiddler &&\n          tiddler.fields.type === 'application/json' &&\n          tiddler.fields['plugin-type'] &&\n          (!pluginType || tiddler.fields['plugin-type'] === pluginType)\n        ) {\n          var disablingTiddler = self.getTiddler(\n            '$:/config/Plugins/Disabled/' + title\n          )\n          if (\n            title === '$:/core' ||\n            !disablingTiddler ||\n            (disablingTiddler.fields.text || '').trim() !== 'yes'\n          ) {\n            self.unregisterPluginTiddlers(null, [title]) // Unregister the plugin if it's already registered\n            pluginTiddlers.push(tiddler)\n            registeredTitles.push(tiddler.fields.title)\n          }\n        }\n      }\n      if (titles) {\n        $tw.utils.each(titles, function (title) {\n          checkTiddler(self.getTiddler(title), title)\n        })\n      } else {\n        this.each(function (tiddler, title) {\n          checkTiddler(tiddler, title)\n        })\n      }\n      return registeredTitles\n    }\n\n    // Unregister the plugin tiddlers of a particular type, or null/undefined for any type,\n    // optionally restricting unregistering to an array of tiddler titles.\n    // Returns an array of the titles affected\n    this.unregisterPluginTiddlers = function (pluginType, titles) {\n      var unregisteredTitles = []\n      // Remove any previous registered plugins of this type\n      for (var t = pluginTiddlers.length - 1; t >= 0; t--) {\n        var tiddler = pluginTiddlers[t]\n        if (\n          tiddler.fields['plugin-type'] &&\n          (!pluginType || tiddler.fields['plugin-type'] === pluginType) &&\n          (!titles || titles.indexOf(tiddler.fields.title) !== -1)\n        ) {\n          unregisteredTitles.push(tiddler.fields.title)\n          pluginTiddlers.splice(t, 1)\n        }\n      }\n      return unregisteredTitles\n    }\n\n    // Unpack the currently registered plugins, creating shadow tiddlers for their constituent tiddlers\n    this.unpackPluginTiddlers = function () {\n      // Sort the plugin titles by the `plugin-priority` field\n      pluginTiddlers.sort(function (a, b) {\n        if ('plugin-priority' in a.fields && 'plugin-priority' in b.fields) {\n          return a.fields['plugin-priority'] - b.fields['plugin-priority']\n        } else if ('plugin-priority' in a.fields) {\n          return -1\n        } else if ('plugin-priority' in b.fields) {\n          return +1\n        } else if (a.fields.title < b.fields.title) {\n          return -1\n        } else if (a.fields.title === b.fields.title) {\n          return 0\n        } else {\n          return +1\n        }\n      })\n      // Now go through the plugins in ascending order and assign the shadows\n      shadowTiddlers = Object.create(null)\n      $tw.utils.each(pluginTiddlers, function (tiddler) {\n        // Extract the constituent tiddlers\n        if ($tw.utils.hop(pluginInfo, tiddler.fields.title)) {\n          $tw.utils.each(pluginInfo[tiddler.fields.title].tiddlers, function (\n            constituentTiddler,\n            constituentTitle\n          ) {\n            // Save the tiddler object\n            if (constituentTitle) {\n              shadowTiddlers[constituentTitle] = {\n                source: tiddler.fields.title,\n                tiddler: new $tw.Tiddler(constituentTiddler, {\n                  title: constituentTitle\n                })\n              }\n            }\n          })\n        }\n      })\n      shadowTiddlerTitles = null\n      this.clearCache(null)\n      this.clearGlobalCache()\n      $tw.utils.each(indexers, function (indexer) {\n        indexer.rebuild()\n      })\n    }\n\n    if (this.addIndexersToWiki) {\n      this.addIndexersToWiki()\n    }\n  }\n\n  // Dummy methods that will be filled in after boot\n  $tw.Wiki.prototype.clearCache = $tw.Wiki.prototype.clearGlobalCache = $tw.Wiki.prototype.enqueueTiddlerEvent = function () {}\n\n  // Add an array of tiddlers\n  $tw.Wiki.prototype.addTiddlers = function (tiddlers) {\n    for (var t = 0; t < tiddlers.length; t++) {\n      this.addTiddler(tiddlers[t])\n    }\n  }\n\n  /**\n   * Define all modules stored in ordinary tiddlers\n   */\n  $tw.Wiki.prototype.defineTiddlerModules = function () {\n    this.each(function (tiddler, title) {\n      if (tiddler.hasField('module-type')) {\n        switch (tiddler.fields.type) {\n          case 'application/javascript':\n            // We only define modules that haven't already been defined, because in the browser modules in system tiddlers are defined in inline script\n            if (!$tw.utils.hop($tw.modules.titles, tiddler.fields.title)) {\n              $tw.modules.define(\n                tiddler.fields.title,\n                tiddler.fields['module-type'],\n                tiddler.fields.text\n              )\n            }\n            break\n          case 'application/json':\n            $tw.modules.define(\n              tiddler.fields.title,\n              tiddler.fields['module-type'],\n              JSON.parse(tiddler.fields.text)\n            )\n            break\n          case 'application/x-tiddler-dictionary':\n            $tw.modules.define(\n              tiddler.fields.title,\n              tiddler.fields['module-type'],\n              $tw.utils.parseFields(tiddler.fields.text)\n            )\n            break\n        }\n      }\n    })\n  }\n\n  /**\n   * Register all the module tiddlers that have a module type\n   */\n  $tw.Wiki.prototype.defineShadowModules = function () {\n    var self = this\n    this.eachShadow(function (tiddler, title) {\n      // Don't define the module if it is overidden by an ordinary tiddler\n      if (!self.tiddlerExists(title) && tiddler.hasField('module-type')) {\n        // Define the module\n        $tw.modules.define(\n          tiddler.fields.title,\n          tiddler.fields['module-type'],\n          tiddler.fields.text\n        )\n      }\n    })\n  }\n\n  /**\n   * Enable safe mode by deleting any tiddlers that override a shadow tiddler\n   */\n  $tw.Wiki.prototype.processSafeMode = function () {\n    var self = this\n    var overrides = []\n    // Find the overriding tiddlers\n    this.each(function (tiddler, title) {\n      if (self.isShadowTiddler(title)) {\n        console.log(title)\n        overrides.push(title)\n      }\n    })\n    // Assemble a report tiddler\n    var titleReportTiddler = 'TiddlyWiki Safe Mode'\n    var report = []\n    report.push(\n      'TiddlyWiki has been started in [[safe mode|https://tiddlywiki.com/static/SafeMode.html]]. All plugins are temporarily disabled. Most customisations have been disabled by renaming the following tiddlers:'\n    )\n    // Delete the overrides\n    overrides.forEach(function (title) {\n      var tiddler = self.getTiddler(title)\n      var newTitle = 'SAFE: ' + title\n      self.deleteTiddler(title)\n      self.addTiddler(new $tw.Tiddler(tiddler, { title: newTitle }))\n      report.push('* [[' + title + '|' + newTitle + ']]')\n    })\n    report.push()\n    this.addTiddler(\n      new $tw.Tiddler({ title: titleReportTiddler, text: report.join('\\n\\n') })\n    )\n    // Set $:/DefaultTiddlers to point to our report\n    this.addTiddler(\n      new $tw.Tiddler({\n        title: '$:/DefaultTiddlers',\n        text: '[[' + titleReportTiddler + ']]'\n      })\n    )\n  }\n\n  /**\n   * Extracts tiddlers from a typed block of text, specifying default field values\n   */\n  $tw.Wiki.prototype.deserializeTiddlers = function (\n    type,\n    text,\n    srcFields,\n    options\n  ) {\n    srcFields = srcFields || Object.create(null)\n    options = options || {}\n    var deserializer = $tw.Wiki.tiddlerDeserializerModules[options.deserializer]\n    var fields = Object.create(null)\n    if (!deserializer) {\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[type]\n    }\n    if (!deserializer && $tw.utils.getFileExtensionInfo(type)) {\n      // If we didn't find the serializer, try converting it from an extension to a content type\n      type = $tw.utils.getFileExtensionInfo(type).type\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[type]\n    }\n    if (!deserializer && $tw.config.contentTypeInfo[type]) {\n      // see if this type has a different deserializer registered with it\n      type = $tw.config.contentTypeInfo[type].deserializerType\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[type]\n    }\n    if (!deserializer) {\n      // If we still don't have a deserializer, treat it as plain text\n      deserializer = $tw.Wiki.tiddlerDeserializerModules['text/plain']\n    }\n    for (var f in srcFields) {\n      fields[f] = srcFields[f]\n    }\n    if (deserializer) {\n      return deserializer.call(this, text, fields, type)\n    } else {\n      // Return a raw tiddler for unknown types\n      fields.text = text\n      return [fields]\n    }\n  }\n\n  /**\n   * Register the built in tiddler deserializer modules\n   */\n  var deserializeHeaderComment = function (text, fields) {\n    var headerCommentRegExp = new RegExp(\n      $tw.config.jsModuleHeaderRegExpString,\n      'mg'\n    )\n    var match = headerCommentRegExp.exec(text)\n    fields.text = text\n    if (match) {\n      fields = $tw.utils.parseFields(match[1].split(/\\r?\\n\\r?\\n/gm)[0], fields)\n    }\n    return [fields]\n  }\n  $tw.modules.define('$:/boot/tiddlerdeserializer/js', 'tiddlerdeserializer', {\n    'application/javascript': deserializeHeaderComment\n  })\n  $tw.modules.define('$:/boot/tiddlerdeserializer/css', 'tiddlerdeserializer', {\n    'text/css': deserializeHeaderComment\n  })\n  $tw.modules.define('$:/boot/tiddlerdeserializer/tid', 'tiddlerdeserializer', {\n    'application/x-tiddler': function (text, fields) {\n      var split = text.split(/\\r?\\n\\r?\\n/gm)\n      if (split.length >= 1) {\n        fields = $tw.utils.parseFields(split[0], fields)\n      }\n      if (split.length >= 2) {\n        fields.text = split.slice(1).join('\\n\\n')\n      }\n      return [fields]\n    }\n  })\n  $tw.modules.define(\n    '$:/boot/tiddlerdeserializer/tids',\n    'tiddlerdeserializer',\n    {\n      'application/x-tiddlers': function (text, fields) {\n        var titles = []\n        var tiddlers = []\n        var match = /\\r?\\n\\r?\\n/gm.exec(text)\n        if (match) {\n          fields = $tw.utils.parseFields(text.substr(0, match.index), fields)\n          var lines = text\n            .substr(match.index + match[0].length)\n            .split(/\\r?\\n/gm)\n          for (var t = 0; t < lines.length; t++) {\n            var line = lines[t]\n            if (line.charAt(0) !== '#') {\n              var colonPos = line.indexOf(':')\n              if (colonPos !== -1) {\n                var tiddler = $tw.utils.extend(Object.create(null), fields)\n                tiddler.title =\n                  (tiddler.title || '') + line.substr(0, colonPos).trim()\n                if (titles.indexOf(tiddler.title) !== -1) {\n                  console.log(\n                    'Warning: .multids file contains multiple definitions for ' +\n                      tiddler.title\n                  )\n                }\n                titles.push(tiddler.title)\n                tiddler.text = line.substr(colonPos + 2).trim()\n                tiddlers.push(tiddler)\n              }\n            }\n          }\n        }\n        return tiddlers\n      }\n    }\n  )\n  $tw.modules.define('$:/boot/tiddlerdeserializer/txt', 'tiddlerdeserializer', {\n    'text/plain': function (text, fields, type) {\n      fields.text = text\n      fields.type = type || 'text/plain'\n      return [fields]\n    }\n  })\n  $tw.modules.define(\n    '$:/boot/tiddlerdeserializer/html',\n    'tiddlerdeserializer',\n    {\n      'text/html': function (text, fields) {\n        fields.text = text\n        fields.type = 'text/html'\n        return [fields]\n      }\n    }\n  )\n  $tw.modules.define(\n    '$:/boot/tiddlerdeserializer/json',\n    'tiddlerdeserializer',\n    {\n      'application/json': function (text, fields) {\n        var isTiddlerValid = function (data) {\n          // Not valid if it's not an object with a title property\n          if (typeof data !== 'object' || !$tw.utils.hop(data, 'title')) {\n            return false\n          }\n          for (var f in data) {\n            if ($tw.utils.hop(data, f)) {\n              // Check field name doesn't contain whitespace or control characters\n              /*eslint no-control-regex:\"off\"*/\n              if (typeof data[f] !== 'string' || /[\\x00-\\x1F\\s]/.test(f)) {\n                return false\n              }\n            }\n          }\n          return true\n        }\n        var isTiddlerArrayValid = function (data) {\n          for (var t = 0; t < data.length; t++) {\n            if (!isTiddlerValid(data[t])) {\n              return false\n            }\n          }\n          return true\n        }\n        var data = JSON.parse(text)\n        if ($tw.utils.isArray(data) && isTiddlerArrayValid(data)) {\n          return data\n        } else if (isTiddlerValid(data)) {\n          return [data]\n        } else {\n          // Plain JSON file\n          fields.text = text\n          fields.type = 'application/json'\n          return [fields]\n        }\n      }\n    }\n  )\n\n  /////////////////////////// Browser definitions\n\n  if ($tw.browser && !$tw.node) {\n    $tw.boot.metamaskPrompt = async function (text, callback) {\n      var checkAccountPermission = async function (provider) {\n        const permissions = await provider.request({\n          method: 'wallet_getPermissions'\n        })\n        const accountsPermission = permissions.find(\n          permission => permission.parentCapability === 'eth_accounts'\n        )\n        if (accountsPermission) {\n          return true\n        }\n        return false\n      }\n      var requestAccountPermission = async function (provider) {\n        const permissions = await provider.request({\n          method: 'wallet_requestPermissions',\n          params: [{ eth_accounts: {} }]\n        })\n        const accountsPermission = permissions.find(\n          permission => permission.parentCapability === 'eth_accounts'\n        )\n        if (accountsPermission) {\n          return true\n        }\n        return false\n      }\n      var decryptedText = null\n      try {\n        const provider = await window.detectEthereumProvider({\n          mustBeMetaMask: true\n        })\n        if (provider === undefined || provider == null) {\n          throw new Error('Please install MetaMask...')\n        }\n        provider.autoRefreshOnNetworkChange = false\n        var accounts = null\n        if (typeof provider.request === 'function') {\n          var permission = false\n          // Permission Attempt\n          try {\n            permission = await checkAccountPermission(provider)\n            if (permission === false) {\n              permission = await requestAccountPermission(provider)\n            }\n          } catch (error) {\n            if (error.code === 4001) {\n              throw error\n            }\n            console.error(error)\n          }\n          // Request Accounts attempt\n          try {\n            if (\n              permission === false ||\n              (await provider._metamask.isUnlocked()) === false\n            ) {\n              accounts = await provider.request({\n                method: 'eth_requestAccounts'\n              })\n            }\n            if (\n              accounts === undefined ||\n              accounts == null ||\n              Array.isArray(accounts) === false ||\n              accounts.length === 0\n            ) {\n              accounts = await provider.request({ method: 'eth_accounts' })\n            }\n          } catch (error) {\n            if (error.code === 4001) {\n              throw error\n            }\n            console.error(error)\n          }\n        }\n        // Enable attempt\n        if (\n          accounts === undefined ||\n          accounts == null ||\n          Array.isArray(accounts) === false ||\n          accounts.length === 0\n        ) {\n          if (typeof provider.enable === 'function') {\n            accounts = await provider.enable()\n          }\n        }\n        if (\n          accounts === undefined ||\n          accounts == null ||\n          Array.isArray(accounts) === false ||\n          accounts.length === 0\n        ) {\n          throw new Error('Unable to retrieve any Ethereum accounts...')\n        }\n        if (provider.chainId !== undefined) {\n          console.log(\n            `Chain: ${provider.chainId}, Connected Account: ${accounts[0]}`\n          )\n        } else {\n          console.log(`Connected Account: ${accounts[0]}`)\n        }\n        try {\n          var tStart = new Date()\n          decryptedText = await provider.request({\n            method: 'eth_decrypt',\n            params: [text, accounts[0]]\n          })\n          if (decryptedText !== undefined || decryptedText !== null) {\n            var tStop = new Date() - tStart\n            var ratio = Math.floor((decryptedText.length * 100) / text.length)\n            console.log(\n              `Ethereum Decrypt: ${tStop}ms, In: ${text.length}, Out: ${decryptedText.length}, Ratio: ${ratio}%`\n            )\n          }\n        } catch (error) {\n          if (error.code === 4001) {\n            throw error\n          }\n          console.error(error)\n          throw new Error('Unable to Decrypt Ethereum content...')\n        }\n      } catch (error) {\n        if (error.code === 4001) {\n          $tw.utils.error('Rejected User Request...')\n        } else {\n          $tw.utils.error(error.message)\n        }\n      }\n      callback(decryptedText)\n    }\n\n    $tw.boot.passwordPrompt = function (text, callback) {\n      var prompt = 'Enter a password to decrypt this TiddlyWiki'\n      // Prompt for the password\n      if ($tw.utils.hop($tw.boot, 'encryptionPrompts')) {\n        prompt = $tw.boot.encryptionPrompts.decrypt\n      }\n      $tw.passwordPrompt.createPrompt({\n        serviceName: prompt,\n        noUserName: true,\n        submitText: 'Decrypt',\n        callback: function (data) {\n          // Attempt to decrypt the tiddlers\n          $tw.crypto.setPassword(data.password)\n          var decryptedText = $tw.crypto.decrypt(text)\n          if (decryptedText) {\n            callback(decryptedText)\n            // Exit and remove the password prompt\n            return true\n          } else {\n            // We didn't decrypt everything, so continue to prompt for password\n            return false\n          }\n        }\n      })\n    }\n\n    $tw.boot.preloadTiddler = function (text, callback) {\n      try {\n        if (text !== undefined && text !== null) {\n          var json = JSON.parse(text)\n          for (var title in json) {\n            $tw.preloadTiddler(json[title])\n          }\n        }\n      } catch (error) {\n        console.error(error)\n      }\n      callback()\n    }\n\n    $tw.boot.inflateTiddlers = function (callback) {\n      var compressedArea = document.getElementById('compressedStoreArea')\n      if (compressedArea) {\n        var inflate = function (b64) {\n          var text = null\n          if (b64 !== undefined && b64 !== null) {\n            text = $tw.compress.inflate(b64)\n          }\n          $tw.boot.preloadTiddler(text, callback)\n        }\n        var text = compressedArea.innerHTML\n        if (text.startsWith('{\"pako\":')) {\n          var json = JSON.parse(text)\n          if (json.pako.startsWith('{\"iv\":')) {\n            $tw.boot.passwordPrompt(json.pako, function (decrypted) {\n              inflate(decrypted)\n            })\n          } else if (json.pako.startsWith('{\"version\":')) {\n            $tw.boot.metamaskPrompt(json.pako, function (decrypted) {\n              inflate(decrypted)\n            })\n          } else {\n            inflate(json.pako)\n          }\n        } else {\n          $tw.boot.preloadTiddler(text, callback)\n        }\n      } else {\n        // Preload any encrypted tiddlers\n        $tw.boot.decryptEncryptedTiddlers(callback)\n      }\n    }\n\n    /**\n     * Decrypt any tiddlers stored within the element with the ID \"encryptedArea\".\n     * The function is asynchronous to allow the user to be prompted for a password\n     * callback: function to be called the decryption is complete\n     */\n    $tw.boot.decryptEncryptedTiddlers = function (callback) {\n      var encryptedArea = document.getElementById('encryptedStoreArea')\n      if (encryptedArea) {\n        var text = encryptedArea.innerHTML\n        if (text.startsWith('{\"iv\":')) {\n          $tw.boot.passwordPrompt(text, function (decrypted) {\n            $tw.boot.preloadTiddler(decrypted, callback)\n          })\n        } else if (text.startsWith('{\"version\":')) {\n          $tw.boot.metamaskPrompt(text, function (decrypted) {\n            $tw.boot.preloadTiddler(decrypted, callback)\n          })\n        } else {\n          $tw.boot.preloadTiddler(text, callback)\n        }\n      } else {\n        // Just invoke the callback straight away if there weren't any encrypted tiddlers\n        callback()\n      }\n    }\n\n    /**\n     * Register a deserializer that can extract tiddlers from the DOM\n     */\n    $tw.modules.define(\n      '$:/boot/tiddlerdeserializer/dom',\n      'tiddlerdeserializer',\n      {\n        '(DOM)': function (node) {\n          var extractTextTiddlers = function (node) {\n            var e = node.firstChild\n            while (e && e.nodeName.toLowerCase() !== 'pre') {\n              e = e.nextSibling\n            }\n            var title = node.getAttribute ? node.getAttribute('title') : null\n            if (e && title) {\n              var attrs = node.attributes\n              var tiddler = {\n                text: $tw.utils.htmlDecode(e.innerHTML)\n              }\n              for (var i = attrs.length - 1; i >= 0; i--) {\n                tiddler[attrs[i].name] = attrs[i].value\n              }\n              return [tiddler]\n            } else {\n              return null\n            }\n          }\n          var extractModuleTiddlers = function (node) {\n            if (node.hasAttribute && node.hasAttribute('data-tiddler-title')) {\n              var text = node.innerHTML\n              var s = text.indexOf('{')\n              var e = text.lastIndexOf('}')\n              if (node.hasAttribute('data-module') && s !== -1 && e !== -1) {\n                text = text.substring(s + 1, e)\n              }\n              var fields = { text: text }\n              var attributes = node.attributes\n              for (var a = 0; a < attributes.length; a++) {\n                if (attributes[a].nodeName.substr(0, 13) === 'data-tiddler-') {\n                  fields[attributes[a].nodeName.substr(13)] =\n                    attributes[a].value\n                }\n              }\n              return [fields]\n            } else {\n              return null\n            }\n          }\n          var t\n          var result = []\n          if (node) {\n            for (t = 0; t < node.childNodes.length; t++) {\n              var childNode = node.childNodes[t]\n              var tiddlers = extractTextTiddlers(childNode)\n              tiddlers = tiddlers || extractModuleTiddlers(childNode)\n              if (tiddlers) {\n                result.push.apply(result, tiddlers)\n              }\n            }\n          }\n          return result\n        }\n      }\n    )\n\n    $tw.loadTiddlersBrowser = function () {\n      // In the browser, we load tiddlers from certain elements\n      var containerIds = [\n        'libraryModules',\n        'modules',\n        'bootKernelPrefix',\n        'bootKernel',\n        'styleArea',\n        'storeArea',\n        'systemArea'\n      ]\n      for (var t = 0; t < containerIds.length; t++) {\n        $tw.wiki.addTiddlers(\n          $tw.wiki.deserializeTiddlers(\n            '(DOM)',\n            document.getElementById(containerIds[t])\n          )\n        )\n      }\n    }\n  } else {\n    /////////////////////////// Server definitions\n\n    /**\n     * Get any compressed tiddlers\n     */\n    $tw.boot.inflateTiddlers = function (callback) {\n      // Storing compressed tiddlers on the server isn't supported yet\n      callback()\n    }\n\n    /**\n     * Get any encrypted tiddlers\n     */\n    $tw.boot.decryptEncryptedTiddlers = function (callback) {\n      // Storing encrypted tiddlers on the server isn't supported yet\n      callback()\n    }\n  } // End of if($tw.browser && !$tw.node)\n\n  /////////////////////////// Node definitions\n\n  if ($tw.node) {\n    /**\n     * Load the tiddlers contained in a particular file (and optionally extract fields from the accompanying .meta file)\n     * returned as {filepath:,type:,tiddlers:[],hasMetaFile:}\n     */\n    $tw.loadTiddlersFromFile = function (filepath, fields) {\n      var ext = path.extname(filepath)\n      var extensionInfo = $tw.utils.getFileExtensionInfo(ext)\n      var type = extensionInfo ? extensionInfo.type : null\n      var typeInfo = type ? $tw.config.contentTypeInfo[type] : null\n      var data = fs.readFileSync(\n        filepath,\n        typeInfo ? typeInfo.encoding : 'utf8'\n      )\n      var tiddlers = $tw.wiki.deserializeTiddlers(ext, data, fields)\n      var metadata = $tw.loadMetadataForFile(filepath)\n      if (metadata) {\n        if (type === 'application/json') {\n          tiddlers = [{ text: data, type: 'application/json' }]\n        }\n        tiddlers = [$tw.utils.extend({}, tiddlers[0], metadata)]\n      }\n      return {\n        filepath: filepath,\n        type: type,\n        tiddlers: tiddlers,\n        hasMetaFile: !!metadata\n      }\n    }\n\n    /**\n     * Load the metadata fields in the .meta file corresponding to a particular file\n     */\n    $tw.loadMetadataForFile = function (filepath) {\n      var metafilename = filepath + '.meta'\n      if (fs.existsSync(metafilename)) {\n        return $tw.utils.parseFields(\n          fs.readFileSync(metafilename, 'utf8') || ''\n        )\n      } else {\n        return null\n      }\n    }\n\n    /**\n     * A default set of files for TiddlyWiki to ignore during load.\n     * This matches what NPM ignores, and adds \"*.meta\" to ignore tiddler\n     * metadata files.\n     */\n    $tw.boot.excludeRegExp = /^\\.DS_Store$|^.*\\.meta$|^\\..*\\.swp$|^\\._.*$|^\\.git$|^\\.hg$|^\\.lock-wscript$|^\\.svn$|^\\.wafpickle-.*$|^CVS$|^npm-debug\\.log$/\n\n    /**\n     * Load all the tiddlers recursively from a directory, including honouring `tiddlywiki.files` files for drawing in external files.\n     * Returns an array of {filepath:,type:,tiddlers: [{..fields...}],hasMetaFile:}.\n     * Note that no file information is returned for externally loaded tiddlers, just the `tiddlers` property.\n     */\n    $tw.loadTiddlersFromPath = function (filepath, excludeRegExp) {\n      excludeRegExp = excludeRegExp || $tw.boot.excludeRegExp\n      var tiddlers = []\n      if (fs.existsSync(filepath)) {\n        var stat = fs.statSync(filepath)\n        if (stat.isDirectory()) {\n          var files = fs.readdirSync(filepath)\n          // Look for a tiddlywiki.files file\n          if (files.indexOf('tiddlywiki.files') !== -1) {\n            Array.prototype.push.apply(\n              tiddlers,\n              $tw.loadTiddlersFromSpecification(filepath, excludeRegExp)\n            )\n          } else {\n            // If not, read all the files in the directory\n            $tw.utils.each(files, function (file) {\n              if (!excludeRegExp.test(file) && file !== 'plugin.info') {\n                tiddlers.push.apply(\n                  tiddlers,\n                  $tw.loadTiddlersFromPath(\n                    filepath + path.sep + file,\n                    excludeRegExp\n                  )\n                )\n              }\n            })\n          }\n        } else if (stat.isFile()) {\n          tiddlers.push($tw.loadTiddlersFromFile(filepath, { title: filepath }))\n        }\n      }\n      return tiddlers\n    }\n\n    /**\n     * Load all the tiddlers defined by a `tiddlywiki.files` specification file\n     * filepath: pathname of the directory containing the specification file\n     */\n    $tw.loadTiddlersFromSpecification = function (filepath, excludeRegExp) {\n      var tiddlers = []\n      // Read the specification\n      var filesInfo = JSON.parse(\n        fs.readFileSync(filepath + path.sep + 'tiddlywiki.files', 'utf8')\n      )\n      // Helper to process a file\n      var processFile = function (filename, isTiddlerFile, fields) {\n        var extInfo = $tw.config.fileExtensionInfo[path.extname(filename)]\n        var type = (extInfo || {}).type || fields.type || 'text/plain'\n        var typeInfo = $tw.config.contentTypeInfo[type] || {}\n        var pathname = path.resolve(filepath, filename)\n        var text = fs.readFileSync(pathname, typeInfo.encoding || 'utf8')\n        var metadata = $tw.loadMetadataForFile(pathname) || {}\n        var fileTiddlers\n        if (isTiddlerFile) {\n          fileTiddlers =\n            $tw.wiki.deserializeTiddlers(\n              path.extname(pathname),\n              text,\n              metadata\n            ) || []\n        } else {\n          fileTiddlers = [$tw.utils.extend({ text: text }, metadata)]\n        }\n        var combinedFields = $tw.utils.extend({}, fields, metadata)\n        $tw.utils.each(fileTiddlers, function (tiddler) {\n          $tw.utils.each(combinedFields, function (fieldInfo, name) {\n            if (typeof fieldInfo === 'string' || $tw.utils.isArray(fieldInfo)) {\n              tiddler[name] = fieldInfo\n            } else {\n              var value = tiddler[name]\n              switch (fieldInfo.source) {\n                case 'filename':\n                  value = path.basename(filename)\n                  break\n                case 'filename-uri-decoded':\n                  value = decodeURIComponent(path.basename(filename))\n                  break\n                case 'basename':\n                  value = path.basename(filename, path.extname(filename))\n                  break\n                case 'basename-uri-decoded':\n                  value = decodeURIComponent(\n                    path.basename(filename, path.extname(filename))\n                  )\n                  break\n                case 'extname':\n                  value = path.extname(filename)\n                  break\n                case 'created':\n                  value = new Date(fs.statSync(pathname).birthtime)\n                  break\n                case 'modified':\n                  value = new Date(fs.statSync(pathname).mtime)\n                  break\n              }\n              if (fieldInfo.prefix) {\n                value = fieldInfo.prefix + value\n              }\n              if (fieldInfo.suffix) {\n                value = value + fieldInfo.suffix\n              }\n              tiddler[name] = value\n            }\n          })\n        })\n        tiddlers.push({ tiddlers: fileTiddlers })\n      }\n      // Process the listed tiddlers\n      $tw.utils.each(filesInfo.tiddlers, function (tidInfo) {\n        if (tidInfo.prefix && tidInfo.suffix) {\n          tidInfo.fields.text = {\n            prefix: tidInfo.prefix,\n            suffix: tidInfo.suffix\n          }\n        } else if (tidInfo.prefix) {\n          tidInfo.fields.text = { prefix: tidInfo.prefix }\n        } else if (tidInfo.suffix) {\n          tidInfo.fields.text = { suffix: tidInfo.suffix }\n        }\n        processFile(tidInfo.file, tidInfo.isTiddlerFile, tidInfo.fields)\n      })\n      // Process any listed directories\n      $tw.utils.each(filesInfo.directories, function (dirSpec) {\n        // Read literal directories directly\n        if (typeof dirSpec === 'string') {\n          var pathname = path.resolve(filepath, dirSpec)\n          if (fs.existsSync(pathname) && fs.statSync(pathname).isDirectory()) {\n            tiddlers.push.apply(\n              tiddlers,\n              $tw.loadTiddlersFromPath(pathname, excludeRegExp)\n            )\n          }\n        } else {\n          // Process directory specifier\n          var dirPath = path.resolve(filepath, dirSpec.path)\n          var files = fs.readdirSync(dirPath)\n          var fileRegExp = new RegExp(dirSpec.filesRegExp || '^.*$')\n          var metaRegExp = /^.*\\.meta$/\n          for (var t = 0; t < files.length; t++) {\n            var filename = files[t]\n            if (\n              filename !== 'tiddlywiki.files' &&\n              !metaRegExp.test(filename) &&\n              fileRegExp.test(filename)\n            ) {\n              processFile(\n                dirPath + path.sep + filename,\n                dirSpec.isTiddlerFile,\n                dirSpec.fields\n              )\n            }\n          }\n        }\n      })\n      return tiddlers\n    }\n\n    /**\n     * Load the tiddlers from a plugin folder, and package them up into a proper JSON plugin tiddler\n     */\n    $tw.loadPluginFolder = function (filepath, excludeRegExp) {\n      excludeRegExp = excludeRegExp || $tw.boot.excludeRegExp\n      var infoPath = filepath + path.sep + 'plugin.info'\n      if (fs.existsSync(filepath) && fs.statSync(filepath).isDirectory()) {\n        // Read the plugin information\n        if (!fs.existsSync(infoPath) || !fs.statSync(infoPath).isFile()) {\n          console.log('Warning: missing plugin.info file in ' + filepath)\n          return null\n        }\n        var pluginInfo = JSON.parse(fs.readFileSync(infoPath, 'utf8'))\n        // Read the plugin files\n        var pluginFiles = $tw.loadTiddlersFromPath(filepath, excludeRegExp)\n        // Save the plugin tiddlers into the plugin info\n        pluginInfo.tiddlers = pluginInfo.tiddlers || Object.create(null)\n        for (var f = 0; f < pluginFiles.length; f++) {\n          var tiddlers = pluginFiles[f].tiddlers\n          for (var t = 0; t < tiddlers.length; t++) {\n            var tiddler = tiddlers[t]\n            if (tiddler.title) {\n              pluginInfo.tiddlers[tiddler.title] = tiddler\n            }\n          }\n        }\n        // Give the plugin the same version number as the core if it doesn't have one\n        if (!('version' in pluginInfo)) {\n          pluginInfo.version = $tw.packageInfo.version\n        }\n        // Use \"plugin\" as the plugin-type if we don't have one\n        if (!('plugin-type' in pluginInfo)) {\n          pluginInfo['plugin-type'] = 'plugin'\n        }\n        pluginInfo.dependents = pluginInfo.dependents || []\n        pluginInfo.type = 'application/json'\n        // Set plugin text\n        pluginInfo.text = JSON.stringify(\n          { tiddlers: pluginInfo.tiddlers },\n          null,\n          4\n        )\n        delete pluginInfo.tiddlers\n        // Deserialise array fields (currently required for the dependents field)\n        for (var field in pluginInfo) {\n          if ($tw.utils.isArray(pluginInfo[field])) {\n            pluginInfo[field] = $tw.utils.stringifyList(pluginInfo[field])\n          }\n        }\n        return pluginInfo\n      } else {\n        return null\n      }\n    }\n\n    /**\n     * name: Name of the plugin to find\n     * paths: array of file paths to search for it\n     * Returns the path of the plugin folder\n     */\n    $tw.findLibraryItem = function (name, paths) {\n      var pathIndex = 0\n      do {\n        var pluginPath = path.resolve(paths[pathIndex], './' + name)\n        if (\n          fs.existsSync(pluginPath) &&\n          fs.statSync(pluginPath).isDirectory()\n        ) {\n          return pluginPath\n        }\n      } while (++pathIndex < paths.length)\n      return null\n    }\n\n    /**\n     * name: Name of the plugin to load\n     * paths: array of file paths to search for it\n     */\n    $tw.loadPlugin = function (name, paths) {\n      var pluginPath = $tw.findLibraryItem(name, paths)\n      if (pluginPath) {\n        var pluginFields = $tw.loadPluginFolder(pluginPath)\n        if (pluginFields) {\n          $tw.wiki.addTiddler(pluginFields)\n          return\n        }\n      }\n      console.log(\"Warning: Cannot find plugin '\" + name + \"'\")\n    }\n\n    /**\n     * libraryPath: Path of library folder for these plugins (relative to core path)\n     * envVar: Environment variable name for these plugins\n     * Returns an array of search paths\n     */\n    $tw.getLibraryItemSearchPaths = function (libraryPath, envVar) {\n      var pluginPaths = [path.resolve($tw.boot.corePath, libraryPath)]\n      var env = process.env[envVar]\n      if (env) {\n        env.split(path.delimiter).map(function (item) {\n          if (item) {\n            pluginPaths.push(item)\n          }\n        })\n      }\n      return pluginPaths\n    }\n\n    /**\n     * plugins: Array of names of plugins (eg, \"tiddlywiki/filesystemadaptor\")\n     * libraryPath: Path of library folder for these plugins (relative to core path)\n     * envVar: Environment variable name for these plugins\n     */\n    $tw.loadPlugins = function (plugins, libraryPath, envVar) {\n      if (plugins) {\n        var pluginPaths = $tw.getLibraryItemSearchPaths(libraryPath, envVar)\n        for (var t = 0; t < plugins.length; t++) {\n          $tw.loadPlugin(plugins[t], pluginPaths)\n        }\n      }\n    }\n\n    /**\n     * path: path of wiki directory\n     * options:\n     *  parentPaths: array of parent paths that we mustn't recurse into\n     *  readOnly: true if the tiddler file paths should not be retained\n     */\n    $tw.loadWikiTiddlers = function (wikiPath, options) {\n      options = options || {}\n      var parentPaths = options.parentPaths || []\n      var wikiInfoPath = path.resolve(wikiPath, $tw.config.wikiInfo)\n      var wikiInfo\n      var pluginFields\n      // Bail if we don't have a wiki info file\n      if (fs.existsSync(wikiInfoPath)) {\n        wikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath, 'utf8'))\n      } else {\n        return null\n      }\n      // Load any parent wikis\n      if (wikiInfo.includeWikis) {\n        parentPaths = parentPaths.slice(0)\n        parentPaths.push(wikiPath)\n        $tw.utils.each(wikiInfo.includeWikis, function (info) {\n          if (typeof info === 'string') {\n            info = { path: info }\n          }\n          var resolvedIncludedWikiPath = path.resolve(wikiPath, info.path)\n          if (parentPaths.indexOf(resolvedIncludedWikiPath) === -1) {\n            var subWikiInfo = $tw.loadWikiTiddlers(resolvedIncludedWikiPath, {\n              parentPaths: parentPaths,\n              readOnly: info['read-only']\n            })\n            // Merge the build targets\n            wikiInfo.build = $tw.utils.extend(\n              [],\n              subWikiInfo.build,\n              wikiInfo.build\n            )\n          } else {\n            $tw.utils.error(\n              'Cannot recursively include wiki ' + resolvedIncludedWikiPath\n            )\n          }\n        })\n      }\n      // Load any plugins, themes and languages listed in the wiki info file\n      $tw.loadPlugins(\n        wikiInfo.plugins,\n        $tw.config.pluginsPath,\n        $tw.config.pluginsEnvVar\n      )\n      $tw.loadPlugins(\n        wikiInfo.themes,\n        $tw.config.themesPath,\n        $tw.config.themesEnvVar\n      )\n      $tw.loadPlugins(\n        wikiInfo.languages,\n        $tw.config.languagesPath,\n        $tw.config.languagesEnvVar\n      )\n      // Load the wiki files, registering them as writable\n      var resolvedWikiPath = path.resolve(\n        wikiPath,\n        $tw.config.wikiTiddlersSubDir\n      )\n      $tw.utils.each($tw.loadTiddlersFromPath(resolvedWikiPath), function (\n        tiddlerFile\n      ) {\n        if (!options.readOnly && tiddlerFile.filepath) {\n          $tw.utils.each(tiddlerFile.tiddlers, function (tiddler) {\n            $tw.boot.files[tiddler.title] = {\n              filepath: tiddlerFile.filepath,\n              type: tiddlerFile.type,\n              hasMetaFile: tiddlerFile.hasMetaFile\n            }\n          })\n        }\n        $tw.wiki.addTiddlers(tiddlerFile.tiddlers)\n      })\n      // Save the original tiddler file locations if requested\n      var config = wikiInfo.config || {}\n      if (config['retain-original-tiddler-path']) {\n        var output = {}\n        var relativePath\n        for (var title in $tw.boot.files) {\n          relativePath = path.relative(\n            resolvedWikiPath,\n            $tw.boot.files[title].filepath\n          )\n          output[title] =\n            path.sep === '/'\n              ? relativePath\n              : relativePath.split(path.sep).join('/')\n        }\n        $tw.wiki.addTiddler({\n          title: '$:/config/OriginalTiddlerPaths',\n          type: 'application/json',\n          text: JSON.stringify(output)\n        })\n      }\n      // Save the path to the tiddlers folder for the filesystemadaptor\n      $tw.boot.wikiTiddlersPath = path.resolve(\n        $tw.boot.wikiPath,\n        config['default-tiddler-location'] || $tw.config.wikiTiddlersSubDir\n      )\n      // Load any plugins within the wiki folder\n      var wikiPluginsPath = path.resolve(wikiPath, $tw.config.wikiPluginsSubDir)\n      if (fs.existsSync(wikiPluginsPath)) {\n        var pluginFolders = fs.readdirSync(wikiPluginsPath)\n        for (var t = 0; t < pluginFolders.length; t++) {\n          pluginFields = $tw.loadPluginFolder(\n            path.resolve(wikiPluginsPath, './' + pluginFolders[t])\n          )\n          if (pluginFields) {\n            $tw.wiki.addTiddler(pluginFields)\n          }\n        }\n      }\n      // Load any themes within the wiki folder\n      var wikiThemesPath = path.resolve(wikiPath, $tw.config.wikiThemesSubDir)\n      if (fs.existsSync(wikiThemesPath)) {\n        var themeFolders = fs.readdirSync(wikiThemesPath)\n        for (var t = 0; t < themeFolders.length; t++) {\n          pluginFields = $tw.loadPluginFolder(\n            path.resolve(wikiThemesPath, './' + themeFolders[t])\n          )\n          if (pluginFields) {\n            $tw.wiki.addTiddler(pluginFields)\n          }\n        }\n      }\n      // Load any languages within the wiki folder\n      var wikiLanguagesPath = path.resolve(\n        wikiPath,\n        $tw.config.wikiLanguagesSubDir\n      )\n      if (fs.existsSync(wikiLanguagesPath)) {\n        var languageFolders = fs.readdirSync(wikiLanguagesPath)\n        for (var t = 0; t < languageFolders.length; t++) {\n          pluginFields = $tw.loadPluginFolder(\n            path.resolve(wikiLanguagesPath, './' + languageFolders[t])\n          )\n          if (pluginFields) {\n            $tw.wiki.addTiddler(pluginFields)\n          }\n        }\n      }\n      return wikiInfo\n    }\n\n    $tw.loadTiddlersNode = function () {\n      // Load the boot tiddlers\n      $tw.utils.each($tw.loadTiddlersFromPath($tw.boot.bootPath), function (\n        tiddlerFile\n      ) {\n        $tw.wiki.addTiddlers(tiddlerFile.tiddlers)\n      })\n      // Load the core tiddlers\n      $tw.wiki.addTiddler($tw.loadPluginFolder($tw.boot.corePath))\n      // Load any extra plugins\n      $tw.utils.each($tw.boot.extraPlugins, function (name) {\n        if (name.charAt(0) === '+') {\n          // Relative path to plugin\n          var pluginFields = $tw.loadPluginFolder(name.substring(1))\n          if (pluginFields) {\n            $tw.wiki.addTiddler(pluginFields)\n          }\n        } else {\n          var parts = name.split('/')\n          var type = parts[0]\n          if (\n            parts.length === 3 &&\n            ['plugins', 'themes', 'languages'].indexOf(type) !== -1\n          ) {\n            $tw.loadPlugins(\n              [parts[1] + '/' + parts[2]],\n              $tw.config[type + 'Path'],\n              $tw.config[type + 'EnvVar']\n            )\n          }\n        }\n      })\n      // Load the tiddlers from the wiki directory\n      if ($tw.boot.wikiPath) {\n        $tw.boot.wikiInfo = $tw.loadWikiTiddlers($tw.boot.wikiPath)\n      }\n    }\n\n    // End of if($tw.node)\n  }\n\n  /////////////////////////// Main startup function called once tiddlers have been decrypted\n\n  /**\n   * Startup TiddlyWiki\n   */\n  $tw.boot.startup = function (options) {\n    options = options || {}\n    // Get the URL hash and check for safe mode\n    $tw.locationHash = '#'\n    if ($tw.browser && !$tw.node) {\n      if (location.hash === '#:safe') {\n        $tw.safeMode = true\n      } else {\n        $tw.locationHash = $tw.utils.getLocationHash()\n      }\n    }\n    // Initialise some more $tw properties\n    $tw.utils.deepDefaults($tw, {\n      modules: {\n        // Information about each module\n        titles: Object.create(null), // hashmap by module title of {fn:, exports:, moduleType:}\n        types: {} // hashmap by module type of hashmap of exports\n      },\n      config: {\n        // Configuration overridables\n        pluginsPath: '../plugins/',\n        themesPath: '../themes/',\n        languagesPath: '../languages/',\n        editionsPath: '../editions/',\n        wikiInfo: './tiddlywiki.info',\n        wikiPluginsSubDir: './plugins',\n        wikiThemesSubDir: './themes',\n        wikiLanguagesSubDir: './languages',\n        wikiTiddlersSubDir: './tiddlers',\n        wikiOutputSubDir: './output',\n        jsModuleHeaderRegExpString:\n          '^\\\\/\\\\*\\\\\\\\(?:\\\\r?\\\\n)((?:^[^\\\\r\\\\n]*(?:\\\\r?\\\\n))+?)(^\\\\\\\\\\\\*\\\\/$(?:\\\\r?\\\\n)?)',\n        fileExtensionInfo: Object.create(null), // Map file extension to {type:}\n        contentTypeInfo: Object.create(null), // Map type to {encoding:,extension:}\n        pluginsEnvVar: 'TIDDLYWIKI_PLUGIN_PATH',\n        themesEnvVar: 'TIDDLYWIKI_THEME_PATH',\n        languagesEnvVar: 'TIDDLYWIKI_LANGUAGE_PATH',\n        editionsEnvVar: 'TIDDLYWIKI_EDITION_PATH'\n      },\n      log: {}, // Log flags\n      unloadTasks: []\n    })\n    if (!$tw.boot.tasks.readBrowserTiddlers) {\n      // For writable tiddler files, a hashmap of title to {filepath:,type:,hasMetaFile:}\n      $tw.boot.files = Object.create(null)\n      // System paths and filenames\n      $tw.boot.bootPath = options.bootPath || path.dirname(module.filename)\n      $tw.boot.corePath = path.resolve($tw.boot.bootPath, '../core')\n      // If there's no arguments then default to `--help`\n      if ($tw.boot.argv.length === 0) {\n        $tw.boot.argv = ['--help']\n      }\n      // Parse any extra plugin references\n      $tw.boot.extraPlugins = $tw.boot.extraPlugins || []\n      while ($tw.boot.argv[0] && $tw.boot.argv[0].indexOf('+') === 0) {\n        $tw.boot.extraPlugins.push($tw.boot.argv[0].substring(1))\n        $tw.boot.argv.splice(0, 1)\n      }\n      // If the first command line argument doesn't start with `--` then we\n      // interpret it as the path to the wiki folder, which will otherwise default\n      // to the current folder\n      if ($tw.boot.argv[0] && $tw.boot.argv[0].indexOf('--') !== 0) {\n        $tw.boot.wikiPath = $tw.boot.argv[0]\n        $tw.boot.argv = $tw.boot.argv.slice(1)\n      } else {\n        $tw.boot.wikiPath = process.cwd()\n      }\n      // Read package info\n      $tw.packageInfo = $tw.packageInfo || require('../package.json')\n      // Check node version number\n      if (\n        !$tw.utils.checkVersions(\n          process.version.substr(1),\n          $tw.packageInfo.engines.node.substr(2)\n        )\n      ) {\n        $tw.utils.error(\n          'TiddlyWiki5 requires node.js version ' + $tw.packageInfo.engines.node\n        )\n      }\n    }\n    // Add file extension information\n    $tw.utils.registerFileType('text/vnd.tiddlywiki', 'utf8', '.tid')\n    $tw.utils.registerFileType('application/x-tiddler', 'utf8', '.tid')\n    $tw.utils.registerFileType('application/x-tiddlers', 'utf8', '.multids')\n    $tw.utils.registerFileType(\n      'application/x-tiddler-html-div',\n      'utf8',\n      '.tiddler'\n    )\n    $tw.utils.registerFileType('text/vnd.tiddlywiki2-recipe', 'utf8', '.recipe')\n    $tw.utils.registerFileType('text/plain', 'utf8', '.txt')\n    $tw.utils.registerFileType('text/css', 'utf8', '.css')\n    $tw.utils.registerFileType('text/html', 'utf8', ['.html', '.htm'])\n    $tw.utils.registerFileType('application/hta', 'utf16le', '.hta', {\n      deserializerType: 'text/html'\n    })\n    $tw.utils.registerFileType('application/javascript', 'utf8', '.js')\n    $tw.utils.registerFileType('application/json', 'utf8', '.json')\n    $tw.utils.registerFileType('application/pdf', 'base64', '.pdf', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('application/zip', 'base64', '.zip')\n    $tw.utils.registerFileType('application/x-zip-compressed', 'base64', '.zip')\n    $tw.utils.registerFileType('image/jpeg', 'base64', ['.jpg', '.jpeg'], {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/png', 'base64', '.png', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/gif', 'base64', '.gif', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/webp', 'base64', '.webp', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/heic', 'base64', '.heic', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/heif', 'base64', '.heif', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/svg+xml', 'utf8', '.svg', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('image/x-icon', 'base64', '.ico', {\n      flags: ['image']\n    })\n    $tw.utils.registerFileType('application/font-woff', 'base64', '.woff')\n    $tw.utils.registerFileType('application/x-font-ttf', 'base64', '.woff')\n    $tw.utils.registerFileType('application/font-woff2', 'base64', '.woff2')\n    $tw.utils.registerFileType('audio/ogg', 'base64', '.ogg')\n    $tw.utils.registerFileType('video/ogg', 'base64', ['.ogm', '.ogv', '.ogg'])\n    $tw.utils.registerFileType('video/webm', 'base64', '.webm')\n    $tw.utils.registerFileType('video/mp4', 'base64', '.mp4')\n    $tw.utils.registerFileType('audio/mp3', 'base64', '.mp3')\n    $tw.utils.registerFileType('audio/mp4', 'base64', ['.mp4', '.m4a'])\n    $tw.utils.registerFileType('text/markdown', 'utf8', ['.md', '.markdown'], {\n      deserializerType: 'text/x-markdown'\n    })\n    $tw.utils.registerFileType('text/x-markdown', 'utf8', ['.md', '.markdown'])\n    $tw.utils.registerFileType('application/enex+xml', 'utf8', '.enex')\n    $tw.utils.registerFileType(\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      'base64',\n      '.docx'\n    )\n    $tw.utils.registerFileType(\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      'base64',\n      '.xlsx'\n    )\n    $tw.utils.registerFileType(\n      'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n      'base64',\n      '.pptx'\n    )\n    $tw.utils.registerFileType('text/x-bibtex', 'utf8', '.bib', {\n      deserializerType: 'application/x-bibtex'\n    })\n    $tw.utils.registerFileType('application/x-bibtex', 'utf8', '.bib')\n    $tw.utils.registerFileType('application/epub+zip', 'base64', '.epub')\n    $tw.utils.registerFileType(\n      'application/octet-stream',\n      'base64',\n      '.octet-stream'\n    )\n    // Create the wiki store for the app\n    $tw.wiki = new $tw.Wiki()\n    // Install built in tiddler fields modules\n    $tw.Tiddler.fieldModules = $tw.modules.getModulesByTypeAsHashmap(\n      'tiddlerfield'\n    )\n    // Install the tiddler deserializer modules\n    $tw.Wiki.tiddlerDeserializerModules = Object.create(null)\n    $tw.modules.applyMethods(\n      'tiddlerdeserializer',\n      $tw.Wiki.tiddlerDeserializerModules\n    )\n    // Call unload handlers in the browser\n    if ($tw.browser) {\n      window.onbeforeunload = function (event) {\n        event = event || {}\n        var result\n        $tw.utils.each($tw.unloadTasks, function (task) {\n          var r = task(event)\n          if (r) {\n            result = r\n          }\n        })\n        return result\n      }\n    }\n    // Load tiddlers\n    if ($tw.boot.tasks.readBrowserTiddlers) {\n      $tw.loadTiddlersBrowser()\n    } else {\n      $tw.loadTiddlersNode()\n    }\n    // Load any preloaded tiddlers\n    if ($tw.preloadTiddlers) {\n      $tw.wiki.addTiddlers($tw.preloadTiddlers)\n    }\n    // Give hooks a chance to modify the store\n    $tw.hooks.invokeHook('th-boot-tiddlers-loaded')\n    // Unpack plugin tiddlers\n    $tw.wiki.readPluginInfo()\n    $tw.wiki.registerPluginTiddlers(\n      'plugin',\n      $tw.safeMode ? ['$:/core'] : undefined\n    )\n    $tw.wiki.unpackPluginTiddlers()\n    // Process \"safe mode\"\n    if ($tw.safeMode) {\n      $tw.wiki.processSafeMode()\n    }\n    // Register typed modules from the tiddlers we've just loaded\n    $tw.wiki.defineTiddlerModules()\n    // And any modules within plugins\n    $tw.wiki.defineShadowModules()\n    // Make sure the crypto state tiddler is up to date\n    if ($tw.crypto) {\n      var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\n      if (encrypted && encrypted.fields._public_key) {\n        $tw.crypto.setEncryptionKey(encrypted.fields._public_key)\n      } else {\n        $tw.crypto.updateCryptoStateTiddler()\n      }\n    }\n    // Gather up any startup modules\n    $tw.boot.remainingStartupModules = [] // Array of startup modules\n    $tw.modules.forEachModuleOfType('startup', function (title, module) {\n      if (module.startup) {\n        $tw.boot.remainingStartupModules.push(module)\n      }\n    })\n    // Keep track of the startup tasks that have been executed\n    $tw.boot.executedStartupModules = Object.create(null)\n    $tw.boot.disabledStartupModules = $tw.boot.disabledStartupModules || []\n    // Repeatedly execute the next eligible task\n    $tw.boot.executeNextStartupTask(options.callback)\n  }\n\n  /**\n   * Add another unload task\n   */\n  $tw.addUnloadTask = function (task) {\n    if ($tw.unloadTasks.indexOf(task) === -1) {\n      $tw.unloadTasks.push(task)\n    }\n  }\n\n  /**\n   * Execute the remaining eligible startup tasks\n   */\n  $tw.boot.executeNextStartupTask = function (callback) {\n    // Find the next eligible task\n    var taskIndex = 0\n    var task\n    var asyncTaskCallback = function () {\n      if (task.name) {\n        $tw.boot.executedStartupModules[task.name] = true\n      }\n      return $tw.boot.executeNextStartupTask(callback)\n    }\n    while (taskIndex < $tw.boot.remainingStartupModules.length) {\n      task = $tw.boot.remainingStartupModules[taskIndex]\n      if ($tw.boot.isStartupTaskEligible(task)) {\n        // Remove this task from the list\n        $tw.boot.remainingStartupModules.splice(taskIndex, 1)\n        // Assemble log message\n        var s = ['Startup task:', task.name]\n        if (task.platforms) {\n          s.push('platforms:', task.platforms.join(','))\n        }\n        if (task.after) {\n          s.push('after:', task.after.join(','))\n        }\n        if (task.before) {\n          s.push('before:', task.before.join(','))\n        }\n        $tw.boot.log(s.join(' '))\n        // Execute task\n        if (!$tw.utils.hop(task, 'synchronous') || task.synchronous) {\n          task.startup()\n          if (task.name) {\n            $tw.boot.executedStartupModules[task.name] = true\n          }\n          return $tw.boot.executeNextStartupTask(callback)\n        } else {\n          task.startup(asyncTaskCallback)\n          return true\n        }\n      }\n      taskIndex++\n    }\n    if (typeof callback === 'function') {\n      callback()\n    }\n    return false\n  }\n\n  /**\n   * Returns true if we are running on one platforms specified in a task modules `platforms` array\n   */\n  $tw.boot.doesTaskMatchPlatform = function (taskModule) {\n    var platforms = taskModule.platforms\n    if (platforms) {\n      for (var t = 0; t < platforms.length; t++) {\n        if (\n          (platforms[t] === 'browser' && !$tw.browser) ||\n          (platforms[t] === 'node' && !$tw.node)\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  $tw.boot.isStartupTaskEligible = function (taskModule) {\n    var t\n    // Check that the platform is correct\n    if (!$tw.boot.doesTaskMatchPlatform(taskModule)) {\n      return false\n    }\n    var name = taskModule.name\n    var remaining = $tw.boot.remainingStartupModules\n    if (name) {\n      // Fail if this module is disabled\n      if ($tw.boot.disabledStartupModules.indexOf(name) !== -1) {\n        return false\n      }\n      // Check that no other outstanding tasks must be executed before this one\n      for (t = 0; t < remaining.length; t++) {\n        var task = remaining[t]\n        if (task.before && task.before.indexOf(name) !== -1) {\n          if (\n            $tw.boot.doesTaskMatchPlatform(task) ||\n            (task.name && $tw.boot.disabledStartupModules.indexOf(name) !== -1)\n          ) {\n            return false\n          }\n        }\n      }\n    }\n    // Check that all of the tasks that we must be performed after has been done\n    var after = taskModule.after\n    if (after) {\n      for (t = 0; t < after.length; t++) {\n        if (!$tw.boot.executedStartupModules[after[t]]) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Global Hooks mechanism which allows plugins to modify default functionality\n   */\n  $tw.hooks = $tw.hooks || { names: {} }\n\n  /**\n   * Add hooks to the  hashmap\n   */\n  $tw.hooks.addHook = function (hookName, definition) {\n    if ($tw.utils.hop($tw.hooks.names, hookName)) {\n      $tw.hooks.names[hookName].push(definition)\n    } else {\n      $tw.hooks.names[hookName] = [definition]\n    }\n  }\n\n  /**\n   * Invoke the hook by key\n   */\n  $tw.hooks.invokeHook = function (hookName /*, value,... */) {\n    var args = Array.prototype.slice.call(arguments, 1)\n    if ($tw.utils.hop($tw.hooks.names, hookName)) {\n      for (var i = 0; i < $tw.hooks.names[hookName].length; i++) {\n        args[0] = $tw.hooks.names[hookName][i].apply(null, args)\n      }\n    }\n    return args[0]\n  }\n\n  /////////////////////////// Main boot function to decrypt tiddlers and then startup\n\n  $tw.boot.boot = function (callback) {\n    // Initialise crypto object\n    $tw.crypto = new $tw.utils.Crypto()\n    // Initialise password prompter\n    if ($tw.browser && !$tw.node) {\n      $tw.passwordPrompt = new $tw.utils.PasswordPrompt()\n    }\n    // Initialise compress object\n    $tw.compress = new $tw.utils.Compress()\n    // Preload any compressed tiddlers\n    $tw.boot.inflateTiddlers(function () {\n      // Startup\n      $tw.boot.startup({ callback: callback })\n    })\n  }\n\n  /////////////////////////// Autoboot in the browser\n\n  if ($tw.browser && !$tw.boot.suppressBoot) {\n    $tw.boot.boot()\n  }\n\n  return $tw\n}\n\nif (typeof exports !== 'undefined') {\n  exports.TiddlyWiki = _boot\n} else {\n  _boot(window.$tw)\n}\n",
    "type": "application/javascript",
    "tags": "$:/ipfs/core"
}