{
    "title": "$:/boot/boot.js",
    "text": "// boot modules\nvar _boot = (function($tw) {\n\n  /*jslint node: true, browser: true */\n  /*global modules: false, $tw: false */\n  \"use strict\";\n\n  // Include bootprefix if we're not given module data\n  if(!$tw) {\n    $tw = require(\"./bootprefix.js\").bootprefix();\n  }\n\n  $tw.utils = $tw.utils || Object.create(null);\n\n  /////////////////////////// Standard node.js libraries\n\n  var fs, path, vm;\n  if($tw.node) {\n    fs = require(\"fs\");\n    path = require(\"path\");\n    vm = require(\"vm\");\n  }\n\n  /////////////////////////// Utility functions\n\n  $tw.boot.log = function(str) {\n    $tw.boot.logMessages = $tw.boot.logMessages || [];\n    $tw.boot.logMessages.push(str);\n  }\n\n  /**\n   * Check if an object has a property\n   */\n  $tw.utils.hop = function(object,property) {\n    return object ? Object.prototype.hasOwnProperty.call(object,property) : false;\n  };\n\n  /**\n   * Determine if a value is an array\n   */\n  $tw.utils.isArray = function(value) {\n    return Object.prototype.toString.call(value) == \"[object Array]\";\n  };\n\n  /**\n   * Check if an array is equal by value and by reference.\n   */\n  $tw.utils.isArrayEqual = function(array1,array2) {\n    if(array1 === array2) {\n      return true;\n    }\n    array1 = array1 || [];\n    array2 = array2 || [];\n    if(array1.length !== array2.length) {\n      return false;\n    }\n    return array1.every(function(value,index) {\n      return value === array2[index];\n    });\n  };\n\n  /**\n   * Push entries onto an array, removing them first if they already exist in the array\n   * array: array to modify (assumed to be free of duplicates)\n   * value: a single value to push or an array of values to push\n   */\n  $tw.utils.pushTop = function(array,value) {\n    var t,p;\n    if($tw.utils.isArray(value)) {\n      // Remove any array entries that are duplicated in the new values\n      if(value.length !== 0) {\n        if(array.length !== 0) {\n          if(value.length < array.length) {\n            for(t=0; t<value.length; t++) {\n              p = array.indexOf(value[t]);\n              if(p !== -1) {\n                array.splice(p,1);\n              }\n            }\n          } else {\n            for(t=array.length-1; t>=0; t--) {\n              p = value.indexOf(array[t]);\n              if(p !== -1) {\n                array.splice(t,1);\n              }\n            }\n          }\n        }\n        // Push the values on top of the main array\n        array.push.apply(array,value);\n      }\n    } else {\n      p = array.indexOf(value);\n      if(p !== -1) {\n        array.splice(p,1);\n      }\n      array.push(value);\n    }\n    return array;\n  };\n\n  /**\n   * Determine if a value is a date\n   */\n  $tw.utils.isDate = function(value) {\n    return Object.prototype.toString.call(value) === \"[object Date]\";\n  };\n\n  /**\n   * Iterate through all the own properties of an object or array. Callback is invoked with (element,title,object)\n   */\n  $tw.utils.each = function(object,callback) {\n    var next,f,length;\n    if(object) {\n      if(Object.prototype.toString.call(object) == \"[object Array]\") {\n        for (f=0, length=object.length; f<length; f++) {\n          next = callback(object[f],f,object);\n          if(next === false) {\n            break;\n          }\n          }\n      } else {\n        var keys = Object.keys(object);\n        for (f=0, length=keys.length; f<length; f++) {\n          var key = keys[f];\n          next = callback(object[key],key,object);\n          if(next === false) {\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Helper for making DOM elements\n   * tag: tag name\n   * options: see below\n   * Options include:\n   * namespace: defaults to http://www.w3.org/1999/xhtml\n   * attributes: hashmap of attribute values\n   * style: hashmap of styles\n   * text: text to add as a child node\n   * children: array of further child nodes\n   * innerHTML: optional HTML for element\n   * class: class name(s)\n   * document: defaults to current document\n   * eventListeners: array of event listeners (this option won't work until $tw.utils.addEventListeners() has been loaded)\n   */\n  $tw.utils.domMaker = function(tag,options) {\n    var doc = options.document || document;\n    var element = doc.createElementNS(options.namespace || \"http://www.w3.org/1999/xhtml\",tag);\n    if(options[\"class\"]) {\n      element.className = options[\"class\"];\n    }\n    if(options.text) {\n      element.appendChild(doc.createTextNode(options.text));\n    }\n    $tw.utils.each(options.children,function(child) {\n      element.appendChild(child);\n    });\n    if(options.innerHTML) {\n      element.innerHTML = options.innerHTML;\n    }\n    $tw.utils.each(options.attributes,function(attribute,name) {\n      element.setAttribute(name,attribute);\n    });\n    $tw.utils.each(options.style,function(value,name) {\n      element.style[name] = value;\n    });\n    if(options.eventListeners) {\n      $tw.utils.addEventListeners(element,options.eventListeners);\n    }\n    return element;\n  };\n\n  /**\n   * Display an error and exit\n   */\n  $tw.utils.error = function(err) {\n    // Prepare the error message\n    var errHeading = ( $tw.language == undefined ? \"Internal JavaScript Error\" : $tw.language.getString(\"InternalJavaScriptError/Title\") ),\n      promptMsg = ( $tw.language == undefined ? \"Well, this is embarrassing. It is recommended that you restart TiddlyWiki by refreshing your browser\" : $tw.language.getString(\"InternalJavaScriptError/Hint\") );\n    // Log the error to the console\n    console.error($tw.node ? \"\\x1b[1;31m\" + err + \"\\x1b[0m\" : err);\n    if($tw.browser && !$tw.node) {\n      // Display an error message to the user\n      var dm = $tw.utils.domMaker,\n        heading = dm(\"h1\",{text: errHeading}),\n        prompt = dm(\"div\",{text: promptMsg, \"class\": \"tc-error-prompt\"}),\n        message = dm(\"div\",{text: err, \"class\":\"tc-error-message\"}),\n        button = dm(\"div\",{children: [dm(\"button\",{text: ( $tw.language == undefined ? \"close\" : $tw.language.getString(\"Buttons/Close/Caption\") )})], \"class\": \"tc-error-prompt\"}),\n        form = dm(\"form\",{children: [heading,prompt,message,button], \"class\": \"tc-error-form\"});\n      document.body.insertBefore(form,document.body.firstChild);\n      form.addEventListener(\"submit\",function(event) {\n        document.body.removeChild(form);\n        event.preventDefault();\n        return false;\n      },true);\n      return null;\n    } else if(!$tw.browser) {\n      // Exit if we're under node.js\n      process.exit(1);\n    }\n  };\n\n  /**\n   * Use our custom error handler if we're in the browser\n   */\n  if($tw.boot.tasks.trapErrors) {\n    window.onerror = function(errorMsg,url,lineNumber) {\n      $tw.utils.error(errorMsg);\n      return false;\n    };\n  }\n\n  /**\n   * Extend an object with the properties from a list of source objects\n   */\n  $tw.utils.extend = function(object /*, sourceObjectList */) {\n    $tw.utils.each(Array.prototype.slice.call(arguments,1),function(source) {\n      if(source) {\n        for (var p in source) {\n          object[p] = source[p];\n        }\n      }\n    });\n    return object;\n  };\n\n  /**\n   * Fill in any null or undefined properties of an object with the properties from a list of source objects.\n   * Each property that is an object is called recursively\n   */\n  $tw.utils.deepDefaults = function(object /*, sourceObjectList */) {\n    $tw.utils.each(Array.prototype.slice.call(arguments,1),function(source) {\n      if(source) {\n        for (var p in source) {\n          if(object[p] === null || object[p] === undefined) {\n            object[p] = source[p];\n          }\n          if(typeof object[p] === \"object\" && typeof source[p] === \"object\") {\n            $tw.utils.deepDefaults(object[p],source[p]);\n          }\n        }\n      }\n    });\n    return object;\n  };\n\n  /**\n   * Convert \"&amp;\" to &, \"&nbsp;\" to nbsp, \"&lt;\" to <, \"&gt;\" to > and \"&quot;\" to \"\n   */\n  $tw.utils.htmlDecode = function(s) {\n    return s.toString().replace(/&lt;/mg,\"<\").replace(/&nbsp;/mg,\"\\xA0\").replace(/&gt;/mg,\">\").replace(/&quot;/mg,\"\\\"\").replace(/&amp;/mg,\"&\");\n  };\n\n  /**\n   * Get the browser location.hash.\n   * We don't use location.hash because of the way that Firefox auto-urldecodes it\n   * (see http://stackoverflow.com/questions/1703552/encoding-of-window-location-hash)\n   */\n  $tw.utils.getLocationHash = function() {\n    var href = window.location.href;\n    var idx = href.indexOf('#');\n    if(idx === -1) {\n      return \"#\";\n    } else if(idx < href.length-1 && href[idx+1] === '#') {\n      // Special case: ignore location hash if it itself starts with a #\n      return \"#\";\n    } else {\n      return href.substring(idx);\n    }\n  };\n\n  /**\n   * Pad a string to a given length with \"0\"s. Length defaults to 2\n   */\n  $tw.utils.pad = function(value,length) {\n    length = length || 2;\n    var s = value.toString();\n    if(s.length < length) {\n      s = \"000000000000000000000000000\".substr(0,length - s.length) + s;\n    }\n    return s;\n  };\n\n  // Convert a date into UTC YYYYMMDDHHMMSSmmm format\n  $tw.utils.stringifyDate = function(value) {\n    return value.getUTCFullYear() +\n        $tw.utils.pad(value.getUTCMonth() + 1) +\n        $tw.utils.pad(value.getUTCDate()) +\n        $tw.utils.pad(value.getUTCHours()) +\n        $tw.utils.pad(value.getUTCMinutes()) +\n        $tw.utils.pad(value.getUTCSeconds()) +\n        $tw.utils.pad(value.getUTCMilliseconds(),3);\n  };\n\n  // Parse a date from a UTC YYYYMMDDHHMMSSmmm format string\n  $tw.utils.parseDate = function(value) {\n    if(typeof value === \"string\") {\n\t\tvar negative = 1;\n\t\tif(value.charAt(0) === \"-\") {\n\t\t\tnegative = -1;\n\t\t\tvalue = value.substr(1);\n\t\t}\n\t\tvar year = parseInt(value.substr(0,4),10) * negative,\n\t\t\td = new Date(Date.UTC(year,\n          parseInt(value.substr(4,2),10)-1,\n          parseInt(value.substr(6,2),10),\n          parseInt(value.substr(8,2)||\"00\",10),\n          parseInt(value.substr(10,2)||\"00\",10),\n          parseInt(value.substr(12,2)||\"00\",10),\n          parseInt(value.substr(14,3)||\"000\",10)));\n\t\t  d.setUTCFullYear(year); // See https://stackoverflow.com/a/5870822\n\t\t  return d;\n    } else if($tw.utils.isDate(value)) {\n      return value;\n    } else {\n      return null;\n    }\n  };\n\n  // Stringify an array of tiddler titles into a list string\n  $tw.utils.stringifyList = function(value) {\n    if($tw.utils.isArray(value)) {\n      var result = new Array(value.length);\n      for(var t=0, l=value.length; t<l; t++) {\n        var entry = value[t] || \"\";\n        if(entry.indexOf(\" \") !== -1) {\n          result[t] = \"[[\" + entry + \"]]\";\n        } else {\n          result[t] = entry;\n        }\n      }\n      return result.join(\" \");\n    } else {\n      return value || \"\";\n    }\n  };\n\n  // Parse a string array from a bracketted list. For example \"OneTiddler [[Another Tiddler]] LastOne\"\n  $tw.utils.parseStringArray = function(value, allowDuplicate) {\n    if(typeof value === \"string\") {\n      var memberRegExp = /(?:^|[^\\S\\xA0])(?:\\[\\[(.*?)\\]\\])(?=[^\\S\\xA0]|$)|([\\S\\xA0]+)/mg,\n        results = [], names = {},\n        match;\n      do {\n        match = memberRegExp.exec(value);\n        if(match) {\n          var item = match[1] || match[2];\n          if(item !== undefined && (!$tw.utils.hop(names,item) || allowDuplicate)) {\n            results.push(item);\n            names[item] = true;\n          }\n        }\n      } while(match);\n      return results;\n    } else if($tw.utils.isArray(value)) {\n      return value;\n    } else {\n      return null;\n    }\n  };\n\n  // Parse a block of name:value fields. The `fields` object is used as the basis for the return value\n  $tw.utils.parseFields = function(text,fields) {\n    fields = fields || Object.create(null);\n    text.split(/\\r?\\n/mg).forEach(function(line) {\n      if(line.charAt(0) !== \"#\") {\n        var p = line.indexOf(\":\");\n        if(p !== -1) {\n          var field = line.substr(0, p).trim(),\n            value = line.substr(p+1).trim();\n          if(field) {\n            fields[field] = value;\n          }\n        }\n      }\n    });\n    return fields;\n  };\n\n  /**\n   * Resolves a source filepath delimited with `/` relative to a specified absolute root filepath.\n   * In relative paths, the special folder name `..` refers to immediate parent directory, and the\n   * name `.` refers to the current directory\n   */\n  $tw.utils.resolvePath = function(sourcepath,rootpath) {\n    // If the source path starts with ./ or ../ then it is relative to the root\n    if(sourcepath.substr(0,2) === \"./\" || sourcepath.substr(0,3) === \"../\" ) {\n      var src = sourcepath.split(\"/\"),\n        root = rootpath.split(\"/\");\n      // Remove the filename part of the root\n      root.splice(root.length-1,1);\n      // Process the source path bit by bit onto the end of the root path\n      while(src.length > 0) {\n        var c = src.shift();\n        if(c === \"..\") { // Slice off the last root entry for a double dot\n          if(root.length > 0) {\n            root.splice(root.length-1,1);\n          }\n        } else if(c !== \".\") { // Ignore dots\n          root.push(c); // Copy other elements across\n        }\n      }\n      return root.join(\"/\");\n    } else {\n      // If it isn't relative, just return the path\n      if(rootpath) {\n        var root = rootpath.split(\"/\");\n        // Remove the filename part of the root\n        root.splice(root.length - 1, 1);\n        return root.join(\"/\") + \"/\" + sourcepath;\n      } else {\n        return sourcepath;\n      }\n    }\n  };\n\n  /**\n   * Parse a semantic version string into its constituent parts -- see https://semver.org\n   */\n  $tw.utils.parseVersion = function(version) {\n    var match = /^v?((\\d+)\\.(\\d+)\\.(\\d+))(?:-([\\dA-Za-z\\-]+(?:\\.[\\dA-Za-z\\-]+)*))?(?:\\+([\\dA-Za-z\\-]+(?:\\.[\\dA-Za-z\\-]+)*))?$/.exec(version);\n    if(match) {\n      return {\n        version: match[1],\n        major: parseInt(match[2],10),\n        minor: parseInt(match[3],10),\n        patch: parseInt(match[4],10),\n        prerelease: match[5],\n        build: match[6]\n      };\n    } else {\n      return null;\n    }\n  };\n\n  /**\n   * Returns +1 if the version string A is greater than the version string B, 0 if they are the same, and +1 if B is greater than A.\n   * Missing or malformed version strings are parsed as 0.0.0\n   */\n  $tw.utils.compareVersions = function(versionStringA,versionStringB) {\n    var defaultVersion = {\n        major: 0,\n        minor: 0,\n        patch: 0\n      },\n      versionA = $tw.utils.parseVersion(versionStringA) || defaultVersion,\n      versionB = $tw.utils.parseVersion(versionStringB) || defaultVersion,\n      diff = [\n        versionA.major - versionB.major,\n        versionA.minor - versionB.minor,\n        versionA.patch - versionB.patch\n      ];\n    if((diff[0] > 0) || (diff[0] === 0 && diff[1] > 0) || (diff[0] === 0 & diff[1] === 0 & diff[2] > 0)) {\n      return +1;\n    } else if((diff[0] < 0) || (diff[0] === 0 && diff[1] < 0) || (diff[0] === 0 & diff[1] === 0 & diff[2] < 0)) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n\n  /**\n   * Returns true if the version string A is greater than the version string B. Returns true if the versions are the same\n   */\n  $tw.utils.checkVersions = function(versionStringA,versionStringB) {\n    return $tw.utils.compareVersions(versionStringA,versionStringB) !== -1;\n  };\n\n  /**\n   * Register file type information\n   * options: {flags: flags,deserializerType: deserializerType}\n   * flags:\"image\" for image types\n   * deserializerType: defaults to type if not specified\n   */\n  $tw.utils.registerFileType = function(type,encoding,extension,options) {\n    options = options || {};\n    if($tw.utils.isArray(extension)) {\n      $tw.utils.each(extension,function(extension) {\n        $tw.config.fileExtensionInfo[extension] = {type: type};\n      });\n      extension = extension[0];\n    } else {\n      $tw.config.fileExtensionInfo[extension] = {type: type};\n    }\n    $tw.config.contentTypeInfo[type] = {encoding: encoding, extension: extension, flags: options.flags || [], deserializerType: options.deserializerType || type};\n  };\n\n  /**\n   * Given an extension, always access the $tw.config.fileExtensionInfo\n   * using a lowercase extension only.\n   */\n  $tw.utils.getFileExtensionInfo = function(ext) {\n    return ext ? $tw.config.fileExtensionInfo[ext.toLowerCase()] : null;\n  }\n\n  /**\n   * Given an extension, get the correct encoding for that file.\n   * defaults to utf8\n   */\n  $tw.utils.getTypeEncoding = function(ext) {\n    var extensionInfo = $tw.utils.getFileExtensionInfo(ext),\n      type = extensionInfo ? extensionInfo.type : null,\n      typeInfo = type ? $tw.config.contentTypeInfo[type] : null;\n    return typeInfo ? typeInfo.encoding : \"utf8\";\n  };\n\n  /**\n   * Creates a PasswordPrompt object\n   */\n  $tw.utils.PasswordPrompt = function() {\n    // Store of pending password prompts\n    this.passwordPrompts = [];\n    // Create the wrapper\n    this.promptWrapper = $tw.utils.domMaker(\"div\",{\"class\":\"tc-password-wrapper\"});\n    document.body.appendChild(this.promptWrapper);\n    // Hide the empty wrapper\n    this.setWrapperDisplay();\n  };\n\n  /**\n   * Hides or shows the wrapper depending on whether there are any outstanding prompts\n   */\n  $tw.utils.PasswordPrompt.prototype.setWrapperDisplay = function() {\n    if(this.passwordPrompts.length) {\n      this.promptWrapper.style.display = \"block\";\n    } else {\n      this.promptWrapper.style.display = \"none\";\n    }\n  };\n\n  /**\n   * Adds a new password prompt. Options are:\n   * submitText: text to use for submit button (defaults to \"Login\")\n   * serviceName: text of the human readable service name\n   * noUserName: set true to disable username prompt\n   * canCancel: set true to enable a cancel button (callback called with null)\n   * repeatPassword: set true to prompt for the password twice\n   * callback: function to be called on submission with parameter of object {username:,password:}. Callback must return `true` to remove the password prompt\n   */\n  $tw.utils.PasswordPrompt.prototype.createPrompt = function(options) {\n    // Create and add the prompt to the DOM\n    var self = this,\n      submitText = options.submitText || \"Login\",\n      dm = $tw.utils.domMaker,\n      children = [dm(\"h1\",{text: options.serviceName})];\n    if(!options.noUserName) {\n      children.push(dm(\"input\",{\n        attributes: {type: \"text\", name: \"username\", placeholder: $tw.language.getString(\"Encryption/Username\")}\n      }));\n    }\n    children.push(dm(\"input\",{\n      attributes: {\n        type: \"password\",\n        name: \"password\",\n        placeholder: ( $tw.language == undefined ? \"Password\" : $tw.language.getString(\"Encryption/Password\") )\n      }\n    }));\n    if(options.repeatPassword) {\n      children.push(dm(\"input\",{\n        attributes: {\n          type: \"password\",\n          name: \"password2\",\n          placeholder: $tw.language.getString(\"Encryption/RepeatPassword\")\n        }\n      }));\n    }\n    if(options.canCancel) {\n      children.push(dm(\"button\",{\n        text: $tw.language.getString(\"Encryption/Cancel\"),\n        attributes: {\n          type: \"button\"\n        },\n        eventListeners: [{\n            name: \"click\",\n            handlerFunction: function(event) {\n              self.removePrompt(promptInfo);\n              options.callback(null);\n            }\n          }]\n      }));\n    }\n    children.push(dm(\"button\",{\n      attributes: {type: \"submit\"},\n      text: submitText\n    }));\n    var form = dm(\"form\",{\n      attributes: {autocomplete: \"off\"},\n      children: children\n    });\n    this.promptWrapper.appendChild(form);\n    window.setTimeout(function() {\n      form.elements[0].focus();\n    },10);\n    // Add a submit event handler\n    var self = this;\n    form.addEventListener(\"submit\",function(event) {\n      // Collect the form data\n      var data = {},t;\n      $tw.utils.each(form.elements,function(element) {\n        if(element.name && element.value) {\n          data[element.name] = element.value;\n        }\n      });\n      // Check that the passwords match\n      if(options.repeatPassword && data.password !== data.password2) {\n        alert($tw.language.getString(\"Encryption/PasswordNoMatch\"));\n      } else {\n        // Call the callback\n        if(options.callback(data)) {\n          // Remove the prompt if the callback returned true\n          self.removePrompt(promptInfo);\n        } else {\n          // Clear the password if the callback returned false\n          $tw.utils.each(form.elements,function(element) {\n            if(element.name === \"password\" || element.name === \"password2\") {\n              element.value = \"\";\n            }\n          });\n        }\n      }\n      event.preventDefault();\n      return false;\n    },true);\n    // Add the prompt to the list\n    var promptInfo = {\n      serviceName: options.serviceName,\n      callback: options.callback,\n      form: form,\n      owner: this\n    };\n    this.passwordPrompts.push(promptInfo);\n    // Make sure the wrapper is displayed\n    this.setWrapperDisplay();\n    return promptInfo;\n  };\n\n  $tw.utils.PasswordPrompt.prototype.removePrompt = function(promptInfo) {\n    var i = this.passwordPrompts.indexOf(promptInfo);\n    if(i !== -1) {\n      this.passwordPrompts.splice(i,1);\n      promptInfo.form.parentNode.removeChild(promptInfo.form);\n      this.setWrapperDisplay();\n    }\n  }\n\n  /**\n   * Crypto helper object for encrypted content. It maintains the password text in a closure, and provides methods to change\n   * the password, and to encrypt/decrypt a block of text\n   */\n  $tw.utils.Crypto = function() {\n    var sjcl = $tw.node ? (global.sjcl || require(\"./sjcl.js\")) : window.sjcl,\n      currentPassword = null,\n      callSjcl = function(method,inputText,password) {\n        password = password || currentPassword;\n        var outputText;\n        try {\n          if(password) {\n            outputText = sjcl[method](password,inputText);\n          }\n        } catch(ex) {\n          console.log(\"Crypto error:\" + ex);\n          outputText = null;\n        }\n        return outputText;\n      };\n    this.setPassword = function(newPassword) {\n      currentPassword = newPassword;\n      this.updateCryptoStateTiddler();\n    };\n    this.updateCryptoStateTiddler = function() {\n      if($tw.wiki) {\n        var state = currentPassword ? \"yes\" : \"no\",\n          tiddler = $tw.wiki.getTiddler(\"$:/isEncrypted\");\n        if(!tiddler || tiddler.fields.text !== state) {\n          $tw.wiki.addTiddler(new $tw.Tiddler({title: \"$:/isEncrypted\", text: state}));\n        }\n      }\n    };\n    this.hasPassword = function() {\n      return !!currentPassword;\n    }\n    this.encrypt = function(text,password) {\n      return callSjcl(\"encrypt\",text,password);\n    };\n    this.decrypt = function(text,password) {\n      return callSjcl(\"decrypt\",text,password);\n    };\n  };\n\n  /////////////////////////// Module mechanism\n\n  /**\n   * Apply a callback to each module of a particular type\n   * moduleType: type of modules to enumerate\n   * callback: function called as callback(title,moduleExports) for each module\n   */\n  $tw.modules.forEachModuleOfType = function(moduleType,callback) {\n    var modules = $tw.modules.types[moduleType];\n    $tw.utils.each(modules,function(element,title) {\n      callback(title,$tw.modules.execute(title));\n    });\n  };\n\n  /**\n   * Get all the modules of a particular type in a hashmap by their `name` field\n   */\n  $tw.modules.getModulesByTypeAsHashmap = function(moduleType,nameField) {\n    nameField = nameField || \"name\";\n    var results = Object.create(null);\n    $tw.modules.forEachModuleOfType(moduleType,function(title,module) {\n      results[module[nameField]] = module;\n    });\n    return results;\n  };\n\n  /**\n   * Apply the exports of the modules of a particular type to a target object\n   */\n  $tw.modules.applyMethods = function(moduleType,targetObject) {\n    if(!targetObject) {\n      targetObject = Object.create(null);\n    }\n    $tw.modules.forEachModuleOfType(moduleType,function(title,module) {\n      $tw.utils.each(module,function(element,title,object) {\n        targetObject[title] = module[title];\n      });\n    });\n    return targetObject;\n  };\n\n  /**\n   * Return a class created from a modules. The module should export the properties to be added to those of the optional base class\n   */\n  $tw.modules.createClassFromModule = function(moduleExports,baseClass) {\n    var newClass = function() {};\n    if(baseClass) {\n      newClass.prototype = new baseClass();\n      newClass.prototype.constructor = baseClass;\n    }\n    $tw.utils.extend(newClass.prototype,moduleExports);\n    return newClass;\n  };\n\n  /**\n   * Return an array of classes created from the modules of a specified type. Each module should export the properties to be added to those of the optional base class\n   */\n  $tw.modules.createClassesFromModules = function(moduleType,subType,baseClass) {\n    var classes = Object.create(null);\n    $tw.modules.forEachModuleOfType(moduleType,function(title,moduleExports) {\n      if(!subType || moduleExports.types[subType]) {\n        classes[moduleExports.name] = $tw.modules.createClassFromModule(moduleExports,baseClass);\n      }\n    });\n    return classes;\n  };\n\n  /////////////////////////// Barebones tiddler object\n\n  /**\n   * Construct a tiddler object from a hashmap of tiddler fields. If multiple hasmaps are provided they are merged,\n   * taking precedence to the right\n   */\n  $tw.Tiddler = function(/* [fields,] fields */) {\n    this.fields = Object.create(null);\n    this.cache = Object.create(null);\n    for(var c=0; c<arguments.length; c++) {\n      var arg = arguments[c],\n        src = (arg instanceof $tw.Tiddler) ? arg.fields : arg;\n      for(var t in src) {\n        if(src[t] === undefined || src[t] === null) {\n          if(t in this.fields) {\n            delete this.fields[t]; // If we get a field that's undefined, delete any previous field value\n          }\n        } else {\n          // Parse the field with the associated field module (if any)\n          var fieldModule = $tw.Tiddler.fieldModules[t],\n            value;\n          if(fieldModule && fieldModule.parse) {\n            value = fieldModule.parse.call(this,src[t]);\n          } else {\n            value = src[t];\n          }\n          // Freeze the field to keep it immutable\n          if(value != null && typeof value === \"object\") {\n            Object.freeze(value);\n          }\n          this.fields[t] = value;\n        }\n      }\n    }\n    // Freeze the tiddler against modification\n    Object.freeze(this.fields);\n    Object.freeze(this);\n  };\n\n  $tw.Tiddler.prototype.hasField = function(field) {\n    return $tw.utils.hop(this.fields,field);\n  };\n\n  /**\n   * Compare two tiddlers for equality\n   * tiddler: the tiddler to compare\n   * excludeFields: array of field names to exclude from the comparison\n   */\n  $tw.Tiddler.prototype.isEqual = function(tiddler,excludeFields) {\n    if(!(tiddler instanceof $tw.Tiddler)) {\n      return false;\n    }\n    excludeFields = excludeFields || [];\n    var self = this,\n      differences = []; // Fields that have differences\n    // Add to the differences array\n    function addDifference(fieldName) {\n      // Check for this field being excluded\n      if(excludeFields.indexOf(fieldName) === -1) {\n        // Save the field as a difference\n        $tw.utils.pushTop(differences,fieldName);\n      }\n    }\n    // Returns true if the two values of this field are equal\n    function isFieldValueEqual(fieldName) {\n      var valueA = self.fields[fieldName],\n        valueB = tiddler.fields[fieldName];\n      // Check for identical string values\n      if(typeof(valueA) === \"string\" && typeof(valueB) === \"string\" && valueA === valueB) {\n        return true;\n      }\n      // Check for identical array values\n      if($tw.utils.isArray(valueA) && $tw.utils.isArray(valueB) && $tw.utils.isArrayEqual(valueA,valueB)) {\n        return true;\n      }\n      // Check for identical date values\n      if($tw.utils.isDate(valueA) && $tw.utils.isDate(valueB) && valueA.getTime() === valueB.getTime()) {\n        return true;\n      }\n      // Otherwise the fields must be different\n      return false;\n    }\n    // Compare our fields\n    for(var fieldName in this.fields) {\n      if(!isFieldValueEqual(fieldName)) {\n        addDifference(fieldName);\n      }\n    }\n    // There's a difference for every field in the other tiddler that we don't have\n    for(fieldName in tiddler.fields) {\n      if(!(fieldName in this.fields)) {\n        addDifference(fieldName);\n      }\n    }\n    // Return whether there were any differences\n    return differences.length === 0;\n  };\n\n  /**\n   * Register and install the built in tiddler field modules\n   */\n  $tw.modules.define(\"$:/boot/tiddlerfields/modified\",\"tiddlerfield\",{\n    name: \"modified\",\n    parse: $tw.utils.parseDate,\n    stringify: $tw.utils.stringifyDate\n  });\n  $tw.modules.define(\"$:/boot/tiddlerfields/created\",\"tiddlerfield\",{\n    name: \"created\",\n    parse: $tw.utils.parseDate,\n    stringify: $tw.utils.stringifyDate\n  });\n  $tw.modules.define(\"$:/boot/tiddlerfields/color\",\"tiddlerfield\",{\n    name: \"color\",\n    editTag: \"input\",\n    editType: \"color\"\n  });\n  $tw.modules.define(\"$:/boot/tiddlerfields/tags\",\"tiddlerfield\",{\n    name: \"tags\",\n    parse: $tw.utils.parseStringArray,\n    stringify: $tw.utils.stringifyList\n  });\n  $tw.modules.define(\"$:/boot/tiddlerfields/list\",\"tiddlerfield\",{\n    name: \"list\",\n    parse: $tw.utils.parseStringArray,\n    stringify: $tw.utils.stringifyList\n  });\n\n  /////////////////////////// Barebones wiki store\n\n  /**\n   * Wiki constructor. State is stored in private members that only a small number of privileged accessor methods have direct access.\n   * Methods added via the prototype have to use these accessors and cannot access the state data directly.\n   * options include:\n   * enableIndexers - Array of indexer names to enable, or null to use all available indexers\n   */\n  $tw.Wiki = function(options) {\n    options = options || {};\n    var self = this,\n      tiddlers = Object.create(null), // Hashmap of tiddlers\n      tiddlerTitles = null, // Array of tiddler titles\n      getTiddlerTitles = function() {\n        if(!tiddlerTitles) {\n          tiddlerTitles = Object.keys(tiddlers);\n        }\n        return tiddlerTitles;\n      },\n      pluginTiddlers = [], // Array of tiddlers containing registered plugins, ordered by priority\n      pluginInfo = Object.create(null), // Hashmap of parsed plugin content\n      shadowTiddlers = Object.create(null), // Hashmap by title of {source:, tiddler:}\n      shadowTiddlerTitles = null,\n      getShadowTiddlerTitles = function() {\n        if(!shadowTiddlerTitles) {\n          shadowTiddlerTitles = Object.keys(shadowTiddlers);\n        }\n        return shadowTiddlerTitles;\n      },\n      enableIndexers = options.enableIndexers || null,\n      indexers = [],\n      indexersByName = Object.create(null);\n\n    this.addIndexer = function(indexer,name) {\n      // Bail if this indexer is not enabled\n      if(enableIndexers && enableIndexers.indexOf(name) === -1) {\n        return;\n      }\n      indexers.push(indexer);\n      indexersByName[name] = indexer;\n      indexer.init();\n    };\n\n    this.getIndexer = function(name) {\n      return indexersByName[name] || null;\n    };\n\n    // Add a tiddler to the store\n    this.addTiddler = function(tiddler) {\n      if(!(tiddler instanceof $tw.Tiddler)) {\n        tiddler = new $tw.Tiddler(tiddler);\n      }\n      // Save the tiddler\n      if(tiddler) {\n        var title = tiddler.fields.title;\n        if(title) {\n          // Uncomment the following line for detailed logs of all tiddler writes\n          // console.log(\"Adding\",title,tiddler)\n          // Record the old tiddler state\n          var updateDescriptor = {\n            old: {\n              tiddler: this.getTiddler(title),\n              shadow: this.isShadowTiddler(title),\n              exists: this.tiddlerExists(title)\n            }\n          }\n          // Save the new tiddler\n          tiddlers[title] = tiddler;\n          // Check we've got it's title\n          if(tiddlerTitles && tiddlerTitles.indexOf(title) === -1) {\n            tiddlerTitles.push(title);\n          }\n          // Record the new tiddler state\n          updateDescriptor[\"new\"] = {\n            tiddler: tiddler,\n            shadow: this.isShadowTiddler(title),\n            exists: this.tiddlerExists(title)\n          }\n          // Update indexes\n          this.clearCache(title);\n          this.clearGlobalCache();\n          $tw.utils.each(indexers,function(indexer) {\n            indexer.update(updateDescriptor);\n          });\n          // Queue a change event\n          this.enqueueTiddlerEvent(title);\n        }\n      }\n    };\n\n    // Delete a tiddler\n    this.deleteTiddler = function(title) {\n      // Uncomment the following line for detailed logs of all tiddler deletions\n      // console.log(\"Deleting\",title)\n      if($tw.utils.hop(tiddlers,title)) {\n        // Record the old tiddler state\n        var updateDescriptor = {\n          old: {\n            tiddler: this.getTiddler(title),\n            shadow: this.isShadowTiddler(title),\n            exists: this.tiddlerExists(title)\n          }\n        }\n        // Delete the tiddler\n        delete tiddlers[title];\n        // Delete it from the list of titles\n        if(tiddlerTitles) {\n          var index = tiddlerTitles.indexOf(title);\n          if(index !== -1) {\n            tiddlerTitles.splice(index,1);\n          }\n        }\n        // Record the new tiddler state\n        updateDescriptor[\"new\"] = {\n          tiddler: this.getTiddler(title),\n          shadow: this.isShadowTiddler(title),\n          exists: this.tiddlerExists(title)\n        }\n        // Update indexes\n        this.clearCache(title);\n        this.clearGlobalCache();\n        $tw.utils.each(indexers,function(indexer) {\n          indexer.update(updateDescriptor);\n        });\n        // Queue a change event\n        this.enqueueTiddlerEvent(title,true);\n      }\n    };\n\n    // Get a tiddler from the store\n    this.getTiddler = function(title) {\n      if(title) {\n        var t = tiddlers[title];\n        if(t instanceof $tw.Tiddler) {\n          return t;\n        } else if(title !== undefined && shadowTiddlers[title]) {\n          return shadowTiddlers[title].tiddler;\n        }\n        return undefined;\n      }\n    };\n\n    // Get an array of all tiddler titles\n    this.allTitles = function() {\n      return getTiddlerTitles().slice(0);\n    };\n\n    // Iterate through all tiddler titles\n    this.each = function(callback) {\n      var titles = getTiddlerTitles(),\n        index,titlesLength,title;\n      for(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\n        title = titles[index];\n        callback(tiddlers[title],title);\n      }\n    };\n\n    // Get an array of all shadow tiddler titles\n    this.allShadowTitles = function() {\n      return getShadowTiddlerTitles().slice(0);\n    };\n\n    // Iterate through all shadow tiddler titles\n    this.eachShadow = function(callback) {\n      var titles = getShadowTiddlerTitles(),\n        index,titlesLength,title;\n      for(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\n        title = titles[index];\n        var shadowInfo = shadowTiddlers[title];\n        callback(shadowInfo.tiddler,title);\n      }\n    };\n\n    // Iterate through all tiddlers and then the shadows\n    this.eachTiddlerPlusShadows = function(callback) {\n      var index,titlesLength,title,\n        titles = getTiddlerTitles();\n      for(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\n        title = titles[index];\n        callback(tiddlers[title],title);\n      }\n      titles = getShadowTiddlerTitles();\n      for(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\n        title = titles[index];\n        if(!tiddlers[title]) {\n          var shadowInfo = shadowTiddlers[title];\n          callback(shadowInfo.tiddler,title);\n        }\n      }\n    };\n\n    // Iterate through all the shadows and then the tiddlers\n    this.eachShadowPlusTiddlers = function(callback) {\n      var index,titlesLength,title,\n        titles = getShadowTiddlerTitles();\n      for(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\n        title = titles[index];\n        if(tiddlers[title]) {\n          callback(tiddlers[title],title);\n        } else {\n          var shadowInfo = shadowTiddlers[title];\n          callback(shadowInfo.tiddler,title);\n        }\n      }\n      titles = getTiddlerTitles();\n      for(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\n        title = titles[index];\n        if(!shadowTiddlers[title]) {\n          callback(tiddlers[title],title);\n        }\n      }\n    };\n\n    // Test for the existence of a tiddler (excludes shadow tiddlers)\n    this.tiddlerExists = function(title) {\n      return !!$tw.utils.hop(tiddlers,title);\n    };\n\n    // Determines if a tiddler is a shadow tiddler, regardless of whether it has been overridden by a real tiddler\n    this.isShadowTiddler = function(title) {\n      return $tw.utils.hop(shadowTiddlers,title);\n    };\n\n    this.getShadowSource = function(title) {\n      if($tw.utils.hop(shadowTiddlers,title)) {\n        return shadowTiddlers[title].source;\n      }\n      return null;\n    };\n\n    // Get an array of all the currently recognised plugin types\n    this.getPluginTypes = function() {\n      var types = [];\n      $tw.utils.each(pluginTiddlers,function(pluginTiddler) {\n        var pluginType = pluginTiddler.fields[\"plugin-type\"];\n        if(pluginType && types.indexOf(pluginType) === -1) {\n          types.push(pluginType);\n        }\n      });\n      return types;\n    };\n\n    // Read plugin info for all plugins, or just an array of titles. Returns the number of plugins updated or deleted\n    this.readPluginInfo = function(titles) {\n      var results = {\n        modifiedPlugins: [],\n        deletedPlugins: []\n      };\n      $tw.utils.each(titles || getTiddlerTitles(),function(title) {\n        var tiddler = tiddlers[title];\n        if(tiddler) {\n          if(tiddler.fields.type === \"application/json\" && tiddler.hasField(\"plugin-type\") && tiddler.fields.text) {\n            pluginInfo[tiddler.fields.title] = JSON.parse(tiddler.fields.text);\n            results.modifiedPlugins.push(tiddler.fields.title);\n          }\n        } else {\n          if(pluginInfo[title]) {\n            delete pluginInfo[title];\n            results.deletedPlugins.push(title);\n          }\n        }\n      });\n      return results;\n    };\n\n    // Get plugin info for a plugin\n    this.getPluginInfo = function(title) {\n      return pluginInfo[title];\n    };\n\n    // Register the plugin tiddlers of a particular type, or null/undefined for any type, optionally restricting registration to an array of tiddler titles. Return the array of titles affected\n    this.registerPluginTiddlers = function(pluginType,titles) {\n      var self = this,\n        registeredTitles = [],\n        checkTiddler = function(tiddler,title) {\n          if(tiddler && tiddler.fields.type === \"application/json\" && tiddler.fields[\"plugin-type\"] && (!pluginType || tiddler.fields[\"plugin-type\"] === pluginType)) {\n            var disablingTiddler = self.getTiddler(\"$:/config/Plugins/Disabled/\" + title);\n            if(title === \"$:/core\" || !disablingTiddler || (disablingTiddler.fields.text || \"\").trim() !== \"yes\") {\n              self.unregisterPluginTiddlers(null,[title]); // Unregister the plugin if it's already registered\n              pluginTiddlers.push(tiddler);\n              registeredTitles.push(tiddler.fields.title);\n            }\n          }\n        };\n      if(titles) {\n        $tw.utils.each(titles,function(title) {\n          checkTiddler(self.getTiddler(title),title);\n        });\n      } else {\n        this.each(function(tiddler,title) {\n          checkTiddler(tiddler,title);\n        });\n      }\n      return registeredTitles;\n    };\n\n    // Unregister the plugin tiddlers of a particular type, or null/undefined for any type, optionally restricting unregistering to an array of tiddler titles. Returns an array of the titles affected\n    this.unregisterPluginTiddlers = function(pluginType,titles) {\n      var self = this,\n        unregisteredTitles = [];\n      // Remove any previous registered plugins of this type\n      for(var t=pluginTiddlers.length-1; t>=0; t--) {\n        var tiddler = pluginTiddlers[t];\n        if(tiddler.fields[\"plugin-type\"] && (!pluginType || tiddler.fields[\"plugin-type\"] === pluginType) && (!titles || titles.indexOf(tiddler.fields.title) !== -1)) {\n          unregisteredTitles.push(tiddler.fields.title);\n          pluginTiddlers.splice(t,1);\n        }\n      }\n      return unregisteredTitles;\n    };\n\n    // Unpack the currently registered plugins, creating shadow tiddlers for their constituent tiddlers\n    this.unpackPluginTiddlers = function() {\n      var self = this;\n      // Sort the plugin titles by the `plugin-priority` field\n      pluginTiddlers.sort(function(a,b) {\n        if(\"plugin-priority\" in a.fields && \"plugin-priority\" in b.fields) {\n          return a.fields[\"plugin-priority\"] - b.fields[\"plugin-priority\"];\n        } else if(\"plugin-priority\" in a.fields) {\n          return -1;\n        } else if(\"plugin-priority\" in b.fields) {\n          return +1;\n        } else if(a.fields.title < b.fields.title) {\n          return -1;\n        } else if(a.fields.title === b.fields.title) {\n          return 0;\n        } else {\n          return +1;\n        }\n      });\n      // Now go through the plugins in ascending order and assign the shadows\n      shadowTiddlers = Object.create(null);\n      $tw.utils.each(pluginTiddlers,function(tiddler) {\n        // Extract the constituent tiddlers\n        if($tw.utils.hop(pluginInfo,tiddler.fields.title)) {\n          $tw.utils.each(pluginInfo[tiddler.fields.title].tiddlers,function(constituentTiddler,constituentTitle) {\n            // Save the tiddler object\n            if(constituentTitle) {\n              shadowTiddlers[constituentTitle] = {\n                source: tiddler.fields.title,\n                tiddler: new $tw.Tiddler(constituentTiddler,{title: constituentTitle})\n              };\n            }\n          });\n        }\n      });\n      shadowTiddlerTitles = null;\n      this.clearCache(null);\n      this.clearGlobalCache();\n      $tw.utils.each(indexers,function(indexer) {\n        indexer.rebuild();\n      });\n    };\n\n    if(this.addIndexersToWiki) {\n      this.addIndexersToWiki();\n    }\n  };\n\n  // Dummy methods that will be filled in after boot\n  $tw.Wiki.prototype.clearCache =\n  $tw.Wiki.prototype.clearGlobalCache =\n  $tw.Wiki.prototype.enqueueTiddlerEvent = function() {};\n\n  // Add an array of tiddlers\n  $tw.Wiki.prototype.addTiddlers = function(tiddlers) {\n    for(var t=0; t<tiddlers.length; t++) {\n      this.addTiddler(tiddlers[t]);\n    }\n  };\n\n  /**\n   * Define all modules stored in ordinary tiddlers\n   */\n  $tw.Wiki.prototype.defineTiddlerModules = function() {\n    this.each(function(tiddler,title) {\n      if(tiddler.hasField(\"module-type\")) {\n        switch (tiddler.fields.type) {\n          case \"application/javascript\":\n            // We only define modules that haven't already been defined, because in the browser modules in system tiddlers are defined in inline script\n            if(!$tw.utils.hop($tw.modules.titles,tiddler.fields.title)) {\n              $tw.modules.define(tiddler.fields.title,tiddler.fields[\"module-type\"],tiddler.fields.text);\n            }\n            break;\n          case \"application/json\":\n            $tw.modules.define(tiddler.fields.title,tiddler.fields[\"module-type\"],JSON.parse(tiddler.fields.text));\n            break;\n          case \"application/x-tiddler-dictionary\":\n            $tw.modules.define(tiddler.fields.title,tiddler.fields[\"module-type\"],$tw.utils.parseFields(tiddler.fields.text));\n            break;\n        }\n      }\n    });\n  };\n\n  /**\n   * Register all the module tiddlers that have a module type\n   */\n  $tw.Wiki.prototype.defineShadowModules = function() {\n    var self = this;\n    this.eachShadow(function(tiddler,title) {\n      // Don't define the module if it is overidden by an ordinary tiddler\n      if(!self.tiddlerExists(title) && tiddler.hasField(\"module-type\")) {\n        // Define the module\n        $tw.modules.define(tiddler.fields.title,tiddler.fields[\"module-type\"],tiddler.fields.text);\n      }\n    });\n  };\n\n  /**\n   * Enable safe mode by deleting any tiddlers that override a shadow tiddler\n   */\n  $tw.Wiki.prototype.processSafeMode = function() {\n    var self = this,\n      overrides = [];\n    // Find the overriding tiddlers\n    this.each(function(tiddler,title) {\n      if(self.isShadowTiddler(title)) {\n        console.log(title);\n        overrides.push(title);\n      }\n    });\n    // Assemble a report tiddler\n    var titleReportTiddler = \"TiddlyWiki Safe Mode\",\n      report = [];\n    report.push(\"TiddlyWiki has been started in [[safe mode|https://tiddlywiki.com/static/SafeMode.html]]. All plugins are temporarily disabled. Most customisations have been disabled by renaming the following tiddlers:\")\n    // Delete the overrides\n    overrides.forEach(function(title) {\n      var tiddler = self.getTiddler(title),\n        newTitle = \"SAFE: \" + title;\n      self.deleteTiddler(title);\n      self.addTiddler(new $tw.Tiddler(tiddler, {title: newTitle}));\n      report.push(\"* [[\" + title + \"|\" + newTitle + \"]]\");\n    });\n    report.push()\n    this.addTiddler(new $tw.Tiddler({title: titleReportTiddler, text: report.join(\"\\n\\n\")}));\n    // Set $:/DefaultTiddlers to point to our report\n    this.addTiddler(new $tw.Tiddler({title: \"$:/DefaultTiddlers\", text: \"[[\" + titleReportTiddler + \"]]\"}));\n  };\n\n  /**\n   * Extracts tiddlers from a typed block of text, specifying default field values\n   */\n  $tw.Wiki.prototype.deserializeTiddlers = function(type,text,srcFields,options) {\n    srcFields = srcFields || Object.create(null);\n    options = options || {};\n    var deserializer = $tw.Wiki.tiddlerDeserializerModules[options.deserializer],\n      fields = Object.create(null);\n    if(!deserializer) {\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[type];\n    }\n    if(!deserializer && $tw.utils.getFileExtensionInfo(type)) {\n      // If we didn't find the serializer, try converting it from an extension to a content type\n      type = $tw.utils.getFileExtensionInfo(type).type;\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[type];\n    }\n    if(!deserializer && $tw.config.contentTypeInfo[type]) {\n      // see if this type has a different deserializer registered with it\n      type = $tw.config.contentTypeInfo[type].deserializerType;\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[type];\n    }\n    if(!deserializer) {\n      // If we still don't have a deserializer, treat it as plain text\n      deserializer = $tw.Wiki.tiddlerDeserializerModules[\"text/plain\"];\n    }\n    for(var f in srcFields) {\n      fields[f] = srcFields[f];\n    }\n    if(deserializer) {\n      return deserializer.call(this,text,fields,type);\n    } else {\n      // Return a raw tiddler for unknown types\n      fields.text = text;\n      return [fields];\n    }\n  };\n\n  /**\n   * Register the built in tiddler deserializer modules\n   */\n  var deserializeHeaderComment = function(text,fields) {\n      var headerCommentRegExp = new RegExp($tw.config.jsModuleHeaderRegExpString,\"mg\"),\n        match = headerCommentRegExp.exec(text);\n      fields.text = text;\n      if(match) {\n        fields = $tw.utils.parseFields(match[1].split(/\\r?\\n\\r?\\n/mg)[0],fields);\n      }\n      return [fields];\n    };\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/js\",\"tiddlerdeserializer\",{\n    \"application/javascript\": deserializeHeaderComment\n  });\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/css\",\"tiddlerdeserializer\",{\n    \"text/css\": deserializeHeaderComment\n  });\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/tid\",\"tiddlerdeserializer\",{\n    \"application/x-tiddler\": function(text,fields) {\n      var split = text.split(/\\r?\\n\\r?\\n/mg);\n      if(split.length >= 1) {\n        fields = $tw.utils.parseFields(split[0],fields);\n      }\n      if(split.length >= 2) {\n        fields.text = split.slice(1).join(\"\\n\\n\");\n      }\n      return [fields];\n    }\n  });\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/tids\",\"tiddlerdeserializer\",{\n    \"application/x-tiddlers\": function(text,fields) {\n      var titles = [],\n        tiddlers = [],\n        match = /\\r?\\n\\r?\\n/mg.exec(text);\n      if(match) {\n        fields = $tw.utils.parseFields(text.substr(0,match.index),fields);\n        var lines = text.substr(match.index + match[0].length).split(/\\r?\\n/mg);\n        for(var t=0; t<lines.length; t++) {\n          var line = lines[t];\n          if(line.charAt(0) !== \"#\") {\n            var colonPos= line.indexOf(\":\");\n            if(colonPos !== -1) {\n              var tiddler = $tw.utils.extend(Object.create(null),fields);\n              tiddler.title = (tiddler.title || \"\") + line.substr(0,colonPos).trim();\n              if(titles.indexOf(tiddler.title) !== -1) {\n                console.log(\"Warning: .multids file contains multiple definitions for \" + tiddler.title);\n              }\n              titles.push(tiddler.title);\n              tiddler.text = line.substr(colonPos + 2).trim();\n              tiddlers.push(tiddler);\n            }\n          }\n        }\n      }\n      return tiddlers;\n    }\n  });\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/txt\",\"tiddlerdeserializer\",{\n    \"text/plain\": function(text,fields,type) {\n      fields.text = text;\n      fields.type = type || \"text/plain\";\n      return [fields];\n    }\n  });\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/html\",\"tiddlerdeserializer\",{\n    \"text/html\": function(text,fields) {\n      fields.text = text;\n      fields.type = \"text/html\";\n      return [fields];\n    }\n  });\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/json\",\"tiddlerdeserializer\",{\n    \"application/json\": function(text,fields) {\n      var isTiddlerValid = function(data) {\n          // Not valid if it's not an object with a title property\n          if(typeof(data) !== \"object\" || !$tw.utils.hop(data,\"title\")) {\n            return false;\n          }\n          for(var f in data) {\n            if($tw.utils.hop(data,f)) {\n              // Check field name doesn't contain whitespace or control characters\n              if(typeof(data[f]) !== \"string\" || /[\\x00-\\x1F\\s]/.test(f)) {\n                return false;\n              }\n            }\n          }\n          return true;\n        },\n        isTiddlerArrayValid = function(data) {\n          for(var t=0; t<data.length; t++) {\n            if(!isTiddlerValid(data[t])) {\n              return false;\n            }\n          }\n          return true;\n        },\n        data = JSON.parse(text);\n      if($tw.utils.isArray(data) && isTiddlerArrayValid(data)) {\n        return data;\n      } else if(isTiddlerValid(data)) {\n        return [data];\n      } else {\n        // Plain JSON file\n        fields.text = text;\n        fields.type = \"application/json\";\n        return [fields];\n      }\n    }\n  });\n\n  /////////////////////////// Browser definitions\n\n  if($tw.browser && !$tw.node) {\n\n  /**\n   * Decrypt any tiddlers stored within the element with the ID \"encryptedArea\".\n   * The function is asynchronous to allow the user to be prompted for a password\n   * callback: function to be called the decryption is complete\n   */\n  $tw.boot.decryptEncryptedTiddlers = function(callback) {\n    var encryptedArea = document.getElementById(\"encryptedStoreArea\");\n    if(encryptedArea) {\n      var encryptedText = encryptedArea.innerHTML,\n        prompt = \"Enter a password to decrypt this TiddlyWiki\";\n      // Prompt for the password\n      if($tw.utils.hop($tw.boot,\"encryptionPrompts\")) {\n        prompt = $tw.boot.encryptionPrompts.decrypt;\n      }\n      $tw.passwordPrompt.createPrompt({\n        serviceName: prompt,\n        noUserName: true,\n        submitText: \"Decrypt\",\n        callback: function(data) {\n          // Attempt to decrypt the tiddlers\n          $tw.crypto.setPassword(data.password);\n          var decryptedText = $tw.crypto.decrypt(encryptedText);\n          if(decryptedText) {\n            var json = JSON.parse(decryptedText);\n            for(var title in json) {\n              $tw.preloadTiddler(json[title]);\n            }\n            // Call the callback\n            callback();\n            // Exit and remove the password prompt\n            return true;\n          } else {\n            // We didn't decrypt everything, so continue to prompt for password\n            return false;\n          }\n        }\n      });\n    } else {\n      // Just invoke the callback straight away if there weren't any encrypted tiddlers\n      callback();\n    }\n  };\n\n  /**\n   * Register a deserializer that can extract tiddlers from the DOM\n   */\n  $tw.modules.define(\"$:/boot/tiddlerdeserializer/dom\",\"tiddlerdeserializer\",{\n    \"(DOM)\": function(node) {\n      var extractTextTiddlers = function(node) {\n          var e = node.firstChild;\n          while(e && e.nodeName.toLowerCase() !== \"pre\") {\n            e = e.nextSibling;\n          }\n          var title = node.getAttribute ? node.getAttribute(\"title\") : null;\n          if(e && title) {\n            var attrs = node.attributes,\n              tiddler = {\n                text: $tw.utils.htmlDecode(e.innerHTML)\n              };\n            for(var i=attrs.length-1; i >= 0; i--) {\n              tiddler[attrs[i].name] = attrs[i].value;\n            }\n            return [tiddler];\n          } else {\n            return null;\n          }\n        },\n        extractModuleTiddlers = function(node) {\n          if(node.hasAttribute && node.hasAttribute(\"data-tiddler-title\")) {\n            var text = node.innerHTML,\n              s = text.indexOf(\"{\"),\n              e = text.lastIndexOf(\"}\");\n            if(node.hasAttribute(\"data-module\") && s !== -1 && e !== -1) {\n              text = text.substring(s+1,e);\n            }\n            var fields = {text: text},\n              attributes = node.attributes;\n            for(var a=0; a<attributes.length; a++) {\n              if(attributes[a].nodeName.substr(0,13) === \"data-tiddler-\") {\n                fields[attributes[a].nodeName.substr(13)] = attributes[a].value;\n              }\n            }\n            return [fields];\n          } else {\n            return null;\n          }\n        },\n        t,result = [];\n      if(node) {\n        for(t = 0; t < node.childNodes.length; t++) {\n            var childNode = node.childNodes[t],\n              tiddlers = extractTextTiddlers(childNode);\n            tiddlers = tiddlers || extractModuleTiddlers(childNode);\n            if(tiddlers) {\n              result.push.apply(result,tiddlers);\n            }\n        }\n      }\n      return result;\n    }\n  });\n\n  $tw.loadTiddlersBrowser = function() {\n    // In the browser, we load tiddlers from certain elements\n    var containerIds = [\n      \"libraryModules\",\n      \"modules\",\n      \"bootKernelPrefix\",\n      \"bootKernel\",\n      \"styleArea\",\n      \"storeArea\",\n      \"systemArea\"\n    ];\n    for(var t=0; t<containerIds.length; t++) {\n      $tw.wiki.addTiddlers($tw.wiki.deserializeTiddlers(\"(DOM)\",document.getElementById(containerIds[t])));\n    }\n  };\n\n  } else {\n\n  /////////////////////////// Server definitions\n\n  /**\n   * Get any encrypted tiddlers\n   */\n  $tw.boot.decryptEncryptedTiddlers = function(callback) {\n    // Storing encrypted tiddlers on the server isn't supported yet\n    callback();\n  };\n\n  } // End of if($tw.browser && !$tw.node)\n\n  /////////////////////////// Node definitions\n\n  if($tw.node) {\n\n    /**\n     * Load the tiddlers contained in a particular file (and optionally extract fields from the accompanying .meta file) returned as {filepath:,type:,tiddlers:[],hasMetaFile:}\n     */\n    $tw.loadTiddlersFromFile = function(filepath,fields) {\n      var ext = path.extname(filepath),\n        extensionInfo = $tw.utils.getFileExtensionInfo(ext),\n        type = extensionInfo ? extensionInfo.type : null,\n        typeInfo = type ? $tw.config.contentTypeInfo[type] : null,\n        data = fs.readFileSync(filepath,typeInfo ? typeInfo.encoding : \"utf8\"),\n        tiddlers = $tw.wiki.deserializeTiddlers(ext,data,fields),\n        metadata = $tw.loadMetadataForFile(filepath);\n      if(metadata) {\n        if(type === \"application/json\") {\n          tiddlers = [{text: data, type: \"application/json\"}];\n        }\n        tiddlers = [$tw.utils.extend({},tiddlers[0],metadata)];\n      }\n      return {filepath: filepath, type: type, tiddlers: tiddlers, hasMetaFile: !!metadata};\n    };\n\n    /**\n     * Load the metadata fields in the .meta file corresponding to a particular file\n     */\n    $tw.loadMetadataForFile = function(filepath) {\n      var metafilename = filepath + \".meta\";\n      if(fs.existsSync(metafilename)) {\n        return $tw.utils.parseFields(fs.readFileSync(metafilename,\"utf8\") || \"\");\n      } else {\n        return null;\n      }\n    };\n\n    /**\n     * A default set of files for TiddlyWiki to ignore during load.\n     * This matches what NPM ignores, and adds \"*.meta\" to ignore tiddler\n     * metadata files.\n     */\n    $tw.boot.excludeRegExp = /^\\.DS_Store$|^.*\\.meta$|^\\..*\\.swp$|^\\._.*$|^\\.git$|^\\.hg$|^\\.lock-wscript$|^\\.svn$|^\\.wafpickle-.*$|^CVS$|^npm-debug\\.log$/;\n\n    /**\n     * Load all the tiddlers recursively from a directory, including honouring `tiddlywiki.files` files for drawing in external files.\n     * Returns an array of {filepath:,type:,tiddlers: [{..fields...}],hasMetaFile:}.\n     * Note that no file information is returned for externally loaded tiddlers, just the `tiddlers` property.\n     */\n    $tw.loadTiddlersFromPath = function(filepath,excludeRegExp) {\n      excludeRegExp = excludeRegExp || $tw.boot.excludeRegExp;\n      var tiddlers = [];\n      if(fs.existsSync(filepath)) {\n        var stat = fs.statSync(filepath);\n        if(stat.isDirectory()) {\n          var files = fs.readdirSync(filepath);\n          // Look for a tiddlywiki.files file\n          if(files.indexOf(\"tiddlywiki.files\") !== -1) {\n            Array.prototype.push.apply(tiddlers,$tw.loadTiddlersFromSpecification(filepath,excludeRegExp));\n          } else {\n            // If not, read all the files in the directory\n            $tw.utils.each(files,function(file) {\n              if(!excludeRegExp.test(file) && file !== \"plugin.info\") {\n                tiddlers.push.apply(tiddlers,$tw.loadTiddlersFromPath(filepath + path.sep + file,excludeRegExp));\n              }\n            });\n          }\n        } else if(stat.isFile()) {\n          tiddlers.push($tw.loadTiddlersFromFile(filepath,{title: filepath}));\n        }\n      }\n      return tiddlers;\n    };\n\n    /**\n     * Load all the tiddlers defined by a `tiddlywiki.files` specification file\n     * filepath: pathname of the directory containing the specification file\n     */\n    $tw.loadTiddlersFromSpecification = function(filepath,excludeRegExp) {\n      var tiddlers = [];\n      // Read the specification\n      var filesInfo = JSON.parse(fs.readFileSync(filepath + path.sep + \"tiddlywiki.files\",\"utf8\"));\n      // Helper to process a file\n      var processFile = function(filename,isTiddlerFile,fields,isEditableFile) {\n        var extInfo = $tw.config.fileExtensionInfo[path.extname(filename)],\n          type = (extInfo || {}).type || fields.type || \"text/plain\",\n          typeInfo = $tw.config.contentTypeInfo[type] || {},\n          pathname = path.resolve(filepath,filename),\n          text = fs.readFileSync(pathname,typeInfo.encoding || \"utf8\"),\n          metadata = $tw.loadMetadataForFile(pathname) || {},\n          fileTiddlers;\n        if(isTiddlerFile) {\n          fileTiddlers = $tw.wiki.deserializeTiddlers(path.extname(pathname),text,metadata) || [];\n        } else {\n          fileTiddlers =  [$tw.utils.extend({text: text},metadata)];\n        }\n        var combinedFields = $tw.utils.extend({},fields,metadata);\n        $tw.utils.each(fileTiddlers,function(tiddler) {\n          $tw.utils.each(combinedFields,function(fieldInfo,name) {\n            if(typeof fieldInfo === \"string\" || $tw.utils.isArray(fieldInfo)) {\n              tiddler[name] = fieldInfo;\n            } else {\n              var value = tiddler[name];\n              switch(fieldInfo.source) {\n                case \"filename\":\n                  value = path.basename(filename);\n                  break;\n                case \"filename-uri-decoded\":\n                  value = decodeURIComponent(path.basename(filename));\n                  break;\n                case \"basename\":\n                  value = path.basename(filename,path.extname(filename));\n                  break;\n                case \"basename-uri-decoded\":\n                  value = decodeURIComponent(path.basename(filename,path.extname(filename)));\n                  break;\n                case \"extname\":\n                  value = path.extname(filename);\n                  break;\n                case \"created\":\n                  value = new Date(fs.statSync(pathname).birthtime);\n                  break;\n                case \"modified\":\n                  value = new Date(fs.statSync(pathname).mtime);\n                  break;\n              }\n              if(fieldInfo.prefix) {\n                value = fieldInfo.prefix + value;\n              }\n              if(fieldInfo.suffix) {\n                value = value + fieldInfo.suffix;\n              }\n              tiddler[name] = value;\n            }\n          });\n        });\n        if(isEditableFile) {\n        tiddlers.push({filepath: pathname, hasMetaFile: !!metadata && !isTiddlerFile, isEditableFile: true, tiddlers: fileTiddlers});\n        } else {\n          tiddlers.push({tiddlers: fileTiddlers});\n        }\n      };\n      // Process the listed tiddlers\n      $tw.utils.each(filesInfo.tiddlers,function(tidInfo) {\n        if(tidInfo.prefix && tidInfo.suffix) {\n          tidInfo.fields.text = {prefix: tidInfo.prefix,suffix: tidInfo.suffix};\n        } else if(tidInfo.prefix) {\n          tidInfo.fields.text = {prefix: tidInfo.prefix};\n        } else if(tidInfo.suffix) {\n          tidInfo.fields.text = {suffix: tidInfo.suffix};\n        }\n        processFile(tidInfo.file,tidInfo.isTiddlerFile,tidInfo.fields);\n      });\n      // Process any listed directories\n      $tw.utils.each(filesInfo.directories,function(dirSpec) {\n        // Read literal directories directly\n        if(typeof dirSpec === \"string\") {\n          var pathname = path.resolve(filepath,dirSpec);\n          if(fs.existsSync(pathname) && fs.statSync(pathname).isDirectory()) {\n            tiddlers.push.apply(tiddlers,$tw.loadTiddlersFromPath(pathname,excludeRegExp));\n          }\n        } else {\n          // Process directory specifier\n        var dirPath = path.resolve(filepath,dirSpec.path);\n        if(fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {\n          var\tfiles = fs.readdirSync(dirPath),\n            fileRegExp = new RegExp(dirSpec.filesRegExp || \"^.*$\"),\n            metaRegExp = /^.*\\.meta$/;\n          for(var t=0; t<files.length; t++) {\n            var filename = files[t];\n            if(filename !== \"tiddlywiki.files\" && !metaRegExp.test(filename) && fileRegExp.test(filename)) {\n              processFile(dirPath + path.sep + filename,dirSpec.isTiddlerFile,dirSpec.fields,dirSpec.isEditableFile);\n            }\n          }\n        } else {\n          console.log(\"Warning: a directory in a tiddlywiki.files file does not exist.\");\n          console.log(\"dirPath: \" + dirPath);\n          console.log(\"tiddlywiki.files location: \" + filepath);\n        }\n      }\n      });\n      return tiddlers;\n    };\n\n    /**\n     * Load the tiddlers from a plugin folder, and package them up into a proper JSON plugin tiddler\n     */\n    $tw.loadPluginFolder = function(filepath,excludeRegExp) {\n      excludeRegExp = excludeRegExp || $tw.boot.excludeRegExp;\n      var infoPath = filepath + path.sep + \"plugin.info\";\n      if(fs.existsSync(filepath) && fs.statSync(filepath).isDirectory()) {\n        // Read the plugin information\n        if(!fs.existsSync(infoPath) || !fs.statSync(infoPath).isFile()) {\n          console.log(\"Warning: missing plugin.info file in \" + filepath);\n          return null;\n        }\n        var pluginInfo = JSON.parse(fs.readFileSync(infoPath,\"utf8\"));\n        // Read the plugin files\n        var pluginFiles = $tw.loadTiddlersFromPath(filepath,excludeRegExp);\n        // Save the plugin tiddlers into the plugin info\n        pluginInfo.tiddlers = pluginInfo.tiddlers || Object.create(null);\n        for(var f=0; f<pluginFiles.length; f++) {\n          var tiddlers = pluginFiles[f].tiddlers;\n          for(var t=0; t<tiddlers.length; t++) {\n            var tiddler= tiddlers[t];\n            if(tiddler.title) {\n              pluginInfo.tiddlers[tiddler.title] = tiddler;\n            }\n          }\n        }\n        // Give the plugin the same version number as the core if it doesn't have one\n        if(!(\"version\" in pluginInfo)) {\n          pluginInfo.version = $tw.packageInfo.version;\n        }\n        // Use \"plugin\" as the plugin-type if we don't have one\n        if(!(\"plugin-type\" in pluginInfo)) {\n          pluginInfo[\"plugin-type\"] = \"plugin\";\n        }\n        pluginInfo.dependents = pluginInfo.dependents || [];\n        pluginInfo.type = \"application/json\";\n        // Set plugin text\n        pluginInfo.text = JSON.stringify({tiddlers: pluginInfo.tiddlers},null,4);\n        delete pluginInfo.tiddlers;\n        // Deserialise array fields (currently required for the dependents field)\n        for(var field in pluginInfo) {\n          if($tw.utils.isArray(pluginInfo[field])) {\n            pluginInfo[field] = $tw.utils.stringifyList(pluginInfo[field]);\n          }\n        }\n        return pluginInfo;\n      } else {\n          return null;\n      }\n    };\n\n    /**\n     * name: Name of the plugin to find\n     * paths: array of file paths to search for it\n     * Returns the path of the plugin folder\n     */\n    $tw.findLibraryItem = function(name,paths) {\n      var pathIndex = 0;\n      do {\n        var pluginPath = path.resolve(paths[pathIndex],\"./\" + name)\n        if(fs.existsSync(pluginPath) && fs.statSync(pluginPath).isDirectory()) {\n          return pluginPath;\n        }\n      } while(++pathIndex < paths.length);\n      return null;\n    };\n\n    /**\n     * name: Name of the plugin to load\n     * paths: array of file paths to search for it\n     */\n    $tw.loadPlugin = function(name,paths) {\n      var pluginPath = $tw.findLibraryItem(name,paths);\n      if(pluginPath) {\n        var pluginFields = $tw.loadPluginFolder(pluginPath);\n        if(pluginFields) {\n          $tw.wiki.addTiddler(pluginFields);\n          return;\n        }\n      }\n      console.log(\"Warning: Cannot find plugin '\" + name + \"'\");\n    };\n\n    /**\n     * libraryPath: Path of library folder for these plugins (relative to core path)\n     * envVar: Environment variable name for these plugins\n     * Returns an array of search paths\n     */\n    $tw.getLibraryItemSearchPaths = function(libraryPath,envVar) {\n      var pluginPaths = [path.resolve($tw.boot.corePath,libraryPath)],\n        env = process.env[envVar];\n      if(env) {\n        env.split(path.delimiter).map(function(item) {\n          if(item) {\n            pluginPaths.push(item);\n          }\n        });\n      }\n      return pluginPaths;\n    };\n\n    /**\n     * plugins: Array of names of plugins (eg, \"tiddlywiki/filesystemadaptor\")\n     * libraryPath: Path of library folder for these plugins (relative to core path)\n     * envVar: Environment variable name for these plugins\n     */\n    $tw.loadPlugins = function(plugins,libraryPath,envVar) {\n      if(plugins) {\n        var pluginPaths = $tw.getLibraryItemSearchPaths(libraryPath,envVar);\n        for(var t=0; t<plugins.length; t++) {\n          $tw.loadPlugin(plugins[t],pluginPaths);\n        }\n      }\n    };\n\n    /**\n     * path: path of wiki directory\n     * options:\n     * parentPaths: array of parent paths that we mustn't recurse into\n     * readOnly: true if the tiddler file paths should not be retained\n     */\n    $tw.loadWikiTiddlers = function(wikiPath,options) {\n      options = options || {};\n      var parentPaths = options.parentPaths || [],\n        wikiInfoPath = path.resolve(wikiPath,$tw.config.wikiInfo),\n        wikiInfo,\n        pluginFields;\n      // Bail if we don't have a wiki info file\n      if(fs.existsSync(wikiInfoPath)) {\n        wikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath,\"utf8\"));\n      } else {\n        return null;\n      }\n    // Save the path to the tiddlers folder for the filesystemadaptor\n    var config = wikiInfo.config || {};\n    if($tw.boot.wikiPath == wikiPath) {\n      $tw.boot.wikiTiddlersPath = path.resolve($tw.boot.wikiPath,config[\"default-tiddler-location\"] || $tw.config.wikiTiddlersSubDir);\n    }\n      // Load any parent wikis\n      if(wikiInfo.includeWikis) {\n        parentPaths = parentPaths.slice(0);\n        parentPaths.push(wikiPath);\n        $tw.utils.each(wikiInfo.includeWikis,function(info) {\n          if(typeof info === \"string\") {\n            info = {path: info};\n          }\n          var resolvedIncludedWikiPath = path.resolve(wikiPath,info.path);\n          if(parentPaths.indexOf(resolvedIncludedWikiPath) === -1) {\n            var subWikiInfo = $tw.loadWikiTiddlers(resolvedIncludedWikiPath,{\n              parentPaths: parentPaths,\n              readOnly: info[\"read-only\"]\n            });\n            // Merge the build targets\n            wikiInfo.build = $tw.utils.extend([],subWikiInfo.build,wikiInfo.build);\n          } else {\n            $tw.utils.error(\"Cannot recursively include wiki \" + resolvedIncludedWikiPath);\n          }\n        });\n      }\n      // Load any plugins, themes and languages listed in the wiki info file\n      $tw.loadPlugins(wikiInfo.plugins,$tw.config.pluginsPath,$tw.config.pluginsEnvVar);\n      $tw.loadPlugins(wikiInfo.themes,$tw.config.themesPath,$tw.config.themesEnvVar);\n      $tw.loadPlugins(wikiInfo.languages,$tw.config.languagesPath,$tw.config.languagesEnvVar);\n      // Load the wiki files, registering them as writable\n      var resolvedWikiPath = path.resolve(wikiPath,$tw.config.wikiTiddlersSubDir);\n      $tw.utils.each($tw.loadTiddlersFromPath(resolvedWikiPath),function(tiddlerFile) {\n        if(!options.readOnly && tiddlerFile.filepath) {\n          $tw.utils.each(tiddlerFile.tiddlers,function(tiddler) {\n            $tw.boot.files[tiddler.title] = {\n              filepath: tiddlerFile.filepath,\n              type: tiddlerFile.type,\n              hasMetaFile: tiddlerFile.hasMetaFile,\n              isEditableFile: config[\"retain-original-tiddler-path\"] || tiddlerFile.isEditableFile || tiddlerFile.filepath.indexOf($tw.boot.wikiTiddlersPath) !== 0\n            };\n          });\n        }\n        $tw.wiki.addTiddlers(tiddlerFile.tiddlers);\n      });\n    if ($tw.boot.wikiPath == wikiPath) {\n      // Save the original tiddler file locations if requested\n      var output = {}, relativePath, fileInfo;\n      for(var title in $tw.boot.files) {\n        fileInfo = $tw.boot.files[title];\n        if(fileInfo.isEditableFile) {\n          relativePath = path.relative($tw.boot.wikiTiddlersPath,fileInfo.filepath);\n          output[title] =\n            path.sep === \"/\" ?\n            relativePath :\n            relativePath.split(path.sep).join(\"/\");\n        }\n      }\n      if(Object.keys(output).length > 0){\n        $tw.wiki.addTiddler({title: \"$:/config/OriginalTiddlerPaths\", type: \"application/json\", text: JSON.stringify(output)});\n      }\n    }\n    // Load any plugins within the wiki folder\n    var wikiPluginsPath = path.resolve(wikiPath,$tw.config.wikiPluginsSubDir);\n    if(fs.existsSync(wikiPluginsPath)) {\n      var pluginFolders = fs.readdirSync(wikiPluginsPath);\n      for(var t=0; t<pluginFolders.length; t++) {\n        pluginFields = $tw.loadPluginFolder(path.resolve(wikiPluginsPath,\"./\" + pluginFolders[t]));\n        if(pluginFields) {\n          $tw.wiki.addTiddler(pluginFields);\n        }\n      }\n    }\n    // Load any themes within the wiki folder\n    var wikiThemesPath = path.resolve(wikiPath,$tw.config.wikiThemesSubDir);\n    if(fs.existsSync(wikiThemesPath)) {\n      var themeFolders = fs.readdirSync(wikiThemesPath);\n      for(var t=0; t<themeFolders.length; t++) {\n        pluginFields = $tw.loadPluginFolder(path.resolve(wikiThemesPath,\"./\" + themeFolders[t]));\n        if(pluginFields) {\n          $tw.wiki.addTiddler(pluginFields);\n        }\n      }\n    }\n    // Load any languages within the wiki folder\n    var wikiLanguagesPath = path.resolve(wikiPath,$tw.config.wikiLanguagesSubDir);\n    if(fs.existsSync(wikiLanguagesPath)) {\n      var languageFolders = fs.readdirSync(wikiLanguagesPath);\n      for(var t=0; t<languageFolders.length; t++) {\n        pluginFields = $tw.loadPluginFolder(path.resolve(wikiLanguagesPath,\"./\" + languageFolders[t]));\n        if(pluginFields) {\n          $tw.wiki.addTiddler(pluginFields);\n        }\n      }\n    }\n    return wikiInfo;\n  };\n\n    $tw.loadTiddlersNode = function() {\n      // Load the boot tiddlers\n      $tw.utils.each($tw.loadTiddlersFromPath($tw.boot.bootPath),function(tiddlerFile) {\n        $tw.wiki.addTiddlers(tiddlerFile.tiddlers);\n      });\n      // Load the core tiddlers\n      $tw.wiki.addTiddler($tw.loadPluginFolder($tw.boot.corePath));\n      // Load any extra plugins\n      $tw.utils.each($tw.boot.extraPlugins,function(name) {\n        if(name.charAt(0) === \"+\") { // Relative path to plugin\n        var pluginFields = $tw.loadPluginFolder(name.substring(1));\n          if(pluginFields) {\n            $tw.wiki.addTiddler(pluginFields);\n          }\n        } else {\n          var parts = name.split(\"/\"),\n            type = parts[0];\n          if(parts.length  === 3 && [\"plugins\",\"themes\",\"languages\"].indexOf(type) !== -1) {\n            $tw.loadPlugins([parts[1] + \"/\" + parts[2]],$tw.config[type + \"Path\"],$tw.config[type + \"EnvVar\"]);\n          }\n        }\n      });\n      // Load the tiddlers from the wiki directory\n      if($tw.boot.wikiPath) {\n        $tw.boot.wikiInfo = $tw.loadWikiTiddlers($tw.boot.wikiPath);\n      }\n    };\n\n  }  // End of if($tw.node)\n\n  /////////////////////////// Main startup function called once tiddlers have been decrypted\n\n  /**\n   * Startup TiddlyWiki\n   */\n  $tw.boot.initStartup = function(options) {\n    // Get the URL hash and check for safe mode\n    $tw.locationHash = \"#\";\n    if($tw.browser && !$tw.node) {\n      if(location.hash === \"#:safe\") {\n        $tw.safeMode = true;\n      } else {\n        $tw.locationHash = $tw.utils.getLocationHash();\n      }\n    }\n    // Initialise some more $tw properties\n    $tw.utils.deepDefaults($tw,{\n      modules: { // Information about each module\n        titles: Object.create(null), // hashmap by module title of {fn:, exports:, moduleType:}\n        types: {} // hashmap by module type of hashmap of exports\n      },\n      config: { // Configuration overridables\n        pluginsPath: \"../plugins/\",\n        themesPath: \"../themes/\",\n        languagesPath: \"../languages/\",\n        editionsPath: \"../editions/\",\n        wikiInfo: \"./tiddlywiki.info\",\n        wikiPluginsSubDir: \"./plugins\",\n        wikiThemesSubDir: \"./themes\",\n        wikiLanguagesSubDir: \"./languages\",\n        wikiTiddlersSubDir: \"./tiddlers\",\n        wikiOutputSubDir: \"./output\",\n        jsModuleHeaderRegExpString: \"^\\\\/\\\\*\\\\\\\\(?:\\\\r?\\\\n)((?:^[^\\\\r\\\\n]*(?:\\\\r?\\\\n))+?)(^\\\\\\\\\\\\*\\\\/$(?:\\\\r?\\\\n)?)\",\n        fileExtensionInfo: Object.create(null), // Map file extension to {type:}\n        contentTypeInfo: Object.create(null), // Map type to {encoding:,extension:}\n        pluginsEnvVar: \"TIDDLYWIKI_PLUGIN_PATH\",\n        themesEnvVar: \"TIDDLYWIKI_THEME_PATH\",\n        languagesEnvVar: \"TIDDLYWIKI_LANGUAGE_PATH\",\n        editionsEnvVar: \"TIDDLYWIKI_EDITION_PATH\"\n      },\n      log: {}, // Log flags\n      unloadTasks: []\n    });\n    if(!$tw.boot.tasks.readBrowserTiddlers) {\n      // For writable tiddler files, a hashmap of title to {filepath:,type:,hasMetaFile:}\n      $tw.boot.files = Object.create(null);\n      // System paths and filenames\n      $tw.boot.bootPath = options.bootPath || path.dirname(module.filename);\n      $tw.boot.corePath = path.resolve($tw.boot.bootPath,\"../core\");\n      // If there's no arguments then default to `--help`\n      if($tw.boot.argv.length === 0) {\n        $tw.boot.argv = [\"--help\"];\n      }\n      // Parse any extra plugin references\n      $tw.boot.extraPlugins = $tw.boot.extraPlugins || [];\n      while($tw.boot.argv[0] && $tw.boot.argv[0].indexOf(\"+\") === 0) {\n        $tw.boot.extraPlugins.push($tw.boot.argv[0].substring(1));\n        $tw.boot.argv.splice(0,1);\n      }\n      // If the first command line argument doesn't start with `--` then we\n      // interpret it as the path to the wiki folder, which will otherwise default\n      // to the current folder\n      if($tw.boot.argv[0] && $tw.boot.argv[0].indexOf(\"--\") !== 0) {\n        $tw.boot.wikiPath = $tw.boot.argv[0];\n        $tw.boot.argv = $tw.boot.argv.slice(1);\n      } else {\n        $tw.boot.wikiPath = process.cwd();\n      }\n      // Read package info\n      $tw.packageInfo = $tw.packageInfo || require(\"../package.json\");\n      // Check node version number\n      if(!$tw.utils.checkVersions(process.version.substr(1),$tw.packageInfo.engines.node.substr(2))) {\n        $tw.utils.error(\"TiddlyWiki5 requires node.js version \" + $tw.packageInfo.engines.node);\n      }\n    }\n    // Add file extension information\n    $tw.utils.registerFileType(\"text/vnd.tiddlywiki\",\"utf8\",\".tid\");\n    $tw.utils.registerFileType(\"application/x-tiddler\",\"utf8\",\".tid\");\n    $tw.utils.registerFileType(\"application/x-tiddlers\",\"utf8\",\".multids\");\n    $tw.utils.registerFileType(\"application/x-tiddler-html-div\",\"utf8\",\".tiddler\");\n    $tw.utils.registerFileType(\"text/vnd.tiddlywiki2-recipe\",\"utf8\",\".recipe\");\n    $tw.utils.registerFileType(\"text/plain\",\"utf8\",\".txt\");\n    $tw.utils.registerFileType(\"text/css\",\"utf8\",\".css\");\n    $tw.utils.registerFileType(\"text/html\",\"utf8\",[\".html\",\".htm\"]);\n    $tw.utils.registerFileType(\"application/hta\",\"utf16le\",\".hta\",{deserializerType:\"text/html\"});\n    $tw.utils.registerFileType(\"application/javascript\",\"utf8\",\".js\");\n    $tw.utils.registerFileType(\"application/json\",\"utf8\",\".json\");\n    $tw.utils.registerFileType(\"application/pdf\",\"base64\",\".pdf\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"application/zip\",\"base64\",\".zip\");\n    $tw.utils.registerFileType(\"application/x-zip-compressed\",\"base64\",\".zip\");\n    $tw.utils.registerFileType(\"image/jpeg\",\"base64\",[\".jpg\",\".jpeg\"],{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/jpg\",\"base64\",[\".jpg\",\".jpeg\"],{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/png\",\"base64\",\".png\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/gif\",\"base64\",\".gif\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/webp\",\"base64\",\".webp\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/heic\",\"base64\",\".heic\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/heif\",\"base64\",\".heif\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/svg+xml\",\"utf8\",\".svg\",{flags:[\"image\"]});\n\t  $tw.utils.registerFileType(\"image/vnd.microsoft.icon\",\"base64\",\".ico\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"image/x-icon\",\"base64\",\".ico\",{flags:[\"image\"]});\n    $tw.utils.registerFileType(\"application/font-woff\",\"base64\",\".woff\");\n    $tw.utils.registerFileType(\"application/x-font-ttf\",\"base64\",\".woff\");\n    $tw.utils.registerFileType(\"application/font-woff2\",\"base64\",\".woff2\");\n    $tw.utils.registerFileType(\"audio/ogg\",\"base64\",\".ogg\");\n    $tw.utils.registerFileType(\"video/ogg\",\"base64\",[\".ogm\",\".ogv\",\".ogg\"]);\n    $tw.utils.registerFileType(\"video/webm\",\"base64\",\".webm\");\n    $tw.utils.registerFileType(\"video/mp4\",\"base64\",\".mp4\");\n    $tw.utils.registerFileType(\"audio/mp3\",\"base64\",\".mp3\");\n    $tw.utils.registerFileType(\"audio/mp4\",\"base64\",[\".mp4\",\".m4a\"]);\n    $tw.utils.registerFileType(\"text/markdown\",\"utf8\",[\".md\",\".markdown\"],{deserializerType:\"text/x-markdown\"});\n    $tw.utils.registerFileType(\"text/x-markdown\",\"utf8\",[\".md\",\".markdown\"]);\n    $tw.utils.registerFileType(\"application/enex+xml\",\"utf8\",\".enex\");\n    $tw.utils.registerFileType(\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\"base64\",\".docx\");\n    $tw.utils.registerFileType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\"base64\",\".xlsx\");\n    $tw.utils.registerFileType(\"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\"base64\",\".pptx\");\n    $tw.utils.registerFileType(\"text/x-bibtex\",\"utf8\",\".bib\",{deserializerType:\"application/x-bibtex\"});\n    $tw.utils.registerFileType(\"application/x-bibtex\",\"utf8\",\".bib\");\n    $tw.utils.registerFileType(\"application/epub+zip\",\"base64\",\".epub\");\n    $tw.utils.registerFileType(\"application/octet-stream\",\"base64\",\".octet-stream\");\n    // Create the wiki store for the app\n    $tw.wiki = new $tw.Wiki();\n    // Install built in tiddler fields modules\n    $tw.Tiddler.fieldModules = $tw.modules.getModulesByTypeAsHashmap(\"tiddlerfield\");\n    // Install the tiddler deserializer modules\n    $tw.Wiki.tiddlerDeserializerModules = Object.create(null);\n    $tw.modules.applyMethods(\"tiddlerdeserializer\",$tw.Wiki.tiddlerDeserializerModules);\n    // Call unload handlers in the browser\n    if($tw.browser) {\n      window.onbeforeunload = function(event) {\n        event = event || {};\n        var result;\n        $tw.utils.each($tw.unloadTasks,function(task) {\n          var r = task(event);\n          if(r) {\n            result = r;\n          }\n        });\n        return result;\n      }\n    }\n  };\n\n  $tw.boot.loadStartup = function(options){\n    // Load tiddlers\n    if($tw.boot.tasks.readBrowserTiddlers) {\n      $tw.loadTiddlersBrowser();\n    } else {\n      $tw.loadTiddlersNode();\n    }\n    // Load any preloaded tiddlers\n    if($tw.preloadTiddlers) {\n      $tw.wiki.addTiddlers($tw.preloadTiddlers);\n    }\n    // Give hooks a chance to modify the store\n    $tw.hooks.invokeHook(\"th-boot-tiddlers-loaded\");\n  }\n\n  $tw.boot.execStartup = function(options){\n    // Unpack plugin tiddlers\n    $tw.wiki.readPluginInfo();\n    $tw.wiki.registerPluginTiddlers(\"plugin\",$tw.safeMode ? [\"$:/core\"] : undefined);\n    $tw.wiki.unpackPluginTiddlers();\n    // Process \"safe mode\"\n    if($tw.safeMode) {\n      $tw.wiki.processSafeMode();\n    }\n    // Register typed modules from the tiddlers we've just loaded\n    $tw.wiki.defineTiddlerModules();\n    // And any modules within plugins\n    $tw.wiki.defineShadowModules();\n    // Gather up any startup modules\n    $tw.boot.remainingStartupModules = []; // Array of startup modules\n    $tw.modules.forEachModuleOfType(\"startup\",function(title,module) {\n      if(module.startup) {\n        $tw.boot.remainingStartupModules.push(module);\n      }\n    });\n    // Keep track of the startup tasks that have been executed\n    $tw.boot.executedStartupModules = Object.create(null);\n    $tw.boot.disabledStartupModules = $tw.boot.disabledStartupModules || [];\n    // Repeatedly execute the next eligible task\n    $tw.boot.executeNextStartupTask(options.callback);\n  }\n\n  /**\n   * Startup TiddlyWiki\n   */\n  $tw.boot.startup = function(options) {\n    options = options || {};\n    // Get the URL hash and check for safe mode\n    $tw.boot.initStartup(options);\n    $tw.boot.loadStartup(options);\n    $tw.boot.execStartup(options);\n  };\n\n  /**\n   * Add another unload task\n   */\n  $tw.addUnloadTask = function(task) {\n    if($tw.unloadTasks.indexOf(task) === -1) {\n      $tw.unloadTasks.push(task);\n    }\n  }\n\n  /**\n   * Execute the remaining eligible startup tasks\n   */\n  $tw.boot.executeNextStartupTask = function(callback) {\n    // Find the next eligible task\n    var taskIndex = 0, task,\n      asyncTaskCallback = function() {\n        if(task.name) {\n          $tw.boot.executedStartupModules[task.name] = true;\n        }\n        return $tw.boot.executeNextStartupTask(callback);\n      };\n    while(taskIndex < $tw.boot.remainingStartupModules.length) {\n      task = $tw.boot.remainingStartupModules[taskIndex];\n      if($tw.boot.isStartupTaskEligible(task)) {\n        // Remove this task from the list\n        $tw.boot.remainingStartupModules.splice(taskIndex,1);\n        // Assemble log message\n        var s = [\"Startup task:\",task.name];\n        if(task.platforms) {\n          s.push(\"platforms:\",task.platforms.join(\",\"));\n        }\n        if(task.after) {\n          s.push(\"after:\",task.after.join(\",\"));\n        }\n        if(task.before) {\n          s.push(\"before:\",task.before.join(\",\"));\n        }\n        $tw.boot.log(s.join(\" \"));\n        // Execute task\n        if(!$tw.utils.hop(task,\"synchronous\") || task.synchronous) {\n          task.startup();\n          if(task.name) {\n            $tw.boot.executedStartupModules[task.name] = true;\n          }\n          return $tw.boot.executeNextStartupTask(callback);\n        } else {\n          task.startup(asyncTaskCallback);\n          return true;\n        }\n      }\n      taskIndex++;\n    }\n    if(typeof callback === 'function') {\n      callback();\n    }\n    return false;\n  };\n\n  /**\n   * Returns true if we are running on one platforms specified in a task modules `platforms` array\n   */\n  $tw.boot.doesTaskMatchPlatform = function(taskModule) {\n    var platforms = taskModule.platforms;\n    if(platforms) {\n      for(var t=0; t<platforms.length; t++) {\n        if((platforms[t] === \"browser\" && !$tw.browser) || (platforms[t] === \"node\" && !$tw.node)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  $tw.boot.isStartupTaskEligible = function(taskModule) {\n    var t;\n    // Check that the platform is correct\n    if(!$tw.boot.doesTaskMatchPlatform(taskModule)) {\n      return false;\n    }\n    var name = taskModule.name,\n      remaining = $tw.boot.remainingStartupModules;\n    if(name) {\n      // Fail if this module is disabled\n      if($tw.boot.disabledStartupModules.indexOf(name) !== -1) {\n        return false;\n      }\n      // Check that no other outstanding tasks must be executed before this one\n      for(t=0; t<remaining.length; t++) {\n        var task = remaining[t];\n        if(task.before && task.before.indexOf(name) !== -1) {\n          if($tw.boot.doesTaskMatchPlatform(task) || (task.name && $tw.boot.disabledStartupModules.indexOf(name) !== -1)) {\n            return false;\n          }\n        }\n      }\n    }\n    // Check that all of the tasks that we must be performed after has been done\n    var after = taskModule.after;\n    if(after) {\n      for(t=0; t<after.length; t++) {\n        if(!$tw.boot.executedStartupModules[after[t]]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Global Hooks mechanism which allows plugins to modify default functionality\n   */\n  $tw.hooks = $tw.hooks || { names: {}};\n\n  /**\n   * Add hooks to the  hashmap\n   */\n  $tw.hooks.addHook = function(hookName,definition) {\n    if($tw.utils.hop($tw.hooks.names,hookName)) {\n      $tw.hooks.names[hookName].push(definition);\n    }\n    else {\n      $tw.hooks.names[hookName] = [definition];\n    }\n  };\n\n  /**\n   * Invoke the hook by key\n   */\n  $tw.hooks.invokeHook = function(hookName /*, value,... */) {\n    var args = Array.prototype.slice.call(arguments,1);\n    if($tw.utils.hop($tw.hooks.names,hookName)) {\n      for (var i = 0; i < $tw.hooks.names[hookName].length; i++) {\n        args[0] = $tw.hooks.names[hookName][i].apply(null,args);\n      }\n    }\n    return args[0];\n  };\n\n  /////////////////////////// Main boot function to decrypt tiddlers and then startup\n\n  $tw.boot.boot = function(callback) {\n    // Initialise crypto object\n    $tw.crypto = new $tw.utils.Crypto();\n    // Initialise password prompter\n    if($tw.browser && !$tw.node) {\n      $tw.passwordPrompt = new $tw.utils.PasswordPrompt();\n    }\n    // Preload any encrypted tiddlers\n    $tw.boot.decryptEncryptedTiddlers(function() {\n      // Startup\n      $tw.boot.startup({callback: callback});\n      // Make sure the crypto state tiddler is up to date\n      if($tw.crypto) {\n        $tw.crypto.updateCryptoStateTiddler();\n      }\n    });\n  };\n\n  return $tw;\n\n  });\n\n  if(typeof(exports) !== \"undefined\") {\n    exports.TiddlyWiki = _boot;\n  } else {\n    _boot(window.$tw);\n  }\nvar ipfsBoot = function ($tw) {\n  /*jslint node: true, browser: true */\n  'use strict'\n\n  const name = 'ipfs-boot'\n\n  /////////////////////////// Standard node.js libraries\n\n  var fs\n  var path\n  var vm\n  if ($tw.node) {\n    fs = require('fs')\n    path = require('path')\n    vm = require('vm')\n  }\n\n  $tw.boot.getLogger = function () {\n    var log = $tw.node ? global.log || require('loglevel') : window.log\n    if (log !== undefined && log !== null) {\n      const loggers = log.getLoggers()\n      var eruda = loggers.eruda\n      if (eruda) {\n        return eruda\n      }\n      var ipfs = loggers.ipfs\n      if (!ipfs) {\n        ipfs = log.getLogger('ipfs')\n        ipfs.setLevel('info', false)\n        ipfs.info('Loglevel is starting up...')\n      }\n      return ipfs\n    }\n    return console\n  }\n\n  /**\n   * Run code globally with specified context variables in scope\n   */\n  $tw.utils.evalGlobal = function (code, context, filename) {\n    var contextCopy = $tw.utils.extend(Object.create(null), context)\n    // Get the context variables as a pair of arrays of names and values\n    var contextNames = []\n    var contextValues = []\n    $tw.utils.each(contextCopy, function (value, name) {\n      contextNames.push(name)\n      contextValues.push(value)\n    })\n    // Add the code prologue and epilogue\n    code = '(function(' + contextNames.join(',') + ') {(function(){\\n' + code + '\\n;})();\\nreturn exports;\\n})\\n'\n    // Compile the code into a function\n    var fn\n    if ($tw.browser) {\n      /*eslint no-eval:\"off\"*/\n      fn = window.eval(code + '\\n\\n//# sourceURL=' + filename)\n    } else {\n      fn = vm.runInThisContext(code, $tw.wiki.getFileName(filename))\n    }\n    // Call the function and return the exports\n    return fn.apply(null, contextValues)\n  }\n\n  /**\n   * Run code in a sandbox with only the specified context variables in scope\n   */\n  $tw.utils.evalSandboxed = $tw.browser\n    ? $tw.utils.evalGlobal\n    : function (code, context, filename) {\n        var sandbox = $tw.utils.extend(Object.create(null), context)\n        vm.runInNewContext(code, sandbox, $tw.wiki.getFileName(filename))\n        return sandbox.exports\n      }\n\n  $tw.Wiki.prototype.getFileName = function (title) {\n    if ($tw.filepaths && $tw.filepaths[title]) {\n      return $tw.filepaths[title]\n    }\n    return title\n  }\n\n  /**\n   * Crypto helper object for encrypted content.\n   * It maintains the password text in a closure, and provides methods to change\n   * the password, and to encrypt/decrypt a block of text\n   */\n  $tw.utils.Crypto = function () {\n    var currentPassword = null\n    var currentPrivateKey = null\n    var currentPublicKey = null\n    var callSjcl = function (method, text, password) {\n      password = password || currentPassword\n      var output = null\n      var sjcl = $tw.node ? global.sjcl || require('sjcl') : window.sjcl\n      try {\n        if (password) {\n          var tStart = new Date()\n          output = sjcl[method](password, text)\n          var tStop = new Date() - tStart\n          var ratio = Math.floor((output.length * 100) / text.length)\n          var uMethod = method.charAt(0).toUpperCase() + method.slice(1) + 'ion'\n          $tw.boot.getLogger().info(`Standford ${uMethod}: ${tStop}ms, In: ${text.length} bytes, Out: ${output.length} bytes, Ratio: ${ratio}%`)\n        }\n      } catch (error) {\n        $tw.boot.getLogger().error('Standford Crypto: ' + error)\n        output = null\n      }\n      return output\n    }\n    var callSigUtil = function (method, text, key) {\n      var output = null\n      var sigUtil = $tw.node ? global.sigUtil || require('eth-sig-util') : window.sigUtil\n      try {\n        if (method === 'encrypt') {\n          key = key || currentPublicKey\n          if (key) {\n            var tStart = new Date()\n            output = sigUtil.encrypt(key, { data: text }, 'x25519-xsalsa20-poly1305')\n            output = JSON.stringify(output)\n            var tStop = new Date() - tStart\n            var ratio = Math.floor((output.length * 100) / text.length)\n            $tw.boot.getLogger().info(`Ethereum Encryption: ${tStop}ms, In: ${text.length} bytes, Out: ${output.length} bytes, Ratio: ${ratio}%`)\n          }\n        } else if (method === 'decrypt') {\n          key = key || currentPrivateKey\n          if (key) {\n            var tStart = new Date()\n            output = sigUtil.decrypt(JSON.parse(text), key)\n            var tStop = new Date() - tStart\n            var ratio = Math.floor((output.length * 100) / text.length)\n            $tw.boot.getLogger().info(`Ethereum Decryption: ${tStop}ms, In: ${text.length} bytes, Out: ${output.length} bytes, Ratio: ${ratio}%`)\n          }\n        }\n      } catch (error) {\n        $tw.boot.getLogger().error('Ethereum Crypto: ' + error)\n        output = null\n      }\n      return output\n    }\n    this.setPassword = function (newPassword) {\n      currentPassword = newPassword === undefined || newPassword == null || newPassword.trim() === '' ? null : newPassword\n      currentPrivateKey = null\n      currentPublicKey = null\n      if ($tw.wiki) {\n        var encryption = $tw.wiki.getTiddler('$:/config/encryption')\n        if (encryption.fields.text !== 'standford') {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({\n              title: '$:/config/encryption',\n              text: 'standford',\n            })\n          )\n        }\n        this.updateCryptoStateTiddler()\n      }\n    }\n    this.setEncryptionKey = function (newPublicKey, newPrivateKey) {\n      currentPrivateKey = newPrivateKey === undefined || newPrivateKey == null || newPrivateKey.trim() === '' ? null : newPrivateKey\n      currentPublicKey = newPublicKey === undefined || newPublicKey == null || newPublicKey.trim() === '' ? null : newPublicKey\n      currentPassword = null\n      if ($tw.wiki) {\n        var encryption = $tw.wiki.getTiddler('$:/config/encryption')\n        if (currentPrivateKey !== null || currentPublicKey !== null) {\n          if (encryption.fields.text !== 'ethereum') {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/config/encryption',\n                text: 'ethereum',\n              })\n            )\n          }\n        } else {\n          if (encryption.fields.text !== 'standford') {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/config/encryption',\n                text: 'standford',\n              })\n            )\n          }\n        }\n        this.updateCryptoStateTiddler()\n      }\n    }\n    this.updateCryptoStateTiddler = function () {\n      if ($tw.wiki) {\n        var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\n        var state = currentPassword || currentPublicKey || currentPrivateKey ? 'yes' : 'no'\n        if (!encrypted || encrypted.fields.text !== state) {\n          if (currentPublicKey) {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/isEncrypted',\n                _encryption_public_key: currentPublicKey,\n                text: state,\n              })\n            )\n          } else {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/isEncrypted',\n                text: state,\n              })\n            )\n          }\n        }\n      }\n    }\n    this.hasPassword = function () {\n      return !!currentPassword\n    }\n    this.hasEncryptionPrivateKey = function () {\n      return !!currentPrivateKey\n    }\n    this.hasEncryptionPublicKey = function () {\n      return !!currentPublicKey\n    }\n    this.encrypt = function (text, password, publicKey) {\n      password = password || currentPassword\n      publicKey = publicKey || currentPublicKey\n      if (text) {\n        if (password) {\n          return callSjcl('encrypt', text, password)\n        } else if (publicKey) {\n          return callSigUtil('encrypt', text, publicKey)\n        }\n      }\n      return null\n    }\n    this.decrypt = function (text, password, privateKey) {\n      password = password || currentPassword\n      privateKey = privateKey || currentPrivateKey\n      if (text) {\n        if (password) {\n          return callSjcl('decrypt', text, password)\n        } else if (privateKey) {\n          return callSigUtil('decrypt', text, privateKey)\n        }\n      }\n      return null\n    }\n    this.keccak256 = function (text) {\n      if (text) {\n        var createKeccakHash = $tw.node ? global.createKeccakHash || require('keccak') : window.createKeccakHash\n        var hash = createKeccakHash('keccak256')\n        hash.update(text)\n        return hash.digest('hex')\n      }\n      return null\n    }\n  }\n\n  /**\n   * Compress helper object for compressed content.\n   */\n  $tw.utils.Compress = function () {\n    var pako = $tw.node ? global.pako || require('pako') : window.pako\n    var currentState = null\n    this.setCompressState = function (state) {\n      currentState = state ? 'yes' : 'no'\n      this.updateCompressStateTiddler()\n    }\n    this.updateCompressStateTiddler = function () {\n      if ($tw.wiki) {\n        var state = currentState === 'yes' ? 'yes' : 'no'\n        var tiddler = $tw.wiki.getTiddler('$:/isCompressed')\n        if (!tiddler || tiddler.fields.text !== state) {\n          $tw.wiki.addTiddler(new $tw.Tiddler({ title: '$:/isCompressed', text: state }))\n        }\n      }\n    }\n    this.deflate = function (str) {\n      var tStart = new Date()\n      var ua = pako.deflate(str, { raw: false })\n      var b64 = this.btoa(ua)\n      var tStop = new Date() - tStart\n      var ratio = Math.floor((b64.length * 100) / str.length)\n      $tw.boot.getLogger().info(`Deflate: ${tStop}ms, In: ${str.length} bytes, Out: ${b64.length} bytes, Ratio: ${ratio}%`)\n      return b64\n    }\n    this.inflate = function (b64) {\n      var tStart = new Date()\n      var ua = this.decode(b64)\n      var str = pako.inflate(ua, { to: 'string' })\n      var tStop = new Date() - tStart\n      var ratio = Math.floor((str.length * 100) / b64.length)\n      $tw.boot.getLogger().info(`Inflate: ${tStop}ms, In: ${b64.length} bytes, Out: ${str.length} bytes, Ratio: ${ratio}%`)\n      return str\n    }\n    this.decode = function (b64) {\n      return Base64Binary.decode(b64)\n    }\n    this.btoa = function (ua) {\n      try {\n        return this.Uint8ArrayToBase64(ua)\n      } catch (error) {\n        return Buffer.from(ua).toString('base64')\n      }\n    }\n    // https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string\n    this.Uint8ArrayToBase64 = function (uint8) {\n      var CHUNK_SIZE = 0x8000\n      var index = 0\n      var length = uint8.length\n      var str = ''\n      var slice\n      while (index < length) {\n        slice = uint8.subarray(index, Math.min(index + CHUNK_SIZE, length))\n        str += String.fromCharCode.apply(null, slice)\n        index += CHUNK_SIZE\n      }\n      return btoa(str)\n    }\n    // https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer/21797381\n    // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\n    /*\n     * Copyright (c) 2011, Daniel Guerrero\n     * All rights reserved.\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     * Redistributions of source code must retain the above copyright\n     * notice, this list of conditions and the following disclaimer.\n     * Redistributions in binary form must reproduce the above copyright\n     * notice, this list of conditions and the following disclaimer in the\n     * documentation and/or other materials provided with the distribution.\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL DANIEL GUERRERO BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n    /**\n     * Uses the new array typed in javascript to binary base64 encode/decode\n     * at the moment just decodes a binary base64 encoded\n     * into either an ArrayBuffer (decodeArrayBuffer)\n     * or into an Uint8Array (decode)\n     *\n     * References:\n     * https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer\n     * https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array\n     */\n    var Base64Binary = {\n      _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      /* will return a  Uint8Array type */\n      decodeArrayBuffer: function (input) {\n        var bytes = (input.length / 4) * 3\n        var ab = new ArrayBuffer(bytes)\n        this.decode(input, ab)\n        return ab\n      },\n      removePaddingChars: function (input) {\n        var lkey = this._keyStr.indexOf(input.charAt(input.length - 1))\n        if (lkey === 64) {\n          return input.substring(0, input.length - 1)\n        }\n        return input\n      },\n      decode: function (input, ab) {\n        //get last chars to see if are valid\n        input = this.removePaddingChars(input)\n        input = this.removePaddingChars(input)\n        var bytes = parseInt((input.length / 4) * 3, 10)\n        var ua\n        var chr1, chr2, chr3\n        var enc1, enc2, enc3, enc4\n        var i = 0\n        var j = 0\n        if (ab) ua = new Uint8Array(ab)\n        else ua = new Uint8Array(bytes)\n        /*eslint no-useless-escape:\"off\"*/\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '')\n        for (i = 0; i < bytes; i += 3) {\n          //get the 3 octects in 4 ascii chars\n          enc1 = this._keyStr.indexOf(input.charAt(j++))\n          enc2 = this._keyStr.indexOf(input.charAt(j++))\n          enc3 = this._keyStr.indexOf(input.charAt(j++))\n          enc4 = this._keyStr.indexOf(input.charAt(j++))\n          chr1 = (enc1 << 2) | (enc2 >> 4)\n          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n          chr3 = ((enc3 & 3) << 6) | enc4\n          ua[i] = chr1\n          if (enc3 !== 64) ua[i + 1] = chr2\n          if (enc4 !== 64) ua[i + 2] = chr3\n        }\n        return ua\n      },\n    }\n  }\n\n  $tw.boot.metamaskPrompt = async function (encrypted, keccak256, signature, callback) {\n    if (!$tw.browser && $tw.node) {\n      callback(null)\n    }\n    var checkAccountPermission = async function (provider) {\n      if (typeof provider.request === 'function') {\n        const permissions = await provider.request({\n          method: 'wallet_getPermissions',\n        })\n        const accountsPermission = permissions.find(permission => permission.parentCapability === 'eth_accounts')\n        if (accountsPermission) {\n          return true\n        }\n      }\n      return false\n    }\n    var requestAccountPermission = async function (provider) {\n      if (typeof provider.request === 'function') {\n        const permissions = await provider.request({\n          method: 'wallet_requestPermissions',\n          params: [{ eth_accounts: {} }],\n        })\n        const accountsPermission = permissions.find(permission => permission.parentCapability === 'eth_accounts')\n        if (accountsPermission) {\n          return true\n        }\n      }\n      return false\n    }\n    var personalRecover = async function (provider, message, signature) {\n      var recovered = null\n      if (typeof provider.request === 'function') {\n        var params = [message, signature]\n        recovered = await provider.request({\n          method: 'personal_ecRecover',\n          params,\n        })\n      }\n      if (recovered === undefined || recovered == null) {\n        const err = new Error('Unrecoverable signature...')\n        err.name = 'UnrecoverableSignature'\n        throw err\n      }\n      return recovered\n    }\n    // Check hash\n    if (keccak256) {\n      const hash = $tw.crypto.keccak256(encrypted)\n      if (keccak256 !== hash) {\n        throw new Error('Tampered encrypted content, signature do not match...')\n      }\n    }\n    // Decrypt\n    var decrypted = null\n    var recovered = null\n    try {\n      const provider = await window.detectEthereumProvider({\n        mustBeMetaMask: true,\n      })\n      if (provider === undefined || provider == null) {\n        throw new Error('Please install MetaMask...')\n      }\n      provider.autoRefreshOnNetworkChange = false\n      var accounts = null\n      var permission = false\n      // Permission Attempt\n      try {\n        permission = await checkAccountPermission(provider)\n        if (permission === false) {\n          permission = await requestAccountPermission(provider)\n        }\n      } catch (error) {\n        if (error.code === 4001) {\n          throw error\n        }\n        $tw.boot.getLogger().error(error)\n      }\n      // Request Accounts attempt\n      try {\n        if (permission === false || (await provider._metamask.isUnlocked()) === false) {\n          accounts = await provider.request({\n            method: 'eth_requestAccounts',\n          })\n        }\n        if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {\n          accounts = await provider.request({ method: 'eth_accounts' })\n        }\n      } catch (error) {\n        if (error.code === 4001) {\n          throw error\n        }\n        $tw.boot.getLogger().error(error)\n      }\n      // Enable attempt\n      if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {\n        if (typeof provider.enable === 'function') {\n          accounts = await provider.enable()\n        }\n      }\n      if (accounts === undefined || accounts == null || Array.isArray(accounts) === false || accounts.length === 0) {\n        throw new Error('Unable to retrieve any Ethereum accounts...')\n      }\n      if (provider.chainId !== undefined) {\n        $tw.boot.getLogger().log(`Chain: ${provider.chainId}, Ethereum Account: ${accounts[0]}`)\n      } else {\n        $tw.boot.getLogger().log(`Ethereum Account: ${accounts[0]}`)\n      }\n      try {\n        if (signature) {\n          var tStart = new Date()\n          signature = await provider.request({\n            method: 'eth_decrypt',\n            params: [signature, accounts[0]],\n          })\n          if (signature !== undefined || signature !== null) {\n            var tStop = new Date() - tStart\n            $tw.boot.getLogger().info(`Ethereum Signature Decrypt: ${tStop}ms`)\n          }\n          recovered = await personalRecover(provider, keccak256, signature)\n          $tw.boot.getLogger().info(`Signed from: https://app.ens.domains/address/${recovered}`)\n        }\n        var tStart = new Date()\n        decrypted = await provider.request({\n          method: 'eth_decrypt',\n          params: [encrypted, accounts[0]],\n        })\n        if (decrypted !== undefined || decrypted !== null) {\n          var tStop = new Date() - tStart\n          var ratio = Math.floor((decrypted.length * 100) / encrypted.length)\n          $tw.boot.getLogger().info(`Ethereum Decrypt: ${tStop}ms, In: ${encrypted.length}, Out: ${decrypted.length}, Ratio: ${ratio}%`)\n        }\n      } catch (error) {\n        if (error.code === 4001) {\n          throw error\n        }\n        if (error.name === 'UnrecoverableSignature') {\n          throw new Error(`Tampered encrypted content. ${error.message}`)\n        }\n        $tw.boot.getLogger().error(error)\n        throw new Error('Unable to Decrypt Ethereum content...')\n      }\n    } catch (error) {\n      if (error.code === 4001) {\n        $tw.utils.error('Rejected User Request...')\n      } else {\n        $tw.utils.error(error.message)\n      }\n    }\n    callback(decrypted, recovered)\n  }\n\n  /////////////////////////// Module mechanism\n\n  /**\n   * Execute the module named 'moduleName'. The name can optionally be relative to the module named 'moduleRoot'\n   */\n  $tw.modules.execute = function (moduleName, moduleRoot) {\n    var name = moduleName\n    if (moduleName.charAt(0) === '.') {\n      name = $tw.utils.resolvePath(moduleName, moduleRoot)\n    }\n    if (!$tw.modules.titles[name]) {\n      if ($tw.modules.titles[name + '.js']) {\n        name = name + '.js'\n      } else if ($tw.modules.titles[name + '/index.js']) {\n        name = name + '/index.js'\n      } else if ($tw.modules.titles[moduleName]) {\n        name = moduleName\n      } else if ($tw.modules.titles[moduleName + '.js']) {\n        name = moduleName + '.js'\n      } else if ($tw.modules.titles[moduleName + '/index.js']) {\n        name = moduleName + '/index.js'\n      }\n    }\n    var moduleInfo = $tw.modules.titles[name]\n    var tiddler = $tw.wiki.getTiddler(name)\n    var _exports = {}\n    var sandbox = {\n      module: { exports: _exports },\n      //moduleInfo: moduleInfo,\n      exports: _exports,\n      console: console,\n      setInterval: setInterval,\n      clearInterval: clearInterval,\n      setTimeout: setTimeout,\n      clearTimeout: clearTimeout,\n      Buffer: $tw.browser ? undefined : Buffer,\n      $tw: $tw,\n      require: function (title) {\n        return $tw.modules.execute(title, name)\n      },\n    }\n\n    Object.defineProperty(sandbox.module, 'id', {\n      value: name,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    })\n\n    if (!$tw.browser) {\n      $tw.utils.extend(sandbox, {\n        process: process,\n      })\n    } else {\n      /*\n      CommonJS optional require.main property:\n      In a browser we offer a fake main module which points back to the boot function\n      (Theoretically, this may allow TW to eventually load itself as a module in the browser)\n      */\n      Object.defineProperty(sandbox.require, 'main', {\n        value: typeof require !== 'undefined' ? require.main : { TiddlyWiki: ipfsBoot },\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      })\n    }\n    if (!moduleInfo) {\n      // We could not find the module on this path\n      // Try to defer to browserify etc, or node\n      if ($tw.browser) {\n        if (window.require) {\n          try {\n            return window.require(moduleName)\n          } catch (e) {}\n        }\n        throw new Error(`Cannot find module named '${moduleName}' required by module '${moduleRoot}', resolved to ${name}`)\n      } else {\n        // If we don't have a module with that name, let node.js try to find it\n        return require(moduleName)\n      }\n    }\n    // Execute the module if we haven't already done so\n    if (!moduleInfo.exports) {\n      try {\n        // Check the type of the definition\n        if (typeof moduleInfo.definition === 'function') {\n          // Function\n          moduleInfo.exports = _exports\n          moduleInfo.definition(moduleInfo, moduleInfo.exports, sandbox.require)\n        } else if (typeof moduleInfo.definition === 'string') {\n          // String\n          moduleInfo.exports = _exports\n          $tw.utils.evalSandboxed(moduleInfo.definition, sandbox, tiddler.fields.title)\n          if (sandbox.module.exports) {\n            moduleInfo.exports = sandbox.module.exports //more codemirror workaround\n          }\n        } else {\n          // Object\n          moduleInfo.exports = moduleInfo.definition\n        }\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          var line = e.lineNumber || e.line // Firefox || Safari\n          if (typeof line !== 'undefined' && line !== null) {\n            $tw.utils.error('Syntax error in boot module ' + name + ':' + line + ':\\n' + e.stack)\n          } else if (!$tw.browser) {\n            // this is the only way to get node.js to display the line at which the syntax error appeared,\n            // and $tw.utils.error would exit anyway\n            // cf. https://bugs.chromium.org/p/v8/issues/detail?id=2589\n            throw e\n          } else {\n            // Opera: line number is included in e.message\n            // Chrome/IE: there's currently no way to get the line number\n            $tw.utils.error('Syntax error in boot module ' + name + ': ' + e.message + '\\n' + e.stack)\n          }\n        } else {\n          // line number should be included in e.stack for runtime errors\n          $tw.utils.error('Error executing boot module ' + name + ': ' + JSON.stringify(e) + '\\n\\n' + e.stack)\n        }\n      }\n    }\n    // Return the exports of the module\n    return moduleInfo.exports\n  }\n\n  /////////////////////////// Browser definitions\n\n  if ($tw.browser && !$tw.node) {\n    $tw.boot.passwordPrompt = function (text, callback) {\n      var prompt = 'Enter a password to decrypt this TiddlyWiki'\n      // Prompt for the password\n      if ($tw.utils.hop($tw.boot, 'encryptionPrompts')) {\n        prompt = $tw.boot.encryptionPrompts.decrypt\n      }\n      $tw.passwordPrompt.createPrompt({\n        serviceName: prompt,\n        noUserName: true,\n        submitText: 'Decrypt',\n        callback: function (data) {\n          // Attempt to decrypt the tiddlers\n          $tw.crypto.setPassword(data.password)\n          var decryptedText = $tw.crypto.decrypt(text)\n          if (decryptedText) {\n            callback(decryptedText)\n            // Exit and remove the password prompt\n            return true\n          } else {\n            // We didn't decrypt everything, so continue to prompt for password\n            return false\n          }\n        },\n      })\n    }\n\n    $tw.boot.preloadTiddler = function (text, callback) {\n      try {\n        if (text !== undefined && text !== null) {\n          var json = JSON.parse(text)\n          for (var title in json) {\n            $tw.preloadTiddler(json[title])\n          }\n        }\n      } catch (error) {\n        $tw.boot.getLogger().error(error)\n      }\n      callback()\n    }\n\n    $tw.boot.inflateTiddlers = function (callback) {\n      var compressedStoreArea = document.getElementById('compressedStoreArea')\n      if (compressedStoreArea) {\n        var inflate = function (b64) {\n          if (b64 !== undefined && b64 !== null) {\n            $tw.boot.preloadTiddler($tw.compress.inflate(b64), callback)\n          }\n        }\n        var content = compressedStoreArea.innerHTML\n        if (content.match(/{\"compressed\":/)) {\n          var json = JSON.parse(content)\n          if (json.compressed.match(/{\"iv\":/)) {\n            $tw.boot.passwordPrompt(json.compressed, function (decrypted) {\n              inflate(decrypted)\n            })\n          } else if (json.compressed.match(/{\"version\":/)) {\n            $tw.boot.metamaskPrompt(json.compressed, json.keccak256, json.signature, function (decrypted, recovered) {\n              inflate(decrypted)\n              if (recovered) {\n                $tw.utils.alert(\n                  name,\n                  `Signed from: <a class=\"tc-tiddlylink-external\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://app.ens.domains/address/${recovered}\">${recovered}</a>`\n                )\n              }\n            })\n          } else {\n            inflate(json.compressed)\n          }\n        } else {\n          $tw.boot.preloadTiddler(content, callback)\n        }\n      } else {\n        // Preload any encrypted tiddlers\n        $tw.boot.decryptEncryptedTiddlers(callback)\n      }\n    }\n\n    /**\n     * Decrypt any tiddlers stored within the element with the ID \"encryptedArea\".\n     * The function is asynchronous to allow the user to be prompted for a password\n     * callback: function to be called the decryption is complete\n     */\n    $tw.boot.decryptEncryptedTiddlers = function (callback) {\n      var encryptedStoreArea = document.getElementById('encryptedStoreArea')\n      if (encryptedStoreArea) {\n        var content = encryptedStoreArea.innerHTML\n        if (content.match(/{\"iv\":/)) {\n          $tw.boot.passwordPrompt(content, function (decrypted) {\n            $tw.boot.preloadTiddler(decrypted, callback)\n          })\n        } else if (content.match(/{\"encrypted\":/)) {\n          const json = JSON.parse(content)\n          $tw.boot.metamaskPrompt(json.encrypted, json.keccak256, json.signature, function (decrypted, recovered) {\n            $tw.boot.preloadTiddler(decrypted, callback)\n            if (recovered) {\n              $tw.utils.alert(\n                name,\n                `Signed from: <a class=\"tc-tiddlylink-external\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://app.ens.domains/address/${recovered}\">${recovered}</a>`\n              )\n            }\n          })\n        } else {\n          $tw.boot.preloadTiddler(content, callback)\n        }\n      } else {\n        // Just invoke the callback straight away if there weren't any encrypted tiddlers\n        callback()\n      }\n    }\n  } else {\n    /////////////////////////// Server definitions\n\n    /**\n     * Get any compressed tiddlers\n     */\n    $tw.boot.inflateTiddlers = function (callback) {\n      // Storing compressed tiddlers on the server isn't supported yet\n      callback()\n    }\n\n    /**\n     * Get any encrypted tiddlers\n     */\n    $tw.boot.decryptEncryptedTiddlers = function (callback) {\n      // Storing encrypted tiddlers on the server isn't supported yet\n      callback()\n    }\n  } // End of if($tw.browser && !$tw.node)\n\n  /////////////////////////// Node definitions\n\n  if ($tw.node) {\n    $tw.filepaths = Object.create(null)\n\n    /**\n     * Load the tiddlers from a plugin folder, and package them up into a proper JSON plugin tiddler\n     */\n    $tw.loadPluginFolder = function (filepath, excludeRegExp) {\n      excludeRegExp = excludeRegExp || $tw.boot.excludeRegExp\n      var infoPath = filepath + path.sep + 'plugin.info'\n      if (fs.existsSync(filepath) && fs.statSync(filepath).isDirectory()) {\n        // Read the plugin information\n        if (!fs.existsSync(infoPath) || !fs.statSync(infoPath).isFile()) {\n          console.log('Warning: missing plugin.info file in ' + filepath)\n          return null\n        }\n        var pluginInfo = JSON.parse(fs.readFileSync(infoPath, 'utf8'))\n        // Read the plugin files\n        var pluginFiles = $tw.loadTiddlersFromPath(filepath, excludeRegExp)\n        // Save the plugin tiddlers into the plugin info\n        pluginInfo.tiddlers = pluginInfo.tiddlers || Object.create(null)\n        for (var f = 0; f < pluginFiles.length; f++) {\n          var tiddlers = pluginFiles[f].tiddlers\n          for (var t = 0; t < tiddlers.length; t++) {\n            var tiddler = tiddlers[t]\n            if (tiddler.title) {\n              if (pluginFiles[f].type === 'application/javascript') {\n                $tw.filepaths[tiddler.title] = pluginFiles[f].filepath\n              }\n              pluginInfo.tiddlers[tiddler.title] = tiddler\n            }\n          }\n        }\n        // Give the plugin the same version number as the core if it doesn't have one\n        if (!('version' in pluginInfo)) {\n          pluginInfo.version = $tw.packageInfo.version\n        }\n        // Use \"plugin\" as the plugin-type if we don't have one\n        if (!('plugin-type' in pluginInfo)) {\n          pluginInfo['plugin-type'] = 'plugin'\n        }\n        pluginInfo.dependents = pluginInfo.dependents || []\n        pluginInfo.type = 'application/json'\n        // Set plugin text\n        pluginInfo.text = JSON.stringify({ tiddlers: pluginInfo.tiddlers }, null, 4)\n        delete pluginInfo.tiddlers\n        // Deserialise array fields (currently required for the dependents field)\n        for (var field in pluginInfo) {\n          if ($tw.utils.isArray(pluginInfo[field])) {\n            pluginInfo[field] = $tw.utils.stringifyList(pluginInfo[field])\n          }\n        }\n        return pluginInfo\n      }\n      return null\n    }\n  }\n\n  /////////////////////////// Main boot function to decrypt tiddlers and then startup\n\n  $tw.boot.boot = function (callback) {\n    // Initialise crypto object\n    $tw.crypto = new $tw.utils.Crypto()\n    // Initialise password prompter\n    if ($tw.browser && !$tw.node) {\n      $tw.passwordPrompt = new $tw.utils.PasswordPrompt()\n    }\n    // Initialise compress object\n    $tw.compress = new $tw.utils.Compress()\n    // Preload any compressed tiddlers\n    $tw.boot.inflateTiddlers(function () {\n      // Startup\n      $tw.boot.startup({ callback: callback })\n      // Make sure the crypto state tiddler is up to date\n      var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\n      if (encrypted && encrypted.fields._encryption_public_key) {\n        $tw.crypto.setEncryptionKey(encrypted.fields._encryption_public_key)\n      } else {\n        $tw.crypto.updateCryptoStateTiddler()\n      }\n      // Make sure the compress state tiddler is up to date\n      var compressed = $tw.wiki.getTiddler('$:/isCompressed')\n      if (!compressed) {\n        $tw.compress.updateCompressStateTiddler()\n      }\n    })\n  }\n\n  if ($tw.browser && !$tw.boot.suppressBoot) {\n    $tw.boot.boot()\n  }\n\n  return $tw\n}\n\nif (typeof exports !== 'undefined') {\n  exports.TiddlyWiki = ipfsBoot\n} else {\n  ipfsBoot(window.$tw)\n}\n\n",
    "tags": "$:/ipfs/boot/modules",
    "type": "application/javascript",
    "version": "0.4.0-beta-TW-v5.1.24-pre+build-210206366",
    "_boot_license_uri": "https://raw.githubusercontent.com/Jermolene/TiddlyWiki5/master/license",
    "_boot_project_uri": "https://github.com/Jermolene/TiddlyWiki5",
    "_boot_source_uri": "https://github.com/Jermolene/TiddlyWiki5/blob/v5.1.23/boot/boot.js"
}