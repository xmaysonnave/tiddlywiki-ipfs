{
    "title": "$:/boot/ipfs-boot.js",
    "text": "/*\\\ntitle: $:/boot/ipfs-boot.js\ntype: application/javascript\ntags: $:/ipfs/core\n\n\\*/\nvar _boot = function ($tw) {\n  /*jslint node: true, browser: true */\n  'use strict'\n\n  $tw.boot.getLogger = function () {\n    var log = $tw.node ? global.log || require('loglevel') : window.log\n    if (log !== undefined && log !== null) {\n      const loggers = log.getLoggers()\n      var eruda = loggers.eruda\n      if (eruda) {\n        return eruda\n      }\n      var ipfs = loggers.ipfs\n      if (!ipfs) {\n        ipfs = log.getLogger('ipfs')\n        ipfs.setLevel('info', false)\n        ipfs.info('Loglevel is starting up...')\n      }\n      return ipfs\n    }\n    return console\n  }\n\n  /**\n   * Crypto helper object for encrypted content. It maintains the password text in a closure, and provides methods to change\n   * the password, and to encrypt/decrypt a block of text\n   */\n  $tw.utils.Crypto = function () {\n    var currentPassword = null\n    var currentPublicKey = null\n    var callSjcl = function (method, inputText, password) {\n      password = password || currentPassword\n      var outputText\n      var sjcl = $tw.node ? global.sjcl || require('sjcl') : window.sjcl\n      try {\n        if (password) {\n          var tStart = new Date()\n          outputText = sjcl[method](password, inputText)\n          var tStop = new Date() - tStart\n          var ratio = Math.floor((outputText.length * 100) / inputText.length)\n          var uMethod = method.charAt(0).toUpperCase() + method.slice(1) + 'ion'\n          $tw.boot\n            .getLogger()\n            .info(\n              `Standford ${uMethod}: ${tStop}ms, In: ${inputText.length} bytes, Out: ${outputText.length} bytes, Ratio: ${ratio}%`\n            )\n        }\n      } catch (ex) {\n        $tw.boot.getLogger().error('Crypto error:' + ex)\n        outputText = null\n      }\n      return outputText\n    }\n    this.setPassword = function (newPassword) {\n      currentPassword =\n        newPassword === undefined || newPassword == null ? null : newPassword\n      currentPublicKey = null\n      if ($tw.wiki) {\n        var encryption = $tw.wiki.getTiddler('$:/config/encryption')\n        if (encryption.fields.text !== 'standford') {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({\n              title: '$:/config/encryption',\n              text: 'standford'\n            })\n          )\n        }\n        this.updateCryptoStateTiddler()\n      }\n    }\n    this.setEncryptionPublicKey = function (newPublicKey) {\n      currentPublicKey =\n        newPublicKey === undefined || newPublicKey == null ? null : newPublicKey\n      currentPassword = null\n      if ($tw.wiki) {\n        var encryption = $tw.wiki.getTiddler('$:/config/encryption')\n        if (currentPublicKey !== null) {\n          if (encryption.fields.text !== 'ethereum') {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/config/encryption',\n                text: 'ethereum'\n              })\n            )\n          }\n        } else {\n          if (encryption.fields.text !== 'standford') {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/config/encryption',\n                text: 'standford'\n              })\n            )\n          }\n        }\n        this.updateCryptoStateTiddler()\n      }\n    }\n    this.updateCryptoStateTiddler = function () {\n      if ($tw.wiki) {\n        var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\n        var state = currentPassword || currentPublicKey ? 'yes' : 'no'\n        if (!encrypted || encrypted.fields.text !== state) {\n          if (currentPublicKey) {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/isEncrypted',\n                _encryption_public_key: currentPublicKey,\n                text: state\n              })\n            )\n          } else {\n            $tw.wiki.addTiddler(\n              new $tw.Tiddler({\n                title: '$:/isEncrypted',\n                text: state\n              })\n            )\n          }\n        }\n      }\n    }\n    this.hasPassword = function () {\n      return !!currentPassword\n    }\n    this.hasEncryptionPublicKey = function () {\n      return !!currentPublicKey\n    }\n    this.encrypt = function (text, password, publicKey) {\n      publicKey = publicKey || currentPublicKey\n      if (publicKey) {\n        var output\n        var sigUtil = $tw.node\n          ? global.sigUtil || require('eth-sig-util')\n          : window.sigUtil\n        var tStart = new Date()\n        try {\n          output = sigUtil.encrypt(\n            publicKey,\n            { data: text },\n            'x25519-xsalsa20-poly1305'\n          )\n          output = JSON.stringify(output)\n          var tStop = new Date() - tStart\n          var ratio = Math.floor((output.length * 100) / text.length)\n          $tw.boot\n            .getLogger()\n            .info(\n              `Ethereum Encryption: ${tStop}ms, In: ${text.length} bytes, Out: ${output.length} bytes, Ratio: ${ratio}%`\n            )\n        } catch (error) {\n          $tw.boot.getLogger().error('Crypto error:' + error)\n          output = null\n        }\n        return output\n      } else {\n        return callSjcl('encrypt', text, password)\n      }\n    }\n    this.decrypt = function (text, password) {\n      return callSjcl('decrypt', text, password)\n    }\n    this.keccak256 = function (text) {\n      var createKeccakHash = $tw.node\n        ? global.createKeccakHash || require('keccak')\n        : window.createKeccakHash\n      var hash = createKeccakHash('keccak256')\n      hash.update(text)\n      return hash.digest('hex')\n    }\n  }\n\n  /**\n   * Compress helper object for compressed content.\n   */\n  $tw.utils.Compress = function () {\n    var pako = $tw.node ? global.pako || require('pako') : window.pako\n    var currentState = null\n    this.setCompressState = function (state) {\n      currentState = state ? 'yes' : 'no'\n      this.updateCompressStateTiddler()\n    }\n    this.updateCompressStateTiddler = function () {\n      if ($tw.wiki) {\n        var state = currentState === 'yes' ? 'yes' : 'no'\n        var tiddler = $tw.wiki.getTiddler('$:/isCompressed')\n        if (!tiddler || tiddler.fields.text !== state) {\n          $tw.wiki.addTiddler(\n            new $tw.Tiddler({ title: '$:/isCompressed', text: state })\n          )\n        }\n      }\n    }\n    this.deflate = function (str) {\n      var tStart = new Date()\n      var ua = pako.deflate(str, { raw: false })\n      var b64 = this.btoa(ua)\n      var tStop = new Date() - tStart\n      var ratio = Math.floor((b64.length * 100) / str.length)\n      $tw.boot\n        .getLogger()\n        .info(\n          `Deflate: ${tStop}ms, In: ${str.length} bytes, Out: ${b64.length} bytes, Ratio: ${ratio}%`\n        )\n      return b64\n    }\n    this.inflate = function (b64) {\n      var tStart = new Date()\n      var ua = this.decode(b64)\n      var str = pako.inflate(ua, { to: 'string' })\n      var tStop = new Date() - tStart\n      var ratio = Math.floor((str.length * 100) / b64.length)\n      $tw.boot\n        .getLogger()\n        .info(\n          `Inflate: ${tStop}ms, In: ${b64.length} bytes, Out: ${str.length} bytes, Ratio: ${ratio}%`\n        )\n      return str\n    }\n    this.decode = function (b64) {\n      return Base64Binary.decode(b64)\n    }\n    this.btoa = function (ua) {\n      try {\n        return this.Uint8ArrayToBase64(ua)\n      } catch (error) {\n        return Buffer.from(ua).toString('base64')\n      }\n    }\n    // https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string\n    this.Uint8ArrayToBase64 = function (uint8) {\n      var CHUNK_SIZE = 0x8000\n      var index = 0\n      var length = uint8.length\n      var str = ''\n      var slice\n      while (index < length) {\n        slice = uint8.subarray(index, Math.min(index + CHUNK_SIZE, length))\n        str += String.fromCharCode.apply(null, slice)\n        index += CHUNK_SIZE\n      }\n      return btoa(str)\n    }\n    // https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer/21797381\n    // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\n    /*\n     * Copyright (c) 2011, Daniel Guerrero\n     * All rights reserved.\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     * Redistributions of source code must retain the above copyright\n     * notice, this list of conditions and the following disclaimer.\n     * Redistributions in binary form must reproduce the above copyright\n     * notice, this list of conditions and the following disclaimer in the\n     * documentation and/or other materials provided with the distribution.\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL DANIEL GUERRERO BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n    /**\n     * Uses the new array typed in javascript to binary base64 encode/decode\n     * at the moment just decodes a binary base64 encoded\n     * into either an ArrayBuffer (decodeArrayBuffer)\n     * or into an Uint8Array (decode)\n     *\n     * References:\n     * https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer\n     * https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array\n     */\n    var Base64Binary = {\n      _keyStr:\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      /* will return a  Uint8Array type */\n      decodeArrayBuffer: function (input) {\n        var bytes = (input.length / 4) * 3\n        var ab = new ArrayBuffer(bytes)\n        this.decode(input, ab)\n        return ab\n      },\n      removePaddingChars: function (input) {\n        var lkey = this._keyStr.indexOf(input.charAt(input.length - 1))\n        if (lkey === 64) {\n          return input.substring(0, input.length - 1)\n        }\n        return input\n      },\n      decode: function (input, ab) {\n        //get last chars to see if are valid\n        input = this.removePaddingChars(input)\n        input = this.removePaddingChars(input)\n        var bytes = parseInt((input.length / 4) * 3, 10)\n        var ua\n        var chr1, chr2, chr3\n        var enc1, enc2, enc3, enc4\n        var i = 0\n        var j = 0\n        if (ab) ua = new Uint8Array(ab)\n        else ua = new Uint8Array(bytes)\n        /*eslint no-useless-escape:\"off\"*/\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '')\n        for (i = 0; i < bytes; i += 3) {\n          //get the 3 octects in 4 ascii chars\n          enc1 = this._keyStr.indexOf(input.charAt(j++))\n          enc2 = this._keyStr.indexOf(input.charAt(j++))\n          enc3 = this._keyStr.indexOf(input.charAt(j++))\n          enc4 = this._keyStr.indexOf(input.charAt(j++))\n          chr1 = (enc1 << 2) | (enc2 >> 4)\n          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n          chr3 = ((enc3 & 3) << 6) | enc4\n          ua[i] = chr1\n          if (enc3 !== 64) ua[i + 1] = chr2\n          if (enc4 !== 64) ua[i + 2] = chr3\n        }\n        return ua\n      }\n    }\n  }\n\n  /////////////////////////// Browser definitions\n\n  if ($tw.browser && !$tw.node) {\n    $tw.boot.metamaskPrompt = async function (\n      encrypted,\n      keccak256,\n      signature,\n      callback\n    ) {\n      var checkAccountPermission = async function (provider) {\n        if (typeof provider.request === 'function') {\n          const permissions = await provider.request({\n            method: 'wallet_getPermissions'\n          })\n          const accountsPermission = permissions.find(\n            permission => permission.parentCapability === 'eth_accounts'\n          )\n          if (accountsPermission) {\n            return true\n          }\n        }\n        return false\n      }\n      var requestAccountPermission = async function (provider) {\n        if (typeof provider.request === 'function') {\n          const permissions = await provider.request({\n            method: 'wallet_requestPermissions',\n            params: [{ eth_accounts: {} }]\n          })\n          const accountsPermission = permissions.find(\n            permission => permission.parentCapability === 'eth_accounts'\n          )\n          if (accountsPermission) {\n            return true\n          }\n        }\n        return false\n      }\n      var personalRecover = async function (provider, message, signature) {\n        var recovered = null\n        if (typeof provider.request === 'function') {\n          var params = [message, signature]\n          recovered = await provider.request({\n            method: 'personal_ecRecover',\n            params\n          })\n        }\n        if (recovered === undefined || recovered == null) {\n          const err = new Error('Unrecoverable signature...')\n          err.name = 'UnrecoverableSignature'\n          throw err\n        }\n        return recovered\n      }\n      // Check hash\n      if (keccak256) {\n        const hash = $tw.crypto.keccak256(encrypted)\n        if (keccak256 !== hash) {\n          throw new Error(\n            'Tampered encrypted content, signature do not match...'\n          )\n        }\n      }\n      // Decrypt\n      var decrypted = null\n      var recovered = null\n      try {\n        const provider = await window.detectEthereumProvider({\n          mustBeMetaMask: true\n        })\n        if (provider === undefined || provider == null) {\n          throw new Error('Please install MetaMask...')\n        }\n        provider.autoRefreshOnNetworkChange = false\n        var accounts = null\n        var permission = false\n        // Permission Attempt\n        try {\n          permission = await checkAccountPermission(provider)\n          if (permission === false) {\n            permission = await requestAccountPermission(provider)\n          }\n        } catch (error) {\n          if (error.code === 4001) {\n            throw error\n          }\n          $tw.boot.getLogger().error(error)\n        }\n        // Request Accounts attempt\n        try {\n          if (\n            permission === false ||\n            (await provider._metamask.isUnlocked()) === false\n          ) {\n            accounts = await provider.request({\n              method: 'eth_requestAccounts'\n            })\n          }\n          if (\n            accounts === undefined ||\n            accounts == null ||\n            Array.isArray(accounts) === false ||\n            accounts.length === 0\n          ) {\n            accounts = await provider.request({ method: 'eth_accounts' })\n          }\n        } catch (error) {\n          if (error.code === 4001) {\n            throw error\n          }\n          $tw.boot.getLogger().error(error)\n        }\n        // Enable attempt\n        if (\n          accounts === undefined ||\n          accounts == null ||\n          Array.isArray(accounts) === false ||\n          accounts.length === 0\n        ) {\n          if (typeof provider.enable === 'function') {\n            accounts = await provider.enable()\n          }\n        }\n        if (\n          accounts === undefined ||\n          accounts == null ||\n          Array.isArray(accounts) === false ||\n          accounts.length === 0\n        ) {\n          throw new Error('Unable to retrieve any Ethereum accounts...')\n        }\n        if (provider.chainId !== undefined) {\n          $tw.boot\n            .getLogger()\n            .log(`Chain: ${provider.chainId}, Ethereum Account: ${accounts[0]}`)\n        } else {\n          $tw.boot.getLogger().log(`Ethereum Account: ${accounts[0]}`)\n        }\n        try {\n          if (signature) {\n            var tStart = new Date()\n            signature = await provider.request({\n              method: 'eth_decrypt',\n              params: [signature, accounts[0]]\n            })\n            if (signature !== undefined || signature !== null) {\n              var tStop = new Date() - tStart\n              $tw.boot\n                .getLogger()\n                .info(`Ethereum Signature Decrypt: ${tStop}ms`)\n            }\n            recovered = await personalRecover(provider, keccak256, signature)\n            $tw.boot\n              .getLogger()\n              .info(`Signed from: https://app.ens.domains/address/${recovered}`)\n          }\n          var tStart = new Date()\n          decrypted = await provider.request({\n            method: 'eth_decrypt',\n            params: [encrypted, accounts[0]]\n          })\n          if (decrypted !== undefined || decrypted !== null) {\n            var tStop = new Date() - tStart\n            var ratio = Math.floor((decrypted.length * 100) / encrypted.length)\n            $tw.boot\n              .getLogger()\n              .info(\n                `Ethereum Decrypt: ${tStop}ms, In: ${encrypted.length}, Out: ${decrypted.length}, Ratio: ${ratio}%`\n              )\n          }\n        } catch (error) {\n          if (error.code === 4001) {\n            throw error\n          }\n          if (error.name === 'UnrecoverableSignature') {\n            throw new Error(`Tampered encrypted content. ${error.message}`)\n          }\n          $tw.boot.getLogger().error(error)\n          throw new Error('Unable to Decrypt Ethereum content...')\n        }\n      } catch (error) {\n        if (error.code === 4001) {\n          $tw.utils.error('Rejected User Request...')\n        } else {\n          $tw.utils.error(error.message)\n        }\n      }\n      callback(decrypted, recovered)\n    }\n\n    $tw.boot.passwordPrompt = function (text, callback) {\n      var prompt = 'Enter a password to decrypt this TiddlyWiki'\n      // Prompt for the password\n      if ($tw.utils.hop($tw.boot, 'encryptionPrompts')) {\n        prompt = $tw.boot.encryptionPrompts.decrypt\n      }\n      $tw.passwordPrompt.createPrompt({\n        serviceName: prompt,\n        noUserName: true,\n        submitText: 'Decrypt',\n        callback: function (data) {\n          // Attempt to decrypt the tiddlers\n          $tw.crypto.setPassword(data.password)\n          var decryptedText = $tw.crypto.decrypt(text)\n          if (decryptedText) {\n            callback(decryptedText)\n            // Exit and remove the password prompt\n            return true\n          } else {\n            // We didn't decrypt everything, so continue to prompt for password\n            return false\n          }\n        }\n      })\n    }\n\n    $tw.boot.preloadTiddler = function (text, callback) {\n      try {\n        if (text !== undefined && text !== null) {\n          var json = JSON.parse(text)\n          for (var title in json) {\n            $tw.preloadTiddler(json[title])\n          }\n        }\n      } catch (error) {\n        $tw.boot.getLogger().error(error)\n      }\n      callback()\n    }\n\n    $tw.boot.inflateTiddlers = function (callback) {\n      var compressedStoreArea = document.getElementById('compressedStoreArea')\n      if (compressedStoreArea) {\n        var inflate = function (b64) {\n          if (b64 !== undefined && b64 !== null) {\n            $tw.boot.preloadTiddler($tw.compress.inflate(b64), callback)\n          }\n        }\n        var content = compressedStoreArea.innerHTML\n        if (content.match(/{\"compressed\":/)) {\n          var json = JSON.parse(content)\n          if (json.compressed.match(/{\"iv\":/)) {\n            $tw.boot.passwordPrompt(json.compressed, function (decrypted) {\n              inflate(decrypted)\n            })\n          } else if (json.compressed.match(/{\"version\":/)) {\n            $tw.boot.metamaskPrompt(\n              json.compressed,\n              json.keccak256,\n              json.signature,\n              function (decrypted, recovered) {\n                inflate(decrypted)\n                if (recovered) {\n                  $tw.utils.alert(\n                    name,\n                    `Signed from: <a class=\"tc-tiddlylink-external\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://app.ens.domains/address/${recovered}\">${recovered}</a>`\n                  )\n                }\n              }\n            )\n          } else {\n            inflate(json.compressed)\n          }\n        } else {\n          $tw.boot.preloadTiddler(content, callback)\n        }\n      } else {\n        // Preload any encrypted tiddlers\n        $tw.boot.decryptEncryptedTiddlers(callback)\n      }\n    }\n\n    /**\n     * Decrypt any tiddlers stored within the element with the ID \"encryptedArea\".\n     * The function is asynchronous to allow the user to be prompted for a password\n     * callback: function to be called the decryption is complete\n     */\n    $tw.boot.decryptEncryptedTiddlers = function (callback) {\n      var encryptedStoreArea = document.getElementById('encryptedStoreArea')\n      if (encryptedStoreArea) {\n        var content = encryptedStoreArea.innerHTML\n        if (content.match(/{\"iv\":/)) {\n          $tw.boot.passwordPrompt(content, function (decrypted) {\n            $tw.boot.preloadTiddler(decrypted, callback)\n          })\n        } else if (content.match(/{\"encrypted\":/)) {\n          const json = JSON.parse(content)\n          $tw.boot.metamaskPrompt(\n            json.encrypted,\n            json.keccak256,\n            json.signature,\n            function (decrypted, recovered) {\n              $tw.boot.preloadTiddler(decrypted, callback)\n              if (recovered) {\n                $tw.utils.alert(\n                  name,\n                  `Signed from: <a class=\"tc-tiddlylink-external\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://app.ens.domains/address/${recovered}\">${recovered}</a>`\n                )\n              }\n            }\n          )\n        } else {\n          $tw.boot.preloadTiddler(content, callback)\n        }\n      } else {\n        // Just invoke the callback straight away if there weren't any encrypted tiddlers\n        callback()\n      }\n    }\n  } else {\n    /////////////////////////// Server definitions\n\n    /**\n     * Get any compressed tiddlers\n     */\n    $tw.boot.inflateTiddlers = function (callback) {\n      // Storing compressed tiddlers on the server isn't supported yet\n      callback()\n    }\n\n    /**\n     * Get any encrypted tiddlers\n     */\n    $tw.boot.decryptEncryptedTiddlers = function (callback) {\n      // Storing encrypted tiddlers on the server isn't supported yet\n      callback()\n    }\n  } // End of if($tw.browser && !$tw.node)\n\n  /////////////////////////// Main boot function to decrypt tiddlers and then startup\n\n  $tw.boot.boot = function (callback) {\n    // Initialise crypto object\n    $tw.crypto = new $tw.utils.Crypto()\n    // Initialise password prompter\n    if ($tw.browser && !$tw.node) {\n      $tw.passwordPrompt = new $tw.utils.PasswordPrompt()\n    }\n    // Initialise compress object\n    $tw.compress = new $tw.utils.Compress()\n    // Preload any compressed tiddlers\n    $tw.boot.inflateTiddlers(function () {\n      // Startup\n      $tw.boot.startup({ callback: callback })\n      // Make sure the crypto state tiddler is up to date\n      if ($tw.crypto) {\n        var encrypted = $tw.wiki.getTiddler('$:/isEncrypted')\n        if (encrypted && encrypted.fields._encryption_public_key) {\n          $tw.crypto.setEncryptionPublicKey(\n            encrypted.fields._encryption_public_key\n          )\n        } else {\n          $tw.crypto.updateCryptoStateTiddler()\n        }\n      }\n    })\n  }\n\n  if ($tw.browser && !$tw.boot.suppressBoot) {\n    $tw.boot.boot()\n  }\n\n  return $tw\n}\n\nif (typeof exports !== 'undefined') {\n  exports.TiddlyWiki = _boot\n} else {\n  _boot(window.$tw)\n}\n",
    "type": "application/javascript",
    "tags": "$:/ipfs/core"
}